
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>tsd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/treivax/tsd/cmd/tsd/main.go (92.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "io"
        "os"

        "github.com/treivax/tsd/constraint"
        "github.com/treivax/tsd/rete"
)

// Config holds the CLI configuration
type Config struct {
        ConstraintFile string
        ConstraintText string
        UseStdin       bool
        FactsFile      string
        Verbose        bool
        ShowVersion    bool
        ShowHelp       bool
}

// Result holds the execution result
type Result struct {
        Network     *rete.ReteNetwork
        Facts       []*rete.Fact
        Activations int
        Error       error
}

func main() <span class="cov0" title="0">{
        exitCode := Run(os.Args[1:], os.Stdin, os.Stdout, os.Stderr)
        os.Exit(exitCode)
}</span>

// Run executes the TSD CLI with the given arguments and returns an exit code
// This function is testable and doesn't call os.Exit
func Run(args []string, stdin io.Reader, stdout, stderr io.Writer) int <span class="cov8" title="1">{
        config, err := ParseFlags(args)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(stderr, "Erreur: %v\n", err)
                return 1
        }</span>

        <span class="cov8" title="1">if config.ShowHelp </span><span class="cov8" title="1">{
                PrintHelp(stdout)
                return 0
        }</span>

        <span class="cov8" title="1">if config.ShowVersion </span><span class="cov8" title="1">{
                PrintVersion(stdout)
                return 0
        }</span>

        <span class="cov8" title="1">if err := ValidateConfig(config); err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(stderr, "Erreur: %v\n\n", err)
                PrintHelp(stderr)
                return 1
        }</span>

        <span class="cov8" title="1">result, sourceName, err := ParseConstraintSource(config, stdin)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(stderr, "Erreur de parsing: %v\n", err)
                return 1
        }</span>

        <span class="cov8" title="1">if config.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(stdout, "‚úÖ Parsing r√©ussi\n")
                fmt.Fprintf(stdout, "üìã Validation du programme...\n")
        }</span>

        <span class="cov8" title="1">if err := constraint.ValidateConstraintProgram(result); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(stderr, "Erreur de validation: %v\n", err)
                return 1
        }</span>

        <span class="cov8" title="1">if config.Verbose </span><span class="cov0" title="0">{
                fmt.Fprintf(stdout, "‚úÖ Contraintes valid√©es avec succ√®s\n")
        }</span>

        <span class="cov8" title="1">if config.FactsFile != "" </span><span class="cov0" title="0">{
                return RunWithFacts(config, sourceName, stdout, stderr)
        }</span>

        <span class="cov8" title="1">return RunValidationOnly(config, stdout)</span>
}

// ParseFlags parses command-line flags and returns a Config
func ParseFlags(args []string) (*Config, error) <span class="cov8" title="1">{
        config := &amp;Config{}
        flagSet := flag.NewFlagSet("tsd", flag.ContinueOnError)

        flagSet.StringVar(&amp;config.ConstraintFile, "constraint", "", "Fichier de contraintes (.constraint)")
        flagSet.StringVar(&amp;config.ConstraintText, "text", "", "Texte de contrainte directement (alternative √† -constraint)")
        flagSet.BoolVar(&amp;config.UseStdin, "stdin", false, "Lire les contraintes depuis stdin")
        flagSet.StringVar(&amp;config.FactsFile, "facts", "", "Fichier de faits (.facts)")
        flagSet.BoolVar(&amp;config.Verbose, "v", false, "Mode verbeux")
        flagSet.BoolVar(&amp;config.ShowVersion, "version", false, "Afficher la version")
        flagSet.BoolVar(&amp;config.ShowHelp, "h", false, "Afficher l'aide")

        if err := flagSet.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// ValidateConfig validates that exactly one input source is specified
func ValidateConfig(config *Config) error <span class="cov8" title="1">{
        sourcesCount := 0
        if config.ConstraintFile != "" </span><span class="cov8" title="1">{
                sourcesCount++
        }</span>
        <span class="cov8" title="1">if config.ConstraintText != "" </span><span class="cov8" title="1">{
                sourcesCount++
        }</span>
        <span class="cov8" title="1">if config.UseStdin </span><span class="cov8" title="1">{
                sourcesCount++
        }</span>

        <span class="cov8" title="1">if sourcesCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("sp√©cifiez une source (-constraint, -text, ou -stdin)")
        }</span>

        <span class="cov8" title="1">if sourcesCount &gt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("sp√©cifiez une seule source d'entr√©e")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ParseConstraintSource parses constraints from the configured source
func ParseConstraintSource(config *Config, stdin io.Reader) (interface{}, string, error) <span class="cov8" title="1">{
        if config.UseStdin </span><span class="cov8" title="1">{
                return parseFromStdin(config, stdin)
        }</span>

        <span class="cov8" title="1">if config.ConstraintText != "" </span><span class="cov8" title="1">{
                return parseFromText(config)
        }</span>

        <span class="cov8" title="1">return parseFromFile(config)</span>
}

// parseFromStdin reads and parses constraints from stdin
func parseFromStdin(config *Config, stdin io.Reader) (interface{}, string, error) <span class="cov8" title="1">{
        sourceName := "&lt;stdin&gt;"

        stdinContent, err := io.ReadAll(stdin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("lecture stdin: %w", err)
        }</span>

        <span class="cov8" title="1">result, err := constraint.ParseConstraint(sourceName, stdinContent)
        return result, sourceName, err</span>
}

// parseFromText parses constraints from a text string
func parseFromText(config *Config) (interface{}, string, error) <span class="cov8" title="1">{
        sourceName := "&lt;text&gt;"

        result, err := constraint.ParseConstraint(sourceName, []byte(config.ConstraintText))
        return result, sourceName, err
}</span>

// parseFromFile parses constraints from a file
func parseFromFile(config *Config) (interface{}, string, error) <span class="cov8" title="1">{
        sourceName := config.ConstraintFile

        if _, err := os.Stat(config.ConstraintFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("fichier contrainte non trouv√©: %s", config.ConstraintFile)
        }</span>

        <span class="cov8" title="1">result, err := constraint.ParseConstraintFile(config.ConstraintFile)
        return result, sourceName, err</span>
}

// RunValidationOnly runs in validation-only mode (no facts file)
func RunValidationOnly(config *Config, stdout io.Writer) int <span class="cov8" title="1">{
        fmt.Fprintf(stdout, "‚úÖ Contraintes valid√©es avec succ√®s\n")

        if config.Verbose </span><span class="cov8" title="1">{
                fmt.Fprintf(stdout, "\nüéâ Validation termin√©e!\n")
                fmt.Fprintf(stdout, "Les contraintes sont syntaxiquement correctes.\n")
                fmt.Fprintf(stdout, "‚ÑπÔ∏è  Utilisez -facts &lt;file&gt; pour ex√©cuter le pipeline RETE complet.\n")
        }</span>

        <span class="cov8" title="1">return 0</span>
}

// RunWithFacts runs the full RETE pipeline with facts and returns exit code
func RunWithFacts(config *Config, sourceName string, stdout, stderr io.Writer) int <span class="cov8" title="1">{
        if config.Verbose </span><span class="cov8" title="1">{
                fmt.Fprintf(stdout, "\nüîß PIPELINE RETE COMPLET\n")
                fmt.Fprintf(stdout, "========================\n")
                fmt.Fprintf(stdout, "Fichier faits: %s\n\n", config.FactsFile)
        }</span>

        <span class="cov8" title="1">if _, err := os.Stat(config.FactsFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                fmt.Fprintf(stderr, "Fichier faits non trouv√©: %s\n", config.FactsFile)
                return 1
        }</span>

        <span class="cov8" title="1">result, err := ExecutePipeline(sourceName, config.FactsFile)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(stderr, "Erreur pipeline RETE: %v\n", err)
                return 1
        }</span>

        <span class="cov8" title="1">PrintResults(config, result, stdout)
        return 0</span>
}

// ExecutePipeline executes the RETE pipeline and returns the result
func ExecutePipeline(constraintSource, factsFile string) (*Result, error) <span class="cov8" title="1">{
        pipeline := rete.NewConstraintPipeline()
        storage := rete.NewMemoryStorage()

        network, facts, err := pipeline.BuildNetworkFromConstraintFileWithFacts(
                constraintSource,
                factsFile,
                storage,
        )

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">activations := CountActivations(network)

        return &amp;Result{
                Network:     network,
                Facts:       facts,
                Activations: activations,
        }, nil</span>
}

// PrintResults prints the RETE pipeline execution results
func PrintResults(config *Config, result *Result, stdout io.Writer) <span class="cov8" title="1">{
        if config.Verbose </span><span class="cov8" title="1">{
                fmt.Fprintf(stdout, "\nüìä R√âSULTATS\n")
                fmt.Fprintf(stdout, "============\n")
                fmt.Fprintf(stdout, "Faits inject√©s: %d\n", len(result.Facts))
        }</span>

        <span class="cov8" title="1">if result.Activations &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(stdout, "\nüéØ ACTIONS DISPONIBLES: %d\n", result.Activations)
                if config.Verbose </span><span class="cov8" title="1">{
                        PrintActivationDetails(result.Network, stdout)
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(stdout, "\n‚ÑπÔ∏è  Aucune action d√©clench√©e\n")
        }</span>

        <span class="cov8" title="1">if config.Verbose </span><span class="cov8" title="1">{
                fmt.Fprintf(stdout, "\n‚úÖ Pipeline RETE ex√©cut√© avec succ√®s\n")
        }</span>
}

// CountActivations counts the total number of activations in the network
func CountActivations(network *rete.ReteNetwork) int <span class="cov8" title="1">{
        if network == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">count := 0
        for _, terminal := range network.TerminalNodes </span><span class="cov8" title="1">{
                if terminal.Memory != nil &amp;&amp; terminal.Memory.Tokens != nil </span><span class="cov8" title="1">{
                        count += len(terminal.Memory.Tokens)
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// PrintActivationDetails prints detailed information about activations
func PrintActivationDetails(network *rete.ReteNetwork, stdout io.Writer) <span class="cov8" title="1">{
        if network == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">count := 0
        for _, terminal := range network.TerminalNodes </span><span class="cov8" title="1">{
                if terminal.Memory != nil &amp;&amp; terminal.Memory.Tokens != nil </span><span class="cov8" title="1">{
                        actionName := "unknown"
                        if terminal.Action != nil </span><span class="cov8" title="1">{
                                actionName = terminal.Action.Job.Name
                        }</span>
                        <span class="cov8" title="1">for _, token := range terminal.Memory.Tokens </span><span class="cov8" title="1">{
                                count++
                                fmt.Fprintf(stdout, "  %d. %s() - %d bindings\n", count, actionName, len(token.Facts))
                        }</span>
                }
        }
}

// PrintVersion prints the version information
func PrintVersion(w io.Writer) <span class="cov8" title="1">{
        fmt.Fprintln(w, "TSD (Type System Development) v1.0")
        fmt.Fprintln(w, "Moteur de r√®gles bas√© sur l'algorithme RETE")
}</span>

// PrintHelp prints the help message
func PrintHelp(w io.Writer) <span class="cov8" title="1">{
        fmt.Fprintln(w, "TSD - Type System Development")
        fmt.Fprintln(w, "Moteur de r√®gles bas√© sur l'algorithme RETE")
        fmt.Fprintln(w, "")
        fmt.Fprintln(w, "USAGE:")
        fmt.Fprintln(w, "  tsd -constraint &lt;file.constraint&gt; [options]")
        fmt.Fprintln(w, "  tsd -text \"&lt;constraint text&gt;\" [options]")
        fmt.Fprintln(w, "  tsd -stdin [options]")
        fmt.Fprintln(w, "  echo \"&lt;constraint&gt;\" | tsd -stdin")
        fmt.Fprintln(w, "")
        fmt.Fprintln(w, "OPTIONS:")
        fmt.Fprintln(w, "  -constraint &lt;file&gt;  Fichier de r√®gles/contraintes")
        fmt.Fprintln(w, "  -text &lt;string&gt;      Texte de contrainte directement")
        fmt.Fprintln(w, "  -stdin              Lire les contraintes depuis stdin")
        fmt.Fprintln(w, "  -facts &lt;file&gt;       Fichier de faits (optionnel, pour futur usage)")
        fmt.Fprintln(w, "  -v                  Mode verbeux")
        fmt.Fprintln(w, "  -version            Afficher la version")
        fmt.Fprintln(w, "  -h                  Afficher cette aide")
        fmt.Fprintln(w, "")
        fmt.Fprintln(w, "EXEMPLES:")
        fmt.Fprintln(w, "  tsd -constraint rules.constraint")
        fmt.Fprintln(w, "  tsd -constraint rules.constraint -v")
        fmt.Fprintln(w, "  tsd -text 'type Person : &lt;id: string, name: string&gt;'")
        fmt.Fprintln(w, "  echo 'type Person : &lt;id: string&gt;' | tsd -stdin")
        fmt.Fprintln(w, "  cat rules.constraint | tsd -stdin -v")
        fmt.Fprintln(w, "")
        fmt.Fprintln(w, "FORMATS DE FICHIERS:")
        fmt.Fprintln(w, "  .constraint : R√®gles en syntaxe TSD")
        fmt.Fprintln(w, "  .facts      : Faits en format structur√© (support futur)")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
