# Primary Keys and Automatic ID Generation

This document describes how TSD automatically generates unique identifiers for facts using primary keys.

## Table of Contents

- [Overview](#overview)
- [Syntax](#syntax)
  - [Simple Primary Key](#simple-primary-key)
  - [Composite Primary Key](#composite-primary-key)
  - [No Primary Key (Hash-Based)](#no-primary-key-hash-based)
- [ID Format](#id-format)
- [Accessing IDs in Rules](#accessing-ids-in-rules)
- [Constraints](#constraints)
- [Best Practices](#best-practices)
- [Examples](#examples)
- [Migration Guide](#migration-guide)

---

## Overview

TSD automatically generates **unique, deterministic identifiers** (IDs) for all facts. These IDs are used internally by the RETE engine to identify and track facts in working memory.

You can control how IDs are generated by marking fields as **primary keys** using the `#` prefix. This provides:

- **Predictable IDs**: IDs based on business data (e.g., `User~alice`)
- **Natural uniqueness**: Prevents duplicate facts with the same key values
- **Readable debugging**: Easy to identify facts in logs and traces
- **Determinism**: Same input always produces the same ID

---

## Syntax

### Simple Primary Key

Mark a **single field** as the primary key by prefixing it with `#`:

```tsd
type Person(#username: string, email: string, age: number)
```

When you assert a fact, the ID is generated from the primary key value:

```tsd
assert Person(username: "alice", email: "alice@example.com", age: 30)
// Generated ID: "Person~alice"

assert Person(username: "bob", email: "bob@example.com", age: 25)
// Generated ID: "Person~bob"
```

**Format**: `TypeName~value`

---

### Composite Primary Key

Mark **multiple fields** as primary keys to create a composite key:

```tsd
type Product(#category: string, #name: string, price: number, stock: number)
```

The ID is generated by concatenating primary key values with underscore (`_`):

```tsd
assert Product(category: "Electronics", name: "Laptop", price: 1200, stock: 5)
// Generated ID: "Product~Electronics_Laptop"

assert Product(category: "Books", name: "TSD Guide", price: 30, stock: 100)
// Generated ID: "Product~Books_TSD%20Guide"
```

**Format**: `TypeName~value1_value2_value3`

**Note**: The order of fields in the type definition determines the order in the ID.

---

### No Primary Key (Hash-Based)

If **no fields** are marked with `#`, TSD generates an ID using a deterministic hash of all field values:

```tsd
type LogEvent(timestamp: number, level: string, message: string)
```

```tsd
assert LogEvent(timestamp: 1704067200, level: "INFO", message: "App started")
// Generated ID: "LogEvent~a1b2c3d4e5f6g7h8" (16-character hex hash)

assert LogEvent(timestamp: 1704067201, level: "ERROR", message: "Connection failed")
// Generated ID: "LogEvent~f3e2d1c0b9a87654" (different hash)
```

**Format**: `TypeName~<16-hex-chars>`

**Important**: The hash is **deterministic** — the same field values always produce the same ID.

---

## ID Format

All IDs follow the format: **`TypeName~identifier`**

### Components

| Part | Description |
|------|-------------|
| `TypeName` | The name of the type (e.g., `User`, `Product`) |
| `~` | Separator between type and identifier |
| `identifier` | Primary key value(s) or hash |

### With Primary Key

- **Simple**: `User~alice`
- **Composite**: `Product~Electronics_Laptop`
- **Numeric**: `Order~2024_1001`

### Without Primary Key

- **Hash**: `LogEvent~a1b2c3d4e5f6g7h8`

### Special Character Encoding

Special characters in primary key values are **percent-encoded** (URL encoding):

| Character | Encoding | Reason |
|-----------|----------|--------|
| `~` (tilde) | `%7E` | Type/value separator |
| `_` (underscore) | `%5F` | Composite key separator |
| `%` (percent) | `%25` | Escape character |
| ` ` (space) | `%20` | Whitespace |
| `/` (slash) | `%2F` | Path separator |

**Example**:

```tsd
type File(#path: string, size: number)

assert File(path: "/home/user~backup_v1", size: 1024)
// Generated ID: "File~%2Fhome%2Fuser%7Ebackup%5Fv1"
```

---

## Accessing IDs in Rules

### The `id` Field

The `id` field is **automatically available** on all facts and is of type `string`.

**Example**: Print the ID

```tsd
rule PrintUserID {
    when {
        u: User()
    }
    then {
        print("User ID: " + u.id)
    }
}
```

### Using IDs in Conditions

You can use `id` in rule conditions:

```tsd
rule SpecificUser {
    when {
        u: User()
        u.id == "User~alice"
    }
    then {
        print("Found Alice")
    }
}
```

### Using IDs in Joins

Reference IDs from other facts:

```tsd
type User(#username: string, email: string)
type Session(#session_id: string, username: string, active: bool)

rule ActiveUserSessions {
    when {
        u: User()
        s: Session()
        s.username == u.username
        s.active == true
    }
    then {
        print("Active session for user " + u.id)
    }
}
```

**Note**: While you can join on `id`, it's often better to join on the primary key fields directly (e.g., `u.username`).

---

## Constraints

### 1. Primary Key Fields Must Be Primitive Types

Primary keys can only be of type `string`, `number`, or `bool`.

```tsd
// ✅ VALID
type User(#username: string, email: string)
type Order(#order_id: number, total: number)
type Flag(#enabled: bool, name: string)

// ❌ INVALID - object is not primitive
type Document(#metadata: object, content: string)
```

### 2. Primary Key Fields Are Required

All primary key fields **must be present** in assertions.

```tsd
type Person(#name: string, age: number)

// ❌ ERROR: Primary key field 'name' is missing
assert Person(age: 30)

// ✅ CORRECT
assert Person(name: "Alice", age: 30)
```

### 3. The `id` Field Is Reserved

You **cannot set** `id` explicitly in assertions. It is always generated automatically.

```tsd
// ❌ ERROR: Field 'id' is reserved
assert Person(id: "custom_id", name: "Alice", age: 30)

// ✅ CORRECT: Let TSD generate the ID
assert Person(name: "Alice", age: 30)
```

**Migration Note**: If your existing types have a field named `id`, rename it (e.g., to `personId`, `userId`, etc.).

---

## Best Practices

### 1. Choose Natural Keys

Select fields that **naturally identify** the entity in your domain:

```tsd
// ✅ Good: username is a natural unique identifier
type User(#username: string, email: string, role: string)

// ✅ Good: SKU (Stock Keeping Unit) is a natural product identifier
type Product(#sku: string, name: string, price: number)

// ✅ Good: ISO country code is a natural identifier
type Country(#code: string, name: string, population: number)
```

### 2. Use Meaningful Field Names

Avoid generic names like `id` or `pk`. Use descriptive names:

```tsd
// ❌ Less clear
type Product(#id: string, name: string)

// ✅ More descriptive
type Product(#sku: string, name: string)
type Order(#order_number: string, customer: string)
type Student(#student_id: number, name: string)
```

### 3. Use Composite Keys for Many-to-Many Relationships

For junction tables or association entities:

```tsd
// Student ↔ Course (many-to-many)
type Enrollment(#student_id: string, #course_id: string, grade: string, semester: string)

// User ↔ Organization (many-to-many)
type Membership(#user_id: string, #org_id: string, role: string, joined_at: number)
```

### 4. Use Hash for Immutable Events

For event logs, audit trails, or temporal data with no natural key:

```tsd
// No primary key → uses hash
type LogEvent(timestamp: number, level: string, message: string, source: string)
type Metric(name: string, value: number, unit: string, timestamp: number)
type Notification(recipient: string, message: string, priority: number, sent_at: number)
```

### 5. Be Consistent Across Related Types

When types reference each other, use consistent field naming:

```tsd
type User(#username: string, email: string)
type Post(#post_id: string, author_username: string, title: string, content: string)
type Comment(#comment_id: string, post_id: string, author_username: string, text: string)

// Post.author_username references User.username
// Comment.post_id references Post.post_id
```

### 6. Keep Primary Keys Stable

Choose fields whose values **don't change** over time:

```tsd
// ✅ Good: username rarely changes
type User(#username: string, email: string)

// ❌ Avoid: email might change
type User(#email: string, name: string)
```

### 7. Avoid Special Characters in Primary Keys

To keep IDs readable, prefer alphanumeric values:

```tsd
// ✅ Readable ID: Product~LAPTOP-001
type Product(#sku: string, name: string)
assert Product(sku: "LAPTOP-001", name: "Gaming Laptop")

// ❌ Escaped ID: Product~%2Fhome%2Fuser%7Ebackup
type File(#path: string, size: number)
assert File(path: "/home/user~backup", size: 1024)
```

---

## Examples

### Example 1: Simple Primary Key

```tsd
type User(#username: string, email: string, role: string)

assert User(username: "alice", email: "alice@example.com", role: "admin")
// ID: User~alice

assert User(username: "bob", email: "bob@example.com", role: "user")
// ID: User~bob

rule AdminUsers {
    when {
        u: User()
        u.role == "admin"
    }
    then {
        print("Admin user: " + u.username + " (ID: " + u.id + ")")
    }
}
```

### Example 2: Composite Primary Key

```tsd
type Product(#category: string, #name: string, price: number, stock: number)

assert Product(category: "Electronics", name: "Laptop", price: 1200, stock: 5)
// ID: Product~Electronics_Laptop

assert Product(category: "Books", name: "Go Programming", price: 45, stock: 100)
// ID: Product~Books_Go%20Programming

rule LowStock {
    when {
        p: Product()
        p.stock < 10
    }
    then {
        print("Low stock: " + p.category + "/" + p.name + " (ID: " + p.id + ")")
    }
}
```

### Example 3: No Primary Key (Hash)

```tsd
type LogEvent(timestamp: number, level: string, message: string)

assert LogEvent(timestamp: 1704067200, level: "INFO", message: "App started")
// ID: LogEvent~<hash1>

assert LogEvent(timestamp: 1704067201, level: "ERROR", message: "Connection failed")
// ID: LogEvent~<hash2>

rule ErrorLogs {
    when {
        log: LogEvent()
        log.level == "ERROR"
    }
    then {
        print("Error logged (ID: " + log.id + "): " + log.message)
    }
}
```

### Example 4: Relationships

```tsd
type User(#username: string, email: string)
type Order(#order_id: string, username: string, total: number, status: string)

assert User(username: "alice", email: "alice@example.com")
// ID: User~alice

assert Order(order_id: "ORD-001", username: "alice", total: 1500, status: "pending")
// ID: Order~ORD-001

rule UserOrders {
    when {
        u: User()
        o: Order()
        o.username == u.username
        o.status == "pending"
    }
    then {
        print("Pending order " + o.order_id + " for user " + u.username)
        print("  User ID: " + u.id)
        print("  Order ID: " + o.id)
    }
}
```

---

## Migration Guide

See [docs/MIGRATION_IDS.md](MIGRATION_IDS.md) for a complete migration guide.

### Quick Summary

**Before** (old syntax):
```tsd
type Person(name: string, age: number)
assert Person(id: "person_1", name: "Alice", age: 30)
```

**After** (new syntax):
```tsd
type Person(#name: string, age: number)
assert Person(name: "Alice", age: 30)
// ID auto-generated: Person~Alice
```

### Migration Steps

1. **Identify natural keys** for each type
2. **Mark fields with `#`** in type definitions
3. **Remove explicit `id` fields** from assertions
4. **Update rule references** if necessary
5. **Test with real data**

---

## See Also

- [Migration Guide](MIGRATION_IDS.md) - Complete migration guide
- [Examples](../examples/pk_*.tsd) - Comprehensive examples
- [Architecture](architecture/id-generation.md) - Internal architecture
- [API Reference](api/id-generator.md) - Developer API

---

**Note**: Primary keys are a recommended best practice but not required. Programs without primary keys continue to work using hash-based IDs.