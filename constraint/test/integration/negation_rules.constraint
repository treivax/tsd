// Extraction des règles de négation (NotNode) pour tests spécifiques
// ===================================================================

type TestPerson : <id: string, name: string, age: number, salary: number, active: bool, score: number, tags: string, status: string, department: string, level: number>
type TestOrder : <id: string, customer_id: string, product_id: string, amount: number, total: number, date: string, status: string, priority: string, discount: number, region: string>
type TestProduct : <id: string, name: string, category: string, price: number, available: bool, rating: number, keywords: string, brand: string, stock: number, supplier: string>
type TestTransaction : <id: string, account_id: string, amount: number, type: string, timestamp: number, approved: bool, currency: string, reference: string>

// =====================================================================
// RÈGLES DE NÉGATION EXTRAITES (NotNode)
// =====================================================================

// 2.1 Négations simples d'égalité
rule r1 : {p: TestPerson} / NOT (p.age == 0) ==> not_zero_age(p.id)
rule r2 : {o: TestOrder} / NOT (o.status == "cancelled") ==> not_cancelled_order(o.id)

// 2.2 Négations de comparaisons
rule r3 : {p: TestPerson} / NOT (p.salary < 30000) ==> not_low_salary(p.id)
rule r4 : {o: TestOrder} / NOT (o.total > 50000) ==> not_high_total(o.id)
rule r5 : {prod: TestProduct} / NOT (prod.price <= 10) ==> not_cheap_product(prod.id)

// 2.3 Négations d'expressions arithmétiques
rule r6 : {p: TestPerson} / NOT (p.age * 1000 < p.salary) ==> not_age_times_thousand_less_salary(p.id)
rule r7 : {o: TestOrder} / NOT (o.amount + o.discount >= o.total) ==> not_amount_plus_discount_geq_total(o.id)

// 2.4 Négations avec conditions logiques
rule r8 : {p: TestPerson} / NOT (p.active == true AND p.salary > 70000) ==> not_active_high_earner(p.id)
rule r9 : {o: TestOrder} / NOT (o.status == "pending" OR o.priority == "low") ==> not_pending_or_low_priority(o.id)

// 2.5 Négations de fonctions string
rule r10 : {p: TestPerson} / NOT (LENGTH(p.name) < 3) ==> not_short_name(p.id)
rule r11 : {prod: TestProduct} / NOT (prod.keywords CONTAINS "obsolete") ==> not_obsolete_product(prod.id)

// 2.6 Négations d'opérateur IN
rule r12 : {p: TestPerson} / NOT (p.department IN ["temp", "intern"]) ==> not_temporary_employee(p.id)
rule r13 : {o: TestOrder} / NOT (o.status IN ["cancelled", "refunded"]) ==> not_cancelled_refunded_order(o.id)

// 2.7 Négations de jointures (NOT avec plusieurs faits)
rule r14 : {p: TestPerson, o: TestOrder} / p.id == o.customer_id AND NOT (o.total > p.salary / 12) ==> not_order_exceeds_monthly_salary(p.id, o.id)

// 2.8 Double négation
rule r15 : {p: TestPerson} / NOT (NOT (p.active == true)) ==> double_not_active(p.id)

// 2.9 Négations complexes imbriquées
rule r16 : {p: TestPerson, o: TestOrder} / p.id == o.customer_id AND NOT ((p.age < 18 OR p.salary < 25000) AND (o.total > 1000 OR o.priority == "urgent")) ==> not_minor_poor_large_urgent_order(p.id, o.id)

// 6.1 Conditions avec valeurs nulles/zero (cas limites)
rule r17 : {p: TestPerson} / p.age != 0 AND p.salary > 0 ==> valid_non_zero_person(p.id)
rule r18 : {o: TestOrder} / o.amount > 0 AND o.total > 0 ==> valid_positive_order(o.id)

// 6.2 Chaînes vides et longueurs
rule r19 : {p: TestPerson} / LENGTH(p.name) > 0 ==> valid_person_name(p.id)
