
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>tsd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/treivax/tsd/cmd/tsd/main.go (0.0%)</option>
				
				<option value="file1">github.com/treivax/tsd/cmd/universal-rete-runner/main.go (0.0%)</option>
				
				<option value="file2">github.com/treivax/tsd/constraint/api.go (17.4%)</option>
				
				<option value="file3">github.com/treivax/tsd/constraint/cmd/main.go (0.0%)</option>
				
				<option value="file4">github.com/treivax/tsd/constraint/constraint_utils.go (87.7%)</option>
				
				<option value="file5">github.com/treivax/tsd/constraint/errors.go (0.0%)</option>
				
				<option value="file6">github.com/treivax/tsd/constraint/internal/config/config.go (0.0%)</option>
				
				<option value="file7">github.com/treivax/tsd/constraint/parser.go (48.8%)</option>
				
				<option value="file8">github.com/treivax/tsd/constraint/pkg/domain/errors.go (86.7%)</option>
				
				<option value="file9">github.com/treivax/tsd/constraint/pkg/domain/types.go (96.0%)</option>
				
				<option value="file10">github.com/treivax/tsd/constraint/pkg/validator/types.go (98.0%)</option>
				
				<option value="file11">github.com/treivax/tsd/constraint/pkg/validator/validator.go (94.4%)</option>
				
				<option value="file12">github.com/treivax/tsd/constraint/program_state.go (90.7%)</option>
				
				<option value="file13">github.com/treivax/tsd/constraint/program_state_methods.go (100.0%)</option>
				
				<option value="file14">github.com/treivax/tsd/rete/alpha_builder.go (0.0%)</option>
				
				<option value="file15">github.com/treivax/tsd/rete/constraint_pipeline.go (19.8%)</option>
				
				<option value="file16">github.com/treivax/tsd/rete/constraint_pipeline_builder.go (64.7%)</option>
				
				<option value="file17">github.com/treivax/tsd/rete/constraint_pipeline_helpers.go (45.1%)</option>
				
				<option value="file18">github.com/treivax/tsd/rete/constraint_pipeline_parser.go (77.3%)</option>
				
				<option value="file19">github.com/treivax/tsd/rete/constraint_pipeline_validator.go (6.5%)</option>
				
				<option value="file20">github.com/treivax/tsd/rete/converter.go (0.0%)</option>
				
				<option value="file21">github.com/treivax/tsd/rete/evaluator.go (20.0%)</option>
				
				<option value="file22">github.com/treivax/tsd/rete/evaluator_comparisons.go (63.4%)</option>
				
				<option value="file23">github.com/treivax/tsd/rete/evaluator_constraints.go (30.6%)</option>
				
				<option value="file24">github.com/treivax/tsd/rete/evaluator_expressions.go (50.0%)</option>
				
				<option value="file25">github.com/treivax/tsd/rete/evaluator_functions.go (0.0%)</option>
				
				<option value="file26">github.com/treivax/tsd/rete/evaluator_operators.go (0.0%)</option>
				
				<option value="file27">github.com/treivax/tsd/rete/evaluator_values.go (33.7%)</option>
				
				<option value="file28">github.com/treivax/tsd/rete/fact_token.go (83.8%)</option>
				
				<option value="file29">github.com/treivax/tsd/rete/internal/config/config.go (0.0%)</option>
				
				<option value="file30">github.com/treivax/tsd/rete/logger.go (5.3%)</option>
				
				<option value="file31">github.com/treivax/tsd/rete/network.go (39.1%)</option>
				
				<option value="file32">github.com/treivax/tsd/rete/node_accumulate.go (74.1%)</option>
				
				<option value="file33">github.com/treivax/tsd/rete/node_alpha.go (52.6%)</option>
				
				<option value="file34">github.com/treivax/tsd/rete/node_base.go (73.1%)</option>
				
				<option value="file35">github.com/treivax/tsd/rete/node_exists.go (18.4%)</option>
				
				<option value="file36">github.com/treivax/tsd/rete/node_join.go (60.4%)</option>
				
				<option value="file37">github.com/treivax/tsd/rete/node_root.go (76.9%)</option>
				
				<option value="file38">github.com/treivax/tsd/rete/node_terminal.go (80.9%)</option>
				
				<option value="file39">github.com/treivax/tsd/rete/node_type.go (73.2%)</option>
				
				<option value="file40">github.com/treivax/tsd/rete/pkg/domain/errors.go (100.0%)</option>
				
				<option value="file41">github.com/treivax/tsd/rete/pkg/domain/facts.go (100.0%)</option>
				
				<option value="file42">github.com/treivax/tsd/rete/pkg/network/beta_network.go (100.0%)</option>
				
				<option value="file43">github.com/treivax/tsd/rete/pkg/nodes/advanced_beta.go (81.5%)</option>
				
				<option value="file44">github.com/treivax/tsd/rete/pkg/nodes/base.go (100.0%)</option>
				
				<option value="file45">github.com/treivax/tsd/rete/pkg/nodes/beta.go (46.0%)</option>
				
				<option value="file46">github.com/treivax/tsd/rete/store_base.go (2.9%)</option>
				
				<option value="file47">github.com/treivax/tsd/rete/store_indexed.go (0.0%)</option>
				
				<option value="file48">github.com/treivax/tsd/scripts/validate_coherence.go (0.0%)</option>
				
				<option value="file49">github.com/treivax/tsd/test/integration/comprehensive_test_runner.go (0.0%)</option>
				
				<option value="file50">github.com/treivax/tsd/test/integration/test_helper.go (88.9%)</option>
				
				<option value="file51">github.com/treivax/tsd/test/testutil/helper.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "io"
        "os"

        "github.com/treivax/tsd/constraint"
        "github.com/treivax/tsd/rete"
)

// Config holds the CLI configuration
type Config struct {
        ConstraintFile string
        ConstraintText string
        UseStdin       bool
        FactsFile      string
        Verbose        bool
        ShowVersion    bool
        ShowHelp       bool
}

func main() <span class="cov0" title="0">{
        config := parseFlags()

        if config.ShowHelp </span><span class="cov0" title="0">{
                printHelp()
                return
        }</span>

        <span class="cov0" title="0">if config.ShowVersion </span><span class="cov0" title="0">{
                printVersion()
                return
        }</span>

        <span class="cov0" title="0">if err := validateConfig(config); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Erreur: %v\n\n", err)
                printHelp()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">result, sourceName, err := parseConstraintSource(config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Erreur de parsing: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ Parsing r√©ussi\n")
                fmt.Printf("üìã Validation du programme...\n")
        }</span>

        <span class="cov0" title="0">if err := constraint.ValidateConstraintProgram(result); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Erreur de validation: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ Contraintes valid√©es avec succ√®s\n")
        }</span>

        <span class="cov0" title="0">if config.FactsFile != "" </span><span class="cov0" title="0">{
                runWithFacts(config, sourceName)
        }</span> else<span class="cov0" title="0"> {
                runValidationOnly(config)
        }</span>
}

// parseFlags parses command-line flags and returns a Config
func parseFlags() *Config <span class="cov0" title="0">{
        config := &amp;Config{}

        flag.StringVar(&amp;config.ConstraintFile, "constraint", "", "Fichier de contraintes (.constraint)")
        flag.StringVar(&amp;config.ConstraintText, "text", "", "Texte de contrainte directement (alternative √† -constraint)")
        flag.BoolVar(&amp;config.UseStdin, "stdin", false, "Lire les contraintes depuis stdin")
        flag.StringVar(&amp;config.FactsFile, "facts", "", "Fichier de faits (.facts)")
        flag.BoolVar(&amp;config.Verbose, "v", false, "Mode verbeux")
        flag.BoolVar(&amp;config.ShowVersion, "version", false, "Afficher la version")
        flag.BoolVar(&amp;config.ShowHelp, "h", false, "Afficher l'aide")

        flag.Parse()

        return config
}</span>

// validateConfig validates that exactly one input source is specified
func validateConfig(config *Config) error <span class="cov0" title="0">{
        sourcesCount := 0
        if config.ConstraintFile != "" </span><span class="cov0" title="0">{
                sourcesCount++
        }</span>
        <span class="cov0" title="0">if config.ConstraintText != "" </span><span class="cov0" title="0">{
                sourcesCount++
        }</span>
        <span class="cov0" title="0">if config.UseStdin </span><span class="cov0" title="0">{
                sourcesCount++
        }</span>

        <span class="cov0" title="0">if sourcesCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("sp√©cifiez une source (-constraint, -text, ou -stdin)")
        }</span>

        <span class="cov0" title="0">if sourcesCount &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("sp√©cifiez une seule source d'entr√©e")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// parseConstraintSource parses constraints from the configured source
func parseConstraintSource(config *Config) (interface{}, string, error) <span class="cov0" title="0">{
        if config.UseStdin </span><span class="cov0" title="0">{
                return parseFromStdin(config)
        }</span>

        <span class="cov0" title="0">if config.ConstraintText != "" </span><span class="cov0" title="0">{
                return parseFromText(config)
        }</span>

        <span class="cov0" title="0">return parseFromFile(config)</span>
}

// parseFromStdin reads and parses constraints from stdin
func parseFromStdin(config *Config) (interface{}, string, error) <span class="cov0" title="0">{
        sourceName := "&lt;stdin&gt;"

        if config.Verbose </span><span class="cov0" title="0">{
                printParsingHeader("stdin")
        }</span>

        <span class="cov0" title="0">stdinContent, err := io.ReadAll(os.Stdin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("lecture stdin: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := constraint.ParseConstraint(sourceName, stdinContent)
        return result, sourceName, err</span>
}

// parseFromText parses constraints from a text string
func parseFromText(config *Config) (interface{}, string, error) <span class="cov0" title="0">{
        sourceName := "&lt;text&gt;"

        if config.Verbose </span><span class="cov0" title="0">{
                printParsingHeader("texte direct")
        }</span>

        <span class="cov0" title="0">result, err := constraint.ParseConstraint(sourceName, []byte(config.ConstraintText))
        return result, sourceName, err</span>
}

// parseFromFile parses constraints from a file
func parseFromFile(config *Config) (interface{}, string, error) <span class="cov0" title="0">{
        sourceName := config.ConstraintFile

        if _, err := os.Stat(config.ConstraintFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("fichier contrainte non trouv√©: %s", config.ConstraintFile)
        }</span>

        <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("üöÄ TSD - Analyse des contraintes\n")
                fmt.Printf("===============================\n")
                fmt.Printf("Fichier: %s\n\n", config.ConstraintFile)
        }</span>

        <span class="cov0" title="0">result, err := constraint.ParseConstraintFile(config.ConstraintFile)
        return result, sourceName, err</span>
}

// printParsingHeader prints the header for parsing operations
func printParsingHeader(source string) <span class="cov0" title="0">{
        fmt.Printf("üöÄ TSD - Analyse des contraintes\n")
        fmt.Printf("===============================\n")
        fmt.Printf("Source: %s\n\n", source)
}</span>

// runValidationOnly runs in validation-only mode (no facts file)
func runValidationOnly(config *Config) <span class="cov0" title="0">{
        fmt.Printf("‚úÖ Contraintes valid√©es avec succ√®s\n")

        if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("\nüéâ Validation termin√©e!\n")
                fmt.Printf("Les contraintes sont syntaxiquement correctes.\n")
                fmt.Printf("‚ÑπÔ∏è  Utilisez -facts &lt;file&gt; pour ex√©cuter le pipeline RETE complet.\n")
        }</span>
}

// runWithFacts runs the full RETE pipeline with facts
func runWithFacts(config *Config, sourceName string) <span class="cov0" title="0">{
        if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("\nüîß PIPELINE RETE COMPLET\n")
                fmt.Printf("========================\n")
                fmt.Printf("Fichier faits: %s\n\n", config.FactsFile)
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(config.FactsFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Fichier faits non trouv√©: %s\n", config.FactsFile)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">pipeline := rete.NewConstraintPipeline()
        storage := rete.NewMemoryStorage()

        network, facts, err := pipeline.BuildNetworkFromConstraintFileWithFacts(
                sourceName,
                config.FactsFile,
                storage,
        )

        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Erreur pipeline RETE: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">printResults(config, network, facts)</span>
}

// printResults prints the RETE pipeline execution results
func printResults(config *Config, network *rete.ReteNetwork, facts []*rete.Fact) <span class="cov0" title="0">{
        if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("\nüìä R√âSULTATS\n")
                fmt.Printf("============\n")
                fmt.Printf("Faits inject√©s: %d\n", len(facts))
        }</span>

        <span class="cov0" title="0">activations := countActivations(network)

        if activations &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nüéØ ACTIONS DISPONIBLES: %d\n", activations)
                if config.Verbose </span><span class="cov0" title="0">{
                        printActivationDetails(network)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("\n‚ÑπÔ∏è  Aucune action d√©clench√©e\n")
        }</span>

        <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("\n‚úÖ Pipeline RETE ex√©cut√© avec succ√®s\n")
        }</span>
}

// countActivations counts the total number of activations in the network
func countActivations(network *rete.ReteNetwork) int <span class="cov0" title="0">{
        count := 0
        for _, terminal := range network.TerminalNodes </span><span class="cov0" title="0">{
                if terminal.Memory != nil &amp;&amp; terminal.Memory.Tokens != nil </span><span class="cov0" title="0">{
                        count += len(terminal.Memory.Tokens)
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// printActivationDetails prints detailed information about activations
func printActivationDetails(network *rete.ReteNetwork) <span class="cov0" title="0">{
        count := 0
        for _, terminal := range network.TerminalNodes </span><span class="cov0" title="0">{
                if terminal.Memory != nil &amp;&amp; terminal.Memory.Tokens != nil </span><span class="cov0" title="0">{
                        actionName := "unknown"
                        if terminal.Action != nil </span><span class="cov0" title="0">{
                                actionName = terminal.Action.Job.Name
                        }</span>
                        <span class="cov0" title="0">for _, token := range terminal.Memory.Tokens </span><span class="cov0" title="0">{
                                count++
                                fmt.Printf("  %d. %s() - %d bindings\n", count, actionName, len(token.Facts))
                        }</span>
                }
        }
}

// printVersion prints the version information
func printVersion() <span class="cov0" title="0">{
        fmt.Println("TSD (Type System Development) v1.0")
        fmt.Println("Moteur de r√®gles bas√© sur l'algorithme RETE")
}</span>

func printHelp() <span class="cov0" title="0">{
        fmt.Println("TSD - Type System Development")
        fmt.Println("Moteur de r√®gles bas√© sur l'algorithme RETE")
        fmt.Println("")
        fmt.Println("USAGE:")
        fmt.Println("  tsd -constraint &lt;file.constraint&gt; [options]")
        fmt.Println("  tsd -text \"&lt;constraint text&gt;\" [options]")
        fmt.Println("  tsd -stdin [options]")
        fmt.Println("  echo \"&lt;constraint&gt;\" | tsd -stdin")
        fmt.Println("")
        fmt.Println("OPTIONS:")
        fmt.Println("  -constraint &lt;file&gt;  Fichier de r√®gles/contraintes")
        fmt.Println("  -text &lt;string&gt;      Texte de contrainte directement")
        fmt.Println("  -stdin              Lire les contraintes depuis stdin")
        fmt.Println("  -facts &lt;file&gt;       Fichier de faits (optionnel, pour futur usage)")
        fmt.Println("  -v                  Mode verbeux")
        fmt.Println("  -version            Afficher la version")
        fmt.Println("  -h                  Afficher cette aide")
        fmt.Println("")
        fmt.Println("EXEMPLES:")
        fmt.Println("  tsd -constraint rules.constraint")
        fmt.Println("  tsd -constraint rules.constraint -v")
        fmt.Println("  tsd -text 'type Person : &lt;id: string, name: string&gt;'")
        fmt.Println("  echo 'type Person : &lt;id: string&gt;' | tsd -stdin")
        fmt.Println("  cat rules.constraint | tsd -stdin -v")
        fmt.Println("")
        fmt.Println("FORMATS DE FICHIERS:")
        fmt.Println("  .constraint : R√®gles en syntaxe TSD")
        fmt.Println("  .facts      : Faits en format structur√© (support futur)")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/treivax/tsd/rete"
)

func main() <span class="cov0" title="0">{
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        fmt.Println("üß™ RUNNER UNIVERSEL - TESTS COMPLETS R√âSEAU RETE")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        fmt.Println("Pipeline unique avec propagation RETE compl√®te")
        fmt.Printf("Date: %s\n", time.Now().Format("2006-01-02 15:04:05"))
        fmt.Println()

        // Trouver tous les fichiers de test
        testDirs := []struct {
                path     string
                category string
        }{
                {"test/coverage/alpha", "alpha"},
                {"beta_coverage_tests", "beta"},
                {"constraint/test/integration", "integration"},
        }

        type TestFile struct {
                name       string
                category   string
                constraint string
                facts      string
        }

        var allTestFiles []TestFile
        for _, dir := range testDirs </span><span class="cov0" title="0">{
                pattern := filepath.Join(dir.path, "*.constraint")
                matches, _ := filepath.Glob(pattern)

                for _, constraintFile := range matches </span><span class="cov0" title="0">{
                        base := strings.TrimSuffix(constraintFile, ".constraint")
                        factsFile := base + ".facts"

                        if _, err := os.Stat(factsFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">baseName := filepath.Base(base)
                        allTestFiles = append(allTestFiles, TestFile{
                                name:       baseName,
                                category:   dir.category,
                                constraint: constraintFile,
                                facts:      factsFile,
                        })</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("ÔøΩÔøΩ Trouv√© %d tests au total\n\n", len(allTestFiles))

        // Tests qui doivent √©chouer (tests de d√©tection d'erreurs)
        errorTests := map[string]bool{
                "error_args_test": true,
        }

        // Ex√©cuter tous les tests
        passed := 0
        failed := 0
        for i, testFile := range allTestFiles </span><span class="cov0" title="0">{
                fmt.Printf("Test %d/%d: %s... ", i+1, len(allTestFiles), testFile.name)

                pipeline := rete.NewConstraintPipeline()
                storage := rete.NewMemoryStorage()

                // Capturer stdout pour d√©tecter les erreurs d'injection
                oldStdout := os.Stdout
                r, w, _ := os.Pipe()
                os.Stdout = w

                // Canal pour lire la sortie en temps r√©el
                outputChan := make(chan string)
                go func() </span><span class="cov0" title="0">{
                        var buf bytes.Buffer
                        io.Copy(&amp;buf, r)
                        outputChan &lt;- buf.String()
                }</span>()

                <span class="cov0" title="0">network, facts, err := pipeline.BuildNetworkFromConstraintFileWithFacts(
                        testFile.constraint,
                        testFile.facts,
                        storage,
                )

                // Restaurer stdout
                w.Close()
                os.Stdout = oldStdout

                // Lire la sortie captur√©e
                output := &lt;-outputChan

                // Afficher la sortie captur√©e
                fmt.Print(output)

                // D√©tecter si des erreurs d'injection ont eu lieu
                hasInjectionErrors := strings.Contains(output, "‚ö†Ô∏è Erreur injection fait")

                // Si c'est un test d'erreur, l'√©chec est un succ√®s
                isErrorTest := errorTests[testFile.name]

                if err != nil </span><span class="cov0" title="0">{
                        if isErrorTest </span><span class="cov0" title="0">{
                                fmt.Printf("‚úÖ PASSED (error detected as expected)\n")
                                passed++
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("‚ùå FAILED\n")
                                failed++
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Pour les tests d'erreur, v√©rifier si des erreurs d'injection ont √©t√© d√©tect√©es
                <span class="cov0" title="0">if isErrorTest </span><span class="cov0" title="0">{
                        if hasInjectionErrors </span><span class="cov0" title="0">{
                                fmt.Printf("‚úÖ PASSED (injection errors detected as expected)\n")
                                passed++
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("‚ùå FAILED (error should have been detected)\n")
                                failed++
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Compter les activations
                <span class="cov0" title="0">activations := 0
                for _, terminal := range network.TerminalNodes </span><span class="cov0" title="0">{
                        if terminal.Memory != nil &amp;&amp; terminal.Memory.Tokens != nil </span><span class="cov0" title="0">{
                                activations += len(terminal.Memory.Tokens)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("‚úÖ PASSED - T:%d R:%d F:%d A:%d\n",
                        len(network.TypeNodes), len(network.TerminalNodes), len(facts), activations)
                passed++</span>
        }

        <span class="cov0" title="0">fmt.Println()
        fmt.Printf("R√©sum√©: %d tests, %d r√©ussis ‚úÖ, %d √©chou√©s ‚ùå\n", len(allTestFiles), passed, failed)
        if failed == 0 </span><span class="cov0" title="0">{
                fmt.Println("üéâ TOUS LES TESTS SONT PASS√âS!")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package constraint

import (
        "encoding/json"
        "fmt"
)

// ParseConstraint parses constraint input and returns the AST.
// It takes a filename (for error reporting) and the input bytes to parse.
// Returns the parsed AST as an interface{} or an error if parsing fails.
//
// Example:
//
//        content, _ := os.ReadFile("rules.constraint")
//        ast, err := ParseConstraint("rules.constraint", content)
func ParseConstraint(filename string, input []byte) (interface{}, error) <span class="cov8" title="1">{
        return Parse(filename, input)
}</span>

// ValidateConstraintProgram validates a parsed constraint program AST.
// It performs semantic validation including type checking, variable resolution,
// and constraint consistency checks.
//
// Example:
//
//        ast, _ := ParseConstraint("rules.constraint", content)
//        err := ValidateConstraintProgram(ast)
func ValidateConstraintProgram(result interface{}) error <span class="cov0" title="0">{
        return ValidateProgram(result)
}</span>

// ParseConstraintFile parses a constraint file from the filesystem.
// It reads the file and parses it, returning the AST or an error.
// This is a convenience function that combines file reading and parsing.
//
// Example:
//
//        ast, err := ParseConstraintFile("rules.constraint")
func ParseConstraintFile(filename string) (interface{}, error) <span class="cov8" title="1">{
        return ParseFile(filename)
}</span>

// ParseFactsFile parses a .facts file using the constraint grammar.
// This allows facts to be parsed using the same grammar as constraint files,
// enabling unified processing of constraint and fact definitions.
//
// Example:
//
//        facts, err := ParseFactsFile("data.facts")
func ParseFactsFile(filename string) (interface{}, error) <span class="cov0" title="0">{
        return ParseFile(filename)
}</span>

// ExtractFactsFromProgram extrait les faits d'un programme pars√© et les convertit au format RETE
func ExtractFactsFromProgram(result interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Convertir le r√©sultat en structure Program
        jsonData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur conversion JSON: %v", err)
        }</span>

        <span class="cov0" title="0">var program Program
        err = json.Unmarshal(jsonData, &amp;program)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur parsing JSON: %v", err)
        }</span>

        // Convertir les faits au format RETE
        <span class="cov0" title="0">reteFacts := ConvertFactsToReteFormat(program)
        return reteFacts, nil</span>
}

// ConvertResultToProgram convertit le r√©sultat du parser en structure Program
func ConvertResultToProgram(result interface{}) (*Program, error) <span class="cov8" title="1">{
        // Convertir le r√©sultat en structure Program
        jsonData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur conversion JSON: %v", err)
        }</span>

        <span class="cov8" title="1">var program Program
        err = json.Unmarshal(jsonData, &amp;program)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur parsing JSON: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;program, nil</span>
}

// ConvertToReteProgram convertit une structure Program des contraintes vers le format attendu par RETE
func ConvertToReteProgram(program *Program) interface{} <span class="cov0" title="0">{
        // Convertir les types en map[string]interface{} via JSON pour √™tre compatible avec RETE
        typesInterface := make([]interface{}, len(program.Types))
        for i, typeDef := range program.Types </span><span class="cov0" title="0">{
                // S√©rialiser vers JSON puis d√©s√©rialiser en map
                jsonData, err := json.Marshal(typeDef)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var typeMap map[string]interface{}
                json.Unmarshal(jsonData, &amp;typeMap)
                typesInterface[i] = typeMap</span>
        }

        // Convertir les expressions en map[string]interface{} via JSON
        <span class="cov0" title="0">expressionsInterface := make([]interface{}, len(program.Expressions))
        for i, expr := range program.Expressions </span><span class="cov0" title="0">{
                // S√©rialiser vers JSON puis d√©s√©rialiser en map
                jsonData, err := json.Marshal(expr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var exprMap map[string]interface{}
                json.Unmarshal(jsonData, &amp;exprMap)
                expressionsInterface[i] = exprMap</span>
        }

        // Cr√©er une structure compatible avec le format attendu par RETE
        <span class="cov0" title="0">reteProgram := map[string]interface{}{
                "types":       typesInterface,
                "expressions": expressionsInterface,
        }
        return reteProgram</span>
}

// NewIterativeParser creates a new iterative parser that can parse multiple files
// and maintain state across parsing operations. This enables parsing type definitions,
// rules, and facts from separate files while ensuring consistency.
//
// Example:
//
//        parser := NewIterativeParser()
//        err := parser.ParseFile("types.constraint")
//        err = parser.ParseFile("rules.constraint")
//        err = parser.ParseFile("facts.constraint")
//        program := parser.GetProgram()
func NewIterativeParser() *IterativeParser <span class="cov0" title="0">{
        return &amp;IterativeParser{
                state: NewProgramState(),
        }
}</span>

// IterativeParser provides iterative parsing capabilities with state management
type IterativeParser struct {
        state *ProgramState
}

// ParseFile parses a file and merges it with the current state.
// The file can contain types, rules, facts, or any combination.
// Validation is performed to ensure consistency with previously parsed content.
func (ip *IterativeParser) ParseFile(filename string) error <span class="cov0" title="0">{
        return ip.state.ParseAndMerge(filename)
}</span>

// ParseContent parses content from a string and merges it with current state.
func (ip *IterativeParser) ParseContent(content, filename string) error <span class="cov0" title="0">{
        return ip.state.ParseAndMergeContent(content, filename)
}</span>

// GetProgram returns the current combined program state
func (ip *IterativeParser) GetProgram() *Program <span class="cov0" title="0">{
        return ip.state.ToProgram()
}</span>

// GetState returns the internal state for advanced usage
func (ip *IterativeParser) GetState() *ProgramState <span class="cov0" title="0">{
        return ip.state
}</span>

// Reset clears all parsed content and resets to empty state
func (ip *IterativeParser) Reset() <span class="cov0" title="0">{
        ip.state = NewProgramState()
}</span>

// GetParsingStatistics returns statistics about the parsing process
func (ip *IterativeParser) GetParsingStatistics() ParsingStatistics <span class="cov0" title="0">{
        return ParsingStatistics{
                TypesCount:       len(ip.state.Types),
                RulesCount:       len(ip.state.Rules),
                FactsCount:       len(ip.state.Facts),
                FilesParsedCount: len(ip.state.FilesParsed),
                FilesParsed:      ip.state.FilesParsed,
        }
}</span>

// ParsingStatistics contains statistics about the parsing process
type ParsingStatistics struct {
        TypesCount       int      `json:"types_count"`
        RulesCount       int      `json:"rules_count"`
        FactsCount       int      `json:"facts_count"`
        FilesParsedCount int      `json:"files_parsed_count"`
        FilesParsed      []string `json:"files_parsed"`
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "log"
        "os"

        "github.com/treivax/tsd/constraint"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage:")
                fmt.Println("  go run main.go &lt;input-file&gt;")
                fmt.Println("")
                fmt.Println("Exemple:")
                fmt.Println("  go run main.go ../tests/test_input.txt")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">inputFile := os.Args[1]
        input, err := os.ReadFile(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Erreur lecture fichier: %v", err)
        }</span>

        // Parse l'input (la fonction Parse sera g√©n√©r√©e par pigeon)
        <span class="cov0" title="0">result, err := constraint.ParseConstraint("", input)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Erreur parsing: %v", err)
        }</span>

        // Validation du programme
        <span class="cov0" title="0">err = constraint.ValidateConstraintProgram(result)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Erreur de validation: %v", err)
        }</span>

        // Convertir en JSON pour affichage
        <span class="cov0" title="0">jsonOutput, err := json.MarshalIndent(result, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Erreur JSON: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println(string(jsonOutput))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package constraint

import (
        "encoding/json"
        "fmt"
)

// Constraint type constants
const (
        ConstraintTypeFieldAccess = "fieldAccess"
        ConstraintTypeComparison  = "comparison"
        ConstraintTypeLogicalExpr = "logicalExpr"
        ConstraintTypeBinaryOp    = "binaryOp"
)

// Value type constants
const (
        ValueTypeString     = "string"
        ValueTypeNumber     = "number"
        ValueTypeBoolean    = "boolean"
        ValueTypeBool       = "bool"
        ValueTypeIdentifier = "identifier"
        ValueTypeVariable   = "variable"
        ValueTypeUnknown    = "unknown"
)

// Special field name constants
const (
        FieldNameID       = "id"
        FieldNameReteType = "reteType"
)

// Fonctions utilitaires pour traiter l'AST du parser de contraintes

// ValidateTypes v√©rifie que tous les types r√©f√©renc√©s dans les expressions sont d√©finis
func ValidateTypes(program Program) error <span class="cov8" title="1">{
        definedTypes := make(map[string]bool)
        for _, typeDef := range program.Types </span><span class="cov8" title="1">{
                definedTypes[typeDef.Name] = true
        }</span>

        // V√©rifier les variables typ√©es dans toutes les expressions
        <span class="cov8" title="1">for i, expression := range program.Expressions </span><span class="cov8" title="1">{
                for _, variable := range expression.Set.Variables </span><span class="cov8" title="1">{
                        if !definedTypes[variable.DataType] </span><span class="cov8" title="1">{
                                return fmt.Errorf("expression %d: type non d√©fini: %s pour la variable %s", i+1, variable.DataType, variable.Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetTypeFields retourne les champs d'un type donn√©
func GetTypeFields(program Program, typeName string) ([]Field, error) <span class="cov8" title="1">{
        for _, typeDef := range program.Types </span><span class="cov8" title="1">{
                if typeDef.Name == typeName </span><span class="cov8" title="1">{
                        return typeDef.Fields, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("type non trouv√©: %s", typeName)</span>
}

// ValidateFieldAccess v√©rifie qu'un acc√®s aux champs est valide dans une expression donn√©e
func ValidateFieldAccess(program Program, fieldAccess FieldAccess, expressionIndex int) error <span class="cov8" title="1">{
        if expressionIndex &gt;= len(program.Expressions) </span><span class="cov8" title="1">{
                return fmt.Errorf("index d'expression invalide: %d", expressionIndex)
        }</span>

        // Trouver le type de l'objet dans l'expression sp√©cifi√©e
        <span class="cov8" title="1">var objectType string
        for _, variable := range program.Expressions[expressionIndex].Set.Variables </span><span class="cov8" title="1">{
                if variable.Name == fieldAccess.Object </span><span class="cov8" title="1">{
                        objectType = variable.DataType
                        break</span>
                }
        }

        <span class="cov8" title="1">if objectType == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("variable non trouv√©e: %s dans l'expression %d", fieldAccess.Object, expressionIndex+1)
        }</span>

        // V√©rifier que le champ existe dans le type
        <span class="cov8" title="1">fields, err := GetTypeFields(program, objectType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, field := range fields </span><span class="cov8" title="1">{
                if field.Name == fieldAccess.Field </span><span class="cov8" title="1">{
                        return nil // Champ trouv√©
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("champ %s non trouv√© dans le type %s", fieldAccess.Field, objectType)</span>
}

// ValidateAction v√©rifie qu'une action est valide dans le contexte d'une expression
func ValidateAction(program Program, action Action, expressionIndex int) error <span class="cov8" title="1">{
        if expressionIndex &gt;= len(program.Expressions) </span><span class="cov8" title="1">{
                return fmt.Errorf("index d'expression invalide: %d", expressionIndex)
        }</span>

        <span class="cov8" title="1">expression := program.Expressions[expressionIndex]

        // Cr√©er une map des variables disponibles dans l'expression
        availableVars := make(map[string]bool)
        for _, variable := range expression.Set.Variables </span><span class="cov8" title="1">{
                availableVars[variable.Name] = true
        }</span>

        // V√©rifier que tous les arguments de l'action r√©f√©rencent des variables valides
        <span class="cov8" title="1">for _, arg := range action.Job.Args </span><span class="cov8" title="1">{
                // Extraire les variables utilis√©es dans l'argument
                vars := extractVariablesFromArg(arg)
                for _, varName := range vars </span><span class="cov8" title="1">{
                        if !availableVars[varName] </span><span class="cov8" title="1">{
                                return fmt.Errorf("action %s: argument contient la variable '%s' qui ne correspond √† aucune variable de l'expression", action.Job.Name, varName)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// extractVariablesFromArg extrait les noms de variables utilis√©es dans un argument d'action
func extractVariablesFromArg(arg interface{}) []string <span class="cov8" title="1">{
        var vars []string

        // Si c'est une string simple, c'est probablement un nom de variable
        if str, ok := arg.(string); ok </span><span class="cov8" title="1">{
                vars = append(vars, str)
                return vars
        }</span>

        // Si c'est un objet (map), extraire les variables selon le type
        <span class="cov8" title="1">if argMap, ok := arg.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                argType, _ := argMap["type"].(string)
                switch argType </span>{
                case "fieldAccess":<span class="cov8" title="1">
                        if object, ok := argMap["object"].(string); ok </span><span class="cov8" title="1">{
                                vars = append(vars, object)
                        }</span>
                case "string":<span class="cov8" title="1"></span>
                        // Les string literals ne contiennent pas de variables
                case "number":<span class="cov8" title="1"></span>
                        // Les number literals ne contiennent pas de variables
                default:<span class="cov0" title="0"></span>
                        // Pour d'autres types, on peut chercher r√©cursivement
                        // mais pour l'instant on ignore
                }
        }

        <span class="cov8" title="1">return vars</span>
}

// GetFieldType retourne le type d'un champ sp√©cifique d'un objet dans une expression
func GetFieldType(program Program, object string, field string, expressionIndex int) (string, error) <span class="cov8" title="1">{
        if expressionIndex &gt;= len(program.Expressions) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("index d'expression invalide: %d", expressionIndex)
        }</span>

        // Trouver le type de l'objet
        <span class="cov8" title="1">var objectType string
        for _, variable := range program.Expressions[expressionIndex].Set.Variables </span><span class="cov8" title="1">{
                if variable.Name == object </span><span class="cov8" title="1">{
                        objectType = variable.DataType
                        break</span>
                }
        }

        <span class="cov8" title="1">if objectType == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("variable non trouv√©e: %s", object)
        }</span>

        // Trouver le type du champ dans la d√©finition du type
        <span class="cov8" title="1">fields, err := GetTypeFields(program, objectType)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">for _, f := range fields </span><span class="cov8" title="1">{
                if f.Name == field </span><span class="cov8" title="1">{
                        return f.Type, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("champ %s non trouv√© dans le type %s", field, objectType)</span>
}

// GetValueType retourne le type d'une valeur dans l'AST
func GetValueType(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                valueType, ok := v["type"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return ValueTypeUnknown
                }</span>
                <span class="cov8" title="1">switch valueType </span>{
                case ValueTypeNumber:<span class="cov8" title="1">
                        return ValueTypeNumber</span>
                case ValueTypeString:<span class="cov8" title="1">
                        return ValueTypeString</span>
                case ValueTypeBoolean:<span class="cov8" title="1">
                        return ValueTypeBool</span>
                case ValueTypeVariable:<span class="cov8" title="1">
                        // Pour les variables comme "true", "false" qui sont pars√©es comme variables
                        name, ok := v["name"].(string)
                        if ok </span><span class="cov8" title="1">{
                                switch name </span>{
                                case "true", "false":<span class="cov8" title="1">
                                        return ValueTypeBool</span>
                                }
                        }
                        <span class="cov8" title="1">return ValueTypeVariable</span> // Type non d√©terminable sans contexte
                }
        }
        <span class="cov8" title="1">return ValueTypeUnknown</span>
}

// ValidateTypeCompatibility v√©rifie la compatibilit√© des types dans les comparaisons
// ValidateTypeCompatibility validates type compatibility within constraints
func ValidateTypeCompatibility(program Program, constraint interface{}, expressionIndex int) error <span class="cov8" title="1">{
        constraintMap, ok := constraint.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">constraintType, ok := constraintMap["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch constraintType </span>{
        case ConstraintTypeComparison:<span class="cov8" title="1">
                return validateConstraintWithOperands(program, constraintMap, expressionIndex, true)</span>
        case ConstraintTypeLogicalExpr:<span class="cov0" title="0">
                return validateLogicalExpressionConstraint(program, constraintMap, expressionIndex)</span>
        case ConstraintTypeBinaryOp:<span class="cov0" title="0">
                return validateConstraintWithOperands(program, constraintMap, expressionIndex, false)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// validateConstraintWithOperands handles validation for constraints with left/right operands
func validateConstraintWithOperands(program Program, c map[string]interface{}, expressionIndex int, checkCompatibility bool) error <span class="cov8" title="1">{
        left := c["left"]
        right := c["right"]

        if left == nil || right == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Validate type compatibility between operands (only for comparisons)
        <span class="cov8" title="1">if checkCompatibility </span><span class="cov8" title="1">{
                if err := validateOperandTypeCompatibility(program, left, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Recursive validation for operands
        <span class="cov8" title="1">if err := ValidateTypeCompatibility(program, left, expressionIndex); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateTypeCompatibility(program, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateOperandTypeCompatibility checks if two operands have compatible types
func validateOperandTypeCompatibility(program Program, left, right interface{}, expressionIndex int) error <span class="cov8" title="1">{
        leftType, err := getOperandType(program, left, expressionIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rightType, err := getOperandType(program, right, expressionIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check compatibility
        <span class="cov8" title="1">if leftType != ValueTypeUnknown &amp;&amp; rightType != ValueTypeUnknown &amp;&amp; rightType != ValueTypeVariable </span><span class="cov8" title="1">{
                if leftType != rightType </span><span class="cov0" title="0">{
                        return fmt.Errorf("incompatibilit√© de types dans la comparaison: %s vs %s", leftType, rightType)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getOperandType determines the type of an operand in a constraint
func getOperandType(program Program, operand interface{}, expressionIndex int) (string, error) <span class="cov8" title="1">{
        operandMap, ok := operand.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return GetValueType(operand), nil
        }</span>

        <span class="cov8" title="1">if operandMap["type"] == ConstraintTypeFieldAccess </span><span class="cov8" title="1">{
                object := operandMap["object"].(string)
                field := operandMap["field"].(string)
                return GetFieldType(program, object, field, expressionIndex)
        }</span>

        <span class="cov8" title="1">return GetValueType(operand), nil</span>
}

// validateLogicalExpressionConstraint handles logical expression validation
func validateLogicalExpressionConstraint(program Program, c map[string]interface{}, expressionIndex int) error <span class="cov8" title="1">{
        if left := c["left"]; left != nil </span><span class="cov8" title="1">{
                if err := ValidateTypeCompatibility(program, left, expressionIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">operations, ok := c["operations"].([]interface{})
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, op := range operations </span><span class="cov8" title="1">{
                opMap, ok := op.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if right := opMap["right"]; right != nil </span><span class="cov8" title="1">{
                        if err := ValidateTypeCompatibility(program, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// validateBinaryOpConstraint handles binary operation validation (wrapper for backward compatibility)
func validateBinaryOpConstraint(program Program, c map[string]interface{}, expressionIndex int) error <span class="cov8" title="1">{
        return validateConstraintWithOperands(program, c, expressionIndex, false)
}</span>

// ValidateConstraintFieldAccess parcourt r√©cursivement les contraintes pour valider les acc√®s aux champs
func ValidateConstraintFieldAccess(program Program, constraint interface{}, expressionIndex int) error <span class="cov8" title="1">{
        switch c := constraint.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                constraintType, ok := c["type"].(string)
                if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">switch constraintType </span>{
                case ConstraintTypeFieldAccess:<span class="cov8" title="1">
                        object, objOk := c["object"].(string)
                        field, fieldOk := c["field"].(string)
                        if objOk &amp;&amp; fieldOk </span><span class="cov8" title="1">{
                                fieldAccess := FieldAccess{
                                        Type:   ConstraintTypeFieldAccess,
                                        Object: object,
                                        Field:  field,
                                }
                                return ValidateFieldAccess(program, fieldAccess, expressionIndex)
                        }</span>
                case ConstraintTypeComparison, ConstraintTypeBinaryOp:<span class="cov8" title="1">
                        return validateFieldAccessInOperands(program, c, expressionIndex)</span>
                case ConstraintTypeLogicalExpr:<span class="cov8" title="1">
                        return validateFieldAccessInLogicalExpr(program, c, expressionIndex)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// validateFieldAccessInOperands validates field access in left/right operands
func validateFieldAccessInOperands(program Program, c map[string]interface{}, expressionIndex int) error <span class="cov8" title="1">{
        if left := c["left"]; left != nil </span><span class="cov8" title="1">{
                if err := ValidateConstraintFieldAccess(program, left, expressionIndex); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if right := c["right"]; right != nil </span><span class="cov8" title="1">{
                if err := ValidateConstraintFieldAccess(program, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// validateFieldAccessInLogicalExpr validates field access in logical expressions
func validateFieldAccessInLogicalExpr(program Program, c map[string]interface{}, expressionIndex int) error <span class="cov8" title="1">{
        if left := c["left"]; left != nil </span><span class="cov8" title="1">{
                if err := ValidateConstraintFieldAccess(program, left, expressionIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if operations, ok := c["operations"].([]interface{}); ok </span><span class="cov8" title="1">{
                for _, op := range operations </span><span class="cov8" title="1">{
                        if opMap, ok := op.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if right := opMap["right"]; right != nil </span><span class="cov8" title="1">{
                                        if err := ValidateConstraintFieldAccess(program, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateProgram effectue une validation compl√®te du programme pars√©
func ValidateProgram(result interface{}) error <span class="cov8" title="1">{
        // Convertir le r√©sultat en structure Program
        program, err := convertResultToProgram(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validation des types
        <span class="cov8" title="1">if err := ValidateTypes(program); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("erreur validation types: %v", err)
        }</span>

        // Validation des faits
        <span class="cov8" title="1">if err := ValidateFacts(program); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur validation faits: %v", err)
        }</span>

        // Validation des contraintes dans les expressions
        <span class="cov8" title="1">if err := validateExpressionConstraints(program); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validation des actions dans les expressions
        <span class="cov8" title="1">if err := validateExpressionActions(program); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Printf("‚úì Programme valide avec %d type(s), %d expression(s) et %d fait(s)\n", len(program.Types), len(program.Expressions), len(program.Facts))
        return nil</span>
}

// convertResultToProgram converts the parser result to a Program structure
func convertResultToProgram(result interface{}) (Program, error) <span class="cov8" title="1">{
        var program Program

        jsonData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return program, fmt.Errorf("erreur conversion JSON: %v", err)
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(jsonData, &amp;program)
        if err != nil </span><span class="cov0" title="0">{
                return program, fmt.Errorf("erreur parsing JSON: %v", err)
        }</span>

        <span class="cov8" title="1">return program, nil</span>
}

// validateExpressionConstraints validates field access and type compatibility in all constraints
func validateExpressionConstraints(program Program) error <span class="cov8" title="1">{
        for i, expression := range program.Expressions </span><span class="cov8" title="1">{
                if expression.Constraints != nil </span><span class="cov8" title="1">{
                        // Validation des acc√®s aux champs
                        if err := ValidateConstraintFieldAccess(program, expression.Constraints, i); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur validation champs dans l'expression %d: %v", i+1, err)
                        }</span>

                        // Validation des types dans les comparaisons
                        <span class="cov8" title="1">if err := ValidateTypeCompatibility(program, expression.Constraints, i); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur validation types dans l'expression %d: %v", i+1, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// validateExpressionActions validates that all expressions have valid actions
func validateExpressionActions(program Program) error <span class="cov8" title="1">{
        for i, expression := range program.Expressions </span><span class="cov8" title="1">{
                if expression.Action != nil </span><span class="cov8" title="1">{
                        if err := ValidateAction(program, *expression.Action, i); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur validation action dans l'expression %d: %v", i+1, err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Avec la nouvelle grammaire, cette condition ne devrait plus arriver
                        return fmt.Errorf("action manquante dans l'expression %d: chaque r√®gle doit avoir une action d√©finie", i+1)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateFacts v√©rifie que tous les faits pars√©s sont coh√©rents avec les d√©finitions de types
func ValidateFacts(program Program) error <span class="cov8" title="1">{
        definedTypes := make(map[string]TypeDefinition)
        for _, typeDef := range program.Types </span><span class="cov8" title="1">{
                definedTypes[typeDef.Name] = typeDef
        }</span>

        <span class="cov8" title="1">for i, fact := range program.Facts </span><span class="cov8" title="1">{
                // V√©rifier que le type du fait existe
                typeDef, exists := definedTypes[fact.TypeName]
                if !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("fait %d: type non d√©fini: %s", i+1, fact.TypeName)
                }</span>

                // Cr√©er une map des champs d√©finis pour ce type
                <span class="cov8" title="1">definedFields := make(map[string]string)
                for _, field := range typeDef.Fields </span><span class="cov8" title="1">{
                        definedFields[field.Name] = field.Type
                }</span>

                // V√©rifier chaque champ du fait
                <span class="cov8" title="1">for j, factField := range fact.Fields </span><span class="cov8" title="1">{
                        // V√©rifier que le champ existe dans le type
                        expectedType, exists := definedFields[factField.Name]
                        if !exists </span><span class="cov8" title="1">{
                                return fmt.Errorf("fait %d, champ %d: champ '%s' non d√©fini dans le type %s", i+1, j+1, factField.Name, fact.TypeName)
                        }</span>

                        // V√©rifier la compatibilit√© du type de la valeur
                        <span class="cov8" title="1">err := ValidateFactFieldType(factField.Value, expectedType, fact.TypeName, factField.Name)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("fait %d, champ %d: %v", i+1, j+1, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateFactFieldType v√©rifie que la valeur d'un champ de fait correspond au type attendu
func ValidateFactFieldType(value FactValue, expectedType, typeName, fieldName string) error <span class="cov8" title="1">{
        switch expectedType </span>{
        case ValueTypeString:<span class="cov8" title="1">
                if value.Type != ValueTypeString &amp;&amp; value.Type != ValueTypeIdentifier </span><span class="cov8" title="1">{
                        return fmt.Errorf("champ '%s' du type %s attend une valeur string, re√ßu %s", fieldName, typeName, value.Type)
                }</span>
        case ValueTypeNumber:<span class="cov8" title="1">
                if value.Type != ValueTypeNumber </span><span class="cov8" title="1">{
                        return fmt.Errorf("champ '%s' du type %s attend une valeur number, re√ßu %s", fieldName, typeName, value.Type)
                }</span>
        case ValueTypeBool, ValueTypeBoolean:<span class="cov8" title="1">
                if value.Type != ValueTypeBoolean </span><span class="cov8" title="1">{
                        return fmt.Errorf("champ '%s' du type %s attend une valeur boolean, re√ßu %s", fieldName, typeName, value.Type)
                }</span>
        default:<span class="cov8" title="1">
                // Type non reconnu, on accepte pour l'instant
                return nil</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ConvertFactsToReteFormat convertit les faits pars√©s par la grammaire vers le format attendu par le r√©seau RETE
func ConvertFactsToReteFormat(program Program) []map[string]interface{} <span class="cov8" title="1">{
        var reteFacts []map[string]interface{}

        for i, fact := range program.Facts </span><span class="cov8" title="1">{
                reteFact := map[string]interface{}{
                        FieldNameReteType: fact.TypeName, // Type RETE (ex: "Balance")
                }

                // Convertir les champs et g√©rer l'ID
                factID := convertFactFields(fact.Fields, reteFact, i)

                // D√©finir l'ID du fait (n√©cessaire pour le r√©seau RETE)
                reteFact[FieldNameID] = factID

                // CORRECTION CRITIQUE: Assurer que le type RETE est toujours pr√©serv√©
                reteFact[FieldNameReteType] = fact.TypeName

                reteFacts = append(reteFacts, reteFact)
        }</span>

        <span class="cov8" title="1">return reteFacts</span>
}

// convertFactFields converts fact fields and returns the fact ID
func convertFactFields(fields []FactField, reteFact map[string]interface{}, factIndex int) string <span class="cov8" title="1">{
        var factID string
        hasExplicitID := false

        for _, field := range fields </span><span class="cov8" title="1">{
                convertedValue := convertFactFieldValue(field.Value)

                // Ajouter le champ au fact
                reteFact[field.Name] = convertedValue

                // V√©rifier si c'est un champ ID
                if field.Name == FieldNameID </span><span class="cov8" title="1">{
                        factID = convertedValue.(string)
                        hasExplicitID = true
                }</span>
        }

        // G√©n√©rer un ID si pas fourni explicitement
        <span class="cov8" title="1">if !hasExplicitID </span><span class="cov0" title="0">{
                factID = fmt.Sprintf("parsed_fact_%d", factIndex+1)
        }</span>

        <span class="cov8" title="1">return factID</span>
}

// convertFactFieldValue converts a fact field value to its appropriate Go type
func convertFactFieldValue(value FactValue) interface{} <span class="cov8" title="1">{
        switch value.Type </span>{
        case ValueTypeString, ValueTypeNumber, ValueTypeBoolean:<span class="cov8" title="1">
                if valMap, ok := value.Value.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        return valMap["value"]
                }</span>
                <span class="cov0" title="0">return value.Value</span>
        case ValueTypeIdentifier:<span class="cov8" title="1">
                // Les identifiants non-quot√©s sont trait√©s comme des strings
                return value.Value</span>
        default:<span class="cov0" title="0">
                return value.Value</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package constraint

import (
        "fmt"
        "strings"
)

// ValidationError represents a non-blocking validation error that occurs during parsing.
// It captures the context of the error including the file, type of element (fact/rule),
// the error message, and optionally the line number where the error occurred.
type ValidationError struct {
        File    string // Source file where the error occurred
        Type    string // Type of element: "fact", "rule", or "type"
        Message string // Descriptive error message
        Line    int    // Line number in the source file (0 if unknown)
}

// Error implements the error interface for ValidationError.
func (ve ValidationError) Error() string <span class="cov0" title="0">{
        if ve.Line &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%d: %s in %s", ve.File, ve.Line, ve.Message, ve.Type)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s: %s in %s", ve.File, ve.Message, ve.Type)</span>
}

// ValidationErrors is a collection of validation errors.
type ValidationErrors []ValidationError

// Error implements the error interface for ValidationErrors.
func (ve ValidationErrors) Error() string <span class="cov0" title="0">{
        if len(ve) == 0 </span><span class="cov0" title="0">{
                return "no validation errors"
        }</span>
        <span class="cov0" title="0">if len(ve) == 1 </span><span class="cov0" title="0">{
                return ve[0].Error()
        }</span>
        <span class="cov0" title="0">var sb strings.Builder
        fmt.Fprintf(&amp;sb, "%d validation errors:\n", len(ve))
        for i, err := range ve </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;sb, "  %d. %s\n", i+1, err.Error())
        }</span>
        <span class="cov0" title="0">return sb.String()</span>
}

// HasErrors returns true if there are any validation errors.
func (ve ValidationErrors) HasErrors() bool <span class="cov0" title="0">{
        return len(ve) &gt; 0
}</span>

// Count returns the number of validation errors.
func (ve ValidationErrors) Count() int <span class="cov0" title="0">{
        return len(ve)
}</span>

// Error type constants for validation errors
const (
        ErrorTypeFact = "fact"
        ErrorTypeRule = "rule"
        ErrorTypeType = "type"
)
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/treivax/tsd/constraint/pkg/domain"
)

// Config repr√©sente la configuration compl√®te du module constraint
type Config struct {
        Parser    domain.ParserConfig    `json:"parser"`
        Validator domain.ValidatorConfig `json:"validator"`
        Logger    domain.LoggerConfig    `json:"logger"`
        Debug     bool                   `json:"debug"`
        Version   string                 `json:"version"`
}

// DefaultConfig retourne une configuration par d√©faut
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Parser: domain.ParserConfig{
                        MaxExpressions: 1000,
                        Debug:          false,
                        Recover:        true,
                },
                Validator: domain.ValidatorConfig{
                        StrictMode: true,
                        AllowedOperators: []string{
                                "==", "!=", "&lt;", "&gt;", "&lt;=", "&gt;=",
                                "AND", "OR", "NOT",
                                "+", "-", "*", "/", "%",
                        },
                        MaxDepth: 20,
                },
                Logger: domain.LoggerConfig{
                        Level:  "info",
                        Format: "json",
                        Output: "stdout",
                },
                Debug:   false,
                Version: "1.0.0",
        }
}</span>

// ConfigManager g√®re la configuration du module
type ConfigManager struct {
        config   *Config
        filePath string
}

// NewConfigManager cr√©e un nouveau gestionnaire de configuration
func NewConfigManager(configPath string) *ConfigManager <span class="cov0" title="0">{
        return &amp;ConfigManager{
                config:   DefaultConfig(),
                filePath: configPath,
        }
}</span>

// LoadFromFile charge la configuration depuis un fichier
func (cm *ConfigManager) LoadFromFile() error <span class="cov0" title="0">{
        if cm.filePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("config file path not set")
        }</span>

        // V√©rifier si le fichier existe
        <span class="cov0" title="0">if _, err := os.Stat(cm.filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Si le fichier n'existe pas, cr√©er la configuration par d√©faut
                return cm.SaveToFile()
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(cm.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config file %s: %w", cm.filePath, err)
        }</span>

        <span class="cov0" title="0">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse config file %s: %w", cm.filePath, err)
        }</span>

        <span class="cov0" title="0">cm.config = &amp;config
        return nil</span>
}

// SaveToFile sauvegarde la configuration dans un fichier
func (cm *ConfigManager) SaveToFile() error <span class="cov0" title="0">{
        if cm.filePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("config file path not set")
        }</span>

        // Cr√©er le r√©pertoire si n√©cessaire
        <span class="cov0" title="0">dir := filepath.Dir(cm.filePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory %s: %w", dir, err)
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(cm.config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(cm.filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file %s: %w", cm.filePath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfig retourne la configuration actuelle
func (cm *ConfigManager) GetConfig() *Config <span class="cov0" title="0">{
        return cm.config
}</span>

// SetConfig d√©finit une nouvelle configuration
func (cm *ConfigManager) SetConfig(config *Config) <span class="cov0" title="0">{
        cm.config = config
}</span>

// GetParserConfig retourne la configuration du parser
func (cm *ConfigManager) GetParserConfig() domain.ParserConfig <span class="cov0" title="0">{
        return cm.config.Parser
}</span>

// GetValidatorConfig retourne la configuration du validateur
func (cm *ConfigManager) GetValidatorConfig() domain.ValidatorConfig <span class="cov0" title="0">{
        return cm.config.Validator
}</span>

// GetLoggerConfig retourne la configuration du logger
func (cm *ConfigManager) GetLoggerConfig() domain.LoggerConfig <span class="cov0" title="0">{
        return cm.config.Logger
}</span>

// IsDebugEnabled v√©rifie si le mode debug est activ√©
func (cm *ConfigManager) IsDebugEnabled() bool <span class="cov0" title="0">{
        return cm.config.Debug || cm.config.Parser.Debug
}</span>

// UpdateParserConfig met √† jour la configuration du parser
func (cm *ConfigManager) UpdateParserConfig(config domain.ParserConfig) <span class="cov0" title="0">{
        cm.config.Parser = config
}</span>

// UpdateValidatorConfig met √† jour la configuration du validateur
func (cm *ConfigManager) UpdateValidatorConfig(config domain.ValidatorConfig) <span class="cov0" title="0">{
        cm.config.Validator = config
}</span>

// UpdateLoggerConfig met √† jour la configuration du logger
func (cm *ConfigManager) UpdateLoggerConfig(config domain.LoggerConfig) <span class="cov0" title="0">{
        cm.config.Logger = config
}</span>

// SetDebug active/d√©sactive le mode debug
func (cm *ConfigManager) SetDebug(enabled bool) <span class="cov0" title="0">{
        cm.config.Debug = enabled
}</span>

// Validate valide la configuration
func (cm *ConfigManager) Validate() error <span class="cov0" title="0">{
        config := cm.config

        // Validation du parser
        if config.Parser.MaxExpressions &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("parser.max_expressions must be positive, got %d", config.Parser.MaxExpressions)
        }</span>

        // Validation du validateur
        <span class="cov0" title="0">if config.Validator.MaxDepth &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("validator.max_depth must be positive, got %d", config.Validator.MaxDepth)
        }</span>

        <span class="cov0" title="0">if len(config.Validator.AllowedOperators) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("validator.allowed_operators cannot be empty")
        }</span>

        // Validation du logger
        <span class="cov0" title="0">validLevels := map[string]bool{
                "debug": true, "info": true, "warn": true, "error": true,
        }
        if !validLevels[config.Logger.Level] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid logger level: %s", config.Logger.Level)
        }</span>

        <span class="cov0" title="0">validFormats := map[string]bool{
                "json": true, "text": true, "plain": true,
        }
        if !validFormats[config.Logger.Format] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid logger format: %s", config.Logger.Format)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// String retourne une repr√©sentation JSON de la configuration
func (cm *ConfigManager) String() string <span class="cov0" title="0">{
        data, err := json.MarshalIndent(cm.config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("ConfigManager{error: %v}", err)
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}

// Clone cr√©e une copie de la configuration
func (cm *ConfigManager) Clone() *ConfigManager <span class="cov0" title="0">{
        configCopy := *cm.config
        return &amp;ConfigManager{
                config:   &amp;configCopy,
                filePath: cm.filePath,
        }
}</span>

// Reset remet la configuration aux valeurs par d√©faut
func (cm *ConfigManager) Reset() <span class="cov0" title="0">{
        cm.config = DefaultConfig()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by pigeon; DO NOT EDIT.

package constraint

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "math"
        "os"
        "sort"
        "strconv"
        "strings"
        "sync"
        "unicode"
        "unicode/utf8"
)

var g = &amp;grammar{
        rules: []*rule{
                {
                        name: "Start",
                        pos:  position{line: 16, col: 1, offset: 413},
                        expr: &amp;actionExpr{
                                pos: position{line: 16, col: 10, offset: 422},
                                run: (*parser).callonStart1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 16, col: 10, offset: 422},
                                        exprs: []any{
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 16, col: 10, offset: 422},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 16, col: 12, offset: 424},
                                                        label: "statements",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 16, col: 23, offset: 435},
                                                                name: "StatementList",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 16, col: 37, offset: 449},
                                                        name: "_",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 16, col: 39, offset: 451},
                                                        name: "EOF",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "StatementList",
                        pos:  position{line: 47, col: 1, offset: 1459},
                        expr: &amp;actionExpr{
                                pos: position{line: 47, col: 18, offset: 1476},
                                run: (*parser).callonStatementList1,
                                expr: &amp;labeledExpr{
                                        pos:   position{line: 47, col: 18, offset: 1476},
                                        label: "statements",
                                        expr: &amp;zeroOrMoreExpr{
                                                pos: position{line: 47, col: 29, offset: 1487},
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 47, col: 30, offset: 1488},
                                                        exprs: []any{
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 47, col: 30, offset: 1488},
                                                                        name: "Statement",
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 47, col: 40, offset: 1498},
                                                                        name: "_",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Statement",
                        pos:  position{line: 57, col: 1, offset: 1722},
                        expr: &amp;choiceExpr{
                                pos: position{line: 57, col: 14, offset: 1735},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 57, col: 14, offset: 1735},
                                                name: "TypeDefinition",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 57, col: 31, offset: 1752},
                                                name: "Expression",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 57, col: 44, offset: 1765},
                                                name: "RemoveFact",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 57, col: 57, offset: 1778},
                                                name: "Fact",
                                        },
                                },
                        },
                },
                {
                        name: "TypeDefinition",
                        pos:  position{line: 59, col: 1, offset: 1784},
                        expr: &amp;actionExpr{
                                pos: position{line: 59, col: 19, offset: 1802},
                                run: (*parser).callonTypeDefinition1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 59, col: 19, offset: 1802},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 59, col: 19, offset: 1802},
                                                        val:        "type",
                                                        ignoreCase: false,
                                                        want:       "\"type\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 26, offset: 1809},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 59, col: 28, offset: 1811},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 59, col: 33, offset: 1816},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 43, offset: 1826},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 59, col: 45, offset: 1828},
                                                        val:        ":",
                                                        ignoreCase: false,
                                                        want:       "\":\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 49, offset: 1832},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 59, col: 51, offset: 1834},
                                                        val:        "&lt;",
                                                        ignoreCase: false,
                                                        want:       "\"&lt;\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 55, offset: 1838},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 59, col: 57, offset: 1840},
                                                        label: "fields",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 59, col: 64, offset: 1847},
                                                                name: "FieldList",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 74, offset: 1857},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 59, col: 76, offset: 1859},
                                                        val:        "&gt;",
                                                        ignoreCase: false,
                                                        want:       "\"&gt;\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FieldList",
                        pos:  position{line: 67, col: 1, offset: 1996},
                        expr: &amp;actionExpr{
                                pos: position{line: 67, col: 14, offset: 2009},
                                run: (*parser).callonFieldList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 67, col: 14, offset: 2009},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 67, col: 14, offset: 2009},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 67, col: 20, offset: 2015},
                                                                name: "Field",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 67, col: 26, offset: 2021},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 67, col: 31, offset: 2026},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 67, col: 32, offset: 2027},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 67, col: 32, offset: 2027},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 67, col: 34, offset: 2029},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 67, col: 38, offset: 2033},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 67, col: 40, offset: 2035},
                                                                                        name: "Field",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Field",
                        pos:  position{line: 77, col: 1, offset: 2256},
                        expr: &amp;actionExpr{
                                pos: position{line: 77, col: 10, offset: 2265},
                                run: (*parser).callonField1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 77, col: 10, offset: 2265},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 77, col: 10, offset: 2265},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 77, col: 15, offset: 2270},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 77, col: 25, offset: 2280},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 77, col: 27, offset: 2282},
                                                        val:        ":",
                                                        ignoreCase: false,
                                                        want:       "\":\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 77, col: 31, offset: 2286},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 77, col: 33, offset: 2288},
                                                        label: "fieldType",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 77, col: 43, offset: 2298},
                                                                name: "AtomicType",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "AtomicType",
                        pos:  position{line: 84, col: 1, offset: 2409},
                        expr: &amp;choiceExpr{
                                pos: position{line: 84, col: 15, offset: 2423},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 84, col: 15, offset: 2423},
                                                run: (*parser).callonAtomicType2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 84, col: 15, offset: 2423},
                                                        val:        "string",
                                                        ignoreCase: false,
                                                        want:       "\"string\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 85, col: 15, offset: 2473},
                                                run: (*parser).callonAtomicType4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 85, col: 15, offset: 2473},
                                                        val:        "number",
                                                        ignoreCase: false,
                                                        want:       "\"number\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 86, col: 15, offset: 2523},
                                                run: (*parser).callonAtomicType6,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 86, col: 15, offset: 2523},
                                                        val:        "bool",
                                                        ignoreCase: false,
                                                        want:       "\"bool\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Expression",
                        pos:  position{line: 88, col: 1, offset: 2556},
                        expr: &amp;actionExpr{
                                pos: position{line: 88, col: 15, offset: 2570},
                                run: (*parser).callonExpression1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 88, col: 15, offset: 2570},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 88, col: 15, offset: 2570},
                                                        label: "set",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 88, col: 19, offset: 2574},
                                                                name: "Set",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 88, col: 23, offset: 2578},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 88, col: 25, offset: 2580},
                                                        val:        "/",
                                                        ignoreCase: false,
                                                        want:       "\"/\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 88, col: 29, offset: 2584},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 88, col: 31, offset: 2586},
                                                        label: "constraints",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 88, col: 43, offset: 2598},
                                                                name: "Constraints",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 88, col: 55, offset: 2610},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 88, col: 57, offset: 2612},
                                                        label: "action",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 88, col: 64, offset: 2619},
                                                                name: "Action",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Set",
                        pos:  position{line: 97, col: 1, offset: 2789},
                        expr: &amp;actionExpr{
                                pos: position{line: 97, col: 8, offset: 2796},
                                run: (*parser).callonSet1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 97, col: 8, offset: 2796},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 97, col: 8, offset: 2796},
                                                        val:        "{",
                                                        ignoreCase: false,
                                                        want:       "\"{\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 97, col: 12, offset: 2800},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 97, col: 14, offset: 2802},
                                                        label: "variables",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 97, col: 24, offset: 2812},
                                                                name: "TypedVariableList",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 97, col: 42, offset: 2830},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 97, col: 44, offset: 2832},
                                                        val:        "}",
                                                        ignoreCase: false,
                                                        want:       "\"}\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "TypedVariableList",
                        pos:  position{line: 104, col: 1, offset: 2942},
                        expr: &amp;actionExpr{
                                pos: position{line: 104, col: 22, offset: 2963},
                                run: (*parser).callonTypedVariableList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 104, col: 22, offset: 2963},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 104, col: 22, offset: 2963},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 104, col: 28, offset: 2969},
                                                                name: "TypedVariable",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 104, col: 42, offset: 2983},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 104, col: 47, offset: 2988},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 104, col: 48, offset: 2989},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 104, col: 48, offset: 2989},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 104, col: 50, offset: 2991},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 104, col: 54, offset: 2995},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 104, col: 56, offset: 2997},
                                                                                        name: "TypedVariable",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "TypedVariable",
                        pos:  position{line: 114, col: 1, offset: 3238},
                        expr: &amp;actionExpr{
                                pos: position{line: 114, col: 18, offset: 3255},
                                run: (*parser).callonTypedVariable1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 114, col: 18, offset: 3255},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 114, col: 18, offset: 3255},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 114, col: 23, offset: 3260},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 114, col: 33, offset: 3270},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 114, col: 35, offset: 3272},
                                                        val:        ":",
                                                        ignoreCase: false,
                                                        want:       "\":\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 114, col: 39, offset: 3276},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 114, col: 41, offset: 3278},
                                                        label: "dataType",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 114, col: 50, offset: 3287},
                                                                name: "IdentName",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Constraints",
                        pos:  position{line: 122, col: 1, offset: 3433},
                        expr: &amp;actionExpr{
                                pos: position{line: 122, col: 16, offset: 3448},
                                run: (*parser).callonConstraints1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 122, col: 16, offset: 3448},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 122, col: 16, offset: 3448},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 122, col: 22, offset: 3454},
                                                                name: "Constraint",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 122, col: 33, offset: 3465},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 122, col: 38, offset: 3470},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 122, col: 39, offset: 3471},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 122, col: 39, offset: 3471},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 122, col: 41, offset: 3473},
                                                                                        name: "LogicalOp",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 122, col: 51, offset: 3483},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 122, col: 53, offset: 3485},
                                                                                        name: "Constraint",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Constraint",
                        pos:  position{line: 144, col: 1, offset: 4029},
                        expr: &amp;choiceExpr{
                                pos: position{line: 144, col: 15, offset: 4043},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 144, col: 15, offset: 4043},
                                                run: (*parser).callonConstraint2,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 144, col: 15, offset: 4043},
                                                        exprs: []any{
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 144, col: 15, offset: 4043},
                                                                        val:        "(",
                                                                        ignoreCase: false,
                                                                        want:       "\"(\"",
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 144, col: 19, offset: 4047},
                                                                        name: "_",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 144, col: 21, offset: 4049},
                                                                        label: "expr",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 144, col: 26, offset: 4054},
                                                                                name: "Constraints",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 144, col: 38, offset: 4066},
                                                                        name: "_",
                                                                },
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 144, col: 40, offset: 4068},
                                                                        val:        ")",
                                                                        ignoreCase: false,
                                                                        want:       "\")\"",
                                                                },
                                                        },
                                                },
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 145, col: 15, offset: 4109},
                                                name: "NotConstraint",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 146, col: 15, offset: 4139},
                                                name: "ExistsConstraint",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 147, col: 15, offset: 4172},
                                                name: "AccumulateConstraint",
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 148, col: 15, offset: 4209},
                                                run: (*parser).callonConstraint13,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 148, col: 15, offset: 4209},
                                                        exprs: []any{
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 148, col: 15, offset: 4209},
                                                                        label: "left",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 148, col: 20, offset: 4214},
                                                                                name: "ArithmeticExpr",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 148, col: 35, offset: 4229},
                                                                        name: "_",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 148, col: 37, offset: 4231},
                                                                        label: "op",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 148, col: 40, offset: 4234},
                                                                                name: "ComparisonOp",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 148, col: 53, offset: 4247},
                                                                        name: "_",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 148, col: 55, offset: 4249},
                                                                        label: "right",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 148, col: 61, offset: 4255},
                                                                                name: "ArithmeticExpr",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "NotConstraint",
                        pos:  position{line: 157, col: 1, offset: 4421},
                        expr: &amp;actionExpr{
                                pos: position{line: 157, col: 18, offset: 4438},
                                run: (*parser).callonNotConstraint1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 157, col: 18, offset: 4438},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 157, col: 18, offset: 4438},
                                                        val:        "NOT",
                                                        ignoreCase: false,
                                                        want:       "\"NOT\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 157, col: 24, offset: 4444},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 157, col: 26, offset: 4446},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 157, col: 30, offset: 4450},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 157, col: 32, offset: 4452},
                                                        label: "expr",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 157, col: 37, offset: 4457},
                                                                name: "Constraints",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 157, col: 49, offset: 4469},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 157, col: 51, offset: 4471},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ExistsConstraint",
                        pos:  position{line: 164, col: 1, offset: 4587},
                        expr: &amp;actionExpr{
                                pos: position{line: 164, col: 21, offset: 4607},
                                run: (*parser).callonExistsConstraint1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 164, col: 21, offset: 4607},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 164, col: 21, offset: 4607},
                                                        val:        "EXISTS",
                                                        ignoreCase: false,
                                                        want:       "\"EXISTS\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 30, offset: 4616},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 164, col: 32, offset: 4618},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 36, offset: 4622},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 164, col: 38, offset: 4624},
                                                        label: "variable",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 164, col: 47, offset: 4633},
                                                                name: "TypedVariable",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 61, offset: 4647},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 164, col: 63, offset: 4649},
                                                        val:        "/",
                                                        ignoreCase: false,
                                                        want:       "\"/\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 67, offset: 4653},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 164, col: 69, offset: 4655},
                                                        label: "condition",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 164, col: 79, offset: 4665},
                                                                name: "Constraints",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 91, offset: 4677},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 164, col: 93, offset: 4679},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "AccumulateConstraint",
                        pos:  position{line: 172, col: 1, offset: 4832},
                        expr: &amp;actionExpr{
                                pos: position{line: 172, col: 25, offset: 4856},
                                run: (*parser).callonAccumulateConstraint1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 172, col: 25, offset: 4856},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 25, offset: 4856},
                                                        label: "accumFunc",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 35, offset: 4866},
                                                                name: "AccumulateFunction",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 54, offset: 4885},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 172, col: 56, offset: 4887},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 60, offset: 4891},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 62, offset: 4893},
                                                        label: "accumVar",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 71, offset: 4902},
                                                                name: "TypedVariable",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 85, offset: 4916},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 172, col: 87, offset: 4918},
                                                        val:        "/",
                                                        ignoreCase: false,
                                                        want:       "\"/\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 91, offset: 4922},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 93, offset: 4924},
                                                        label: "accumCond",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 103, offset: 4934},
                                                                name: "Constraints",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 115, offset: 4946},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 117, offset: 4948},
                                                        label: "accumField",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 172, col: 128, offset: 4959},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 172, col: 129, offset: 4960},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 172, col: 129, offset: 4960},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 172, col: 131, offset: 4962},
                                                                                        val:        ";",
                                                                                        ignoreCase: false,
                                                                                        want:       "\";\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 172, col: 135, offset: 4966},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 172, col: 137, offset: 4968},
                                                                                        name: "FieldAccess",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 151, offset: 4982},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 172, col: 153, offset: 4984},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 157, offset: 4988},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 159, offset: 4990},
                                                        label: "accumOp",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 167, offset: 4998},
                                                                name: "ComparisonOp",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 180, offset: 5011},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 182, offset: 5013},
                                                        label: "accumThreshold",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 197, offset: 5028},
                                                                name: "ArithmeticExpr",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "AccumulateFunction",
                        pos:  position{line: 190, col: 1, offset: 5510},
                        expr: &amp;choiceExpr{
                                pos: position{line: 190, col: 23, offset: 5532},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 190, col: 23, offset: 5532},
                                                run: (*parser).callonAccumulateFunction2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 190, col: 23, offset: 5532},
                                                        val:        "AVG",
                                                        ignoreCase: false,
                                                        want:       "\"AVG\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 191, col: 22, offset: 5583},
                                                run: (*parser).callonAccumulateFunction4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 191, col: 22, offset: 5583},
                                                        val:        "COUNT",
                                                        ignoreCase: false,
                                                        want:       "\"COUNT\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 192, col: 22, offset: 5638},
                                                run: (*parser).callonAccumulateFunction6,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 192, col: 22, offset: 5638},
                                                        val:        "SUM",
                                                        ignoreCase: false,
                                                        want:       "\"SUM\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 193, col: 22, offset: 5689},
                                                run: (*parser).callonAccumulateFunction8,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 193, col: 22, offset: 5689},
                                                        val:        "MIN",
                                                        ignoreCase: false,
                                                        want:       "\"MIN\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 194, col: 22, offset: 5740},
                                                run: (*parser).callonAccumulateFunction10,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 194, col: 22, offset: 5740},
                                                        val:        "MAX",
                                                        ignoreCase: false,
                                                        want:       "\"MAX\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ArithmeticExpr",
                        pos:  position{line: 197, col: 1, offset: 5770},
                        expr: &amp;actionExpr{
                                pos: position{line: 197, col: 19, offset: 5788},
                                run: (*parser).callonArithmeticExpr1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 197, col: 19, offset: 5788},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 197, col: 19, offset: 5788},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 197, col: 25, offset: 5794},
                                                                name: "Term",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 197, col: 30, offset: 5799},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 197, col: 35, offset: 5804},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 197, col: 36, offset: 5805},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 197, col: 36, offset: 5805},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;choiceExpr{
                                                                                        pos: position{line: 197, col: 39, offset: 5808},
                                                                                        alternatives: []any{
                                                                                                &amp;litMatcher{
                                                                                                        pos:        position{line: 197, col: 39, offset: 5808},
                                                                                                        val:        "+",
                                                                                                        ignoreCase: false,
                                                                                                        want:       "\"+\"",
                                                                                                },
                                                                                                &amp;litMatcher{
                                                                                                        pos:        position{line: 197, col: 45, offset: 5814},
                                                                                                        val:        "-",
                                                                                                        ignoreCase: false,
                                                                                                        want:       "\"-\"",
                                                                                                },
                                                                                        },
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 197, col: 50, offset: 5819},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 197, col: 52, offset: 5821},
                                                                                        name: "Term",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Term",
                        pos:  position{line: 216, col: 1, offset: 6264},
                        expr: &amp;actionExpr{
                                pos: position{line: 216, col: 9, offset: 6272},
                                run: (*parser).callonTerm1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 216, col: 9, offset: 6272},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 216, col: 9, offset: 6272},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 216, col: 15, offset: 6278},
                                                                name: "Factor",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 216, col: 22, offset: 6285},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 216, col: 27, offset: 6290},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 216, col: 28, offset: 6291},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 216, col: 28, offset: 6291},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;choiceExpr{
                                                                                        pos: position{line: 216, col: 31, offset: 6294},
                                                                                        alternatives: []any{
                                                                                                &amp;litMatcher{
                                                                                                        pos:        position{line: 216, col: 31, offset: 6294},
                                                                                                        val:        "*",
                                                                                                        ignoreCase: false,
                                                                                                        want:       "\"*\"",
                                                                                                },
                                                                                                &amp;litMatcher{
                                                                                                        pos:        position{line: 216, col: 37, offset: 6300},
                                                                                                        val:        "/",
                                                                                                        ignoreCase: false,
                                                                                                        want:       "\"/\"",
                                                                                                },
                                                                                        },
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 216, col: 42, offset: 6305},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 216, col: 44, offset: 6307},
                                                                                        name: "Factor",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Factor",
                        pos:  position{line: 235, col: 1, offset: 6752},
                        expr: &amp;choiceExpr{
                                pos: position{line: 235, col: 11, offset: 6762},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 235, col: 11, offset: 6762},
                                                run: (*parser).callonFactor2,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 235, col: 11, offset: 6762},
                                                        exprs: []any{
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 235, col: 11, offset: 6762},
                                                                        val:        "(",
                                                                        ignoreCase: false,
                                                                        want:       "\"(\"",
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 235, col: 15, offset: 6766},
                                                                        name: "_",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 235, col: 17, offset: 6768},
                                                                        label: "expr",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 235, col: 22, offset: 6773},
                                                                                name: "ArithmeticExpr",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 235, col: 37, offset: 6788},
                                                                        name: "_",
                                                                },
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 235, col: 39, offset: 6790},
                                                                        val:        ")",
                                                                        ignoreCase: false,
                                                                        want:       "\")\"",
                                                                },
                                                        },
                                                },
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 236, col: 11, offset: 6827},
                                                name: "FunctionCall",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 237, col: 11, offset: 6852},
                                                name: "FieldAccess",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 238, col: 11, offset: 6876},
                                                name: "Number",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 239, col: 11, offset: 6895},
                                                name: "StringLiteral",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 240, col: 11, offset: 6921},
                                                name: "BooleanLiteral",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 241, col: 11, offset: 6948},
                                                name: "ArrayLiteral",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 242, col: 11, offset: 6973},
                                                name: "Variable",
                                        },
                                },
                        },
                },
                {
                        name: "FieldAccess",
                        pos:  position{line: 244, col: 1, offset: 6983},
                        expr: &amp;actionExpr{
                                pos: position{line: 244, col: 16, offset: 6998},
                                run: (*parser).callonFieldAccess1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 244, col: 16, offset: 6998},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 244, col: 16, offset: 6998},
                                                        label: "object",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 244, col: 23, offset: 7005},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 244, col: 33, offset: 7015},
                                                        val:        ".",
                                                        ignoreCase: false,
                                                        want:       "\".\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 244, col: 37, offset: 7019},
                                                        label: "field",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 244, col: 43, offset: 7025},
                                                                name: "IdentName",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Variable",
                        pos:  position{line: 252, col: 1, offset: 7167},
                        expr: &amp;actionExpr{
                                pos: position{line: 252, col: 13, offset: 7179},
                                run: (*parser).callonVariable1,
                                expr: &amp;labeledExpr{
                                        pos:   position{line: 252, col: 13, offset: 7179},
                                        label: "name",
                                        expr: &amp;ruleRefExpr{
                                                pos:  position{line: 252, col: 18, offset: 7184},
                                                name: "IdentName",
                                        },
                                },
                        },
                },
                {
                        name: "ArrayLiteral",
                        pos:  position{line: 259, col: 1, offset: 7295},
                        expr: &amp;actionExpr{
                                pos: position{line: 259, col: 17, offset: 7311},
                                run: (*parser).callonArrayLiteral1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 259, col: 17, offset: 7311},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 259, col: 17, offset: 7311},
                                                        val:        "[",
                                                        ignoreCase: false,
                                                        want:       "\"[\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 259, col: 21, offset: 7315},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 259, col: 23, offset: 7317},
                                                        label: "elements",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 259, col: 32, offset: 7326},
                                                                expr: &amp;ruleRefExpr{
                                                                        pos:  position{line: 259, col: 32, offset: 7326},
                                                                        name: "ArrayElementList",
                                                                },
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 259, col: 50, offset: 7344},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 259, col: 52, offset: 7346},
                                                        val:        "]",
                                                        ignoreCase: false,
                                                        want:       "\"]\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ArrayElementList",
                        pos:  position{line: 269, col: 1, offset: 7529},
                        expr: &amp;actionExpr{
                                pos: position{line: 269, col: 21, offset: 7549},
                                run: (*parser).callonArrayElementList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 269, col: 21, offset: 7549},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 269, col: 21, offset: 7549},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 269, col: 27, offset: 7555},
                                                                name: "ArithmeticExpr",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 269, col: 42, offset: 7570},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 269, col: 47, offset: 7575},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 269, col: 48, offset: 7576},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 269, col: 48, offset: 7576},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 269, col: 50, offset: 7578},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 269, col: 54, offset: 7582},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 269, col: 56, offset: 7584},
                                                                                        name: "ArithmeticExpr",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FunctionCall",
                        pos:  position{line: 279, col: 1, offset: 7822},
                        expr: &amp;actionExpr{
                                pos: position{line: 279, col: 17, offset: 7838},
                                run: (*parser).callonFunctionCall1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 279, col: 17, offset: 7838},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 279, col: 17, offset: 7838},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 279, col: 22, offset: 7843},
                                                                name: "FunctionName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 279, col: 35, offset: 7856},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 279, col: 37, offset: 7858},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 279, col: 41, offset: 7862},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 279, col: 43, offset: 7864},
                                                        label: "args",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 279, col: 48, offset: 7869},
                                                                expr: &amp;ruleRefExpr{
                                                                        pos:  position{line: 279, col: 48, offset: 7869},
                                                                        name: "FunctionArgList",
                                                                },
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 279, col: 65, offset: 7886},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 279, col: 67, offset: 7888},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FunctionName",
                        pos:  position{line: 290, col: 1, offset: 8077},
                        expr: &amp;choiceExpr{
                                pos: position{line: 290, col: 17, offset: 8093},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 290, col: 17, offset: 8093},
                                                run: (*parser).callonFunctionName2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 290, col: 17, offset: 8093},
                                                        val:        "LENGTH",
                                                        ignoreCase: false,
                                                        want:       "\"LENGTH\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 291, col: 17, offset: 8145},
                                                run: (*parser).callonFunctionName4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 291, col: 17, offset: 8145},
                                                        val:        "SUBSTRING",
                                                        ignoreCase: false,
                                                        want:       "\"SUBSTRING\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 292, col: 17, offset: 8203},
                                                run: (*parser).callonFunctionName6,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 292, col: 17, offset: 8203},
                                                        val:        "UPPER",
                                                        ignoreCase: false,
                                                        want:       "\"UPPER\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 293, col: 17, offset: 8253},
                                                run: (*parser).callonFunctionName8,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 293, col: 17, offset: 8253},
                                                        val:        "LOWER",
                                                        ignoreCase: false,
                                                        want:       "\"LOWER\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 294, col: 17, offset: 8303},
                                                run: (*parser).callonFunctionName10,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 294, col: 17, offset: 8303},
                                                        val:        "TRIM",
                                                        ignoreCase: false,
                                                        want:       "\"TRIM\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 295, col: 17, offset: 8351},
                                                run: (*parser).callonFunctionName12,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 295, col: 17, offset: 8351},
                                                        val:        "ABS",
                                                        ignoreCase: false,
                                                        want:       "\"ABS\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 296, col: 17, offset: 8397},
                                                run: (*parser).callonFunctionName14,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 296, col: 17, offset: 8397},
                                                        val:        "ROUND",
                                                        ignoreCase: false,
                                                        want:       "\"ROUND\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 297, col: 17, offset: 8447},
                                                run: (*parser).callonFunctionName16,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 297, col: 17, offset: 8447},
                                                        val:        "FLOOR",
                                                        ignoreCase: false,
                                                        want:       "\"FLOOR\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 298, col: 17, offset: 8497},
                                                run: (*parser).callonFunctionName18,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 298, col: 17, offset: 8497},
                                                        val:        "CEIL",
                                                        ignoreCase: false,
                                                        want:       "\"CEIL\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FunctionArgList",
                        pos:  position{line: 300, col: 1, offset: 8528},
                        expr: &amp;actionExpr{
                                pos: position{line: 300, col: 20, offset: 8547},
                                run: (*parser).callonFunctionArgList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 300, col: 20, offset: 8547},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 300, col: 20, offset: 8547},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 300, col: 26, offset: 8553},
                                                                name: "ArithmeticExpr",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 300, col: 41, offset: 8568},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 300, col: 46, offset: 8573},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 300, col: 47, offset: 8574},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 300, col: 47, offset: 8574},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 300, col: 49, offset: 8576},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 300, col: 53, offset: 8580},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 300, col: 55, offset: 8582},
                                                                                        name: "ArithmeticExpr",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Action",
                        pos:  position{line: 310, col: 1, offset: 8804},
                        expr: &amp;actionExpr{
                                pos: position{line: 310, col: 11, offset: 8814},
                                run: (*parser).callonAction1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 310, col: 11, offset: 8814},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 310, col: 11, offset: 8814},
                                                        val:        "==&gt;",
                                                        ignoreCase: false,
                                                        want:       "\"==&gt;\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 310, col: 17, offset: 8820},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 310, col: 19, offset: 8822},
                                                        label: "job",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 310, col: 23, offset: 8826},
                                                                name: "JobCall",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "JobCall",
                        pos:  position{line: 317, col: 1, offset: 8931},
                        expr: &amp;actionExpr{
                                pos: position{line: 317, col: 12, offset: 8942},
                                run: (*parser).callonJobCall1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 317, col: 12, offset: 8942},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 317, col: 12, offset: 8942},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 317, col: 17, offset: 8947},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 317, col: 27, offset: 8957},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 317, col: 29, offset: 8959},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 317, col: 33, offset: 8963},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 317, col: 35, offset: 8965},
                                                        label: "args",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 317, col: 40, offset: 8970},
                                                                expr: &amp;ruleRefExpr{
                                                                        pos:  position{line: 317, col: 40, offset: 8970},
                                                                        name: "ArgumentList",
                                                                },
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 317, col: 54, offset: 8984},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 317, col: 56, offset: 8986},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ArgumentList",
                        pos:  position{line: 328, col: 1, offset: 9170},
                        expr: &amp;actionExpr{
                                pos: position{line: 328, col: 17, offset: 9186},
                                run: (*parser).callonArgumentList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 328, col: 17, offset: 9186},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 328, col: 17, offset: 9186},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 328, col: 23, offset: 9192},
                                                                name: "ArithmeticExpr",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 328, col: 38, offset: 9207},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 328, col: 43, offset: 9212},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 328, col: 44, offset: 9213},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 328, col: 44, offset: 9213},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 328, col: 46, offset: 9215},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 328, col: 50, offset: 9219},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 328, col: 52, offset: 9221},
                                                                                        name: "ArithmeticExpr",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ComparisonOp",
                        pos:  position{line: 338, col: 1, offset: 9463},
                        expr: &amp;choiceExpr{
                                pos: position{line: 338, col: 17, offset: 9479},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 338, col: 17, offset: 9479},
                                                run: (*parser).callonComparisonOp2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 338, col: 17, offset: 9479},
                                                        val:        "==",
                                                        ignoreCase: false,
                                                        want:       "\"==\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 339, col: 17, offset: 9523},
                                                run: (*parser).callonComparisonOp4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 339, col: 17, offset: 9523},
                                                        val:        "!=",
                                                        ignoreCase: false,
                                                        want:       "\"!=\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 340, col: 17, offset: 9567},
                                                run: (*parser).callonComparisonOp6,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 340, col: 17, offset: 9567},
                                                        val:        "&lt;=",
                                                        ignoreCase: false,
                                                        want:       "\"&lt;=\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 341, col: 17, offset: 9611},
                                                run: (*parser).callonComparisonOp8,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 341, col: 17, offset: 9611},
                                                        val:        "&gt;=",
                                                        ignoreCase: false,
                                                        want:       "\"&gt;=\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 342, col: 17, offset: 9655},
                                                run: (*parser).callonComparisonOp10,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 342, col: 17, offset: 9655},
                                                        val:        "&lt;",
                                                        ignoreCase: false,
                                                        want:       "\"&lt;\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 343, col: 17, offset: 9698},
                                                run: (*parser).callonComparisonOp12,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 343, col: 17, offset: 9698},
                                                        val:        "&gt;",
                                                        ignoreCase: false,
                                                        want:       "\"&gt;\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 344, col: 17, offset: 9741},
                                                run: (*parser).callonComparisonOp14,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 344, col: 17, offset: 9741},
                                                        val:        "IN",
                                                        ignoreCase: false,
                                                        want:       "\"IN\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 345, col: 17, offset: 9785},
                                                run: (*parser).callonComparisonOp16,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 345, col: 17, offset: 9785},
                                                        val:        "LIKE",
                                                        ignoreCase: false,
                                                        want:       "\"LIKE\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 346, col: 17, offset: 9833},
                                                run: (*parser).callonComparisonOp18,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 346, col: 17, offset: 9833},
                                                        val:        "MATCHES",
                                                        ignoreCase: false,
                                                        want:       "\"MATCHES\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 347, col: 17, offset: 9887},
                                                run: (*parser).callonComparisonOp20,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 347, col: 17, offset: 9887},
                                                        val:        "CONTAINS",
                                                        ignoreCase: false,
                                                        want:       "\"CONTAINS\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "LogicalOp",
                        pos:  position{line: 349, col: 1, offset: 9926},
                        expr: &amp;choiceExpr{
                                pos: position{line: 349, col: 14, offset: 9939},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 349, col: 14, offset: 9939},
                                                run: (*parser).callonLogicalOp2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 349, col: 14, offset: 9939},
                                                        val:        "AND",
                                                        ignoreCase: false,
                                                        want:       "\"AND\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 350, col: 14, offset: 9982},
                                                run: (*parser).callonLogicalOp4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 350, col: 14, offset: 9982},
                                                        val:        "OR",
                                                        ignoreCase: false,
                                                        want:       "\"OR\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "BooleanLiteral",
                        pos:  position{line: 352, col: 1, offset: 10010},
                        expr: &amp;choiceExpr{
                                pos: position{line: 352, col: 19, offset: 10028},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 352, col: 19, offset: 10028},
                                                run: (*parser).callonBooleanLiteral2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 352, col: 19, offset: 10028},
                                                        val:        "true",
                                                        ignoreCase: false,
                                                        want:       "\"true\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 358, col: 5, offset: 10161},
                                                run: (*parser).callonBooleanLiteral4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 358, col: 5, offset: 10161},
                                                        val:        "false",
                                                        ignoreCase: false,
                                                        want:       "\"false\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Number",
                        pos:  position{line: 365, col: 1, offset: 10291},
                        expr: &amp;actionExpr{
                                pos: position{line: 365, col: 11, offset: 10301},
                                run: (*parser).callonNumber1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 365, col: 11, offset: 10301},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 365, col: 11, offset: 10301},
                                                        label: "sign",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 365, col: 16, offset: 10306},
                                                                expr: &amp;litMatcher{
                                                                        pos:        position{line: 365, col: 16, offset: 10306},
                                                                        val:        "-",
                                                                        ignoreCase: false,
                                                                        want:       "\"-\"",
                                                                },
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 365, col: 21, offset: 10311},
                                                        label: "digits",
                                                        expr: &amp;oneOrMoreExpr{
                                                                pos: position{line: 365, col: 28, offset: 10318},
                                                                expr: &amp;charClassMatcher{
                                                                        pos:        position{line: 365, col: 28, offset: 10318},
                                                                        val:        "[0-9]",
                                                                        ranges:     []rune{'0', '9'},
                                                                        ignoreCase: false,
                                                                        inverted:   false,
                                                                },
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 365, col: 35, offset: 10325},
                                                        label: "decimal",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 365, col: 43, offset: 10333},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 365, col: 44, offset: 10334},
                                                                        exprs: []any{
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 365, col: 44, offset: 10334},
                                                                                        val:        ".",
                                                                                        ignoreCase: false,
                                                                                        want:       "\".\"",
                                                                                },
                                                                                &amp;oneOrMoreExpr{
                                                                                        pos: position{line: 365, col: 48, offset: 10338},
                                                                                        expr: &amp;charClassMatcher{
                                                                                                pos:        position{line: 365, col: 48, offset: 10338},
                                                                                                val:        "[0-9]",
                                                                                                ranges:     []rune{'0', '9'},
                                                                                                ignoreCase: false,
                                                                                                inverted:   false,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "StringLiteral",
                        pos:  position{line: 376, col: 1, offset: 10551},
                        expr: &amp;choiceExpr{
                                pos: position{line: 376, col: 18, offset: 10568},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 376, col: 18, offset: 10568},
                                                run: (*parser).callonStringLiteral2,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 376, col: 18, offset: 10568},
                                                        exprs: []any{
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 376, col: 18, offset: 10568},
                                                                        val:        "\"",
                                                                        ignoreCase: false,
                                                                        want:       "\"\\\"\"",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 376, col: 23, offset: 10573},
                                                                        label: "chars",
                                                                        expr: &amp;zeroOrMoreExpr{
                                                                                pos: position{line: 376, col: 29, offset: 10579},
                                                                                expr: &amp;ruleRefExpr{
                                                                                        pos:  position{line: 376, col: 29, offset: 10579},
                                                                                        name: "DoubleStringChar",
                                                                                },
                                                                        },
                                                                },
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 376, col: 47, offset: 10597},
                                                                        val:        "\"",
                                                                        ignoreCase: false,
                                                                        want:       "\"\\\"\"",
                                                                },
                                                        },
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 388, col: 5, offset: 10933},
                                                run: (*parser).callonStringLiteral9,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 388, col: 5, offset: 10933},
                                                        exprs: []any{
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 388, col: 5, offset: 10933},
                                                                        val:        "'",
                                                                        ignoreCase: false,
                                                                        want:       "\"'\"",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 388, col: 9, offset: 10937},
                                                                        label: "chars",
                                                                        expr: &amp;zeroOrMoreExpr{
                                                                                pos: position{line: 388, col: 15, offset: 10943},
                                                                                expr: &amp;ruleRefExpr{
                                                                                        pos:  position{line: 388, col: 15, offset: 10943},
                                                                                        name: "SingleStringChar",
                                                                                },
                                                                        },
                                                                },
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 388, col: 33, offset: 10961},
                                                                        val:        "'",
                                                                        ignoreCase: false,
                                                                        want:       "\"'\"",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "DoubleStringChar",
                        pos:  position{line: 401, col: 1, offset: 11291},
                        expr: &amp;choiceExpr{
                                pos: position{line: 401, col: 21, offset: 11311},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 401, col: 21, offset: 11311},
                                                name: "EscapeSequence",
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 401, col: 38, offset: 11328},
                                                run: (*parser).callonDoubleStringChar3,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 401, col: 39, offset: 11329},
                                                        exprs: []any{
                                                                &amp;notExpr{
                                                                        pos: position{line: 401, col: 39, offset: 11329},
                                                                        expr: &amp;litMatcher{
                                                                                pos:        position{line: 401, col: 40, offset: 11330},
                                                                                val:        "\"",
                                                                                ignoreCase: false,
                                                                                want:       "\"\\\"\"",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 401, col: 44, offset: 11334},
                                                                        name: "UnicodeChar",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "SingleStringChar",
                        pos:  position{line: 405, col: 1, offset: 11383},
                        expr: &amp;choiceExpr{
                                pos: position{line: 405, col: 21, offset: 11403},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 405, col: 21, offset: 11403},
                                                name: "EscapeSequence",
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 405, col: 38, offset: 11420},
                                                run: (*parser).callonSingleStringChar3,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 405, col: 39, offset: 11421},
                                                        exprs: []any{
                                                                &amp;notExpr{
                                                                        pos: position{line: 405, col: 39, offset: 11421},
                                                                        expr: &amp;litMatcher{
                                                                                pos:        position{line: 405, col: 40, offset: 11422},
                                                                                val:        "'",
                                                                                ignoreCase: false,
                                                                                want:       "\"'\"",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 405, col: 45, offset: 11427},
                                                                        name: "UnicodeChar",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "EscapeSequence",
                        pos:  position{line: 409, col: 1, offset: 11476},
                        expr: &amp;actionExpr{
                                pos: position{line: 409, col: 19, offset: 11494},
                                run: (*parser).callonEscapeSequence1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 409, col: 19, offset: 11494},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 409, col: 19, offset: 11494},
                                                        val:        "\\",
                                                        ignoreCase: false,
                                                        want:       "\"\\\\\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 409, col: 24, offset: 11499},
                                                        label: "char",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 409, col: 29, offset: 11504},
                                                                name: "EscapeChar",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "EscapeChar",
                        pos:  position{line: 428, col: 1, offset: 11833},
                        expr: &amp;choiceExpr{
                                pos: position{line: 428, col: 15, offset: 11847},
                                alternatives: []any{
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 15, offset: 11847},
                                                val:        "n",
                                                ignoreCase: false,
                                                want:       "\"n\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 21, offset: 11853},
                                                val:        "t",
                                                ignoreCase: false,
                                                want:       "\"t\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 27, offset: 11859},
                                                val:        "r",
                                                ignoreCase: false,
                                                want:       "\"r\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 33, offset: 11865},
                                                val:        "\\",
                                                ignoreCase: false,
                                                want:       "\"\\\\\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 40, offset: 11872},
                                                val:        "\"",
                                                ignoreCase: false,
                                                want:       "\"\\\"\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 47, offset: 11879},
                                                val:        "'",
                                                ignoreCase: false,
                                                want:       "\"'\"",
                                        },
                                        &amp;anyMatcher{
                                                line: 428, col: 53, offset: 11885,
                                        },
                                },
                        },
                },
                {
                        name: "UnicodeChar",
                        pos:  position{line: 430, col: 1, offset: 11888},
                        expr: &amp;anyMatcher{
                                line: 430, col: 16, offset: 11903,
                        },
                },
                {
                        name: "RemoveFact",
                        pos:  position{line: 433, col: 1, offset: 12003},
                        expr: &amp;actionExpr{
                                pos: position{line: 433, col: 15, offset: 12017},
                                run: (*parser).callonRemoveFact1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 433, col: 15, offset: 12017},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 433, col: 15, offset: 12017},
                                                        val:        "remove",
                                                        ignoreCase: false,
                                                        want:       "\"remove\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 433, col: 24, offset: 12026},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 433, col: 26, offset: 12028},
                                                        label: "typeName",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 433, col: 35, offset: 12037},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 433, col: 45, offset: 12047},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 433, col: 47, offset: 12049},
                                                        label: "factID",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 433, col: 54, offset: 12056},
                                                                name: "FactID",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FactID",
                        pos:  position{line: 442, col: 1, offset: 12284},
                        expr: &amp;actionExpr{
                                pos: position{line: 442, col: 11, offset: 12294},
                                run: (*parser).callonFactID1,
                                expr: &amp;labeledExpr{
                                        pos:   position{line: 442, col: 11, offset: 12294},
                                        label: "chars",
                                        expr: &amp;oneOrMoreExpr{
                                                pos: position{line: 442, col: 17, offset: 12300},
                                                expr: &amp;choiceExpr{
                                                        pos: position{line: 442, col: 18, offset: 12301},
                                                        alternatives: []any{
                                                                &amp;charClassMatcher{
                                                                        pos:        position{line: 442, col: 18, offset: 12301},
                                                                        val:        "[a-zA-Z0-9_-]",
                                                                        chars:      []rune{'_', '-'},
                                                                        ranges:     []rune{'a', 'z', 'A', 'Z', '0', '9'},
                                                                        ignoreCase: false,
                                                                        inverted:   false,
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 442, col: 34, offset: 12317},
                                                                        name: "SpecialFactChar",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Fact",
                        pos:  position{line: 447, col: 1, offset: 12459},
                        expr: &amp;actionExpr{
                                pos: position{line: 447, col: 9, offset: 12467},
                                run: (*parser).callonFact1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 447, col: 9, offset: 12467},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 447, col: 9, offset: 12467},
                                                        label: "typeName",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 447, col: 18, offset: 12476},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 447, col: 28, offset: 12486},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 447, col: 32, offset: 12490},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 447, col: 34, offset: 12492},
                                                        label: "fields",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 447, col: 41, offset: 12499},
                                                                name: "FactFieldList",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 447, col: 55, offset: 12513},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 447, col: 57, offset: 12515},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FactFieldList",
                        pos:  position{line: 455, col: 1, offset: 12650},
                        expr: &amp;actionExpr{
                                pos: position{line: 455, col: 18, offset: 12667},
                                run: (*parser).callonFactFieldList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 455, col: 18, offset: 12667},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 455, col: 18, offset: 12667},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 455, col: 24, offset: 12673},
                                                                name: "FactField",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 455, col: 34, offset: 12683},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 455, col: 39, offset: 12688},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 455, col: 40, offset: 12689},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 455, col: 40, offset: 12689},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 455, col: 42, offset: 12691},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 455, col: 46, offset: 12695},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 455, col: 48, offset: 12697},
                                                                                        name: "FactField",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FactField",
                        pos:  position{line: 465, col: 1, offset: 12922},
                        expr: &amp;actionExpr{
                                pos: position{line: 465, col: 14, offset: 12935},
                                run: (*parser).callonFactField1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 465, col: 14, offset: 12935},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 465, col: 14, offset: 12935},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 465, col: 19, offset: 12940},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 465, col: 29, offset: 12950},
                                                        val:        ":",
                                                        ignoreCase: false,
                                                        want:       "\":\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 465, col: 33, offset: 12954},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 465, col: 35, offset: 12956},
                                                        label: "value",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 465, col: 41, offset: 12962},
                                                                name: "FactValue",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FactValue",
                        pos:  position{line: 472, col: 1, offset: 13069},
                        expr: &amp;choiceExpr{
                                pos: position{line: 472, col: 14, offset: 13082},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 472, col: 14, offset: 13082},
                                                name: "StringLiteral",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 472, col: 30, offset: 13098},
                                                name: "Number",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 472, col: 39, offset: 13107},
                                                name: "BooleanLiteral",
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 472, col: 56, offset: 13124},
                                                run: (*parser).callonFactValue5,
                                                expr: &amp;ruleRefExpr{
                                                        pos:  position{line: 472, col: 56, offset: 13124},
                                                        name: "ComplexIdentifier",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ComplexIdentifier",
                        pos:  position{line: 480, col: 1, offset: 13335},
                        expr: &amp;actionExpr{
                                pos: position{line: 480, col: 22, offset: 13356},
                                run: (*parser).callonComplexIdentifier1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 480, col: 22, offset: 13356},
                                        exprs: []any{
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 480, col: 22, offset: 13356},
                                                        name: "ComplexIdentStart",
                                                },
                                                &amp;zeroOrMoreExpr{
                                                        pos: position{line: 480, col: 40, offset: 13374},
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 480, col: 40, offset: 13374},
                                                                name: "ComplexIdentContinue",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ComplexIdentStart",
                        pos:  position{line: 484, col: 1, offset: 13432},
                        expr: &amp;choiceExpr{
                                pos: position{line: 484, col: 22, offset: 13453},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 484, col: 22, offset: 13453},
                                                val:        "[a-zA-Z0-9_]",
                                                chars:      []rune{'_'},
                                                ranges:     []rune{'a', 'z', 'A', 'Z', '0', '9'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 484, col: 37, offset: 13468},
                                                name: "UnicodeLetterStart",
                                        },
                                },
                        },
                },
                {
                        name: "ComplexIdentContinue",
                        pos:  position{line: 486, col: 1, offset: 13488},
                        expr: &amp;choiceExpr{
                                pos: position{line: 486, col: 25, offset: 13512},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 486, col: 25, offset: 13512},
                                                val:        "[a-zA-Z0-9_-]",
                                                chars:      []rune{'_', '-'},
                                                ranges:     []rune{'a', 'z', 'A', 'Z', '0', '9'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 486, col: 41, offset: 13528},
                                                name: "UnicodeLetterContinue",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 486, col: 65, offset: 13552},
                                                name: "SpecialFactChar",
                                        },
                                },
                        },
                },
                {
                        name: "SpecialFactChar",
                        pos:  position{line: 489, col: 1, offset: 13631},
                        expr: &amp;charClassMatcher{
                                pos:        position{line: 489, col: 20, offset: 13650},
                                val:        "[-_:.]",
                                chars:      []rune{'-', '_', ':', '.'},
                                ignoreCase: false,
                                inverted:   false,
                        },
                },
                {
                        name: "IdentName",
                        pos:  position{line: 491, col: 1, offset: 13658},
                        expr: &amp;actionExpr{
                                pos: position{line: 491, col: 14, offset: 13671},
                                run: (*parser).callonIdentName1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 491, col: 14, offset: 13671},
                                        exprs: []any{
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 491, col: 14, offset: 13671},
                                                        name: "IdentStart",
                                                },
                                                &amp;zeroOrMoreExpr{
                                                        pos: position{line: 491, col: 25, offset: 13682},
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 491, col: 25, offset: 13682},
                                                                name: "IdentContinue",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "IdentStart",
                        pos:  position{line: 495, col: 1, offset: 13733},
                        expr: &amp;choiceExpr{
                                pos: position{line: 495, col: 15, offset: 13747},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 495, col: 15, offset: 13747},
                                                val:        "[a-zA-Z_]",
                                                chars:      []rune{'_'},
                                                ranges:     []rune{'a', 'z', 'A', 'Z'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 495, col: 27, offset: 13759},
                                                name: "UnicodeLetterStart",
                                        },
                                },
                        },
                },
                {
                        name: "IdentContinue",
                        pos:  position{line: 497, col: 1, offset: 13779},
                        expr: &amp;choiceExpr{
                                pos: position{line: 497, col: 18, offset: 13796},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 497, col: 18, offset: 13796},
                                                val:        "[a-zA-Z0-9_-]",
                                                chars:      []rune{'_', '-'},
                                                ranges:     []rune{'a', 'z', 'A', 'Z', '0', '9'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 497, col: 34, offset: 13812},
                                                name: "UnicodeLetterContinue",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 497, col: 58, offset: 13836},
                                                name: "PunctuationChar",
                                        },
                                },
                        },
                },
                {
                        name: "UnicodeLetterStart",
                        pos:  position{line: 500, col: 1, offset: 13947},
                        expr: &amp;choiceExpr{
                                pos: position{line: 500, col: 23, offset: 13969},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 500, col: 23, offset: 13969},
                                                val:        "[\\u00C0-\\u00D6]",
                                                ranges:     []rune{'√Ä', '√ñ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 500, col: 41, offset: 13987},
                                                val:        "[\\u00D8-\\u00F6]",
                                                ranges:     []rune{'√ò', '√∂'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 500, col: 59, offset: 14005},
                                                val:        "[\\u00F8-\\u017F]",
                                                ranges:     []rune{'√∏', '≈ø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 501, col: 23, offset: 14045},
                                                val:        "[\\u0100-\\u024F]",
                                                ranges:     []rune{'ƒÄ', '…è'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 501, col: 41, offset: 14063},
                                                val:        "[\\u1E00-\\u1EFF]",
                                                ranges:     []rune{'·∏Ä', '·ªø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 501, col: 59, offset: 14081},
                                                val:        "[\\u0370-\\u03FF]",
                                                ranges:     []rune{'Õ∞', 'œø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 502, col: 23, offset: 14121},
                                                val:        "[\\u0400-\\u04FF]",
                                                ranges:     []rune{'–Ä', '”ø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 502, col: 41, offset: 14139},
                                                val:        "[\\u0590-\\u05FF]",
                                                ranges:     []rune{'\u0590', '\u05ff'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 502, col: 59, offset: 14157},
                                                val:        "[\\u0600-\\u06FF]",
                                                ranges:     []rune{'\u0600', '€ø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                },
                        },
                },
                {
                        name: "UnicodeLetterContinue",
                        pos:  position{line: 504, col: 1, offset: 14174},
                        expr: &amp;choiceExpr{
                                pos: position{line: 504, col: 26, offset: 14199},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 504, col: 26, offset: 14199},
                                                val:        "[\\u00C0-\\u00D6]",
                                                ranges:     []rune{'√Ä', '√ñ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 504, col: 44, offset: 14217},
                                                val:        "[\\u00D8-\\u00F6]",
                                                ranges:     []rune{'√ò', '√∂'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 504, col: 62, offset: 14235},
                                                val:        "[\\u00F8-\\u017F]",
                                                ranges:     []rune{'√∏', '≈ø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 505, col: 26, offset: 14278},
                                                val:        "[\\u0100-\\u024F]",
                                                ranges:     []rune{'ƒÄ', '…è'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 505, col: 44, offset: 14296},
                                                val:        "[\\u1E00-\\u1EFF]",
                                                ranges:     []rune{'·∏Ä', '·ªø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 505, col: 62, offset: 14314},
                                                val:        "[\\u0370-\\u03FF]",
                                                ranges:     []rune{'Õ∞', 'œø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 506, col: 26, offset: 14357},
                                                val:        "[\\u0400-\\u04FF]",
                                                ranges:     []rune{'–Ä', '”ø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 506, col: 44, offset: 14375},
                                                val:        "[\\u0590-\\u05FF]",
                                                ranges:     []rune{'\u0590', '\u05ff'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 506, col: 62, offset: 14393},
                                                val:        "[\\u0600-\\u06FF]",
                                                ranges:     []rune{'\u0600', '€ø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 507, col: 26, offset: 14436},
                                                val:        "[\\u0300-\\u036F]",
                                                ranges:     []rune{'ÃÄ', 'ÕØ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 507, col: 44, offset: 14454},
                                                val:        "[\\u1AB0-\\u1AFF]",
                                                ranges:     []rune{'·™∞', '\u1aff'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 507, col: 62, offset: 14472},
                                                val:        "[\\u1DC0-\\u1DFF]",
                                                ranges:     []rune{'·∑Ä', '·∑ø'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                },
                        },
                },
                {
                        name: "PunctuationChar",
                        pos:  position{line: 509, col: 1, offset: 14489},
                        expr: &amp;choiceExpr{
                                pos: position{line: 509, col: 20, offset: 14508},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 509, col: 20, offset: 14508},
                                                val:        "[-_]",
                                                chars:      []rune{'-', '_'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 509, col: 27, offset: 14515},
                                                val:        "[']",
                                                chars:      []rune{'\''},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 509, col: 33, offset: 14521},
                                                val:        "[\\u2010-\\u2015]",
                                                ranges:     []rune{'‚Äê', '‚Äï'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 509, col: 51, offset: 14539},
                                                val:        "[\\u2032-\\u2037]",
                                                ranges:     []rune{'‚Ä≤', '‚Ä∑'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                },
                        },
                },
                {
                        name: "_",
                        pos:  position{line: 511, col: 1, offset: 14556},
                        expr: &amp;zeroOrMoreExpr{
                                pos: position{line: 511, col: 6, offset: 14561},
                                expr: &amp;choiceExpr{
                                        pos: position{line: 511, col: 7, offset: 14562},
                                        alternatives: []any{
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 511, col: 7, offset: 14562},
                                                        name: "Whitespace",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 511, col: 20, offset: 14575},
                                                        name: "Comment",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Whitespace",
                        pos:  position{line: 513, col: 1, offset: 14586},
                        expr: &amp;charClassMatcher{
                                pos:        position{line: 513, col: 15, offset: 14600},
                                val:        "[ \\t\\r\\n]",
                                chars:      []rune{' ', '\t', '\r', '\n'},
                                ignoreCase: false,
                                inverted:   false,
                        },
                },
                {
                        name: "Comment",
                        pos:  position{line: 515, col: 1, offset: 14611},
                        expr: &amp;choiceExpr{
                                pos: position{line: 515, col: 12, offset: 14622},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 515, col: 12, offset: 14622},
                                                name: "LineComment",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 515, col: 26, offset: 14636},
                                                name: "BlockComment",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 515, col: 41, offset: 14651},
                                                name: "EndOfLineComment",
                                        },
                                },
                        },
                },
                {
                        name: "LineComment",
                        pos:  position{line: 517, col: 1, offset: 14669},
                        expr: &amp;actionExpr{
                                pos: position{line: 517, col: 16, offset: 14684},
                                run: (*parser).callonLineComment1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 517, col: 16, offset: 14684},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 517, col: 16, offset: 14684},
                                                        val:        "//",
                                                        ignoreCase: false,
                                                        want:       "\"//\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 517, col: 21, offset: 14689},
                                                        label: "CommentText",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 517, col: 33, offset: 14701},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 517, col: 34, offset: 14702},
                                                                        exprs: []any{
                                                                                &amp;notExpr{
                                                                                        pos: position{line: 517, col: 34, offset: 14702},
                                                                                        expr: &amp;charClassMatcher{
                                                                                                pos:        position{line: 517, col: 35, offset: 14703},
                                                                                                val:        "[\\r\\n]",
                                                                                                chars:      []rune{'\r', '\n'},
                                                                                                ignoreCase: false,
                                                                                                inverted:   false,
                                                                                        },
                                                                                },
                                                                                &amp;anyMatcher{
                                                                                        line: 517, col: 42, offset: 14710,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "BlockComment",
                        pos:  position{line: 521, col: 1, offset: 14779},
                        expr: &amp;actionExpr{
                                pos: position{line: 521, col: 17, offset: 14795},
                                run: (*parser).callonBlockComment1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 521, col: 17, offset: 14795},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 521, col: 17, offset: 14795},
                                                        val:        "/*",
                                                        ignoreCase: false,
                                                        want:       "\"/*\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 521, col: 22, offset: 14800},
                                                        label: "CommentText",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 521, col: 34, offset: 14812},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 521, col: 35, offset: 14813},
                                                                        exprs: []any{
                                                                                &amp;notExpr{
                                                                                        pos: position{line: 521, col: 35, offset: 14813},
                                                                                        expr: &amp;litMatcher{
                                                                                                pos:        position{line: 521, col: 36, offset: 14814},
                                                                                                val:        "*/",
                                                                                                ignoreCase: false,
                                                                                                want:       "\"*/\"",
                                                                                        },
                                                                                },
                                                                                &amp;anyMatcher{
                                                                                        line: 521, col: 41, offset: 14819,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 521, col: 45, offset: 14823},
                                                        val:        "*/",
                                                        ignoreCase: false,
                                                        want:       "\"*/\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "EndOfLineComment",
                        pos:  position{line: 525, col: 1, offset: 14893},
                        expr: &amp;actionExpr{
                                pos: position{line: 525, col: 21, offset: 14913},
                                run: (*parser).callonEndOfLineComment1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 525, col: 21, offset: 14913},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 525, col: 21, offset: 14913},
                                                        val:        "#",
                                                        ignoreCase: false,
                                                        want:       "\"#\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 525, col: 25, offset: 14917},
                                                        label: "CommentText",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 525, col: 37, offset: 14929},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 525, col: 38, offset: 14930},
                                                                        exprs: []any{
                                                                                &amp;notExpr{
                                                                                        pos: position{line: 525, col: 38, offset: 14930},
                                                                                        expr: &amp;charClassMatcher{
                                                                                                pos:        position{line: 525, col: 39, offset: 14931},
                                                                                                val:        "[\\r\\n]",
                                                                                                chars:      []rune{'\r', '\n'},
                                                                                                ignoreCase: false,
                                                                                                inverted:   false,
                                                                                        },
                                                                                },
                                                                                &amp;anyMatcher{
                                                                                        line: 525, col: 46, offset: 14938,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "EOF",
                        pos:  position{line: 529, col: 1, offset: 15016},
                        expr: &amp;notExpr{
                                pos: position{line: 529, col: 8, offset: 15023},
                                expr: &amp;anyMatcher{
                                        line: 529, col: 9, offset: 15024,
                                },
                        },
                },
        },
}

func (c *current) onStart1(statements any) (any, error) <span class="cov8" title="1">{
        // S√©parer types, expressions, faits et retractions
        types := []interface{}{}
        expressions := []interface{}{}
        facts := []interface{}{}
        retractions := []interface{}{}

        if statements != nil </span><span class="cov8" title="1">{
                for _, stmt := range statements.([]interface{}) </span><span class="cov8" title="1">{
                        if stmtMap, ok := stmt.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if stmtMap["type"] == "typeDefinition" </span><span class="cov8" title="1">{
                                        types = append(types, stmt)
                                }</span> else<span class="cov8" title="1"> if stmtMap["type"] == "expression" </span><span class="cov8" title="1">{
                                        expressions = append(expressions, stmt)
                                }</span> else<span class="cov8" title="1"> if stmtMap["type"] == "fact" </span><span class="cov8" title="1">{
                                        facts = append(facts, stmt)
                                }</span> else<span class="cov8" title="1"> if stmtMap["type"] == "retraction" </span><span class="cov8" title="1">{
                                        retractions = append(retractions, stmt)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return map[string]interface{}{
                "types":       types,
                "expressions": expressions,
                "facts":       facts,
                "retractions": retractions,
        }, nil</span>
}

func (p *parser) callonStart1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onStart1(stack["statements"])
}</span>

func (c *current) onStatementList1(statements any) (any, error) <span class="cov8" title="1">{
        result := []interface{}{}
        if statements != nil </span><span class="cov8" title="1">{
                for _, stmt := range statements.([]interface{}) </span><span class="cov8" title="1">{
                        result = append(result, stmt.([]interface{})[0])
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func (p *parser) callonStatementList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onStatementList1(stack["statements"])
}</span>

func (c *current) onTypeDefinition1(name, fields any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":   "typeDefinition",
                "name":   name,
                "fields": fields,
        }, nil
}</span>

func (p *parser) callonTypeDefinition1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onTypeDefinition1(stack["name"], stack["fields"])
}</span>

func (c *current) onFieldList1(first, rest any) (any, error) <span class="cov8" title="1">{
        fields := []interface{}{first}
        if rest != nil </span><span class="cov8" title="1">{
                for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                        fields = append(fields, item.([]interface{})[3])
                }</span>
        }
        <span class="cov8" title="1">return fields, nil</span>
}

func (p *parser) callonFieldList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFieldList1(stack["first"], stack["rest"])
}</span>

func (c *current) onField1(name, fieldType any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "name": name,
                "type": fieldType,
        }, nil
}</span>

func (p *parser) callonField1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onField1(stack["name"], stack["fieldType"])
}</span>

func (c *current) onAtomicType2() (any, error) <span class="cov8" title="1">{
        return "string", nil
}</span>

func (p *parser) callonAtomicType2() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAtomicType2()
}</span>

func (c *current) onAtomicType4() (any, error) <span class="cov8" title="1">{
        return "number", nil
}</span>

func (p *parser) callonAtomicType4() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAtomicType4()
}</span>

func (c *current) onAtomicType6() (any, error) <span class="cov0" title="0">{
        return "bool", nil
}</span>

func (p *parser) callonAtomicType6() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAtomicType6()
}</span>

func (c *current) onExpression1(set, constraints, action any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":        "expression",
                "set":         set,
                "constraints": constraints,
                "action":      action,
        }, nil
}</span>

func (p *parser) callonExpression1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onExpression1(stack["set"], stack["constraints"], stack["action"])
}</span>

func (c *current) onSet1(variables any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":      "set",
                "variables": variables,
        }, nil
}</span>

func (p *parser) callonSet1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onSet1(stack["variables"])
}</span>

func (c *current) onTypedVariableList1(first, rest any) (any, error) <span class="cov8" title="1">{
        variables := []interface{}{first}
        if rest != nil </span><span class="cov8" title="1">{
                for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                        variables = append(variables, item.([]interface{})[3])
                }</span>
        }
        <span class="cov8" title="1">return variables, nil</span>
}

func (p *parser) callonTypedVariableList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onTypedVariableList1(stack["first"], stack["rest"])
}</span>

func (c *current) onTypedVariable1(name, dataType any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "typedVariable",
                "name":     name,
                "dataType": dataType,
        }, nil
}</span>

func (p *parser) callonTypedVariable1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onTypedVariable1(stack["name"], stack["dataType"])
}</span>

func (c *current) onConstraints1(first, rest any) (any, error) <span class="cov8" title="1">{
        if rest == nil || len(rest.([]interface{})) == 0 </span><span class="cov0" title="0">{
                return first, nil
        }</span>

        <span class="cov8" title="1">operations := []map[string]interface{}{}
        for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                op := item.([]interface{})[1]
                right := item.([]interface{})[3]
                operations = append(operations, map[string]interface{}{
                        "op":    op,
                        "right": right,
                })
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "type":       "logicalExpr",
                "left":       first,
                "operations": operations,
        }, nil</span>
}

func (p *parser) callonConstraints1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onConstraints1(stack["first"], stack["rest"])
}</span>

func (c *current) onConstraint2(expr any) (any, error) <span class="cov0" title="0">{
        return expr, nil
}</span>

func (p *parser) callonConstraint2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onConstraint2(stack["expr"])
}</span>

func (c *current) onConstraint13(left, op, right any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "comparison",
                "left":     left,
                "operator": op,
                "right":    right,
        }, nil
}</span>

func (p *parser) callonConstraint13() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onConstraint13(stack["left"], stack["op"], stack["right"])
}</span>

func (c *current) onNotConstraint1(expr any) (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":       "notConstraint",
                "expression": expr,
        }, nil
}</span>

func (p *parser) callonNotConstraint1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onNotConstraint1(stack["expr"])
}</span>

func (c *current) onExistsConstraint1(variable, condition any) (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":      "existsConstraint",
                "variable":  variable,
                "condition": condition,
        }, nil
}</span>

func (p *parser) callonExistsConstraint1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onExistsConstraint1(stack["variable"], stack["condition"])
}</span>

func (c *current) onAccumulateConstraint1(accumFunc, accumVar, accumCond, accumField, accumOp, accumThreshold any) (any, error) <span class="cov0" title="0">{
        fieldValue := ""
        if accumField != nil </span><span class="cov0" title="0">{
                fieldAccess := accumField.([]interface{})[3].(map[string]interface{})
                fieldValue = fieldAccess["field"].(string)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type":      "accumulateConstraint",
                "function":  accumFunc,
                "variable":  accumVar,
                "condition": accumCond,
                "field":     fieldValue,
                "operator":  accumOp,
                "threshold": accumThreshold,
        }, nil</span>
}

func (p *parser) callonAccumulateConstraint1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateConstraint1(stack["accumFunc"], stack["accumVar"], stack["accumCond"], stack["accumField"], stack["accumOp"], stack["accumThreshold"])
}</span>

func (c *current) onAccumulateFunction2() (any, error) <span class="cov0" title="0">{
        return "AVG", nil
}</span>

func (p *parser) callonAccumulateFunction2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction2()
}</span>

func (c *current) onAccumulateFunction4() (any, error) <span class="cov0" title="0">{
        return "COUNT", nil
}</span>

func (p *parser) callonAccumulateFunction4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction4()
}</span>

func (c *current) onAccumulateFunction6() (any, error) <span class="cov0" title="0">{
        return "SUM", nil
}</span>

func (p *parser) callonAccumulateFunction6() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction6()
}</span>

func (c *current) onAccumulateFunction8() (any, error) <span class="cov0" title="0">{
        return "MIN", nil
}</span>

func (p *parser) callonAccumulateFunction8() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction8()
}</span>

func (c *current) onAccumulateFunction10() (any, error) <span class="cov0" title="0">{
        return "MAX", nil
}</span>

func (p *parser) callonAccumulateFunction10() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction10()
}</span>

func (c *current) onArithmeticExpr1(first, rest any) (any, error) <span class="cov8" title="1">{
        if rest == nil || len(rest.([]interface{})) == 0 </span><span class="cov8" title="1">{
                return first, nil
        }</span>

        <span class="cov0" title="0">result := first
        for _, item := range rest.([]interface{}) </span><span class="cov0" title="0">{
                op := item.([]interface{})[1]
                right := item.([]interface{})[3]
                result = map[string]interface{}{
                        "type":     "binaryOp",
                        "left":     result,
                        "operator": op,
                        "right":    right,
                }
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (p *parser) callonArithmeticExpr1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onArithmeticExpr1(stack["first"], stack["rest"])
}</span>

func (c *current) onTerm1(first, rest any) (any, error) <span class="cov8" title="1">{
        if rest == nil || len(rest.([]interface{})) == 0 </span><span class="cov8" title="1">{
                return first, nil
        }</span>

        <span class="cov0" title="0">result := first
        for _, item := range rest.([]interface{}) </span><span class="cov0" title="0">{
                op := item.([]interface{})[1]
                right := item.([]interface{})[3]
                result = map[string]interface{}{
                        "type":     "binaryOp",
                        "left":     result,
                        "operator": op,
                        "right":    right,
                }
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (p *parser) callonTerm1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onTerm1(stack["first"], stack["rest"])
}</span>

func (c *current) onFactor2(expr any) (any, error) <span class="cov0" title="0">{
        return expr, nil
}</span>

func (p *parser) callonFactor2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactor2(stack["expr"])
}</span>

func (c *current) onFieldAccess1(object, field any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":   "fieldAccess",
                "object": object,
                "field":  field,
        }, nil
}</span>

func (p *parser) callonFieldAccess1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFieldAccess1(stack["object"], stack["field"])
}</span>

func (c *current) onVariable1(name any) (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "variable",
                "name": name,
        }, nil
}</span>

func (p *parser) callonVariable1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onVariable1(stack["name"])
}</span>

func (c *current) onArrayLiteral1(elements any) (any, error) <span class="cov0" title="0">{
        if elements == nil </span><span class="cov0" title="0">{
                elements = []interface{}{}
        }</span>
        <span class="cov0" title="0">return map[string]interface{}{
                "type":     "arrayLiteral",
                "elements": elements,
        }, nil</span>
}

func (p *parser) callonArrayLiteral1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onArrayLiteral1(stack["elements"])
}</span>

func (c *current) onArrayElementList1(first, rest any) (any, error) <span class="cov0" title="0">{
        elements := []interface{}{first}
        if rest != nil </span><span class="cov0" title="0">{
                for _, item := range rest.([]interface{}) </span><span class="cov0" title="0">{
                        elements = append(elements, item.([]interface{})[3])
                }</span>
        }
        <span class="cov0" title="0">return elements, nil</span>
}

func (p *parser) callonArrayElementList1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onArrayElementList1(stack["first"], stack["rest"])
}</span>

func (c *current) onFunctionCall1(name, args any) (any, error) <span class="cov0" title="0">{
        if args == nil </span><span class="cov0" title="0">{
                args = []interface{}{}
        }</span>
        <span class="cov0" title="0">return map[string]interface{}{
                "type": "functionCall",
                "name": name,
                "args": args,
        }, nil</span>
}

func (p *parser) callonFunctionCall1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionCall1(stack["name"], stack["args"])
}</span>

func (c *current) onFunctionName2() (any, error) <span class="cov0" title="0">{
        return "LENGTH", nil
}</span>

func (p *parser) callonFunctionName2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName2()
}</span>

func (c *current) onFunctionName4() (any, error) <span class="cov0" title="0">{
        return "SUBSTRING", nil
}</span>

func (p *parser) callonFunctionName4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName4()
}</span>

func (c *current) onFunctionName6() (any, error) <span class="cov0" title="0">{
        return "UPPER", nil
}</span>

func (p *parser) callonFunctionName6() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName6()
}</span>

func (c *current) onFunctionName8() (any, error) <span class="cov0" title="0">{
        return "LOWER", nil
}</span>

func (p *parser) callonFunctionName8() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName8()
}</span>

func (c *current) onFunctionName10() (any, error) <span class="cov0" title="0">{
        return "TRIM", nil
}</span>

func (p *parser) callonFunctionName10() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName10()
}</span>

func (c *current) onFunctionName12() (any, error) <span class="cov0" title="0">{
        return "ABS", nil
}</span>

func (p *parser) callonFunctionName12() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName12()
}</span>

func (c *current) onFunctionName14() (any, error) <span class="cov0" title="0">{
        return "ROUND", nil
}</span>

func (p *parser) callonFunctionName14() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName14()
}</span>

func (c *current) onFunctionName16() (any, error) <span class="cov0" title="0">{
        return "FLOOR", nil
}</span>

func (p *parser) callonFunctionName16() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName16()
}</span>

func (c *current) onFunctionName18() (any, error) <span class="cov0" title="0">{
        return "CEIL", nil
}</span>

func (p *parser) callonFunctionName18() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName18()
}</span>

func (c *current) onFunctionArgList1(first, rest any) (any, error) <span class="cov0" title="0">{
        args := []interface{}{first}
        if rest != nil </span><span class="cov0" title="0">{
                for _, item := range rest.([]interface{}) </span><span class="cov0" title="0">{
                        args = append(args, item.([]interface{})[3])
                }</span>
        }
        <span class="cov0" title="0">return args, nil</span>
}

func (p *parser) callonFunctionArgList1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionArgList1(stack["first"], stack["rest"])
}</span>

func (c *current) onAction1(job any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type": "action",
                "job":  job,
        }, nil
}</span>

func (p *parser) callonAction1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAction1(stack["job"])
}</span>

func (c *current) onJobCall1(name, args any) (any, error) <span class="cov8" title="1">{
        if args == nil </span><span class="cov0" title="0">{
                args = []interface{}{}
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{
                "type": "jobCall",
                "name": name,
                "args": args,
        }, nil</span>
}

func (p *parser) callonJobCall1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onJobCall1(stack["name"], stack["args"])
}</span>

func (c *current) onArgumentList1(first, rest any) (any, error) <span class="cov8" title="1">{
        arguments := []interface{}{first}
        if rest != nil </span><span class="cov8" title="1">{
                for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                        arguments = append(arguments, item.([]interface{})[3])
                }</span>
        }
        <span class="cov8" title="1">return arguments, nil</span>
}

func (p *parser) callonArgumentList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onArgumentList1(stack["first"], stack["rest"])
}</span>

func (c *current) onComparisonOp2() (any, error) <span class="cov0" title="0">{
        return "==", nil
}</span>

func (p *parser) callonComparisonOp2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp2()
}</span>

func (c *current) onComparisonOp4() (any, error) <span class="cov0" title="0">{
        return "!=", nil
}</span>

func (p *parser) callonComparisonOp4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp4()
}</span>

func (c *current) onComparisonOp6() (any, error) <span class="cov0" title="0">{
        return "&lt;=", nil
}</span>

func (p *parser) callonComparisonOp6() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp6()
}</span>

func (c *current) onComparisonOp8() (any, error) <span class="cov0" title="0">{
        return "&gt;=", nil
}</span>

func (p *parser) callonComparisonOp8() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp8()
}</span>

func (c *current) onComparisonOp10() (any, error) <span class="cov0" title="0">{
        return "&lt;", nil
}</span>

func (p *parser) callonComparisonOp10() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp10()
}</span>

func (c *current) onComparisonOp12() (any, error) <span class="cov8" title="1">{
        return "&gt;", nil
}</span>

func (p *parser) callonComparisonOp12() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp12()
}</span>

func (c *current) onComparisonOp14() (any, error) <span class="cov0" title="0">{
        return "IN", nil
}</span>

func (p *parser) callonComparisonOp14() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp14()
}</span>

func (c *current) onComparisonOp16() (any, error) <span class="cov0" title="0">{
        return "LIKE", nil
}</span>

func (p *parser) callonComparisonOp16() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp16()
}</span>

func (c *current) onComparisonOp18() (any, error) <span class="cov0" title="0">{
        return "MATCHES", nil
}</span>

func (p *parser) callonComparisonOp18() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp18()
}</span>

func (c *current) onComparisonOp20() (any, error) <span class="cov0" title="0">{
        return "CONTAINS", nil
}</span>

func (p *parser) callonComparisonOp20() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp20()
}</span>

func (c *current) onLogicalOp2() (any, error) <span class="cov8" title="1">{
        return "AND", nil
}</span>

func (p *parser) callonLogicalOp2() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onLogicalOp2()
}</span>

func (c *current) onLogicalOp4() (any, error) <span class="cov0" title="0">{
        return "OR", nil
}</span>

func (p *parser) callonLogicalOp4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onLogicalOp4()
}</span>

func (c *current) onBooleanLiteral2() (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "boolean",
                "value": true,
        }, nil

}</span>

func (p *parser) callonBooleanLiteral2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onBooleanLiteral2()
}</span>

func (c *current) onBooleanLiteral4() (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "boolean",
                "value": false,
        }, nil

}</span>

func (p *parser) callonBooleanLiteral4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onBooleanLiteral4()
}</span>

func (c *current) onNumber1(sign, digits, decimal any) (any, error) <span class="cov8" title="1">{
        val, err := strconv.ParseFloat(string(c.text), 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{
                "type":  "number",
                "value": val,
        }, nil</span>
}

func (p *parser) callonNumber1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onNumber1(stack["sign"], stack["digits"], stack["decimal"])
}</span>

func (c *current) onStringLiteral2(chars any) (any, error) <span class="cov8" title="1">{
        var builder strings.Builder
        if chars != nil </span><span class="cov8" title="1">{
                for _, char := range chars.([]interface{}) </span><span class="cov8" title="1">{
                        builder.WriteString(char.(string))
                }</span>
        }
        <span class="cov8" title="1">return map[string]interface{}{
                "type":  "string",
                "value": builder.String(),
        }, nil</span>

}

func (p *parser) callonStringLiteral2() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onStringLiteral2(stack["chars"])
}</span>

func (c *current) onStringLiteral9(chars any) (any, error) <span class="cov0" title="0">{
        var builder strings.Builder
        if chars != nil </span><span class="cov0" title="0">{
                for _, char := range chars.([]interface{}) </span><span class="cov0" title="0">{
                        builder.WriteString(char.(string))
                }</span>
        }
        <span class="cov0" title="0">return map[string]interface{}{
                "type":  "string",
                "value": builder.String(),
        }, nil</span>

}

func (p *parser) callonStringLiteral9() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onStringLiteral9(stack["chars"])
}</span>

func (c *current) onDoubleStringChar3() (any, error) <span class="cov8" title="1">{
        return string(c.text), nil
}</span>

func (p *parser) callonDoubleStringChar3() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onDoubleStringChar3()
}</span>

func (c *current) onSingleStringChar3() (any, error) <span class="cov0" title="0">{
        return string(c.text), nil
}</span>

func (p *parser) callonSingleStringChar3() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onSingleStringChar3()
}</span>

func (c *current) onEscapeSequence1(char any) (any, error) <span class="cov0" title="0">{
        switch char </span>{
        case "n":<span class="cov0" title="0">
                return "\n", nil</span>
        case "t":<span class="cov0" title="0">
                return "\t", nil</span>
        case "r":<span class="cov0" title="0">
                return "\r", nil</span>
        case "\\":<span class="cov0" title="0">
                return "\\", nil</span>
        case "\"":<span class="cov0" title="0">
                return "\"", nil</span>
        case "'":<span class="cov0" title="0">
                return "'", nil</span>
        default:<span class="cov0" title="0">
                return "\\" + char.(string), nil</span>
        }
}

func (p *parser) callonEscapeSequence1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onEscapeSequence1(stack["char"])
}</span>

func (c *current) onRemoveFact1(typeName, factID any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "retraction",
                "typeName": typeName,
                "factID":   factID,
        }, nil
}</span>

func (p *parser) callonRemoveFact1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onRemoveFact1(stack["typeName"], stack["factID"])
}</span>

func (c *current) onFactID1(chars any) (any, error) <span class="cov8" title="1">{
        return string(c.text), nil
}</span>

func (p *parser) callonFactID1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactID1(stack["chars"])
}</span>

func (c *current) onFact1(typeName, fields any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "fact",
                "typeName": typeName,
                "fields":   fields,
        }, nil
}</span>

func (p *parser) callonFact1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFact1(stack["typeName"], stack["fields"])
}</span>

func (c *current) onFactFieldList1(first, rest any) (any, error) <span class="cov8" title="1">{
        fields := []interface{}{first}
        if rest != nil </span><span class="cov8" title="1">{
                for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                        fields = append(fields, item.([]interface{})[3])
                }</span>
        }
        <span class="cov8" title="1">return fields, nil</span>
}

func (p *parser) callonFactFieldList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactFieldList1(stack["first"], stack["rest"])
}</span>

func (c *current) onFactField1(name, value any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "name":  name,
                "value": value,
        }, nil
}</span>

func (p *parser) callonFactField1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactField1(stack["name"], stack["value"])
}</span>

func (c *current) onFactValue5() (any, error) <span class="cov8" title="1">{
        // ComplexIdentifier pour les valeurs non-quot√©es complexes comme des IDs
        return map[string]interface{}{
                "type":  "identifier",
                "value": string(c.text),
        }, nil
}</span>

func (p *parser) callonFactValue5() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactValue5()
}</span>

func (c *current) onComplexIdentifier1() (any, error) <span class="cov8" title="1">{
        return string(c.text), nil
}</span>

func (p *parser) callonComplexIdentifier1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComplexIdentifier1()
}</span>

func (c *current) onIdentName1() (any, error) <span class="cov8" title="1">{
        return string(c.text), nil
}</span>

func (p *parser) callonIdentName1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onIdentName1()
}</span>

func (c *current) onLineComment1(CommentText any) (any, error) <span class="cov8" title="1">{
        return nil, nil // Les commentaires ne retournent rien
}</span>

func (p *parser) callonLineComment1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onLineComment1(stack["CommentText"])
}</span>

func (c *current) onBlockComment1(CommentText any) (any, error) <span class="cov8" title="1">{
        return nil, nil // Les commentaires ne retournent rien
}</span>

func (p *parser) callonBlockComment1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onBlockComment1(stack["CommentText"])
}</span>

func (c *current) onEndOfLineComment1(CommentText any) (any, error) <span class="cov8" title="1">{
        return nil, nil // Support pour commentaires style shell/Python
}</span>

func (p *parser) callonEndOfLineComment1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onEndOfLineComment1(stack["CommentText"])
}</span>

var (
        // errNoRule is returned when the grammar to parse has no rule.
        errNoRule = errors.New("grammar has no rule")

        // errInvalidEntrypoint is returned when the specified entrypoint rule
        // does not exit.
        errInvalidEntrypoint = errors.New("invalid entrypoint")

        // errInvalidEncoding is returned when the source is not properly
        // utf8-encoded.
        errInvalidEncoding = errors.New("invalid encoding")

        // errMaxExprCnt is used to signal that the maximum number of
        // expressions have been parsed.
        errMaxExprCnt = errors.New("max number of expressions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// MaxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func MaxExpressions(maxExprCnt uint64) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                oldMaxExprCnt := p.maxExprCnt
                p.maxExprCnt = maxExprCnt
                return MaxExpressions(oldMaxExprCnt)
        }</span>
}

// Entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func Entrypoint(ruleName string) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                oldEntrypoint := p.entrypoint
                p.entrypoint = ruleName
                if ruleName == "" </span><span class="cov0" title="0">{
                        p.entrypoint = g.rules[0].name
                }</span>
                <span class="cov0" title="0">return Entrypoint(oldEntrypoint)</span>
        }
}

// Statistics adds a user provided Stats struct to the parser to allow
// the user to process the results after the parsing has finished.
// Also the key for the "no match" counter is set.
//
// Example usage:
//
//        input := "input"
//        stats := Stats{}
//        _, err := Parse("input-file", []byte(input), Statistics(&amp;stats, "no match"))
//        if err != nil {
//            log.Panicln(err)
//        }
//        b, err := json.MarshalIndent(stats.ChoiceAltCnt, "", "  ")
//        if err != nil {
//            log.Panicln(err)
//        }
//        fmt.Println(string(b))
func Statistics(stats *Stats, choiceNoMatch string) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                oldStats := p.Stats
                p.Stats = stats
                oldChoiceNoMatch := p.choiceNoMatch
                p.choiceNoMatch = choiceNoMatch
                if p.Stats.ChoiceAltCnt == nil </span><span class="cov0" title="0">{
                        p.Stats.ChoiceAltCnt = make(map[string]map[string]int)
                }</span>
                <span class="cov0" title="0">return Statistics(oldStats, oldChoiceNoMatch)</span>
        }
}

// Debug creates an Option to set the debug flag to b. When set to true,
// debugging information is printed to stdout while parsing.
//
// The default is false.
func Debug(b bool) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.debug
                p.debug = b
                return Debug(old)
        }</span>
}

// Memoize creates an Option to set the memoize flag to b. When set to true,
// the parser will cache all results so each expression is evaluated only
// once. This guarantees linear parsing time even for pathological cases,
// at the expense of more memory and slower times for typical cases.
//
// The default is false.
func Memoize(b bool) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.memoize
                p.memoize = b
                return Memoize(old)
        }</span>
}

// AllowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func AllowInvalidUTF8(b bool) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.allowInvalidUTF8
                p.allowInvalidUTF8 = b
                return AllowInvalidUTF8(old)
        }</span>
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.recover
                p.recover = b
                return Recover(old)
        }</span>
}

// GlobalStore creates an Option to set a key to a certain value in
// the globalStore.
func GlobalStore(key string, value any) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.cur.globalStore[key]
                p.cur.globalStore[key] = value
                return GlobalStore(key, old)
        }</span>
}

// InitState creates an Option to set a key to a certain value in
// the global "state" store.
func InitState(key string, value any) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.cur.state[key]
                p.cur.state[key] = value
                return InitState(key, old)
        }</span>
}

// ParseFile parses the file identified by filename.
func ParseFile(filename string, opts ...Option) (i any, err error) <span class="cov8" title="1">{
        f, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := f.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }()
        <span class="cov8" title="1">return ParseReader(filename, f, opts...)</span>
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func ParseReader(filename string, r io.Reader, opts ...Option) (any, error) <span class="cov8" title="1">{
        b, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return Parse(filename, b, opts...)</span>
}

// Parse parses the data from b using filename as information in the
// error messages.
func Parse(filename string, b []byte, opts ...Option) (any, error) <span class="cov8" title="1">{
        return newParser(filename, b, opts...).parse(g)
}</span>

// position records a position in the text.
type position struct {
        line, col, offset int
}

func (p position) String() string <span class="cov0" title="0">{
        return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}</span>

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
        position
        rn rune
        w  int
}

type current struct {
        pos  position // start position of the match
        text []byte   // raw text of the match

        // state is a store for arbitrary key,value pairs that the user wants to be
        // tied to the backtracking of the parser.
        // This is always rolled back if a parsing rule fails.
        state storeDict

        // globalStore is a general store for the user to store arbitrary key-value
        // pairs that they need to manage and that they do not want tied to the
        // backtracking of the parser. This is only modified by the user and never
        // rolled back by the parser. It is always up to the user to keep this in a
        // consistent state.
        globalStore storeDict
}

type storeDict map[string]any

// the AST types...

type grammar struct {
        pos   position
        rules []*rule
}

type rule struct {
        pos         position
        name        string
        displayName string
        expr        any
}

type choiceExpr struct {
        pos          position
        alternatives []any
}

type actionExpr struct {
        pos  position
        expr any
        run  func(*parser) (any, error)
}

type recoveryExpr struct {
        pos          position
        expr         any
        recoverExpr  any
        failureLabel []string
}

type seqExpr struct {
        pos   position
        exprs []any
}

type throwExpr struct {
        pos   position
        label string
}

type labeledExpr struct {
        pos   position
        label string
        expr  any
}

type expr struct {
        pos  position
        expr any
}

type (
        andExpr        expr
        notExpr        expr
        zeroOrOneExpr  expr
        zeroOrMoreExpr expr
        oneOrMoreExpr  expr
)

type ruleRefExpr struct {
        pos  position
        name string
}

type stateCodeExpr struct {
        pos position
        run func(*parser) error
}

type andCodeExpr struct {
        pos position
        run func(*parser) (bool, error)
}

type notCodeExpr struct {
        pos position
        run func(*parser) (bool, error)
}

type litMatcher struct {
        pos        position
        val        string
        ignoreCase bool
        want       string
}

type charClassMatcher struct {
        pos             position
        val             string
        basicLatinChars [128]bool
        chars           []rune
        ranges          []rune
        classes         []*unicode.RangeTable
        ignoreCase      bool
        inverted        bool
}

type anyMatcher position

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) <span class="cov0" title="0">{
        *e = append(*e, err)
}</span>

func (e errList) err() error <span class="cov8" title="1">{
        if len(e) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">e.dedupe()
        return e</span>
}

func (e *errList) dedupe() <span class="cov0" title="0">{
        var cleaned []error
        set := make(map[string]bool)
        for _, err := range *e </span><span class="cov0" title="0">{
                if msg := err.Error(); !set[msg] </span><span class="cov0" title="0">{
                        set[msg] = true
                        cleaned = append(cleaned, err)
                }</span>
        }
        <span class="cov0" title="0">*e = cleaned</span>
}

func (e errList) Error() string <span class="cov0" title="0">{
        switch len(e) </span>{
        case 0:<span class="cov0" title="0">
                return ""</span>
        case 1:<span class="cov0" title="0">
                return e[0].Error()</span>
        default:<span class="cov0" title="0">
                var buf bytes.Buffer

                for i, err := range e </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                buf.WriteRune('\n')
                        }</span>
                        <span class="cov0" title="0">buf.WriteString(err.Error())</span>
                }
                <span class="cov0" title="0">return buf.String()</span>
        }
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
        Inner    error
        pos      position
        prefix   string
        expected []string
}

// Error returns the error message.
func (p *parserError) Error() string <span class="cov0" title="0">{
        return p.prefix + ": " + p.Inner.Error()
}</span>

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser <span class="cov8" title="1">{
        stats := Stats{
                ChoiceAltCnt: make(map[string]map[string]int),
        }

        p := &amp;parser{
                filename: filename,
                errs:     new(errList),
                data:     b,
                pt:       savepoint{position: position{line: 1}},
                recover:  true,
                cur: current{
                        state:       make(storeDict),
                        globalStore: make(storeDict),
                },
                maxFailPos:      position{col: 1, line: 1},
                maxFailExpected: make([]string, 0, 20),
                Stats:           &amp;stats,
                // start rule is rule [0] unless an alternate entrypoint is specified
                entrypoint: g.rules[0].name,
        }
        p.setOptions(opts)

        if p.maxExprCnt == 0 </span><span class="cov8" title="1">{
                p.maxExprCnt = math.MaxUint64
        }</span>

        <span class="cov8" title="1">return p</span>
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) <span class="cov8" title="1">{
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(p)
        }</span>
}

type resultTuple struct {
        v   any
        b   bool
        end savepoint
}

const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
        // ExprCnt counts the number of expressions processed during parsing
        // This value is compared to the maximum number of expressions allowed
        // (set by the MaxExpressions option).
        ExprCnt uint64

        // ChoiceAltCnt is used to count for each ordered choice expression,
        // which alternative is used how may times.
        // These numbers allow to optimize the order of the ordered choice expression
        // to increase the performance of the parser
        //
        // The outer key of ChoiceAltCnt is composed of the name of the rule as well
        // as the line and the column of the ordered choice.
        // The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
        // For each alternative the number of matches are counted. If an ordered choice does not
        // match, a special counter is incremented. The name of this counter is set with
        // the parser option Statistics.
        // For an alternative to be included in ChoiceAltCnt, it has to match at least once.
        ChoiceAltCnt map[string]map[string]int
}

type parser struct {
        filename string
        pt       savepoint
        cur      current

        data []byte
        errs *errList

        depth   int
        recover bool
        debug   bool

        memoize bool
        // memoization table for the packrat algorithm:
        // map[offset in source] map[expression or rule] {value, match}
        memo map[int]map[any]resultTuple

        // rules table, maps the rule identifier to the rule node
        rules map[string]*rule
        // variables stack, map of label to value
        vstack []map[string]any
        // rule stack, allows identification of the current rule in errors
        rstack []*rule

        // parse fail
        maxFailPos            position
        maxFailExpected       []string
        maxFailInvertExpected bool

        // max number of expressions to be parsed
        maxExprCnt uint64
        // entrypoint for the parser
        entrypoint string

        allowInvalidUTF8 bool

        *Stats

        choiceNoMatch string
        // recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
        recoveryStack []map[string]any
}

// push a variable set on the vstack.
func (p *parser) pushV() <span class="cov8" title="1">{
        if cap(p.vstack) == len(p.vstack) </span><span class="cov8" title="1">{
                // create new empty slot in the stack
                p.vstack = append(p.vstack, nil)
        }</span> else<span class="cov8" title="1"> {
                // slice to 1 more
                p.vstack = p.vstack[:len(p.vstack)+1]
        }</span>

        // get the last args set
        <span class="cov8" title="1">m := p.vstack[len(p.vstack)-1]
        if m != nil &amp;&amp; len(m) == 0 </span><span class="cov8" title="1">{
                // empty map, all good
                return
        }</span>

        <span class="cov8" title="1">m = make(map[string]any)
        p.vstack[len(p.vstack)-1] = m</span>
}

// pop a variable set from the vstack.
func (p *parser) popV() <span class="cov8" title="1">{
        // if the map is not empty, clear it
        m := p.vstack[len(p.vstack)-1]
        if len(m) &gt; 0 </span><span class="cov8" title="1">{
                // GC that map
                p.vstack[len(p.vstack)-1] = nil
        }</span>
        <span class="cov8" title="1">p.vstack = p.vstack[:len(p.vstack)-1]</span>
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr any) <span class="cov0" title="0">{
        if cap(p.recoveryStack) == len(p.recoveryStack) </span><span class="cov0" title="0">{
                // create new empty slot in the stack
                p.recoveryStack = append(p.recoveryStack, nil)
        }</span> else<span class="cov0" title="0"> {
                // slice to 1 more
                p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
        }</span>

        <span class="cov0" title="0">m := make(map[string]any, len(labels))
        for _, fl := range labels </span><span class="cov0" title="0">{
                m[fl] = expr
        }</span>
        <span class="cov0" title="0">p.recoveryStack[len(p.recoveryStack)-1] = m</span>
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() <span class="cov0" title="0">{
        // GC that map
        p.recoveryStack[len(p.recoveryStack)-1] = nil

        p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}</span>

func (p *parser) print(prefix, s string) string <span class="cov0" title="0">{
        if !p.debug </span><span class="cov0" title="0">{
                return s
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s %d:%d:%d: %s [%#U]\n",
                prefix, p.pt.line, p.pt.col, p.pt.offset, s, p.pt.rn)
        return s</span>
}

func (p *parser) printIndent(mark string, s string) string <span class="cov0" title="0">{
        return p.print(strings.Repeat(" ", p.depth)+mark, s)
}</span>

func (p *parser) in(s string) string <span class="cov0" title="0">{
        res := p.printIndent("&gt;", s)
        p.depth++
        return res
}</span>

func (p *parser) out(s string) string <span class="cov0" title="0">{
        p.depth--
        return p.printIndent("&lt;", s)
}</span>

func (p *parser) addErr(err error) <span class="cov0" title="0">{
        p.addErrAt(err, p.pt.position, []string{})
}</span>

func (p *parser) addErrAt(err error, pos position, expected []string) <span class="cov0" title="0">{
        var buf bytes.Buffer
        if p.filename != "" </span><span class="cov0" title="0">{
                buf.WriteString(p.filename)
        }</span>
        <span class="cov0" title="0">if buf.Len() &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(":")
        }</span>
        <span class="cov0" title="0">buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
        if len(p.rstack) &gt; 0 </span><span class="cov0" title="0">{
                if buf.Len() &gt; 0 </span><span class="cov0" title="0">{
                        buf.WriteString(": ")
                }</span>
                <span class="cov0" title="0">rule := p.rstack[len(p.rstack)-1]
                if rule.displayName != "" </span><span class="cov0" title="0">{
                        buf.WriteString("rule " + rule.displayName)
                }</span> else<span class="cov0" title="0"> {
                        buf.WriteString("rule " + rule.name)
                }</span>
        }
        <span class="cov0" title="0">pe := &amp;parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
        p.errs.add(pe)</span>
}

func (p *parser) failAt(fail bool, pos position, want string) <span class="cov8" title="1">{
        // process fail if parsing fails and not inverted or parsing succeeds and invert is set
        if fail == p.maxFailInvertExpected </span><span class="cov8" title="1">{
                if pos.offset &lt; p.maxFailPos.offset </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">if pos.offset &gt; p.maxFailPos.offset </span><span class="cov8" title="1">{
                        p.maxFailPos = pos
                        p.maxFailExpected = p.maxFailExpected[:0]
                }</span>

                <span class="cov8" title="1">if p.maxFailInvertExpected </span><span class="cov8" title="1">{
                        want = "!" + want
                }</span>
                <span class="cov8" title="1">p.maxFailExpected = append(p.maxFailExpected, want)</span>
        }
}

// read advances the parser to the next rune.
func (p *parser) read() <span class="cov8" title="1">{
        p.pt.offset += p.pt.w
        rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
        p.pt.rn = rn
        p.pt.w = n
        p.pt.col++
        if rn == '\n' </span><span class="cov8" title="1">{
                p.pt.line++
                p.pt.col = 0
        }</span>

        <span class="cov8" title="1">if rn == utf8.RuneError &amp;&amp; n == 1 </span><span class="cov0" title="0">{ // see utf8.DecodeRune
                if !p.allowInvalidUTF8 </span><span class="cov0" title="0">{
                        p.addErr(errInvalidEncoding)
                }</span>
        }
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("restore"))
        }</span>
        <span class="cov8" title="1">if pt.offset == p.pt.offset </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">p.pt = pt</span>
}

// Cloner is implemented by any value that has a Clone method, which returns a
// copy of the value. This is mainly used for types which are not passed by
// value (e.g map, slice, chan) or structs that contain such types.
//
// This is used in conjunction with the global state feature to create proper
// copies of the state to allow the parser to properly restore the state in
// the case of backtracking.
type Cloner interface {
        Clone() any
}

var statePool = &amp;sync.Pool{
        New: func() any <span class="cov8" title="1">{ return make(storeDict) }</span>,
}

func (sd storeDict) Discard() <span class="cov8" title="1">{
        for k := range sd </span><span class="cov0" title="0">{
                delete(sd, k)
        }</span>
        <span class="cov8" title="1">statePool.Put(sd)</span>
}

// clone and return parser current state.
func (p *parser) cloneState() storeDict <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("cloneState"))
        }</span>

        <span class="cov8" title="1">state := statePool.Get().(storeDict)
        for k, v := range p.cur.state </span><span class="cov0" title="0">{
                if c, ok := v.(Cloner); ok </span><span class="cov0" title="0">{
                        state[k] = c.Clone()
                }</span> else<span class="cov0" title="0"> {
                        state[k] = v
                }</span>
        }
        <span class="cov8" title="1">return state</span>
}

// restore parser current state to the state storeDict.
// every restoreState should applied only one time for every cloned state
func (p *parser) restoreState(state storeDict) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("restoreState"))
        }</span>
        <span class="cov8" title="1">p.cur.state.Discard()
        p.cur.state = state</span>
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte <span class="cov8" title="1">{
        return p.data[start.position.offset:p.pt.position.offset]
}</span>

func (p *parser) getMemoized(node any) (resultTuple, bool) <span class="cov0" title="0">{
        if len(p.memo) == 0 </span><span class="cov0" title="0">{
                return resultTuple{}, false
        }</span>
        <span class="cov0" title="0">m := p.memo[p.pt.offset]
        if len(m) == 0 </span><span class="cov0" title="0">{
                return resultTuple{}, false
        }</span>
        <span class="cov0" title="0">res, ok := m[node]
        return res, ok</span>
}

func (p *parser) setMemoized(pt savepoint, node any, tuple resultTuple) <span class="cov0" title="0">{
        if p.memo == nil </span><span class="cov0" title="0">{
                p.memo = make(map[int]map[any]resultTuple)
        }</span>
        <span class="cov0" title="0">m := p.memo[pt.offset]
        if m == nil </span><span class="cov0" title="0">{
                m = make(map[any]resultTuple)
                p.memo[pt.offset] = m
        }</span>
        <span class="cov0" title="0">m[node] = tuple</span>
}

func (p *parser) buildRulesTable(g *grammar) <span class="cov8" title="1">{
        p.rules = make(map[string]*rule, len(g.rules))
        for _, r := range g.rules </span><span class="cov8" title="1">{
                p.rules[r.name] = r
        }</span>
}

func (p *parser) parse(g *grammar) (val any, err error) <span class="cov8" title="1">{
        if len(g.rules) == 0 </span><span class="cov0" title="0">{
                p.addErr(errNoRule)
                return nil, p.errs.err()
        }</span>

        // TODO : not super critical but this could be generated
        <span class="cov8" title="1">p.buildRulesTable(g)

        if p.recover </span><span class="cov8" title="1">{
                // panic can be used in action code to stop parsing immediately
                // and return the panic as an error.
                defer func() </span><span class="cov8" title="1">{
                        if e := recover(); e != nil </span><span class="cov0" title="0">{
                                if p.debug </span><span class="cov0" title="0">{
                                        defer p.out(p.in("panic handler"))
                                }</span>
                                <span class="cov0" title="0">val = nil
                                switch e := e.(type) </span>{
                                case error:<span class="cov0" title="0">
                                        p.addErr(e)</span>
                                default:<span class="cov0" title="0">
                                        p.addErr(fmt.Errorf("%v", e))</span>
                                }
                                <span class="cov0" title="0">err = p.errs.err()</span>
                        }
                }()
        }

        <span class="cov8" title="1">startRule, ok := p.rules[p.entrypoint]
        if !ok </span><span class="cov0" title="0">{
                p.addErr(errInvalidEntrypoint)
                return nil, p.errs.err()
        }</span>

        <span class="cov8" title="1">p.read() // advance to first rune
        val, ok = p.parseRuleWrap(startRule)
        if !ok </span><span class="cov0" title="0">{
                if len(*p.errs) == 0 </span><span class="cov0" title="0">{
                        // If parsing fails, but no errors have been recorded, the expected values
                        // for the farthest parser position are returned as error.
                        maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
                        for _, v := range p.maxFailExpected </span><span class="cov0" title="0">{
                                maxFailExpectedMap[v] = struct{}{}
                        }</span>
                        <span class="cov0" title="0">expected := make([]string, 0, len(maxFailExpectedMap))
                        eof := false
                        if _, ok := maxFailExpectedMap["!."]; ok </span><span class="cov0" title="0">{
                                delete(maxFailExpectedMap, "!.")
                                eof = true
                        }</span>
                        <span class="cov0" title="0">for k := range maxFailExpectedMap </span><span class="cov0" title="0">{
                                expected = append(expected, k)
                        }</span>
                        <span class="cov0" title="0">sort.Strings(expected)
                        if eof </span><span class="cov0" title="0">{
                                expected = append(expected, "EOF")
                        }</span>
                        <span class="cov0" title="0">p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)</span>
                }

                <span class="cov0" title="0">return nil, p.errs.err()</span>
        }
        <span class="cov8" title="1">return val, p.errs.err()</span>
}

func listJoin(list []string, sep string, lastSep string) string <span class="cov0" title="0">{
        switch len(list) </span>{
        case 0:<span class="cov0" title="0">
                return ""</span>
        case 1:<span class="cov0" title="0">
                return list[0]</span>
        default:<span class="cov0" title="0">
                return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]</span>
        }
}

func (p *parser) parseRuleMemoize(rule *rule) (any, bool) <span class="cov0" title="0">{
        res, ok := p.getMemoized(rule)
        if ok </span><span class="cov0" title="0">{
                p.restore(res.end)
                return res.v, res.b
        }</span>

        <span class="cov0" title="0">startMark := p.pt
        val, ok := p.parseRule(rule)
        p.setMemoized(startMark, rule, resultTuple{val, ok, p.pt})

        return val, ok</span>
}

func (p *parser) parseRuleWrap(rule *rule) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseRule " + rule.name))
        }</span>
        <span class="cov8" title="1">var (
                val       any
                ok        bool
                startMark = p.pt
        )

        if p.memoize </span><span class="cov0" title="0">{
                val, ok = p.parseRuleMemoize(rule)
        }</span> else<span class="cov8" title="1"> {
                val, ok = p.parseRule(rule)
        }</span>

        <span class="cov8" title="1">if ok &amp;&amp; p.debug </span><span class="cov0" title="0">{
                p.printIndent("MATCH", string(p.sliceFrom(startMark)))
        }</span>
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseRule(rule *rule) (any, bool) <span class="cov8" title="1">{
        p.rstack = append(p.rstack, rule)
        p.pushV()
        val, ok := p.parseExprWrap(rule.expr)
        p.popV()
        p.rstack = p.rstack[:len(p.rstack)-1]
        return val, ok
}</span>

func (p *parser) parseExprWrap(expr any) (any, bool) <span class="cov8" title="1">{
        var pt savepoint

        if p.memoize </span><span class="cov0" title="0">{
                res, ok := p.getMemoized(expr)
                if ok </span><span class="cov0" title="0">{
                        p.restore(res.end)
                        return res.v, res.b
                }</span>
                <span class="cov0" title="0">pt = p.pt</span>
        }

        <span class="cov8" title="1">val, ok := p.parseExpr(expr)

        if p.memoize </span><span class="cov0" title="0">{
                p.setMemoized(pt, expr, resultTuple{val, ok, p.pt})
        }</span>
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseExpr(expr any) (any, bool) <span class="cov8" title="1">{
        p.ExprCnt++
        if p.ExprCnt &gt; p.maxExprCnt </span><span class="cov0" title="0">{
                panic(errMaxExprCnt)</span>
        }

        <span class="cov8" title="1">var val any
        var ok bool
        switch expr := expr.(type) </span>{
        case *actionExpr:<span class="cov8" title="1">
                val, ok = p.parseActionExpr(expr)</span>
        case *andCodeExpr:<span class="cov0" title="0">
                val, ok = p.parseAndCodeExpr(expr)</span>
        case *andExpr:<span class="cov0" title="0">
                val, ok = p.parseAndExpr(expr)</span>
        case *anyMatcher:<span class="cov8" title="1">
                val, ok = p.parseAnyMatcher(expr)</span>
        case *charClassMatcher:<span class="cov8" title="1">
                val, ok = p.parseCharClassMatcher(expr)</span>
        case *choiceExpr:<span class="cov8" title="1">
                val, ok = p.parseChoiceExpr(expr)</span>
        case *labeledExpr:<span class="cov8" title="1">
                val, ok = p.parseLabeledExpr(expr)</span>
        case *litMatcher:<span class="cov8" title="1">
                val, ok = p.parseLitMatcher(expr)</span>
        case *notCodeExpr:<span class="cov0" title="0">
                val, ok = p.parseNotCodeExpr(expr)</span>
        case *notExpr:<span class="cov8" title="1">
                val, ok = p.parseNotExpr(expr)</span>
        case *oneOrMoreExpr:<span class="cov8" title="1">
                val, ok = p.parseOneOrMoreExpr(expr)</span>
        case *recoveryExpr:<span class="cov0" title="0">
                val, ok = p.parseRecoveryExpr(expr)</span>
        case *ruleRefExpr:<span class="cov8" title="1">
                val, ok = p.parseRuleRefExpr(expr)</span>
        case *seqExpr:<span class="cov8" title="1">
                val, ok = p.parseSeqExpr(expr)</span>
        case *stateCodeExpr:<span class="cov0" title="0">
                val, ok = p.parseStateCodeExpr(expr)</span>
        case *throwExpr:<span class="cov0" title="0">
                val, ok = p.parseThrowExpr(expr)</span>
        case *zeroOrMoreExpr:<span class="cov8" title="1">
                val, ok = p.parseZeroOrMoreExpr(expr)</span>
        case *zeroOrOneExpr:<span class="cov8" title="1">
                val, ok = p.parseZeroOrOneExpr(expr)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unknown expression type %T", expr))</span>
        }
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseActionExpr(act *actionExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseActionExpr"))
        }</span>

        <span class="cov8" title="1">start := p.pt
        val, ok := p.parseExprWrap(act.expr)
        if ok </span><span class="cov8" title="1">{
                p.cur.pos = start.position
                p.cur.text = p.sliceFrom(start)
                state := p.cloneState()
                actVal, err := act.run(p)
                if err != nil </span><span class="cov0" title="0">{
                        p.addErrAt(err, start.position, []string{})
                }</span>
                <span class="cov8" title="1">p.restoreState(state)

                val = actVal</span>
        }
        <span class="cov8" title="1">if ok &amp;&amp; p.debug </span><span class="cov0" title="0">{
                p.printIndent("MATCH", string(p.sliceFrom(start)))
        }</span>
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseAndCodeExpr"))
        }</span>

        <span class="cov0" title="0">state := p.cloneState()

        ok, err := and.run(p)
        if err != nil </span><span class="cov0" title="0">{
                p.addErr(err)
        }</span>
        <span class="cov0" title="0">p.restoreState(state)

        return nil, ok</span>
}

func (p *parser) parseAndExpr(and *andExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseAndExpr"))
        }</span>

        <span class="cov0" title="0">pt := p.pt
        state := p.cloneState()
        p.pushV()
        _, ok := p.parseExprWrap(and.expr)
        p.popV()
        p.restoreState(state)
        p.restore(pt)

        return nil, ok</span>
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseAnyMatcher"))
        }</span>

        <span class="cov8" title="1">if p.pt.rn == utf8.RuneError &amp;&amp; p.pt.w == 0 </span><span class="cov8" title="1">{
                // EOF - see utf8.DecodeRune
                p.failAt(false, p.pt.position, ".")
                return nil, false
        }</span>
        <span class="cov8" title="1">start := p.pt
        p.read()
        p.failAt(true, start.position, ".")
        return p.sliceFrom(start), true</span>
}

func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseCharClassMatcher"))
        }</span>

        <span class="cov8" title="1">cur := p.pt.rn
        start := p.pt

        // can't match EOF
        if cur == utf8.RuneError &amp;&amp; p.pt.w == 0 </span><span class="cov8" title="1">{ // see utf8.DecodeRune
                p.failAt(false, start.position, chr.val)
                return nil, false
        }</span>

        <span class="cov8" title="1">if chr.ignoreCase </span><span class="cov0" title="0">{
                cur = unicode.ToLower(cur)
        }</span>

        // try to match in the list of available chars
        <span class="cov8" title="1">for _, rn := range chr.chars </span><span class="cov8" title="1">{
                if rn == cur </span><span class="cov8" title="1">{
                        if chr.inverted </span><span class="cov0" title="0">{
                                p.failAt(false, start.position, chr.val)
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">p.read()
                        p.failAt(true, start.position, chr.val)
                        return p.sliceFrom(start), true</span>
                }
        }

        // try to match in the list of ranges
        <span class="cov8" title="1">for i := 0; i &lt; len(chr.ranges); i += 2 </span><span class="cov8" title="1">{
                if cur &gt;= chr.ranges[i] &amp;&amp; cur &lt;= chr.ranges[i+1] </span><span class="cov8" title="1">{
                        if chr.inverted </span><span class="cov0" title="0">{
                                p.failAt(false, start.position, chr.val)
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">p.read()
                        p.failAt(true, start.position, chr.val)
                        return p.sliceFrom(start), true</span>
                }
        }

        // try to match in the list of Unicode classes
        <span class="cov8" title="1">for _, cl := range chr.classes </span><span class="cov0" title="0">{
                if unicode.Is(cl, cur) </span><span class="cov0" title="0">{
                        if chr.inverted </span><span class="cov0" title="0">{
                                p.failAt(false, start.position, chr.val)
                                return nil, false
                        }</span>
                        <span class="cov0" title="0">p.read()
                        p.failAt(true, start.position, chr.val)
                        return p.sliceFrom(start), true</span>
                }
        }

        <span class="cov8" title="1">if chr.inverted </span><span class="cov0" title="0">{
                p.read()
                p.failAt(true, start.position, chr.val)
                return p.sliceFrom(start), true
        }</span>
        <span class="cov8" title="1">p.failAt(false, start.position, chr.val)
        return nil, false</span>
}

func (p *parser) incChoiceAltCnt(ch *choiceExpr, altI int) <span class="cov8" title="1">{
        choiceIdent := fmt.Sprintf("%s %d:%d", p.rstack[len(p.rstack)-1].name, ch.pos.line, ch.pos.col)
        m := p.ChoiceAltCnt[choiceIdent]
        if m == nil </span><span class="cov8" title="1">{
                m = make(map[string]int)
                p.ChoiceAltCnt[choiceIdent] = m
        }</span>
        // We increment altI by 1, so the keys do not start at 0
        <span class="cov8" title="1">alt := strconv.Itoa(altI + 1)
        if altI == choiceNoMatch </span><span class="cov8" title="1">{
                alt = p.choiceNoMatch
        }</span>
        <span class="cov8" title="1">m[alt]++</span>
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseChoiceExpr"))
        }</span>

        <span class="cov8" title="1">for altI, alt := range ch.alternatives </span><span class="cov8" title="1">{
                // dummy assignment to prevent compile error if optimized
                _ = altI

                state := p.cloneState()

                p.pushV()
                val, ok := p.parseExprWrap(alt)
                p.popV()
                if ok </span><span class="cov8" title="1">{
                        p.incChoiceAltCnt(ch, altI)
                        return val, ok
                }</span>
                <span class="cov8" title="1">p.restoreState(state)</span>
        }
        <span class="cov8" title="1">p.incChoiceAltCnt(ch, choiceNoMatch)
        return nil, false</span>
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseLabeledExpr"))
        }</span>

        <span class="cov8" title="1">p.pushV()
        val, ok := p.parseExprWrap(lab.expr)
        p.popV()
        if ok &amp;&amp; lab.label != "" </span><span class="cov8" title="1">{
                m := p.vstack[len(p.vstack)-1]
                m[lab.label] = val
        }</span>
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseLitMatcher(lit *litMatcher) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseLitMatcher"))
        }</span>

        <span class="cov8" title="1">start := p.pt
        for _, want := range lit.val </span><span class="cov8" title="1">{
                cur := p.pt.rn
                if lit.ignoreCase </span><span class="cov0" title="0">{
                        cur = unicode.ToLower(cur)
                }</span>
                <span class="cov8" title="1">if cur != want </span><span class="cov8" title="1">{
                        p.failAt(false, start.position, lit.want)
                        p.restore(start)
                        return nil, false
                }</span>
                <span class="cov8" title="1">p.read()</span>
        }
        <span class="cov8" title="1">p.failAt(true, start.position, lit.want)
        return p.sliceFrom(start), true</span>
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseNotCodeExpr"))
        }</span>

        <span class="cov0" title="0">state := p.cloneState()

        ok, err := not.run(p)
        if err != nil </span><span class="cov0" title="0">{
                p.addErr(err)
        }</span>
        <span class="cov0" title="0">p.restoreState(state)

        return nil, !ok</span>
}

func (p *parser) parseNotExpr(not *notExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseNotExpr"))
        }</span>

        <span class="cov8" title="1">pt := p.pt
        state := p.cloneState()
        p.pushV()
        p.maxFailInvertExpected = !p.maxFailInvertExpected
        _, ok := p.parseExprWrap(not.expr)
        p.maxFailInvertExpected = !p.maxFailInvertExpected
        p.popV()
        p.restoreState(state)
        p.restore(pt)

        return nil, !ok</span>
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseOneOrMoreExpr"))
        }</span>

        <span class="cov8" title="1">var vals []any

        for </span><span class="cov8" title="1">{
                p.pushV()
                val, ok := p.parseExprWrap(expr.expr)
                p.popV()
                if !ok </span><span class="cov8" title="1">{
                        if len(vals) == 0 </span><span class="cov8" title="1">{
                                // did not match once, no match
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">return vals, true</span>
                }
                <span class="cov8" title="1">vals = append(vals, val)</span>
        }
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseRecoveryExpr (" + strings.Join(recover.failureLabel, ",") + ")"))
        }</span>

        <span class="cov0" title="0">p.pushRecovery(recover.failureLabel, recover.recoverExpr)
        val, ok := p.parseExprWrap(recover.expr)
        p.popRecovery()

        return val, ok</span>
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseRuleRefExpr " + ref.name))
        }</span>

        <span class="cov8" title="1">if ref.name == "" </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%s: invalid rule: missing name", ref.pos))</span>
        }

        <span class="cov8" title="1">rule := p.rules[ref.name]
        if rule == nil </span><span class="cov0" title="0">{
                p.addErr(fmt.Errorf("undefined rule: %s", ref.name))
                return nil, false
        }</span>
        <span class="cov8" title="1">return p.parseRuleWrap(rule)</span>
}

func (p *parser) parseSeqExpr(seq *seqExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseSeqExpr"))
        }</span>

        <span class="cov8" title="1">vals := make([]any, 0, len(seq.exprs))

        pt := p.pt
        state := p.cloneState()
        for _, expr := range seq.exprs </span><span class="cov8" title="1">{
                val, ok := p.parseExprWrap(expr)
                if !ok </span><span class="cov8" title="1">{
                        p.restoreState(state)
                        p.restore(pt)
                        return nil, false
                }</span>
                <span class="cov8" title="1">vals = append(vals, val)</span>
        }
        <span class="cov8" title="1">return vals, true</span>
}

func (p *parser) parseStateCodeExpr(state *stateCodeExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseStateCodeExpr"))
        }</span>

        <span class="cov0" title="0">err := state.run(p)
        if err != nil </span><span class="cov0" title="0">{
                p.addErr(err)
        }</span>
        <span class="cov0" title="0">return nil, true</span>
}

func (p *parser) parseThrowExpr(expr *throwExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseThrowExpr"))
        }</span>

        <span class="cov0" title="0">for i := len(p.recoveryStack) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok </span><span class="cov0" title="0">{
                        if val, ok := p.parseExprWrap(recoverExpr); ok </span><span class="cov0" title="0">{
                                return val, ok
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, false</span>
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseZeroOrMoreExpr"))
        }</span>

        <span class="cov8" title="1">var vals []any

        for </span><span class="cov8" title="1">{
                p.pushV()
                val, ok := p.parseExprWrap(expr.expr)
                p.popV()
                if !ok </span><span class="cov8" title="1">{
                        return vals, true
                }</span>
                <span class="cov8" title="1">vals = append(vals, val)</span>
        }
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseZeroOrOneExpr"))
        }</span>

        <span class="cov8" title="1">p.pushV()
        val, _ := p.parseExprWrap(expr.expr)
        p.popV()
        // whether it matched or not, consider it a match
        return val, true</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package domain

import (
        "fmt"
)

// ErrorType d√©finit les types d'erreurs du module constraint
type ErrorType string

const (
        // Erreurs de parsing
        ParseError ErrorType = "PARSE_ERROR"

        // Erreurs de validation
        ValidationError    ErrorType = "VALIDATION_ERROR"
        TypeMismatchError  ErrorType = "TYPE_MISMATCH_ERROR"
        FieldNotFoundError ErrorType = "FIELD_NOT_FOUND_ERROR"
        UnknownTypeError   ErrorType = "UNKNOWN_TYPE_ERROR"

        // Erreurs de contraintes
        ConstraintValidationError ErrorType = "CONSTRAINT_ERROR"
        ActionError               ErrorType = "ACTION_ERROR"
)

// Error repr√©sente une erreur structur√©e du module constraint
type Error struct {
        Type    ErrorType `json:"type"`
        Message string    `json:"message"`
        Context Context   `json:"context"`
        Cause   error     `json:"cause,omitempty"`
}

// Context fournit des informations contextuelles sur l'erreur
type Context struct {
        File     string      `json:"file,omitempty"`
        Line     int         `json:"line,omitempty"`
        Column   int         `json:"column,omitempty"`
        Field    string      `json:"field,omitempty"`
        Type     string      `json:"type,omitempty"`
        Variable string      `json:"variable,omitempty"`
        Value    interface{} `json:"value,omitempty"`
        Expected string      `json:"expected,omitempty"`
        Actual   string      `json:"actual,omitempty"`
}

// Error impl√©mente l'interface error
func (ce *Error) Error() string <span class="cov8" title="1">{
        if ce.Context.File != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s at %s:%d:%d: %s",
                        ce.Type, ce.Context.File, ce.Context.Line, ce.Context.Column, ce.Message)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s: %s", ce.Type, ce.Message)</span>
}

// Unwrap permet le unwrapping des erreurs
func (ce *Error) Unwrap() error <span class="cov8" title="1">{
        return ce.Cause
}</span>

// Is permet la comparaison des types d'erreurs
func (ce *Error) Is(target error) bool <span class="cov8" title="1">{
        if t, ok := target.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == t.Type
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Constructeurs d'erreurs

// NewParseError cr√©e une erreur de parsing
func NewParseError(message, file string, line, column int) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Type:    ParseError,
                Message: message,
                Context: Context{
                        File:   file,
                        Line:   line,
                        Column: column,
                },
        }
}</span>

// NewValidationError cr√©e une erreur de validation
func NewValidationError(message string, ctx Context) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Type:    ValidationError,
                Message: message,
                Context: ctx,
        }
}</span>

// NewTypeMismatchError cr√©e une erreur de type incompatible
func NewTypeMismatchError(expected, actual string, ctx Context) *Error <span class="cov8" title="1">{
        ctx.Expected = expected
        ctx.Actual = actual
        return &amp;Error{
                Type:    TypeMismatchError,
                Message: fmt.Sprintf("type mismatch: expected %s, got %s", expected, actual),
                Context: ctx,
        }
}</span>

// NewFieldNotFoundError cr√©e une erreur de champ introuvable
func NewFieldNotFoundError(field, typeName string, ctx Context) *Error <span class="cov8" title="1">{
        ctx.Field = field
        ctx.Type = typeName
        return &amp;Error{
                Type:    FieldNotFoundError,
                Message: fmt.Sprintf("field '%s' not found in type '%s'", field, typeName),
                Context: ctx,
        }
}</span>

// NewUnknownTypeError cr√©e une erreur de type inconnu
func NewUnknownTypeError(typeName string, ctx Context) *Error <span class="cov8" title="1">{
        ctx.Type = typeName
        return &amp;Error{
                Type:    UnknownTypeError,
                Message: fmt.Sprintf("unknown type '%s'", typeName),
                Context: ctx,
        }
}</span>

// NewConstraintError cr√©e une erreur de contrainte
func NewConstraintError(message string, ctx Context) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Type:    ConstraintValidationError,
                Message: message,
                Context: ctx,
        }
}</span>

// NewActionError cr√©e une erreur d'action
func NewActionError(message string, ctx Context) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Type:    ActionError,
                Message: message,
                Context: ctx,
        }
}</span>

// Helpers pour v√©rifier les types d'erreurs

// IsParseError v√©rifie si l'erreur est une erreur de parsing
func IsParseError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == ParseError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsValidationError v√©rifie si l'erreur est une erreur de validation
func IsValidationError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == ValidationError ||
                        ce.Type == TypeMismatchError ||
                        ce.Type == FieldNotFoundError ||
                        ce.Type == UnknownTypeError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsTypeMismatchError v√©rifie si l'erreur est une erreur de type incompatible
func IsTypeMismatchError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == TypeMismatchError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsFieldNotFoundError v√©rifie si l'erreur est une erreur de champ introuvable
func IsFieldNotFoundError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == FieldNotFoundError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsUnknownTypeError v√©rifie si l'erreur est une erreur de type inconnu
func IsUnknownTypeError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == UnknownTypeError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ErrorCollection permet de collecter plusieurs erreurs
type ErrorCollection struct {
        Errors []*Error `json:"errors"`
}

// NewErrorCollection cr√©e une nouvelle collection d'erreurs
func NewErrorCollection() *ErrorCollection <span class="cov8" title="1">{
        return &amp;ErrorCollection{
                Errors: make([]*Error, 0),
        }
}</span>

// Add ajoute une erreur √† la collection
func (ec *ErrorCollection) Add(err *Error) <span class="cov8" title="1">{
        ec.Errors = append(ec.Errors, err)
}</span>

// HasErrors v√©rifie s'il y a des erreurs
func (ec *ErrorCollection) HasErrors() bool <span class="cov8" title="1">{
        return len(ec.Errors) &gt; 0
}</span>

// Error impl√©mente l'interface error pour la collection
func (ec *ErrorCollection) Error() string <span class="cov8" title="1">{
        if len(ec.Errors) == 0 </span><span class="cov8" title="1">{
                return "no errors"
        }</span>
        <span class="cov8" title="1">if len(ec.Errors) == 1 </span><span class="cov8" title="1">{
                return ec.Errors[0].Error()
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%d errors: %s (and %d more)",
                len(ec.Errors), ec.Errors[0].Error(), len(ec.Errors)-1)</span>
}

// First retourne la premi√®re erreur ou nil
func (ec *ErrorCollection) First() *Error <span class="cov8" title="1">{
        if len(ec.Errors) &gt; 0 </span><span class="cov8" title="1">{
                return ec.Errors[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package domain

import (
        "encoding/json"
        "fmt"
        "time"
)

// Program repr√©sente un programme complet de contraintes
type Program struct {
        Types       []TypeDefinition `json:"types"`
        Expressions []Expression     `json:"expressions"`
        Metadata    *Metadata        `json:"metadata,omitempty"`
}

// Metadata contient les informations sur le programme
type Metadata struct {
        Version     string    `json:"version"`
        CreatedAt   time.Time `json:"created_at"`
        Author      string    `json:"author,omitempty"`
        Description string    `json:"description,omitempty"`
}

// TypeDefinition d√©finit un type personnalis√© avec ses champs
type TypeDefinition struct {
        Type   string  `json:"type"`
        Name   string  `json:"name"`
        Fields []Field `json:"fields"`
}

// Field repr√©sente un champ dans une d√©finition de type
type Field struct {
        Name string `json:"name"`
        Type string `json:"type"`
}

// Expression repr√©sente une r√®gle m√©tier compl√®te
type Expression struct {
        Type        string      `json:"type"`
        Set         Set         `json:"set"`
        Constraints interface{} `json:"constraints"`
        Action      *Action     `json:"action,omitempty"`
}

// Set repr√©sente l'ensemble de variables typ√©es dans une r√®gle
type Set struct {
        Type      string          `json:"type"`
        Variables []TypedVariable `json:"variables"`
}

// TypedVariable repr√©sente une variable avec son type
type TypedVariable struct {
        Type     string `json:"type"`
        Name     string `json:"name"`
        DataType string `json:"dataType"`
}

// Constraint repr√©sente une contrainte (condition)
type Constraint struct {
        Type     string      `json:"type"`
        Left     interface{} `json:"left,omitempty"`
        Operator string      `json:"operator,omitempty"`
        Right    interface{} `json:"right,omitempty"`
}

// Action repr√©sente une action √† ex√©cuter quand les conditions sont remplies
type Action struct {
        Type string  `json:"type"`
        Job  JobCall `json:"job"`
}

// JobCall repr√©sente l'appel d'une fonction/job
type JobCall struct {
        Type string        `json:"type"`
        Name string        `json:"name"`
        Args []interface{} `json:"args"`
}

// FieldAccess repr√©sente l'acc√®s √† un champ d'une variable
type FieldAccess struct {
        Type   string `json:"type"`
        Object string `json:"object"`
        Field  string `json:"field"`
}

// Variable repr√©sente une r√©f√©rence √† une variable
type Variable struct {
        Type string `json:"type"`
        Name string `json:"name"`
}

// Literal types pour les valeurs constantes
type BooleanLiteral struct {
        Type  string `json:"type"`
        Value bool   `json:"value"`
}

type StringLiteral struct {
        Type  string `json:"type"`
        Value string `json:"value"`
}

type NumberLiteral struct {
        Type  string  `json:"type"`
        Value float64 `json:"value"`
}

type IntegerLiteral struct {
        Type  string `json:"type"`
        Value int64  `json:"value"`
}

// Constructeurs pour faciliter la cr√©ation des structures

// NewProgram cr√©e un nouveau programme
func NewProgram() *Program <span class="cov8" title="1">{
        return &amp;Program{
                Types:       make([]TypeDefinition, 0),
                Expressions: make([]Expression, 0),
                Metadata: &amp;Metadata{
                        Version:   "1.0",
                        CreatedAt: time.Now(),
                },
        }
}</span>

// NewTypeDefinition cr√©e une nouvelle d√©finition de type
func NewTypeDefinition(name string) *TypeDefinition <span class="cov8" title="1">{
        return &amp;TypeDefinition{
                Type:   "typeDefinition",
                Name:   name,
                Fields: make([]Field, 0),
        }
}</span>

// AddField ajoute un champ √† la d√©finition de type
func (td *TypeDefinition) AddField(name, fieldType string) <span class="cov8" title="1">{
        td.Fields = append(td.Fields, Field{
                Name: name,
                Type: fieldType,
        })
}</span>

// NewExpression cr√©e une nouvelle expression/r√®gle
func NewExpression() *Expression <span class="cov8" title="1">{
        return &amp;Expression{
                Type: "expression",
                Set: Set{
                        Type:      "set",
                        Variables: make([]TypedVariable, 0),
                },
        }
}</span>

// AddVariable ajoute une variable au set de l'expression
func (e *Expression) AddVariable(name, dataType string) <span class="cov8" title="1">{
        e.Set.Variables = append(e.Set.Variables, TypedVariable{
                Type:     "typedVariable",
                Name:     name,
                DataType: dataType,
        })
}</span>

// NewConstraint cr√©e une nouvelle contrainte binaire
func NewConstraint(left interface{}, operator string, right interface{}) *Constraint <span class="cov8" title="1">{
        return &amp;Constraint{
                Type:     "constraint",
                Left:     left,
                Operator: operator,
                Right:    right,
        }
}</span>

// NewFieldAccess cr√©e un nouvel acc√®s de champ
func NewFieldAccess(object, field string) *FieldAccess <span class="cov8" title="1">{
        return &amp;FieldAccess{
                Type:   "fieldAccess",
                Object: object,
                Field:  field,
        }
}</span>

// NewAction cr√©e une nouvelle action
func NewAction(jobName string, args ...interface{}) *Action <span class="cov8" title="1">{
        return &amp;Action{
                Type: "action",
                Job: JobCall{
                        Type: "jobCall",
                        Name: jobName,
                        Args: args,
                },
        }
}</span>

// M√©thodes utilitaires

// String retourne une repr√©sentation JSON format√©e du programme
func (p *Program) String() string <span class="cov8" title="1">{
        data, err := json.MarshalIndent(p, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Program{Types: %d, Expressions: %d}", len(p.Types), len(p.Expressions))
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

// GetTypeByName trouve une d√©finition de type par son nom
func (p *Program) GetTypeByName(name string) *TypeDefinition <span class="cov8" title="1">{
        for i := range p.Types </span><span class="cov8" title="1">{
                if p.Types[i].Name == name </span><span class="cov8" title="1">{
                        return &amp;p.Types[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetFieldByName trouve un champ dans la d√©finition de type par son nom
func (td *TypeDefinition) GetFieldByName(name string) *Field <span class="cov8" title="1">{
        for i := range td.Fields </span><span class="cov8" title="1">{
                if td.Fields[i].Name == name </span><span class="cov8" title="1">{
                        return &amp;td.Fields[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// HasField v√©rifie si un type a un champ donn√©
func (td *TypeDefinition) HasField(name string) bool <span class="cov8" title="1">{
        return td.GetFieldByName(name) != nil
}</span>

// Validation helpers

// IsValidOperator v√©rifie si un op√©rateur est valide
func IsValidOperator(op string) bool <span class="cov8" title="1">{
        validOps := map[string]bool{
                "==": true, "!=": true, "&lt;": true, "&gt;": true, "&lt;=": true, "&gt;=": true,
                "AND": true, "OR": true, "NOT": true,
                "+": true, "-": true, "*": true, "/": true, "%": true,
        }
        return validOps[op]
}</span>

// IsValidType v√©rifie si un type est valide
func IsValidType(t string) bool <span class="cov8" title="1">{
        validTypes := map[string]bool{
                "string": true, "number": true, "bool": true, "integer": true,
        }
        return validTypes[t]
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package validator

import (
        "fmt"
        "sync"

        "github.com/treivax/tsd/constraint/pkg/domain"
)

// TypeRegistry impl√©mente l'interface domain.TypeRegistry
type TypeRegistry struct {
        types map[string]domain.TypeDefinition
        mutex sync.RWMutex
}

// NewTypeRegistry cr√©e un nouveau registre de types
func NewTypeRegistry() *TypeRegistry <span class="cov8" title="1">{
        return &amp;TypeRegistry{
                types: make(map[string]domain.TypeDefinition),
                mutex: sync.RWMutex{},
        }
}</span>

// RegisterType enregistre un nouveau type
func (tr *TypeRegistry) RegisterType(typeDef domain.TypeDefinition) error <span class="cov8" title="1">{
        tr.mutex.Lock()
        defer tr.mutex.Unlock()

        if _, exists := tr.types[typeDef.Name]; exists </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        fmt.Sprintf("type '%s' already exists", typeDef.Name),
                        domain.Context{Type: typeDef.Name},
                )
        }</span>

        <span class="cov8" title="1">tr.types[typeDef.Name] = typeDef
        return nil</span>
}

// GetType r√©cup√®re un type par son nom
func (tr *TypeRegistry) GetType(name string) (*domain.TypeDefinition, error) <span class="cov8" title="1">{
        tr.mutex.RLock()
        defer tr.mutex.RUnlock()

        if typeDef, exists := tr.types[name]; exists </span><span class="cov8" title="1">{
                return &amp;typeDef, nil
        }</span>

        <span class="cov8" title="1">return nil, domain.NewUnknownTypeError(
                name,
                domain.Context{Type: name},
        )</span>
}

// HasType v√©rifie si un type existe
func (tr *TypeRegistry) HasType(name string) bool <span class="cov8" title="1">{
        tr.mutex.RLock()
        defer tr.mutex.RUnlock()

        _, exists := tr.types[name]
        return exists
}</span>

// ListTypes retourne tous les types enregistr√©s
func (tr *TypeRegistry) ListTypes() []domain.TypeDefinition <span class="cov8" title="1">{
        tr.mutex.RLock()
        defer tr.mutex.RUnlock()

        types := make([]domain.TypeDefinition, 0, len(tr.types))
        for _, typeDef := range tr.types </span><span class="cov8" title="1">{
                types = append(types, typeDef)
        }</span>
        <span class="cov8" title="1">return types</span>
}

// GetTypeFields retourne les champs d'un type
func (tr *TypeRegistry) GetTypeFields(typeName string) (map[string]string, error) <span class="cov8" title="1">{
        typeDef, err := tr.GetType(typeName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fields := make(map[string]string)
        for _, field := range typeDef.Fields </span><span class="cov8" title="1">{
                fields[field.Name] = field.Type
        }</span>

        <span class="cov8" title="1">return fields, nil</span>
}

// Clear supprime tous les types (utile pour les tests)
func (tr *TypeRegistry) Clear() <span class="cov8" title="1">{
        tr.mutex.Lock()
        defer tr.mutex.Unlock()

        tr.types = make(map[string]domain.TypeDefinition)
}</span>

// TypeChecker impl√©mente l'interface domain.TypeChecker
type TypeChecker struct {
        registry domain.TypeRegistry
}

// NewTypeChecker cr√©e un nouveau v√©rificateur de types
func NewTypeChecker(registry domain.TypeRegistry) *TypeChecker <span class="cov8" title="1">{
        return &amp;TypeChecker{
                registry: registry,
        }
}</span>

// GetFieldType retourne le type d'un champ
func (tc *TypeChecker) GetFieldType(fieldAccess interface{}, variables []domain.TypedVariable, types []domain.TypeDefinition) (string, error) <span class="cov8" title="1">{
        // Cast vers FieldAccess
        fa, ok := fieldAccess.(*domain.FieldAccess)
        if !ok </span><span class="cov8" title="1">{
                // Essayer avec une map (format JSON)
                if faMap, ok := fieldAccess.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        objectName, _ := faMap["object"].(string)
                        fieldName, _ := faMap["field"].(string)

                        fa = &amp;domain.FieldAccess{
                                Object: objectName,
                                Field:  fieldName,
                        }
                }</span> else<span class="cov8" title="1"> {
                        return "", domain.NewValidationError(
                                "invalid field access format",
                                domain.Context{Value: fieldAccess},
                        )
                }</span>
        }

        // Trouver la variable
        <span class="cov8" title="1">var variableType string
        for _, variable := range variables </span><span class="cov8" title="1">{
                if variable.Name == fa.Object </span><span class="cov8" title="1">{
                        variableType = variable.DataType
                        break</span>
                }
        }

        <span class="cov8" title="1">if variableType == "" </span><span class="cov8" title="1">{
                return "", domain.NewValidationError(
                        fmt.Sprintf("variable '%s' not found", fa.Object),
                        domain.Context{Variable: fa.Object},
                )
        }</span>

        // Trouver le type de la variable
        <span class="cov8" title="1">typeDef, err := tc.registry.GetType(variableType)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Trouver le champ dans le type
        <span class="cov8" title="1">field := typeDef.GetFieldByName(fa.Field)
        if field == nil </span><span class="cov8" title="1">{
                return "", domain.NewFieldNotFoundError(
                        fa.Field,
                        variableType,
                        domain.Context{
                                Field:    fa.Field,
                                Type:     variableType,
                                Variable: fa.Object,
                        },
                )
        }</span>

        <span class="cov8" title="1">return field.Type, nil</span>
}

// GetValueType retourne le type d'une valeur
func (tc *TypeChecker) GetValueType(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case bool:<span class="cov8" title="1">
                return "bool"</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return "integer"</span>
        case float32, float64:<span class="cov8" title="1">
                return "number"</span>
        case string:<span class="cov8" title="1">
                return "string"</span>
        case map[string]interface{}:<span class="cov8" title="1">
                // Format JSON, essayer de d√©terminer le type
                if valueType, ok := v["type"].(string); ok </span><span class="cov8" title="1">{
                        switch valueType </span>{
                        case "booleanLiteral":<span class="cov8" title="1">
                                return "bool"</span>
                        case "integerLiteral":<span class="cov8" title="1">
                                return "integer"</span>
                        case "numberLiteral":<span class="cov8" title="1">
                                return "number"</span>
                        case "stringLiteral":<span class="cov8" title="1">
                                return "string"</span>
                        }
                }
                // Si on a une valeur directe
                <span class="cov8" title="1">if val, ok := v["value"]; ok </span><span class="cov8" title="1">{
                        return tc.GetValueType(val)
                }</span>
                <span class="cov0" title="0">return "unknown"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// ValidateTypeCompatibility v√©rifie la compatibilit√© entre types
func (tc *TypeChecker) ValidateTypeCompatibility(leftType, rightType, operator string) error <span class="cov8" title="1">{
        // Op√©rateurs de comparaison
        comparisonOps := map[string]bool{
                "==": true, "!=": true, "&lt;": true, "&gt;": true, "&lt;=": true, "&gt;=": true,
        }

        // Op√©rateurs logiques
        logicalOps := map[string]bool{
                "AND": true, "OR": true, "NOT": true,
        }

        // Op√©rateurs arithm√©tiques
        arithmeticOps := map[string]bool{
                "+": true, "-": true, "*": true, "/": true, "%": true,
        }

        // V√©rification basique des op√©rateurs
        if !domain.IsValidOperator(operator) </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        fmt.Sprintf("invalid operator: %s", operator),
                        domain.Context{
                                Expected: "valid operator (==, !=, &lt;, &gt;, &lt;=, &gt;=, AND, OR, NOT, +, -, *, /, %)",
                                Actual:   operator,
                        },
                )
        }</span>

        // R√®gles sp√©cifiques par op√©rateur
        <span class="cov8" title="1">if comparisonOps[operator] </span><span class="cov8" title="1">{
                // Pour les comparaisons, les types doivent √™tre compatibles
                return tc.validateComparisonTypes(leftType, rightType, operator)
        }</span>

        <span class="cov8" title="1">if logicalOps[operator] </span><span class="cov8" title="1">{
                // Pour les op√©rations logiques, les op√©randes doivent √™tre bool√©ens
                return tc.validateLogicalTypes(leftType, rightType, operator)
        }</span>

        <span class="cov8" title="1">if arithmeticOps[operator] </span><span class="cov8" title="1">{
                // Pour l'arithm√©tique, les types doivent √™tre num√©riques
                return tc.validateArithmeticTypes(leftType, rightType, operator)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateComparisonTypes valide les types pour les op√©rateurs de comparaison
func (tc *TypeChecker) validateComparisonTypes(leftType, rightType, operator string) error <span class="cov8" title="1">{
        // √âgalit√©/in√©galit√© : tous types compatibles si identiques
        if operator == "==" || operator == "!=" </span><span class="cov8" title="1">{
                if leftType != rightType </span><span class="cov8" title="1">{
                        return domain.NewTypeMismatchError(
                                leftType,
                                rightType,
                                domain.Context{},
                        )
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Comparaisons ordinales : seulement pour les types num√©riques et strings
        <span class="cov8" title="1">orderableTypes := map[string]bool{
                "number": true, "integer": true, "string": true,
        }

        if !orderableTypes[leftType] || !orderableTypes[rightType] </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        fmt.Sprintf("operator '%s' not supported for types '%s' and '%s'",
                                operator, leftType, rightType),
                        domain.Context{
                                Expected: "number, integer, or string",
                                Actual:   fmt.Sprintf("%s, %s", leftType, rightType),
                        },
                )
        }</span>

        <span class="cov8" title="1">if leftType != rightType </span><span class="cov8" title="1">{
                return domain.NewTypeMismatchError(
                        leftType,
                        rightType,
                        domain.Context{},
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateLogicalTypes valide les types pour les op√©rateurs logiques
func (tc *TypeChecker) validateLogicalTypes(leftType, rightType, operator string) error <span class="cov8" title="1">{
        if operator == "NOT" </span><span class="cov8" title="1">{
                // NOT est unaire, v√©rifier seulement le type de gauche
                if leftType != "bool" </span><span class="cov8" title="1">{
                        return domain.NewTypeMismatchError(
                                "bool",
                                leftType,
                                domain.Context{},
                        )
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // AND/OR : les deux op√©randes doivent √™tre bool√©ens
        <span class="cov8" title="1">if leftType != "bool" || rightType != "bool" </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        fmt.Sprintf("logical operator '%s' requires boolean operands", operator),
                        domain.Context{
                                Expected: "bool, bool",
                                Actual:   fmt.Sprintf("%s, %s", leftType, rightType),
                        },
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateArithmeticTypes valide les types pour les op√©rateurs arithm√©tiques
func (tc *TypeChecker) validateArithmeticTypes(leftType, rightType, operator string) error <span class="cov8" title="1">{
        numericTypes := map[string]bool{
                "number": true, "integer": true,
        }

        if !numericTypes[leftType] || !numericTypes[rightType] </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        fmt.Sprintf("arithmetic operator '%s' requires numeric operands", operator),
                        domain.Context{
                                Expected: "number or integer",
                                Actual:   fmt.Sprintf("%s, %s", leftType, rightType),
                        },
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package validator

import (
        "fmt"
        "strings"

        "github.com/treivax/tsd/constraint/pkg/domain"
)

// ConstraintValidator impl√©mente l'interface domain.Validator
type ConstraintValidator struct {
        typeRegistry domain.TypeRegistry
        typeChecker  domain.TypeChecker
        config       domain.ValidatorConfig
}

// NewConstraintValidator cr√©e un nouveau validateur
func NewConstraintValidator(registry domain.TypeRegistry, checker domain.TypeChecker) *ConstraintValidator <span class="cov8" title="1">{
        return &amp;ConstraintValidator{
                typeRegistry: registry,
                typeChecker:  checker,
                config: domain.ValidatorConfig{
                        StrictMode:       true,
                        AllowedOperators: []string{"==", "!=", "&lt;", "&gt;", "&lt;=", "&gt;=", "AND", "OR", "NOT"},
                        MaxDepth:         10,
                },
        }
}</span>

// ValidateProgram valide un programme complet
func (v *ConstraintValidator) ValidateProgram(program interface{}) error <span class="cov8" title="1">{
        // Conversion vers Program
        prog, ok := program.(*domain.Program)
        if !ok </span><span class="cov8" title="1">{
                return domain.NewValidationError("invalid program type", domain.Context{})
        }</span>

        // Validation des types d'abord
        <span class="cov8" title="1">if err := v.ValidateTypes(prog.Types); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Enregistrer les types dans le registry
        <span class="cov8" title="1">for _, typeDef := range prog.Types </span><span class="cov8" title="1">{
                if err := v.typeRegistry.RegisterType(typeDef); err != nil </span><span class="cov0" title="0">{
                        return domain.NewValidationError(
                                fmt.Sprintf("failed to register type %s: %v", typeDef.Name, err),
                                domain.Context{Type: typeDef.Name},
                        )
                }</span>
        }

        // Validation des expressions
        <span class="cov8" title="1">for i, expr := range prog.Expressions </span><span class="cov8" title="1">{
                if err := v.ValidateExpression(expr, prog.Types); err != nil </span><span class="cov8" title="1">{
                        ctx := domain.Context{
                                Field: fmt.Sprintf("expression[%d]", i),
                        }
                        return domain.NewValidationError(
                                fmt.Sprintf("invalid expression %d: %v", i, err),
                                ctx,
                        )
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateTypes valide les d√©finitions de types
func (v *ConstraintValidator) ValidateTypes(types []domain.TypeDefinition) error <span class="cov8" title="1">{
        typeNames := make(map[string]bool)

        for i, typeDef := range types </span><span class="cov8" title="1">{
                // V√©rifier les noms dupliqu√©s
                if typeNames[typeDef.Name] </span><span class="cov8" title="1">{
                        return domain.NewValidationError(
                                fmt.Sprintf("duplicate type name: %s", typeDef.Name),
                                domain.Context{
                                        Type:  typeDef.Name,
                                        Field: fmt.Sprintf("types[%d]", i),
                                },
                        )
                }</span>
                <span class="cov8" title="1">typeNames[typeDef.Name] = true

                // V√©rifier que le type a un nom valide
                if typeDef.Name == "" </span><span class="cov8" title="1">{
                        return domain.NewValidationError(
                                "type name cannot be empty",
                                domain.Context{Field: fmt.Sprintf("types[%d].name", i)},
                        )
                }</span>

                // V√©rifier que le type a des champs
                <span class="cov8" title="1">if len(typeDef.Fields) == 0 </span><span class="cov8" title="1">{
                        return domain.NewValidationError(
                                fmt.Sprintf("type %s must have at least one field", typeDef.Name),
                                domain.Context{
                                        Type:  typeDef.Name,
                                        Field: fmt.Sprintf("types[%d].fields", i),
                                },
                        )
                }</span>

                // Valider chaque champ
                <span class="cov8" title="1">fieldNames := make(map[string]bool)
                for j, field := range typeDef.Fields </span><span class="cov8" title="1">{
                        if fieldNames[field.Name] </span><span class="cov8" title="1">{
                                return domain.NewValidationError(
                                        fmt.Sprintf("duplicate field name '%s' in type '%s'", field.Name, typeDef.Name),
                                        domain.Context{
                                                Type:  typeDef.Name,
                                                Field: field.Name,
                                        },
                                )
                        }</span>
                        <span class="cov8" title="1">fieldNames[field.Name] = true

                        if field.Name == "" </span><span class="cov8" title="1">{
                                return domain.NewValidationError(
                                        fmt.Sprintf("field name cannot be empty in type %s", typeDef.Name),
                                        domain.Context{
                                                Type:  typeDef.Name,
                                                Field: fmt.Sprintf("types[%d].fields[%d].name", i, j),
                                        },
                                )
                        }</span>

                        <span class="cov8" title="1">if !domain.IsValidType(field.Type) </span><span class="cov8" title="1">{
                                return domain.NewValidationError(
                                        fmt.Sprintf("invalid field type '%s' for field '%s' in type '%s'",
                                                field.Type, field.Name, typeDef.Name),
                                        domain.Context{
                                                Type:     typeDef.Name,
                                                Field:    field.Name,
                                                Expected: "string, number, bool, or integer",
                                                Actual:   field.Type,
                                        },
                                )
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateExpression valide une expression/r√®gle
func (v *ConstraintValidator) ValidateExpression(expr domain.Expression, types []domain.TypeDefinition) error <span class="cov8" title="1">{
        // Valider le set de variables
        if len(expr.Set.Variables) == 0 </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        "expression must have at least one variable",
                        domain.Context{},
                )
        }</span>

        // V√©rifier que tous les types des variables existent
        <span class="cov8" title="1">for i, variable := range expr.Set.Variables </span><span class="cov8" title="1">{
                found := false
                for _, typeDef := range types </span><span class="cov8" title="1">{
                        if typeDef.Name == variable.DataType </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return domain.NewUnknownTypeError(
                                variable.DataType,
                                domain.Context{
                                        Variable: variable.Name,
                                        Field:    fmt.Sprintf("set.variables[%d].dataType", i),
                                },
                        )
                }</span>
        }

        // Valider les contraintes si elles existent
        <span class="cov8" title="1">if expr.Constraints != nil </span><span class="cov0" title="0">{
                if err := v.ValidateConstraint(expr.Constraints, expr.Set.Variables, types); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Valider l'action (maintenant obligatoire)
        <span class="cov8" title="1">if expr.Action != nil </span><span class="cov8" title="1">{
                validator := NewActionValidator()
                if err := validator.ValidateAction(expr.Action); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                // Avec la nouvelle grammaire, cette condition ne devrait plus arriver
                return fmt.Errorf("action manquante: chaque r√®gle doit avoir une action d√©finie")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateConstraint valide une contrainte
func (v *ConstraintValidator) ValidateConstraint(constraint interface{}, variables []domain.TypedVariable, types []domain.TypeDefinition) error <span class="cov8" title="1">{
        // Cette m√©thode d√©l√®gue au type checker pour les d√©tails de validation des types
        return v.typeChecker.ValidateTypeCompatibility("", "", "")
}</span>

// SetConfig configure le validateur
func (v *ConstraintValidator) SetConfig(config domain.ValidatorConfig) <span class="cov8" title="1">{
        v.config = config
}</span>

// GetConfig retourne la configuration actuelle
func (v *ConstraintValidator) GetConfig() domain.ValidatorConfig <span class="cov8" title="1">{
        return v.config
}</span>

// ActionValidator valide les actions
type ActionValidator struct{}

// NewActionValidator cr√©e un nouveau validateur d'actions
func NewActionValidator() *ActionValidator <span class="cov8" title="1">{
        return &amp;ActionValidator{}
}</span>

// ValidateAction valide une action
func (av *ActionValidator) ValidateAction(action *domain.Action) error <span class="cov8" title="1">{
        if action == nil </span><span class="cov8" title="1">{
                return domain.NewActionError(
                        "action cannot be nil",
                        domain.Context{},
                )
        }</span>

        <span class="cov8" title="1">return av.ValidateJobCall(action.Job)</span>
}

// ValidateJobCall valide un appel de fonction/job
func (av *ActionValidator) ValidateJobCall(jobCall domain.JobCall) error <span class="cov8" title="1">{
        if strings.TrimSpace(jobCall.Name) == "" </span><span class="cov8" title="1">{
                return domain.NewActionError(
                        "job name cannot be empty",
                        domain.Context{Field: "job.name"},
                )
        }</span>

        // Valider les arguments (optionnel)
        <span class="cov8" title="1">for i, arg := range jobCall.Args </span><span class="cov8" title="1">{
                // Convertir l'argument en string pour la validation
                var argStr string
                if s, ok := arg.(string); ok </span><span class="cov8" title="1">{
                        argStr = s
                }</span> else<span class="cov8" title="1"> {
                        // Pour les objets complexes, on les consid√®re comme valides s'ils ne sont pas nil
                        if arg == nil </span><span class="cov8" title="1">{
                                return domain.NewActionError(
                                        fmt.Sprintf("job argument %d cannot be nil", i),
                                        domain.Context{
                                                Field: fmt.Sprintf("job.args[%d]", i),
                                                Value: arg,
                                        },
                                )
                        }</span>
                        <span class="cov8" title="1">continue</span> // Les objets complexes sont valides s'ils ne sont pas nil
                }

                <span class="cov8" title="1">if strings.TrimSpace(argStr) == "" </span><span class="cov8" title="1">{
                        return domain.NewActionError(
                                fmt.Sprintf("job argument %d cannot be empty", i),
                                domain.Context{
                                        Field: fmt.Sprintf("job.args[%d]", i),
                                        Value: arg,
                                },
                        )
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package constraint

import (
        "fmt"
)

// ProgramState maintains the cumulative state of parsed types, rules, and facts
// across multiple file parsing operations
type ProgramState struct {
        Types       map[string]*TypeDefinition `json:"types"`
        Rules       []*Expression              `json:"rules"`
        Facts       []*Fact                    `json:"facts"`
        FilesParsed []string                   `json:"files_parsed"`
        Errors      []ValidationError          `json:"errors"`
}

// NewProgramState creates a new empty program state
func NewProgramState() *ProgramState <span class="cov8" title="1">{
        return &amp;ProgramState{
                Types:       make(map[string]*TypeDefinition),
                Rules:       make([]*Expression, 0),
                Facts:       make([]*Fact, 0),
                FilesParsed: make([]string, 0),
                Errors:      make([]ValidationError, 0),
        }
}</span>

// ParseAndMerge parses a file and merges the results into the program state
// It validates that new rules and facts are compatible with existing type definitions
func (ps *ProgramState) ParseAndMerge(filename string) error <span class="cov8" title="1">{
        // Parse the file
        result, err := ParseConstraintFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing file %s: %w", filename, err)
        }</span>

        // Convert to program structure
        <span class="cov8" title="1">program, err := ConvertResultToProgram(result)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error converting result for %s: %w", filename, err)
        }</span>

        // Merge types (new types or validate existing ones)
        <span class="cov8" title="1">err = ps.mergeTypes(program.Types, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging types from %s: %w", filename, err)
        }</span>

        // Merge and validate rules
        <span class="cov8" title="1">err = ps.mergeRules(program.Expressions, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging rules from %s: %w", filename, err)
        }</span>

        // Merge and validate facts
        <span class="cov8" title="1">err = ps.mergeFacts(program.Facts, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging facts from %s: %w", filename, err)
        }</span>

        // Record the parsed file
        <span class="cov8" title="1">ps.FilesParsed = append(ps.FilesParsed, filename)

        return nil</span>
}

// ParseAndMergeContent parses content from a string and merges the results into the program state
// It validates that new rules and facts are compatible with existing type definitions
func (ps *ProgramState) ParseAndMergeContent(content, filename string) error <span class="cov8" title="1">{
        if ps == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ProgramState is nil")
        }</span>
        <span class="cov8" title="1">if filename == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("filename cannot be empty")
        }</span>
        <span class="cov8" title="1">if content == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("content cannot be empty")
        }</span>

        // Parse the content
        <span class="cov8" title="1">result, err := ParseConstraint(filename, []byte(content))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing content %s: %w", filename, err)
        }</span>

        // Convert to program structure
        <span class="cov8" title="1">program, err := ConvertResultToProgram(result)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error converting result for %s: %w", filename, err)
        }</span>

        // Merge types (new types or validate existing ones)
        <span class="cov8" title="1">err = ps.mergeTypes(program.Types, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging types from %s: %w", filename, err)
        }</span>

        // Merge and validate rules
        <span class="cov8" title="1">err = ps.mergeRules(program.Expressions, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging rules from %s: %w", filename, err)
        }</span>

        // Merge and validate facts
        <span class="cov8" title="1">err = ps.mergeFacts(program.Facts, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging facts from %s: %w", filename, err)
        }</span>

        // Record the parsed file
        <span class="cov8" title="1">ps.FilesParsed = append(ps.FilesParsed, filename)

        return nil</span>
}

// mergeTypes merges new type definitions into the program state
func (ps *ProgramState) mergeTypes(newTypes []TypeDefinition, filename string) error <span class="cov8" title="1">{
        if ps == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ProgramState is nil")
        }</span>
        <span class="cov8" title="1">if ps.Types == nil </span><span class="cov0" title="0">{
                ps.Types = make(map[string]*TypeDefinition)
        }</span>

        <span class="cov8" title="1">for _, typeDef := range newTypes </span><span class="cov8" title="1">{
                // Create a copy with filename information
                newType := &amp;TypeDefinition{
                        Type:   typeDef.Type,
                        Name:   typeDef.Name,
                        Fields: typeDef.Fields,
                }

                // Check if type already exists
                if existingType, exists := ps.Types[typeDef.Name]; exists </span><span class="cov8" title="1">{
                        // Validate compatibility
                        if !ps.areTypesCompatible(existingType, newType) </span><span class="cov8" title="1">{
                                return fmt.Errorf("type %s redefined incompatibly in %s",
                                        typeDef.Name, filename)
                        }</span>
                        // Use the more detailed definition
                        <span class="cov8" title="1">if len(newType.Fields) &gt; len(existingType.Fields) </span><span class="cov8" title="1">{
                                ps.Types[typeDef.Name] = newType
                        }</span>
                } else<span class="cov8" title="1"> {
                        ps.Types[typeDef.Name] = newType
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// mergeRules merges new rules and validates them against existing types
func (ps *ProgramState) mergeRules(newRules []Expression, filename string) error <span class="cov8" title="1">{
        if ps == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ProgramState is nil")
        }</span>

        <span class="cov8" title="1">for _, rule := range newRules </span><span class="cov8" title="1">{
                // Create a copy of the rule
                newRule := &amp;Expression{
                        Type:        rule.Type,
                        Set:         rule.Set,
                        Constraints: rule.Constraints,
                        Action:      rule.Action,
                }

                // Validate rule against existing types
                err := ps.validateRule(newRule, filename)
                if err != nil </span><span class="cov8" title="1">{
                        // Non-blocking error: record and continue
                        ps.Errors = append(ps.Errors, ValidationError{
                                File:    filename,
                                Type:    "rule",
                                Message: err.Error(),
                                Line:    0,
                        })
                        fmt.Printf("‚ö†Ô∏è  Skipping invalid rule in %s: %v\n", filename, err)
                        continue</span>
                }

                <span class="cov8" title="1">ps.Rules = append(ps.Rules, newRule)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// mergeFacts merges new facts and validates them against existing types
func (ps *ProgramState) mergeFacts(newFacts []Fact, filename string) error <span class="cov8" title="1">{
        if ps == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ProgramState is nil")
        }</span>

        <span class="cov8" title="1">for _, fact := range newFacts </span><span class="cov8" title="1">{
                // Create a copy of the fact
                newFact := &amp;Fact{
                        Type:     fact.Type,
                        TypeName: fact.TypeName,
                        Fields:   fact.Fields,
                }

                // Validate fact against existing types
                err := ps.validateFact(newFact, filename)
                if err != nil </span><span class="cov8" title="1">{
                        // Non-blocking error: record and continue
                        ps.Errors = append(ps.Errors, ValidationError{
                                File:    filename,
                                Type:    "fact",
                                Message: err.Error(),
                                Line:    0,
                        })
                        fmt.Printf("‚ö†Ô∏è  Skipping invalid fact in %s: %v\n", filename, err)
                        continue</span>
                }

                <span class="cov8" title="1">ps.Facts = append(ps.Facts, newFact)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateRule validates a rule against existing type definitions
func (ps *ProgramState) validateRule(rule *Expression, filename string) error <span class="cov8" title="1">{
        // Extract variables from the set
        variables := make(map[string]string)
        for _, variable := range rule.Set.Variables </span><span class="cov8" title="1">{
                variables[variable.Name] = variable.DataType
        }</span>

        // Validate each variable type exists
        <span class="cov8" title="1">for varName, varType := range variables </span><span class="cov8" title="1">{
                if _, exists := ps.Types[varType]; !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("variable %s references undefined type %s in %s", varName, varType, filename)
                }</span>
        }

        // Validate field accesses in constraints and action
        <span class="cov8" title="1">err := ps.validateFieldAccesses(rule.Constraints, variables)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("constraint validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if rule.Action != nil </span><span class="cov8" title="1">{
                err = ps.validateFieldAccesses(rule.Action, variables)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("action validation failed: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateFact validates a fact against existing type definitions
func (ps *ProgramState) validateFact(fact *Fact, filename string) error <span class="cov8" title="1">{
        // Check if type exists
        typeDef, exists := ps.Types[fact.TypeName]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("fact references undefined type %s in %s", fact.TypeName, filename)
        }</span>

        // Create a map of field definitions for easy lookup
        <span class="cov8" title="1">fieldDefs := make(map[string]Field)
        for _, field := range typeDef.Fields </span><span class="cov8" title="1">{
                fieldDefs[field.Name] = field
        }</span>

        // Validate each field in the fact
        <span class="cov8" title="1">for _, factField := range fact.Fields </span><span class="cov8" title="1">{
                // Find field definition
                fieldDef, found := fieldDefs[factField.Name]
                if !found </span><span class="cov8" title="1">{
                        return fmt.Errorf("fact contains undefined field %s for type %s in %s",
                                factField.Name, fact.TypeName, filename)
                }</span>

                // Validate field value type
                <span class="cov8" title="1">err := ps.validateFactValue(factField.Value, fieldDef.Type)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("field %s validation failed in %s: %w", factField.Name, filename, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ToProgram converts the program state back to a Program structure
func (ps *ProgramState) ToProgram() *Program <span class="cov8" title="1">{
        // Convert types
        var types []TypeDefinition
        for _, typeDef := range ps.Types </span><span class="cov8" title="1">{
                types = append(types, *typeDef)
        }</span>

        // Convert rules
        <span class="cov8" title="1">var expressions []Expression
        for _, rule := range ps.Rules </span><span class="cov8" title="1">{
                expressions = append(expressions, *rule)
        }</span>

        // Convert facts
        <span class="cov8" title="1">var facts []Fact
        for _, fact := range ps.Facts </span><span class="cov8" title="1">{
                facts = append(facts, *fact)
        }</span>

        <span class="cov8" title="1">return &amp;Program{
                Types:       types,
                Expressions: expressions,
                Facts:       facts,
        }</span>
}

// Helper functions

func (ps *ProgramState) areTypesCompatible(type1, type2 *TypeDefinition) bool <span class="cov8" title="1">{
        if type1.Name != type2.Name </span><span class="cov8" title="1">{
                return false
        }</span>

        // Create field maps for comparison
        <span class="cov8" title="1">fields1 := make(map[string]string)
        fields2 := make(map[string]string)

        for _, field := range type1.Fields </span><span class="cov8" title="1">{
                fields1[field.Name] = field.Type
        }</span>
        <span class="cov8" title="1">for _, field := range type2.Fields </span><span class="cov8" title="1">{
                fields2[field.Name] = field.Type
        }</span>

        // Check that all common fields have the same type
        <span class="cov8" title="1">for name, type1 := range fields1 </span><span class="cov8" title="1">{
                if type2, exists := fields2[name]; exists </span><span class="cov8" title="1">{
                        if type1 != type2 </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}

func (ps *ProgramState) validateFieldAccesses(data interface{}, variables map[string]string) error <span class="cov8" title="1">{
        // Recursively scan for fieldAccess patterns
        return ps.scanForFieldAccess(data, variables)
}</span>

func (ps *ProgramState) scanForFieldAccess(data interface{}, variables map[string]string) error <span class="cov8" title="1">{
        switch v := data.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                // Check if this is a fieldAccess
                if objType, hasType := v["type"].(string); hasType &amp;&amp; objType == "fieldAccess" </span><span class="cov8" title="1">{
                        object := getStringValue(v, "object")
                        field := getStringValue(v, "field")

                        // Validate the field access
                        if varType, exists := variables[object]; exists </span><span class="cov8" title="1">{
                                if typeDef, typeExists := ps.Types[varType]; typeExists </span><span class="cov8" title="1">{
                                        fieldFound := false
                                        for _, fieldDef := range typeDef.Fields </span><span class="cov8" title="1">{
                                                if fieldDef.Name == field </span><span class="cov8" title="1">{
                                                        fieldFound = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if !fieldFound </span><span class="cov8" title="1">{
                                                return fmt.Errorf("field %s.%s not found in type %s", object, field, varType)
                                        }</span>
                                }
                        }
                }

                // Recursively check all map values
                <span class="cov8" title="1">for _, value := range v </span><span class="cov8" title="1">{
                        err := ps.scanForFieldAccess(value, variables)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        case []interface{}:<span class="cov8" title="1">
                // Recursively check all slice elements
                for _, item := range v </span><span class="cov8" title="1">{
                        err := ps.scanForFieldAccess(item, variables)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (ps *ProgramState) validateFactValue(value FactValue, expectedType string) error <span class="cov8" title="1">{
        // Basic type validation
        switch expectedType </span>{
        case "string":<span class="cov8" title="1">
                if value.Type != "string" &amp;&amp; value.Type != "identifier" </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected string, got %s", value.Type)
                }</span>
        case "number":<span class="cov8" title="1">
                if value.Type != "number" </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected number, got %s", value.Type)
                }</span>
        case "bool":<span class="cov8" title="1">
                if value.Type != "boolean" </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected boolean, got %s", value.Type)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getStringValue(m map[string]interface{}, key string) string <span class="cov8" title="1">{
        if value, exists := m[key]; exists </span><span class="cov8" title="1">{
                if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package constraint

import "fmt"

// HasErrors returns true if there are any validation errors
func (ps *ProgramState) HasErrors() bool <span class="cov8" title="1">{
        return len(ps.Errors) &gt; 0
}</span>

// GetErrorCount returns the number of validation errors
func (ps *ProgramState) GetErrorCount() int <span class="cov8" title="1">{
        return len(ps.Errors)
}</span>

// GetErrors returns a copy of all validation errors
func (ps *ProgramState) GetErrors() []ValidationError <span class="cov8" title="1">{
        // Return a copy to prevent external modifications
        errors := make([]ValidationError, len(ps.Errors))
        copy(errors, ps.Errors)
        return errors
}</span>

// PrintErrors prints all validation errors to console
func (ps *ProgramState) PrintErrors() <span class="cov8" title="1">{
        for _, err := range ps.Errors </span><span class="cov8" title="1">{
                fmt.Printf("‚ö†Ô∏è  Error in %s: %s (line %d): %s\n",
                        err.File, err.Type, err.Line, err.Message)
        }</span>
}

// AddError adds a validation error to the program state
func (ps *ProgramState) AddError(err ValidationError) <span class="cov8" title="1">{
        ps.Errors = append(ps.Errors, err)
}</span>

// ClearErrors removes all validation errors
func (ps *ProgramState) ClearErrors() <span class="cov8" title="1">{
        ps.Errors = []ValidationError{}
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package rete

import (
        "fmt"
)

// AlphaConditionBuilder aide √† construire des conditions Alpha
type AlphaConditionBuilder struct{}

// NewAlphaConditionBuilder cr√©e un nouveau constructeur de conditions
func NewAlphaConditionBuilder() *AlphaConditionBuilder <span class="cov0" title="0">{
        return &amp;AlphaConditionBuilder{}
}</span>

// FieldEquals cr√©e une condition d'√©galit√© sur un champ
func (acb *AlphaConditionBuilder) FieldEquals(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "==",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldNotEquals cr√©e une condition d'in√©galit√© sur un champ
func (acb *AlphaConditionBuilder) FieldNotEquals(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "!=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldLessThan cr√©e une condition de comparaison inf√©rieure sur un champ
func (acb *AlphaConditionBuilder) FieldLessThan(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&lt;",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldLessOrEqual cr√©e une condition de comparaison inf√©rieure ou √©gale sur un champ
func (acb *AlphaConditionBuilder) FieldLessOrEqual(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&lt;=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldGreaterThan cr√©e une condition de comparaison sup√©rieure sur un champ
func (acb *AlphaConditionBuilder) FieldGreaterThan(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&gt;",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldGreaterOrEqual cr√©e une condition de comparaison sup√©rieure ou √©gale sur un champ
func (acb *AlphaConditionBuilder) FieldGreaterOrEqual(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&gt;=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// And cr√©e une condition logique AND
func (acb *AlphaConditionBuilder) And(left, right interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "logicalExpression",
                "left": left,
                "operations": []interface{}{
                        map[string]interface{}{
                                "op":    "AND",
                                "right": right,
                        },
                },
        }
}</span>

// Or cr√©e une condition logique OR
func (acb *AlphaConditionBuilder) Or(left, right interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "logicalExpression",
                "left": left,
                "operations": []interface{}{
                        map[string]interface{}{
                                "op":    "OR",
                                "right": right,
                        },
                },
        }
}</span>

// AndMultiple cr√©e une condition logique AND avec plusieurs conditions
func (acb *AlphaConditionBuilder) AndMultiple(conditions ...interface{}) interface{} <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return acb.True()
        }</span>
        <span class="cov0" title="0">if len(conditions) == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>

        <span class="cov0" title="0">operations := make([]interface{}, 0, len(conditions)-1)
        for _, condition := range conditions[1:] </span><span class="cov0" title="0">{
                operations = append(operations, map[string]interface{}{
                        "op":    "AND",
                        "right": condition,
                })
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type":       "logicalExpression",
                "left":       conditions[0],
                "operations": operations,
        }</span>
}

// OrMultiple cr√©e une condition logique OR avec plusieurs conditions
func (acb *AlphaConditionBuilder) OrMultiple(conditions ...interface{}) interface{} <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return acb.False()
        }</span>
        <span class="cov0" title="0">if len(conditions) == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>

        <span class="cov0" title="0">operations := make([]interface{}, 0, len(conditions)-1)
        for _, condition := range conditions[1:] </span><span class="cov0" title="0">{
                operations = append(operations, map[string]interface{}{
                        "op":    "OR",
                        "right": condition,
                })
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type":       "logicalExpression",
                "left":       conditions[0],
                "operations": operations,
        }</span>
}

// True cr√©e une condition toujours vraie
func (acb *AlphaConditionBuilder) True() interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "booleanLiteral",
                "value": true,
        }
}</span>

// False cr√©e une condition toujours fausse
func (acb *AlphaConditionBuilder) False() interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "booleanLiteral",
                "value": false,
        }
}</span>

// FieldRange cr√©e une condition de plage pour un champ (min &lt;= field &lt;= max)
func (acb *AlphaConditionBuilder) FieldRange(variable, field string, min, max interface{}) interface{} <span class="cov0" title="0">{
        minCondition := acb.FieldGreaterOrEqual(variable, field, min)
        maxCondition := acb.FieldLessOrEqual(variable, field, max)
        return acb.And(minCondition, maxCondition)
}</span>

// FieldIn cr√©e une condition de pr√©sence dans une liste de valeurs
func (acb *AlphaConditionBuilder) FieldIn(variable, field string, values ...interface{}) interface{} <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return acb.False()
        }</span>

        <span class="cov0" title="0">conditions := make([]interface{}, len(values))
        for i, value := range values </span><span class="cov0" title="0">{
                conditions[i] = acb.FieldEquals(variable, field, value)
        }</span>

        <span class="cov0" title="0">return acb.OrMultiple(conditions...)</span>
}

// FieldNotIn cr√©e une condition d'absence dans une liste de valeurs
func (acb *AlphaConditionBuilder) FieldNotIn(variable, field string, values ...interface{}) interface{} <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return acb.True()
        }</span>

        <span class="cov0" title="0">conditions := make([]interface{}, len(values))
        for i, value := range values </span><span class="cov0" title="0">{
                conditions[i] = acb.FieldNotEquals(variable, field, value)
        }</span>

        <span class="cov0" title="0">return acb.AndMultiple(conditions...)</span>
}

// createLiteral cr√©e un litt√©ral typ√©
func (acb *AlphaConditionBuilder) createLiteral(value interface{}) map[string]interface{} <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "stringLiteral",
                        "value": v,
                }</span>
        case int:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case int32:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case int64:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case float32:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case float64:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": v,
                }</span>
        case bool:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "booleanLiteral",
                        "value": v,
                }</span>
        default:<span class="cov0" title="0">
                // Fallback vers string
                return map[string]interface{}{
                        "type":  "stringLiteral",
                        "value": fmt.Sprintf("%v", v),
                }</span>
        }
}

// CreateConstraintFromAST cr√©e une condition √† partir d'un AST de contrainte
func (acb *AlphaConditionBuilder) CreateConstraintFromAST(constraint interface{}) interface{} <span class="cov0" title="0">{
        // Si c'est d√©j√† une map, la retourner telle quelle
        if constraintMap, ok := constraint.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                return constraintMap
        }</span>

        // Sinon, retourner tel quel (sera trait√© par l'√©valuateur)
        <span class="cov0" title="0">return constraint</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// AggregationInfo contient les informations extraites d'une agr√©gation
type AggregationInfo struct {
        Function      string      // AVG, SUM, COUNT, MIN, MAX
        MainVariable  string      // Variable principale (ex: "e" pour Employee)
        MainType      string      // Type principal (ex: "Employee")
        AggVariable   string      // Variable √† agr√©ger (ex: "p" pour Performance)
        AggType       string      // Type √† agr√©ger (ex: "Performance")
        Field         string      // Champ √† agr√©ger (ex: "score")
        Operator      string      // Op√©rateur de comparaison (&gt;=, &gt;, etc.)
        Threshold     float64     // Valeur de seuil
        JoinField     string      // Champ de jointure dans faits agr√©g√©s (ex: "employee_id")
        MainField     string      // Champ de jointure dans fait principal (ex: "id")
        JoinCondition interface{} // Condition de jointure compl√®te
}

// ConstraintPipeline impl√©mente le pipeline complet :
// fichier .constraint ‚Üí parseur PEG ‚Üí conversion AST ‚Üí r√©seau RETE
type ConstraintPipeline struct{}

// NewConstraintPipeline cr√©e une nouvelle instance du pipeline
func NewConstraintPipeline() *ConstraintPipeline <span class="cov8" title="1">{
        return &amp;ConstraintPipeline{}
}</span>

// BuildNetworkFromConstraintFile construit un r√©seau RETE complet √† partir d'un fichier .constraint
// Cette fonction impl√©mente le pipeline unique utilis√© par TOUS les tests
func (cp *ConstraintPipeline) BuildNetworkFromConstraintFile(constraintFile string, storage Storage) (*ReteNetwork, error) <span class="cov8" title="1">{
        fmt.Printf("========================================\n")
        fmt.Printf("üìÅ Fichier: %s\n", constraintFile)

        // √âTAPE 1: Parsing avec le vrai parseur PEG
        parsedAST, err := constraint.ParseConstraintFile(constraintFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur parsing fichier %s: %w", constraintFile, err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Parsing r√©ussi\n")

        // √âTAPE 1.5: Validation s√©mantique du programme
        err = constraint.ValidateConstraintProgram(parsedAST)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur validation s√©mantique: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Validation s√©mantique r√©ussie\n")

        // Valider que c'est un map[string]interface{}
        resultMap, ok := parsedAST.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format AST non reconnu: %T", parsedAST)
        }</span>

        // √âTAPE 2: Extraction et validation des composants
        <span class="cov8" title="1">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // √âTAPE 3: Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // √âTAPE 4: Validation finale
        err = cp.validateNetwork(network)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur validation r√©seau: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Validation r√©ussie\n")

        fmt.Printf("üéØ PIPELINE TERMIN√â AVEC SUCC√àS\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// BuildNetworkFromMultipleFiles construit un r√©seau RETE en parsant plusieurs fichiers de mani√®re it√©rative
// Cette fonction permet de parser des types, r√®gles et faits r√©partis dans diff√©rents fichiers
func (cp *ConstraintPipeline) BuildNetworkFromMultipleFiles(filenames []string, storage Storage) (*ReteNetwork, error) <span class="cov0" title="0">{
        fmt.Printf("========================================\n")
        fmt.Printf("üìÅ Fichiers: %v\n", filenames)

        // Cr√©er un parser it√©ratif
        parser := constraint.NewIterativeParser()

        // Parser tous les fichiers de mani√®re it√©rative
        for i, filename := range filenames </span><span class="cov0" title="0">{
                fmt.Printf("  üìÑ Parsing fichier %d/%d: %s\n", i+1, len(filenames), filename)
                err := parser.ParseFile(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("‚ùå Erreur parsing fichier %s: %w", filename, err)
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("‚úÖ Parsing it√©ratif r√©ussi\n")

        // Obtenir le programme combin√©
        program := parser.GetProgram()

        // Convertir au format RETE
        reteProgram := constraint.ConvertToReteProgram(program)
        resultMap, ok := reteProgram.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format programme RETE invalide: %T", reteProgram)
        }</span>

        // Extraire les composants
        <span class="cov0" title="0">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // Injection des faits dans le r√©seau
        if len(program.Facts) &gt; 0 </span><span class="cov0" title="0">{
                factsForRete := constraint.ConvertFactsToReteFormat(*program)

                err := network.SubmitFactsFromGrammar(factsForRete)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Erreur injection faits: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚úÖ Injection termin√©e: %d faits inject√©s\n", len(factsForRete))
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üéØ PIPELINE MULTIFILES TERMIN√â\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// BuildNetworkFromIterativeParser construit un r√©seau RETE √† partir d'un parser it√©ratif existant
// Cette m√©thode est utile quand le parsing a d√©j√† √©t√© fait et qu'on veut juste construire le r√©seau
func (cp *ConstraintPipeline) BuildNetworkFromIterativeParser(parser *constraint.IterativeParser, storage Storage) (*ReteNetwork, error) <span class="cov0" title="0">{
        fmt.Printf("========================================\n")

        // Obtenir le programme combin√©
        program := parser.GetProgram()

        // Convertir au format RETE
        reteProgram := constraint.ConvertToReteProgram(program)
        resultMap, ok := reteProgram.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format programme RETE invalide: %T", reteProgram)
        }</span>

        // Extraire les composants
        <span class="cov0" title="0">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // Injection des faits dans le r√©seau
        if len(program.Facts) &gt; 0 </span><span class="cov0" title="0">{
                factsForRete := constraint.ConvertFactsToReteFormat(*program)

                err := network.SubmitFactsFromGrammar(factsForRete)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Erreur injection faits: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚úÖ Injection termin√©e: %d faits inject√©s\n", len(factsForRete))
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üéØ PIPELINE DEPUIS PARSER TERMIN√â\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// BuildNetworkFromConstraintFileWithFacts construit un r√©seau et soumet imm√©diatement des faits
func (cp *ConstraintPipeline) BuildNetworkFromConstraintFileWithFacts(constraintFile, factsFile string, storage Storage) (*ReteNetwork, []*Fact, error) <span class="cov0" title="0">{
        fmt.Printf("========================================\n")
        fmt.Printf("üìÅ Fichier contraintes: %s\n", constraintFile)
        fmt.Printf("üìÅ Fichier faits: %s\n", factsFile)

        // √âTAPE 1: Construire le r√©seau depuis le fichier de contraintes
        network, err := cp.BuildNetworkFromConstraintFile(constraintFile, storage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>

        // √âTAPE 2: Parser et soumettre les faits
        <span class="cov0" title="0">fmt.Printf("üìä Parsing des faits depuis %s\n", factsFile)

        parsedFacts, err := constraint.ParseFactsFile(factsFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("‚ùå Erreur parsing faits: %w", err)
        }</span>

        // Extraire les faits du programme pars√©
        <span class="cov0" title="0">factsList, err := constraint.ExtractFactsFromProgram(parsedFacts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("‚ùå Erreur extraction faits: %w", err)
        }</span>

        // Convertir et soumettre chaque fait
        <span class="cov0" title="0">submittedFacts := []*Fact{}
        for _, factMap := range factsList </span><span class="cov0" title="0">{
                // ExtractFactsFromProgram retourne des maps avec 'reteType' et tous les champs directement
                factID := getStringField(factMap, "id", "")
                factType := getStringField(factMap, "reteType", "") // Utiliser 'reteType' au lieu de 'type'

                if factID == "" || factType == "" </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è Fait ignor√©: id='%s', type='%s'\n", factID, factType)
                        continue</span>
                }

                // Les champs sont directement dans factMap (pas de sous-cl√© 'fields')
                <span class="cov0" title="0">fields := make(map[string]interface{})
                for key, value := range factMap </span><span class="cov0" title="0">{
                        // Exclure les m√©tadonn√©es RETE (id, reteType)
                        if key != "id" &amp;&amp; key != "reteType" </span><span class="cov0" title="0">{
                                fields[key] = value
                        }</span>
                }

                <span class="cov0" title="0">fact := &amp;Fact{
                        ID:     factID,
                        Type:   factType,
                        Fields: fields,
                }

                err := network.SubmitFact(fact)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è Erreur soumission fait %s: %v\n", factID, err)
                }</span>
                <span class="cov0" title="0">submittedFacts = append(submittedFacts, fact)</span>
        }

        <span class="cov0" title="0">fmt.Printf("‚úÖ %d faits soumis au r√©seau\n", len(submittedFacts))
        fmt.Printf("üéØ PIPELINE AVEC FAITS TERMIN√â\n")
        fmt.Printf("========================================\n\n")

        return network, submittedFacts, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package rete

import (
        "fmt"
        "strings"
)

// Node condition type constants
const (
        ConditionTypePassthrough = "passthrough"
        ConditionTypeSimple      = "simple"
        ConditionTypeExists      = "exists"
        ConditionTypeComparison  = "comparison"
)

// Node side constants for beta nodes
const (
        NodeSideLeft  = "left"
        NodeSideRight = "right"
)

// buildNetwork construit le r√©seau RETE √† partir des types et expressions pars√©s
func (cp *ConstraintPipeline) buildNetwork(storage Storage, types []interface{}, expressions []interface{}) (*ReteNetwork, error) <span class="cov8" title="1">{
        // Cr√©er le r√©seau
        network := NewReteNetwork(storage)

        // √âTAPE 1: Cr√©er les TypeNodes
        err := cp.createTypeNodes(network, types, storage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur cr√©ation TypeNodes: %w", err)
        }</span>

        // √âTAPE 2: Cr√©er les r√®gles (AlphaNodes, BetaNodes, TerminalNodes)
        <span class="cov8" title="1">err = cp.createRuleNodes(network, expressions, storage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur cr√©ation r√®gles: %w", err)
        }</span>

        <span class="cov8" title="1">return network, nil</span>
}

// createTypeNodes cr√©e les TypeNodes √† partir des d√©finitions de types
func (cp *ConstraintPipeline) createTypeNodes(network *ReteNetwork, types []interface{}, storage Storage) error <span class="cov8" title="1">{
        for _, typeInterface := range types </span><span class="cov8" title="1">{
                typeMap, ok := typeInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("format type invalide: %T", typeInterface)
                }</span>

                // Extraire le nom du type
                <span class="cov8" title="1">typeName, ok := typeMap["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("nom de type non trouv√©")
                }</span>

                // Cr√©er la d√©finition de type
                <span class="cov8" title="1">typeDef := cp.createTypeDefinition(typeName, typeMap)

                // Cr√©er le TypeNode
                typeNode := NewTypeNode(typeName, typeDef, storage)
                network.TypeNodes[typeName] = typeNode

                // CRUCIAL: Connecter le TypeNode au RootNode pour permettre la propagation des faits
                network.RootNode.AddChild(typeNode)

                fmt.Printf("   ‚úì TypeNode cr√©√©: %s\n", typeName)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createTypeDefinition cr√©e une d√©finition de type √† partir d'une map
func (cp *ConstraintPipeline) createTypeDefinition(typeName string, typeMap map[string]interface{}) TypeDefinition <span class="cov8" title="1">{
        typeDef := TypeDefinition{
                Type:   "type",
                Name:   typeName,
                Fields: []Field{},
        }

        // Extraire les champs
        fieldsData, hasFields := typeMap["fields"]
        if !hasFields </span><span class="cov0" title="0">{
                return typeDef
        }</span>

        <span class="cov8" title="1">fields, ok := fieldsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return typeDef
        }</span>

        <span class="cov8" title="1">for _, fieldInterface := range fields </span><span class="cov8" title="1">{
                fieldMap, ok := fieldInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">fieldName := getStringField(fieldMap, "name", "")
                fieldType := getStringField(fieldMap, "type", "")

                if fieldName != "" &amp;&amp; fieldType != "" </span><span class="cov8" title="1">{
                        typeDef.Fields = append(typeDef.Fields, Field{
                                Name: fieldName,
                                Type: fieldType,
                        })
                }</span>
        }

        <span class="cov8" title="1">return typeDef</span>
}

// createRuleNodes cr√©e les n≈ìuds de r√®gles (Alpha, Beta, Terminal) √† partir des expressions
func (cp *ConstraintPipeline) createRuleNodes(network *ReteNetwork, expressions []interface{}, storage Storage) error <span class="cov8" title="1">{
        for i, exprInterface := range expressions </span><span class="cov8" title="1">{
                exprMap, ok := exprInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("format expression invalide: %T", exprInterface)
                }</span>

                // G√©n√©rer un ID de r√®gle
                <span class="cov8" title="1">ruleID := fmt.Sprintf("rule_%d", i)

                // Cr√©er la r√®gle
                err := cp.createSingleRule(network, ruleID, exprMap, storage)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur cr√©ation r√®gle %s: %w", ruleID, err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("   ‚úì R√®gle cr√©√©e: %s\n", ruleID)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createSingleRule cr√©e une r√®gle unique (refactoris√©e en petites fonctions)
func (cp *ConstraintPipeline) createSingleRule(network *ReteNetwork, ruleID string, exprMap map[string]interface{}, storage Storage) error <span class="cov8" title="1">{
        // √âtape 1: Extraire l'action
        action, err := cp.extractActionFromExpression(exprMap, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // √âtape 2: Extraire et analyser les contraintes
        <span class="cov8" title="1">constraintsData, hasConstraints := exprMap["constraints"]
        var condition map[string]interface{}
        var hasAggregation bool

        if hasConstraints </span><span class="cov8" title="1">{
                // D√©tecter si c'est une agr√©gation
                hasAggregation = cp.detectAggregation(constraintsData)

                // Construire la condition appropri√©e
                condition, err = cp.buildConditionFromConstraints(constraintsData)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur construction condition pour r√®gle %s: %w", ruleID, err)
                }</span>
        } else<span class="cov0" title="0"> {
                condition = map[string]interface{}{
                        "type": ConditionTypeSimple,
                }
        }</span>

        // √âtape 3: Extraire les variables
        <span class="cov8" title="1">variables, variableNames, variableTypes := cp.extractVariablesFromExpression(exprMap)

        // √âtape 4: D√©terminer le type de r√®gle et la cr√©er
        ruleType := cp.determineRuleType(exprMap, len(variables), hasAggregation)
        cp.logRuleCreation(ruleType, ruleID, variableNames)

        switch ruleType </span>{
        case "exists":<span class="cov0" title="0">
                return cp.createExistsRule(network, ruleID, exprMap, condition, action, storage)</span>

        case "accumulator":<span class="cov8" title="1">
                aggInfo, err := cp.extractAggregationInfo(constraintsData)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ö†Ô∏è  Impossible d'extraire info agr√©gation: %v, utilisation JoinNode standard\n", err)
                        return cp.createJoinRule(network, ruleID, variables, variableNames, variableTypes, condition, action, storage)
                }</span>
                <span class="cov8" title="1">return cp.createAccumulatorRule(network, ruleID, variables, variableNames, variableTypes, aggInfo, action, storage)</span>

        case "join":<span class="cov8" title="1">
                return cp.createJoinRule(network, ruleID, variables, variableNames, variableTypes, condition, action, storage)</span>

        case "alpha":<span class="cov0" title="0">
                return cp.createAlphaRule(network, ruleID, variables, variableNames, variableTypes, condition, action, storage)</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("type de r√®gle inconnu: %s", ruleType)</span>
        }
}

// createAlphaRule cr√©e une r√®gle alpha simple avec une seule variable
func (cp *ConstraintPipeline) createAlphaRule(
        network *ReteNetwork,
        ruleID string,
        variables []map[string]interface{},
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Extraire les informations de la variable
        variableName, variableType := cp.getVariableInfo(variables, variableTypes)

        // Cr√©er l'AlphaNode avec son terminal
        return cp.createAlphaNodeWithTerminal(
                network,
                ruleID,
                condition,
                variableName,
                variableType,
                action,
                storage,
        )
}</span>

// createJoinRule cr√©e une r√®gle de jointure avec JoinNode
func (cp *ConstraintPipeline) createJoinRule(
        network *ReteNetwork,
        ruleID string,
        variables []map[string]interface{},
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        action *Action,
        storage Storage,
) error <span class="cov8" title="1">{
        // Cr√©er le n≈ìud terminal pour cette r√®gle
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // D√©l√©guer √† la fonction appropri√©e selon le nombre de variables
        if len(variableNames) &gt; 2 </span><span class="cov8" title="1">{
                return cp.createCascadeJoinRule(network, ruleID, variableNames, variableTypes, condition, terminalNode, storage)
        }</span>

        <span class="cov8" title="1">return cp.createBinaryJoinRule(network, ruleID, variableNames, variableTypes, condition, terminalNode, storage)</span>
}

// createExistsRule cr√©e une r√®gle EXISTS avec ExistsNode
func (cp *ConstraintPipeline) createExistsRule(
        network *ReteNetwork,
        ruleID string,
        exprMap map[string]interface{},
        condition map[string]interface{},
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Cr√©er le n≈ìud terminal pour cette r√®gle
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // Extraire les variables
        mainVariable, existsVariable, mainVarType, existsVarType, err := cp.extractExistsVariables(exprMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extraire les conditions d'EXISTS
        <span class="cov0" title="0">existsConditions, err := cp.extractExistsConditions(exprMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Cr√©er l'objet condition pour l'ExistsNode
        <span class="cov0" title="0">existsConditionObj := map[string]interface{}{
                "type":       ConditionTypeExists,
                "conditions": existsConditions,
        }

        // Cr√©er le mapping variable -&gt; type pour l'ExistsNode
        varTypes := make(map[string]string)
        varTypes[mainVariable] = mainVarType
        varTypes[existsVariable] = existsVarType

        // Cr√©er l'ExistsNode avec les vraies conditions
        existsNode := NewExistsNode(ruleID+"_exists", existsConditionObj, mainVariable, existsVariable, varTypes, storage)
        existsNode.AddChild(terminalNode)

        // Stocker l'ExistsNode dans les BetaNodes du r√©seau
        network.BetaNodes[existsNode.ID] = existsNode

        // Cr√©er des AlphaNodes pass-through pour les deux variables
        cp.connectExistsNodeToTypeNodes(network, ruleID, existsNode, mainVariable, mainVarType, existsVariable, existsVarType)

        fmt.Printf("   ‚úÖ ExistsNode %s cr√©√© pour %s EXISTS %s\n", existsNode.ID, mainVariable, existsVariable)
        return nil</span>
}

// extractExistsVariables extrait les variables d'une r√®gle EXISTS
func (cp *ConstraintPipeline) extractExistsVariables(exprMap map[string]interface{}) (string, string, string, string, error) <span class="cov0" title="0">{
        var mainVariable, existsVariable string
        var mainVarType, existsVarType string

        // Extraire la variable principale depuis "set"
        if setData, hasSet := exprMap["set"]; hasSet </span><span class="cov0" title="0">{
                if setMap, ok := setData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if varsData, hasVars := setMap["variables"]; hasVars </span><span class="cov0" title="0">{
                                if varsList, ok := varsData.([]interface{}); ok &amp;&amp; len(varsList) &gt; 0 </span><span class="cov0" title="0">{
                                        if varMap, ok := varsList[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if name, ok := varMap["name"].(string); ok </span><span class="cov0" title="0">{
                                                        mainVariable = name
                                                }</span>
                                                <span class="cov0" title="0">if dataType, ok := varMap["dataType"].(string); ok </span><span class="cov0" title="0">{
                                                        mainVarType = dataType
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Extraire la variable d'existence depuis les contraintes
        <span class="cov0" title="0">if constraintsData, hasConstraints := exprMap["constraints"]; hasConstraints </span><span class="cov0" title="0">{
                if constraintMap, ok := constraintsData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if variable, hasVar := constraintMap["variable"]; hasVar </span><span class="cov0" title="0">{
                                if varMap, ok := variable.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if name, ok := varMap["name"].(string); ok </span><span class="cov0" title="0">{
                                                existsVariable = name
                                        }</span>
                                        <span class="cov0" title="0">if dataType, ok := varMap["dataType"].(string); ok </span><span class="cov0" title="0">{
                                                existsVarType = dataType
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">if mainVariable == "" || existsVariable == "" </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("variables EXISTS non trouv√©es: main=%s, exists=%s", mainVariable, existsVariable)
        }</span>

        <span class="cov0" title="0">return mainVariable, existsVariable, mainVarType, existsVarType, nil</span>
}

// extractExistsConditions extrait les conditions d'une r√®gle EXISTS
func (cp *ConstraintPipeline) extractExistsConditions(exprMap map[string]interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var existsConditions []map[string]interface{}

        if constraintsData, hasConstraints := exprMap["constraints"]; hasConstraints </span><span class="cov0" title="0">{
                if constraintMap, ok := constraintsData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Essayer d'abord "condition" (au singulier)
                        if conditionData, hasCondition := constraintMap["condition"]; hasCondition </span><span class="cov0" title="0">{
                                if conditionObj, ok := conditionData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        existsConditions = append(existsConditions, conditionObj)
                                }</span>
                        }
                        // Puis essayer "conditions" (au pluriel) si pas trouv√©
                        <span class="cov0" title="0">if len(existsConditions) == 0 </span><span class="cov0" title="0">{
                                if conditionsData, hasConditions := constraintMap["conditions"]; hasConditions </span><span class="cov0" title="0">{
                                        if conditionsList, ok := conditionsData.([]interface{}); ok </span><span class="cov0" title="0">{
                                                for _, conditionData := range conditionsList </span><span class="cov0" title="0">{
                                                        if conditionObj, ok := conditionData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                                existsConditions = append(existsConditions, conditionObj)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return existsConditions, nil</span>
}

// connectExistsNodeToTypeNodes connecte un ExistsNode aux TypeNodes appropri√©s
func (cp *ConstraintPipeline) connectExistsNodeToTypeNodes(
        network *ReteNetwork,
        ruleID string,
        existsNode *ExistsNode,
        mainVariable string,
        mainVarType string,
        existsVariable string,
        existsVarType string,
) <span class="cov0" title="0">{
        // Connecter les variables principale et d'existence √† l'ExistsNode
        if mainVarType != "" </span><span class="cov0" title="0">{
                cp.connectTypeNodeToBetaNode(network, ruleID, mainVariable, mainVarType, existsNode, NodeSideLeft)
        }</span>
        <span class="cov0" title="0">if existsVarType != "" </span><span class="cov0" title="0">{
                cp.connectTypeNodeToBetaNode(network, ruleID, existsVariable, existsVarType, existsNode, NodeSideRight)
        }</span>
}

// createAccumulatorRule cr√©e une r√®gle avec AccumulatorNode
func (cp *ConstraintPipeline) createAccumulatorRule(
        network *ReteNetwork,
        ruleID string,
        variables []map[string]interface{},
        variableNames []string,
        variableTypes []string,
        aggInfo *AggregationInfo,
        action *Action,
        storage Storage,
) error <span class="cov8" title="1">{
        // Extraire la variable principale et son type depuis variables
        if len(variables) == 0 || len(variableTypes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune variable principale trouv√©e")
        }</span>

        <span class="cov8" title="1">mainVariable := variableNames[0]
        mainType := variableTypes[0]

        // Stocker dans aggInfo
        aggInfo.MainVariable = mainVariable
        aggInfo.MainType = mainType

        // Cr√©er le n≈ìud terminal
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // Cr√©er la condition de comparaison
        condition := map[string]interface{}{
                "type":     ConditionTypeComparison,
                "operator": aggInfo.Operator,
                "value":    aggInfo.Threshold,
        }

        // Cr√©er l'AccumulatorNode avec tous les param√®tres
        accumNode := NewAccumulatorNode(
                ruleID+"_accum",
                aggInfo.MainVariable, // "e"
                aggInfo.MainType,     // "Employee"
                aggInfo.AggVariable,  // "p"
                aggInfo.AggType,      // "Performance"
                aggInfo.Field,        // "score"
                aggInfo.JoinField,    // "employee_id"
                aggInfo.MainField,    // "id"
                aggInfo.Function,     // "AVG"
                condition,
                storage,
        )
        accumNode.AddChild(terminalNode)
        network.BetaNodes[accumNode.ID] = accumNode

        // Connecter les TypeNodes √† l'AccumulatorNode
        cp.connectTypeNodeToBetaNode(network, ruleID, mainVariable, mainType, accumNode, "")
        fmt.Printf("   ‚úì %s -&gt; PassthroughAlpha -&gt; AccumulatorNode[%s]\n", mainType, aggInfo.Function)

        cp.connectTypeNodeToBetaNode(network, ruleID, aggInfo.AggVariable, aggInfo.AggType, accumNode, "")
        fmt.Printf("   ‚úì %s -&gt; PassthroughAlpha -&gt; AccumulatorNode[%s] (pour agr√©gation)\n", aggInfo.AggType, aggInfo.Function)

        fmt.Printf("   ‚úÖ AccumulatorNode %s cr√©√© pour %s(%s.%s) %s %.2f\n",
                accumNode.ID, aggInfo.Function, aggInfo.AggVariable, aggInfo.Field, aggInfo.Operator, aggInfo.Threshold)
        return nil</span>
}

// createPassthroughAlphaNode creates a passthrough AlphaNode with optional side specification
func (cp *ConstraintPipeline) createPassthroughAlphaNode(ruleID, varName, side string, storage Storage) *AlphaNode <span class="cov8" title="1">{
        passCondition := map[string]interface{}{
                "type": ConditionTypePassthrough,
        }
        if side != "" </span><span class="cov8" title="1">{
                passCondition["side"] = side
        }</span>
        <span class="cov8" title="1">return NewAlphaNode(ruleID+"_pass_"+varName, passCondition, varName, storage)</span>
}

// connectTypeNodeToBetaNode connects a TypeNode to a BetaNode via a passthrough AlphaNode
func (cp *ConstraintPipeline) connectTypeNodeToBetaNode(
        network *ReteNetwork,
        ruleID string,
        varName string,
        varType string,
        betaNode Node,
        side string,
) <span class="cov8" title="1">{
        if typeNode, exists := network.TypeNodes[varType]; exists </span><span class="cov8" title="1">{
                alphaNode := cp.createPassthroughAlphaNode(ruleID, varName, side, network.Storage)
                typeNode.AddChild(alphaNode)
                alphaNode.AddChild(betaNode)

                sideInfo := ""
                if side != "" </span><span class="cov8" title="1">{
                        sideInfo = fmt.Sprintf(" (%s)", strings.ToUpper(side))
                }</span>
                <span class="cov8" title="1">fmt.Printf("   ‚úì %s -&gt; PassthroughAlpha_%s -&gt; %s%s\n", varType, varName, betaNode.GetID(), sideInfo)</span>
        }
}

// createBinaryJoinRule creates a simple binary join rule (2 variables)
func (cp *ConstraintPipeline) createBinaryJoinRule(
        network *ReteNetwork,
        ruleID string,
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        terminalNode *TerminalNode,
        storage Storage,
) error <span class="cov8" title="1">{
        leftVars := []string{variableNames[0]}
        rightVars := []string{variableNames[1]}

        // Cr√©er le mapping variable -&gt; type
        varTypes := make(map[string]string)
        for i, varName := range variableNames </span><span class="cov8" title="1">{
                varTypes[varName] = variableTypes[i]
        }</span>

        <span class="cov8" title="1">joinNode := NewJoinNode(ruleID+"_join", condition, leftVars, rightVars, varTypes, storage)
        joinNode.AddChild(terminalNode)

        // Stocker le JoinNode dans les BetaNodes du r√©seau
        network.BetaNodes[joinNode.ID] = joinNode

        // Connecter les TypeNodes via des AlphaNodes pass-through
        for i, varName := range variableNames </span><span class="cov8" title="1">{
                varType := variableTypes[i]
                if varType != "" </span><span class="cov8" title="1">{
                        side := NodeSideRight
                        if i == 0 </span><span class="cov8" title="1">{
                                side = NodeSideLeft
                        }</span>
                        <span class="cov8" title="1">cp.connectTypeNodeToBetaNode(network, ruleID, varName, varType, joinNode, side)</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚ö†Ô∏è Type vide pour variable %s\n", varName)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("   ‚úÖ JoinNode %s cr√©√© pour jointure %s\n", joinNode.ID, strings.Join(variableNames, " ‚ãà "))
        return nil</span>
}

// createCascadeJoinRule creates a cascade of join nodes for multi-variable rules (3+ variables)
func (cp *ConstraintPipeline) createCascadeJoinRule(
        network *ReteNetwork,
        ruleID string,
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        terminalNode *TerminalNode,
        storage Storage,
) error <span class="cov8" title="1">{
        fmt.Printf("   üìç R√®gle multi-variables d√©tect√©e (%d variables): %v\n", len(variableNames), variableNames)
        fmt.Printf("   üîß Construction d'architecture en cascade de JoinNodes\n")

        // Cr√©er le mapping variable -&gt; type
        varTypes := make(map[string]string)
        for i, varName := range variableNames </span><span class="cov8" title="1">{
                varTypes[varName] = variableTypes[i]
        }</span>

        // √âtape 1: Cr√©er le premier JoinNode pour les 2 premi√®res variables
        <span class="cov8" title="1">leftVars := []string{variableNames[0]}
        rightVars := []string{variableNames[1]}
        currentVarTypes := map[string]string{
                variableNames[0]: variableTypes[0],
                variableNames[1]: variableTypes[1],
        }

        currentJoinNode := NewJoinNode(
                fmt.Sprintf("%s_join_%d_%d", ruleID, 0, 1),
                condition,
                leftVars,
                rightVars,
                currentVarTypes,
                storage,
        )
        network.BetaNodes[currentJoinNode.ID] = currentJoinNode

        // Connecter les 2 premi√®res variables au premier JoinNode
        for i := 0; i &lt; 2; i++ </span><span class="cov8" title="1">{
                varName := variableNames[i]
                varType := variableTypes[i]
                side := NodeSideRight
                if i == 0 </span><span class="cov8" title="1">{
                        side = NodeSideLeft
                }</span>
                <span class="cov8" title="1">cp.connectTypeNodeToBetaNode(network, ruleID, varName, varType, currentJoinNode, side)
                fmt.Printf("   ‚úì Cascade level 1 connection\n")</span>
        }

        <span class="cov8" title="1">fmt.Printf("   ‚úÖ JoinNode cascade level 1: %s ‚ãà %s\n", variableNames[0], variableNames[1])

        // √âtape 2+: Joindre chaque variable suivante au r√©sultat pr√©c√©dent
        for i := 2; i &lt; len(variableNames); i++ </span><span class="cov8" title="1">{
                nextVarName := variableNames[i]
                nextVarType := variableTypes[i]

                // Variables accumul√©es jusqu'ici
                accumulatedVars := variableNames[0:i]
                accumulatedVarTypes := make(map[string]string)
                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                        accumulatedVarTypes[variableNames[j]] = variableTypes[j]
                }</span>
                <span class="cov8" title="1">accumulatedVarTypes[nextVarName] = nextVarType

                // Cr√©er le prochain JoinNode
                nextJoinNode := NewJoinNode(
                        fmt.Sprintf("%s_join_%d", ruleID, i),
                        condition,
                        accumulatedVars,
                        []string{nextVarName},
                        accumulatedVarTypes,
                        storage,
                )
                network.BetaNodes[nextJoinNode.ID] = nextJoinNode

                // Connecter le JoinNode pr√©c√©dent au nouveau JoinNode
                currentJoinNode.AddChild(nextJoinNode)

                // Connecter la nouvelle variable au JoinNode
                cp.connectTypeNodeToBetaNode(network, ruleID, nextVarName, nextVarType, nextJoinNode, NodeSideRight)
                fmt.Printf("   ‚úì Cascade level %d connection\n", i)

                fmt.Printf("   ‚úÖ JoinNode cascade level %d: (%s) ‚ãà %s\n", i, strings.Join(accumulatedVars, " ‚ãà "), nextVarName)

                currentJoinNode = nextJoinNode</span>
        }

        // Connecter le dernier JoinNode au terminal
        <span class="cov8" title="1">currentJoinNode.AddChild(terminalNode)
        fmt.Printf("   ‚úÖ Architecture en cascade compl√®te: %s\n", strings.Join(variableNames, " ‚ãà "))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package rete

import (
        "fmt"
)

// createAction cr√©e une action RETE √† partir d'une map d'action pars√©e
func (cp *ConstraintPipeline) createAction(actionMap map[string]interface{}) *Action <span class="cov8" title="1">{
        actionType := getStringField(actionMap, "type", "print")

        // Extraire le job depuis l'action
        jobData, hasJob := actionMap["job"]
        if !hasJob </span><span class="cov0" title="0">{
                // Fallback: action simple sans job (ne devrait pas arriver avec le nouveau parser)
                return &amp;Action{
                        Type: actionType,
                        Job: JobCall{
                                Name: actionType,
                                Args: []interface{}{},
                        },
                }
        }</span>

        <span class="cov8" title="1">jobMap, ok := jobData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;Action{
                        Type: actionType,
                        Job: JobCall{
                                Name: actionType,
                                Args: []interface{}{},
                        },
                }
        }</span>

        // Extraire le nom du job
        <span class="cov8" title="1">jobName := getStringField(jobMap, "name", actionType)

        action := &amp;Action{
                Type: actionType,
                Job: JobCall{
                        Name: jobName,
                        Args: []interface{}{},
                },
        }

        // Extraire les arguments du job (pas de l'action)
        if argsData, hasArgs := jobMap["args"]; hasArgs </span><span class="cov8" title="1">{
                if argsList, ok := argsData.([]interface{}); ok </span><span class="cov8" title="1">{
                        action.Job.Args = argsList
                }</span>
        }

        <span class="cov8" title="1">return action</span>
}

// buildConditionFromConstraints construit une condition appropri√©e √† partir de contraintes
func (cp *ConstraintPipeline) buildConditionFromConstraints(constraintsData interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        if constraintsData == nil </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "type": "simple",
                }, nil
        }</span>

        // V√©rifier si c'est une agr√©gation
        <span class="cov8" title="1">if cp.detectAggregation(constraintsData) </span><span class="cov8" title="1">{
                return map[string]interface{}{
                        "type": "passthrough",
                }, nil
        }</span>

        // Analyser les contraintes pour d√©tecter les n√©gations
        <span class="cov8" title="1">isNegation, negatedCondition, err := cp.analyzeConstraints(constraintsData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur analyse contraintes: %w", err)
        }</span>

        <span class="cov8" title="1">if isNegation </span><span class="cov0" title="0">{
                fmt.Printf("   üö´ D√©tection contrainte NOT - cr√©ation d'un AlphaNode de n√©gation\n")
                return map[string]interface{}{
                        "type":      "negation",
                        "negated":   true,
                        "condition": negatedCondition,
                }, nil
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "type":       "constraint",
                "constraint": constraintsData,
        }, nil</span>
}

// extractActionFromExpression extrait l'action d'une expression de r√®gle
func (cp *ConstraintPipeline) extractActionFromExpression(exprMap map[string]interface{}, ruleID string) (*Action, error) <span class="cov8" title="1">{
        actionData, hasAction := exprMap["action"]
        if !hasAction </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aucune action trouv√©e pour r√®gle %s", ruleID)
        }</span>

        <span class="cov8" title="1">actionMap, ok := actionData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("format action invalide pour r√®gle %s: %T", ruleID, actionData)
        }</span>

        <span class="cov8" title="1">return cp.createAction(actionMap), nil</span>
}

// determineRuleType d√©termine le type de r√®gle (alpha, join, exists, accumulator)
// Retourne (ruleType string, shouldProcess bool)
func (cp *ConstraintPipeline) determineRuleType(
        exprMap map[string]interface{},
        variableCount int,
        hasAggregation bool,
) string <span class="cov8" title="1">{
        // V√©rifier si c'est une contrainte EXISTS
        if constraintsData, hasConstraints := exprMap["constraints"]; hasConstraints </span><span class="cov8" title="1">{
                if cp.isExistsConstraint(constraintsData) </span><span class="cov0" title="0">{
                        return "exists"
                }</span>
        }

        // Si c'est une agr√©gation
        <span class="cov8" title="1">if hasAggregation </span><span class="cov8" title="1">{
                return "accumulator"
        }</span>

        // Si plus d'une variable, c'est une jointure
        <span class="cov8" title="1">if variableCount &gt; 1 </span><span class="cov8" title="1">{
                return "join"
        }</span>

        // Sinon, c'est une r√®gle alpha simple
        <span class="cov0" title="0">return "alpha"</span>
}

// getVariableInfo extrait les informations de la premi√®re variable
// Retourne (variableName, variableType)
func (cp *ConstraintPipeline) getVariableInfo(variables []map[string]interface{}, variableTypes []string) (string, string) <span class="cov0" title="0">{
        variableName := "p" // d√©faut
        variableType := ""

        if len(variables) &gt; 0 </span><span class="cov0" title="0">{
                if name, ok := variables[0]["name"].(string); ok </span><span class="cov0" title="0">{
                        variableName = name
                }</span>
                <span class="cov0" title="0">if len(variableTypes) &gt; 0 </span><span class="cov0" title="0">{
                        variableType = variableTypes[0]
                }</span>
        }

        <span class="cov0" title="0">return variableName, variableType</span>
}

// connectAlphaNodeToTypeNode connecte un AlphaNode au TypeNode appropri√©
func (cp *ConstraintPipeline) connectAlphaNodeToTypeNode(
        network *ReteNetwork,
        alphaNode *AlphaNode,
        variableType string,
        variableName string,
) <span class="cov0" title="0">{
        if variableType != "" </span><span class="cov0" title="0">{
                // Les TypeNodes sont stock√©s avec leur nom direct, pas avec "type_" pr√©fixe
                if typeNode, exists := network.TypeNodes[variableType]; exists </span><span class="cov0" title="0">{
                        typeNode.AddChild(alphaNode)
                        fmt.Printf("   ‚úì AlphaNode %s connect√© au TypeNode %s\n", alphaNode.ID, variableType)
                        return
                }</span>
                <span class="cov0" title="0">fmt.Printf("   ‚ö†Ô∏è  TypeNode %s non trouv√© pour variable %s\n", variableType, variableName)</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("   ‚ö†Ô∏è  Type de variable non trouv√© pour %s, fallback\n", variableName)
        }</span>

        // Fallback: connecter au premier type node trouv√©
        <span class="cov0" title="0">for _, typeNode := range network.TypeNodes </span><span class="cov0" title="0">{
                typeNode.AddChild(alphaNode)
                break</span>
        }
}

// createAlphaNodeWithTerminal cr√©e un AlphaNode et son n≈ìud terminal associ√©
func (cp *ConstraintPipeline) createAlphaNodeWithTerminal(
        network *ReteNetwork,
        ruleID string,
        condition map[string]interface{},
        variableName string,
        variableType string,
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Cr√©er un n≈ìud Alpha avec la condition appropri√©e
        alphaNode := NewAlphaNode(ruleID+"_alpha", condition, variableName, storage)

        // Connecter au type node appropri√©
        cp.connectAlphaNodeToTypeNode(network, alphaNode, variableType, variableName)

        network.AlphaNodes[alphaNode.ID] = alphaNode

        // Cr√©er le terminal
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        alphaNode.AddChild(terminalNode)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        if condition["type"] == "negation" </span><span class="cov0" title="0">{
                fmt.Printf("   ‚úì AlphaNode de n√©gation cr√©√©: %s -&gt; %s\n", alphaNode.ID, terminalNode.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// logRuleCreation affiche un message de log pour la cr√©ation d'une r√®gle
func (cp *ConstraintPipeline) logRuleCreation(ruleType string, ruleID string, variableNames []string) <span class="cov8" title="1">{
        switch ruleType </span>{
        case "join":<span class="cov8" title="1">
                fmt.Printf("   üìç R√®gle multi-variables d√©tect√©e (%d variables): %v\n", len(variableNames), variableNames)</span>
        case "exists":<span class="cov0" title="0">
                fmt.Printf("   üîç R√®gle EXISTS d√©tect√©e pour: %s\n", ruleID)</span>
        case "accumulator":<span class="cov8" title="1">
                fmt.Printf("   üìä R√®gle d'agr√©gation d√©tect√©e pour: %s\n", ruleID)</span>
        case "alpha":<span class="cov0" title="0">
                fmt.Printf("   ‚úì R√®gle alpha simple cr√©√©e pour: %s\n", ruleID)</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package rete

import (
        "fmt"
        "strings"
)

// extractComponents extrait les types et expressions d'un AST pars√©
// Retourne (types, expressions, error)
func (cp *ConstraintPipeline) extractComponents(resultMap map[string]interface{}) ([]interface{}, []interface{}, error) <span class="cov8" title="1">{
        // Extraire les types
        typesData, hasTypes := resultMap["types"]
        if !hasTypes </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("aucun type trouv√© dans l'AST")
        }</span>

        <span class="cov8" title="1">types, ok := typesData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("format types invalide: %T", typesData)
        }</span>

        // Extraire les expressions
        <span class="cov8" title="1">expressionsData, hasExpressions := resultMap["expressions"]
        if !hasExpressions </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("aucune expression trouv√©e dans l'AST")
        }</span>

        <span class="cov8" title="1">expressions, ok := expressionsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("format expressions invalide: %T", expressionsData)
        }</span>

        <span class="cov8" title="1">return types, expressions, nil</span>
}

// analyzeConstraints analyse les contraintes pour d√©tecter les n√©gations
// Retourne (isNegation, negatedCondition, error)
func (cp *ConstraintPipeline) analyzeConstraints(constraints interface{}) (bool, interface{}, error) <span class="cov8" title="1">{
        constraintMap, ok := constraints.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return false, constraints, nil
        }</span>

        // D√©tecter contrainte NOT
        <span class="cov8" title="1">if constraintType, exists := constraintMap["type"].(string); exists </span><span class="cov8" title="1">{
                if constraintType == "notConstraint" </span><span class="cov0" title="0">{
                        // Extraire la contrainte ni√©e
                        if negatedConstraint, hasNegated := constraintMap["constraint"]; hasNegated </span><span class="cov0" title="0">{
                                return true, negatedConstraint, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return false, constraints, nil</span>
}

// extractAggregationInfo extrait les informations d'agr√©gation d'une contrainte
func (cp *ConstraintPipeline) extractAggregationInfo(constraintsData interface{}) (*AggregationInfo, error) <span class="cov8" title="1">{
        constraintMap, ok := constraintsData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constraints n'est pas un map: %T", constraintsData)
        }</span>

        <span class="cov8" title="1">aggInfo := &amp;AggregationInfo{}

        // Extraire la fonction d'agr√©gation (AVG, SUM, COUNT, etc.)
        if function, ok := constraintMap["function"].(string); ok </span><span class="cov8" title="1">{
                aggInfo.Function = function
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("fonction d'agr√©gation non trouv√©e")
        }</span>

        // Extraire l'op√©rateur de comparaison
        <span class="cov8" title="1">if operator, ok := constraintMap["operator"].(string); ok </span><span class="cov8" title="1">{
                aggInfo.Operator = operator
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("op√©rateur de comparaison non trouv√©")
        }</span>

        // Extraire le seuil (threshold) depuis constraintMap["threshold"]["value"]
        <span class="cov8" title="1">if thresholdData, ok := constraintMap["threshold"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if threshold, ok := thresholdData["value"].(float64); ok </span><span class="cov8" title="1">{
                        aggInfo.Threshold = threshold
                }</span> else<span class="cov0" title="0"> if thresholdInt, ok := thresholdData["value"].(int); ok </span><span class="cov0" title="0">{
                        aggInfo.Threshold = float64(thresholdInt)
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("valeur de seuil non trouv√©e ou invalide")
                }</span>
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("seuil manquant")
        }</span>

        // Extraire la condition de jointure compl√®te
        <span class="cov8" title="1">if joinCond, ok := constraintMap["join"]; ok </span><span class="cov0" title="0">{
                aggInfo.JoinCondition = joinCond
        }</span>

        // Extraire la variable √† agr√©ger depuis constraintMap["variable"]
        <span class="cov8" title="1">if variableData, ok := constraintMap["variable"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if aggVar, ok := variableData["name"].(string); ok </span><span class="cov8" title="1">{
                        aggInfo.AggVariable = aggVar
                }</span>
                <span class="cov8" title="1">if aggType, ok := variableData["dataType"].(string); ok </span><span class="cov8" title="1">{
                        aggInfo.AggType = aggType
                }</span>
        }

        // Extraire le champ √† agr√©ger
        <span class="cov8" title="1">if field, ok := constraintMap["field"].(string); ok </span><span class="cov8" title="1">{
                aggInfo.Field = field
        }</span>

        // Extraire les informations de jointure depuis la condition
        <span class="cov8" title="1">if conditionData, ok := constraintMap["condition"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                aggInfo.JoinCondition = conditionData

                // Extraire les champs de jointure depuis la condition de type comparison
                if condType, ok := conditionData["type"].(string); ok &amp;&amp; condType == "comparison" </span><span class="cov8" title="1">{
                        // Left side: p.employee_id
                        if leftData, ok := conditionData["left"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if leftType, ok := leftData["type"].(string); ok &amp;&amp; leftType == "fieldAccess" </span><span class="cov8" title="1">{
                                        if joinField, ok := leftData["field"].(string); ok </span><span class="cov8" title="1">{
                                                aggInfo.JoinField = joinField
                                        }</span>
                                }
                        }

                        // Right side: e.id
                        <span class="cov8" title="1">if rightData, ok := conditionData["right"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if rightType, ok := rightData["type"].(string); ok &amp;&amp; rightType == "fieldAccess" </span><span class="cov8" title="1">{
                                        if mainField, ok := rightData["field"].(string); ok </span><span class="cov8" title="1">{
                                                aggInfo.MainField = mainField
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return aggInfo, nil</span>
}

// extractVariablesFromExpression extrait les variables d'une expression
// Retourne (variables, variableNames, variableTypes)
func (cp *ConstraintPipeline) extractVariablesFromExpression(exprMap map[string]interface{}) ([]map[string]interface{}, []string, []string) <span class="cov8" title="1">{
        variables := []map[string]interface{}{}
        variableNames := []string{}
        variableTypes := []string{}

        if setData, hasSet := exprMap["set"]; hasSet </span><span class="cov8" title="1">{
                if setMap, ok := setData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if varsData, hasVars := setMap["variables"]; hasVars </span><span class="cov8" title="1">{
                                if varsList, ok := varsData.([]interface{}); ok &amp;&amp; len(varsList) &gt; 0 </span><span class="cov8" title="1">{
                                        // Extraire toutes les variables
                                        for _, varInterface := range varsList </span><span class="cov8" title="1">{
                                                if varMap, ok := varInterface.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                                        variables = append(variables, varMap)

                                                        if name, ok := varMap["name"].(string); ok </span><span class="cov8" title="1">{
                                                                variableNames = append(variableNames, name)
                                                        }</span>

                                                        // Extraire le type de la variable
                                                        <span class="cov8" title="1">var varType string
                                                        if dataType, ok := varMap["dataType"].(string); ok </span><span class="cov8" title="1">{
                                                                varType = dataType
                                                        }</span> else<span class="cov0" title="0"> if typeField, ok := varMap["type"].(string); ok </span><span class="cov0" title="0">{
                                                                varType = typeField
                                                        }</span>
                                                        <span class="cov8" title="1">variableTypes = append(variableTypes, varType)</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return variables, variableNames, variableTypes</span>
}

// detectAggregation d√©tecte si une contrainte contient une agr√©gation
func (cp *ConstraintPipeline) detectAggregation(constraintsData interface{}) bool <span class="cov8" title="1">{
        if constraintStr := fmt.Sprintf("%v", constraintsData); constraintStr != "" </span><span class="cov8" title="1">{
                return strings.Contains(constraintStr, "AVG") ||
                        strings.Contains(constraintStr, "SUM") ||
                        strings.Contains(constraintStr, "COUNT") ||
                        strings.Contains(constraintStr, "MIN") ||
                        strings.Contains(constraintStr, "MAX") ||
                        strings.Contains(constraintStr, "ACCUMULATE")
        }</span>
        <span class="cov0" title="0">return false</span>
}

// isExistsConstraint v√©rifie si une contrainte est de type EXISTS
func (cp *ConstraintPipeline) isExistsConstraint(constraintsData interface{}) bool <span class="cov8" title="1">{
        if constraintMap, ok := constraintsData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if constraintType, exists := constraintMap["type"].(string); exists &amp;&amp; constraintType == "existsConstraint" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// getStringField extrait un champ string d'une map avec une valeur par d√©faut
func getStringField(m map[string]interface{}, key, defaultValue string) string <span class="cov8" title="1">{
        if value, ok := m[key].(string); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package rete

import (
        "fmt"
)

// validateNetwork valide qu'un r√©seau RETE est bien form√©
func (cp *ConstraintPipeline) validateNetwork(network *ReteNetwork) error <span class="cov8" title="1">{
        if network == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("r√©seau est nil")
        }</span>

        // V√©rifier qu'on a au moins un TypeNode
        <span class="cov8" title="1">if len(network.TypeNodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aucun TypeNode dans le r√©seau")
        }</span>

        // V√©rifier qu'on a au moins un n≈ìud terminal
        <span class="cov8" title="1">if len(network.TerminalNodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aucun n≈ìud terminal dans le r√©seau")
        }</span>

        // V√©rifier que les n≈ìuds terminaux ont des actions
        <span class="cov8" title="1">for id, terminal := range network.TerminalNodes </span><span class="cov8" title="1">{
                if terminal.Action == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("n≈ìud terminal %s sans action", id)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateAction valide qu'une action est bien form√©e
func (cp *ConstraintPipeline) validateAction(actionMap map[string]interface{}) error <span class="cov0" title="0">{
        if actionMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("action map est nil")
        }</span>

        // V√©rifier qu'on a un type d'action
        <span class="cov0" title="0">actionType, hasType := actionMap["type"].(string)
        if !hasType </span><span class="cov0" title="0">{
                return fmt.Errorf("type d'action non trouv√©")
        }</span>

        // V√©rifier selon le type d'action
        <span class="cov0" title="0">switch actionType </span>{
        case "print", "PRINT":<span class="cov0" title="0">
                // L'action print doit avoir un message ou une expression
                if _, hasMsg := actionMap["message"]; !hasMsg </span><span class="cov0" title="0">{
                        if _, hasExpr := actionMap["expression"]; !hasExpr </span><span class="cov0" title="0">{
                                return fmt.Errorf("action print sans message ni expression")
                        }</span>
                }
        case "assert", "ASSERT":<span class="cov0" title="0">
                // L'action assert doit avoir un fait √† ins√©rer
                if _, hasFact := actionMap["fact"]; !hasFact </span><span class="cov0" title="0">{
                        return fmt.Errorf("action assert sans fait")
                }</span>
        case "retract", "RETRACT":<span class="cov0" title="0">
                // L'action retract doit avoir un fait √† retirer
                if _, hasFact := actionMap["fact"]; !hasFact </span><span class="cov0" title="0">{
                        return fmt.Errorf("action retract sans fait")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateRuleExpression valide qu'une expression de r√®gle est bien form√©e
func (cp *ConstraintPipeline) validateRuleExpression(exprMap map[string]interface{}) error <span class="cov0" title="0">{
        if exprMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("expression map est nil")
        }</span>

        // V√©rifier qu'on a une action
        <span class="cov0" title="0">actionData, hasAction := exprMap["action"]
        if !hasAction </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune action trouv√©e dans la r√®gle")
        }</span>

        <span class="cov0" title="0">actionMap, ok := actionData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("format action invalide: %T", actionData)
        }</span>

        // Valider l'action
        <span class="cov0" title="0">if err := cp.validateAction(actionMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("action invalide: %w", err)
        }</span>

        // V√©rifier qu'on a des variables (set)
        <span class="cov0" title="0">if _, hasSet := exprMap["set"]; !hasSet </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune variable (set) trouv√©e dans la r√®gle")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateTypeDefinition valide qu'une d√©finition de type est bien form√©e
func (cp *ConstraintPipeline) validateTypeDefinition(typeName string, typeMap map[string]interface{}) error <span class="cov0" title="0">{
        if typeName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("nom de type vide")
        }</span>

        <span class="cov0" title="0">if typeMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("d√©finition de type nil pour %s", typeName)
        }</span>

        // V√©rifier qu'on a des champs
        <span class="cov0" title="0">fieldsData, hasFields := typeMap["fields"]
        if !hasFields </span><span class="cov0" title="0">{
                return fmt.Errorf("type %s sans champs", typeName)
        }</span>

        <span class="cov0" title="0">fields, ok := fieldsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("format fields invalide pour type %s: %T", typeName, fieldsData)
        }</span>

        <span class="cov0" title="0">if len(fields) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("type %s avec liste de champs vide", typeName)
        }</span>

        // V√©rifier chaque champ
        <span class="cov0" title="0">for i, fieldInterface := range fields </span><span class="cov0" title="0">{
                fieldMap, ok := fieldInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ %d du type %s invalide: %T", i, typeName, fieldInterface)
                }</span>

                // V√©rifier qu'on a un nom de champ
                <span class="cov0" title="0">fieldName, hasName := fieldMap["name"].(string)
                if !hasName || fieldName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ %d du type %s sans nom", i, typeName)
                }</span>

                // V√©rifier qu'on a un type de champ
                <span class="cov0" title="0">fieldType, hasType := fieldMap["type"].(string)
                if !hasType || fieldType == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ %s du type %s sans type", fieldName, typeName)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateAggregationInfo valide qu'une information d'agr√©gation est compl√®te
func (cp *ConstraintPipeline) validateAggregationInfo(aggInfo *AggregationInfo) error <span class="cov0" title="0">{
        if aggInfo == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("information d'agr√©gation nil")
        }</span>

        // V√©rifier la fonction
        <span class="cov0" title="0">if aggInfo.Function == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("fonction d'agr√©gation vide")
        }</span>

        <span class="cov0" title="0">validFunctions := map[string]bool{
                "AVG": true, "SUM": true, "COUNT": true,
                "MIN": true, "MAX": true, "ACCUMULATE": true,
        }
        if !validFunctions[aggInfo.Function] </span><span class="cov0" title="0">{
                return fmt.Errorf("fonction d'agr√©gation invalide: %s", aggInfo.Function)
        }</span>

        // V√©rifier l'op√©rateur
        <span class="cov0" title="0">if aggInfo.Operator == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("op√©rateur de comparaison vide")
        }</span>

        <span class="cov0" title="0">validOperators := map[string]bool{
                "&gt;=": true, "&lt;=": true, "&gt;": true, "&lt;": true, "==": true, "!=": true,
        }
        if !validOperators[aggInfo.Operator] </span><span class="cov0" title="0">{
                return fmt.Errorf("op√©rateur de comparaison invalide: %s", aggInfo.Operator)
        }</span>

        // V√©rifier les champs de jointure si pr√©sents
        <span class="cov0" title="0">if aggInfo.JoinField != "" &amp;&amp; aggInfo.MainField == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("champ de jointure principal manquant")
        }</span>
        <span class="cov0" title="0">if aggInfo.MainField != "" &amp;&amp; aggInfo.JoinField == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("champ de jointure agr√©g√© manquant")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateJoinCondition valide qu'une condition de jointure est bien form√©e
func (cp *ConstraintPipeline) validateJoinCondition(condition map[string]interface{}) error <span class="cov0" title="0">{
        if condition == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("condition de jointure nil")
        }</span>

        <span class="cov0" title="0">condType, hasType := condition["type"].(string)
        if !hasType </span><span class="cov0" title="0">{
                return fmt.Errorf("type de condition non sp√©cifi√©")
        }</span>

        <span class="cov0" title="0">switch condType </span>{
        case "simple", "passthrough":<span class="cov0" title="0">
                // Conditions simples, pas de validation suppl√©mentaire
                return nil</span>
        case "constraint":<span class="cov0" title="0">
                // Doit avoir une contrainte
                if _, hasConstraint := condition["constraint"]; !hasConstraint </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition de type constraint sans contrainte")
                }</span>
        case "negation":<span class="cov0" title="0">
                // Doit avoir une condition ni√©e
                if _, hasNegated := condition["negated"]; !hasNegated </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition de type negation sans flag negated")
                }</span>
                <span class="cov0" title="0">if _, hasCondition := condition["condition"]; !hasCondition </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition de type negation sans condition ni√©e")
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("type de condition inconnu: %s", condType)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// ASTConverter convertit l'AST du parser constraint vers les types RETE
type ASTConverter struct{}

// NewASTConverter cr√©e un nouveau convertisseur AST
func NewASTConverter() *ASTConverter <span class="cov0" title="0">{
        return &amp;ASTConverter{}
}</span>

// ConvertProgram convertit un constraint.Program vers un rete.Program
func (ac *ASTConverter) ConvertProgram(constraintProgram interface{}) (*Program, error) <span class="cov0" title="0">{
        // Essayer de caster vers constraint.Program
        program, ok := constraintProgram.(*constraint.Program)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type de programme AST non reconnu")
        }</span>

        <span class="cov0" title="0">reteProgram := &amp;Program{
                Types:       make([]TypeDefinition, len(program.Types)),
                Expressions: make([]Expression, len(program.Expressions)),
        }

        // Convertir les types
        for i, constraintType := range program.Types </span><span class="cov0" title="0">{
                reteProgram.Types[i] = TypeDefinition{
                        Type:   constraintType.Type,
                        Name:   constraintType.Name,
                        Fields: ac.convertFields(constraintType.Fields),
                }
        }</span>

        // Convertir les expressions
        <span class="cov0" title="0">for i, constraintExpr := range program.Expressions </span><span class="cov0" title="0">{
                reteExpr, err := ac.convertExpression(constraintExpr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur conversion expression %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">reteProgram.Expressions[i] = *reteExpr</span>
        }

        <span class="cov0" title="0">return reteProgram, nil</span>
}

// convertFields convertit les champs
func (ac *ASTConverter) convertFields(constraintFields []constraint.Field) []Field <span class="cov0" title="0">{
        fields := make([]Field, len(constraintFields))
        for i, field := range constraintFields </span><span class="cov0" title="0">{
                fields[i] = Field{
                        Name: field.Name,
                        Type: field.Type,
                }
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// convertExpression convertit une expression
func (ac *ASTConverter) convertExpression(constraintExpr constraint.Expression) (*Expression, error) <span class="cov0" title="0">{
        expr := &amp;Expression{
                Type:        constraintExpr.Type,
                Constraints: constraintExpr.Constraints,
        }

        // Convertir le set
        expr.Set = Set{
                Type:      constraintExpr.Set.Type,
                Variables: ac.convertTypedVariables(constraintExpr.Set.Variables),
        }

        // Convertir l'action (maintenant obligatoire)
        if constraintExpr.Action != nil </span><span class="cov0" title="0">{
                action, err := ac.convertAction(*constraintExpr.Action)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur conversion action: %w", err)
                }</span>
                <span class="cov0" title="0">expr.Action = action</span>
        } else<span class="cov0" title="0"> {
                // Cette condition ne devrait plus arriver avec la nouvelle grammaire
                return nil, fmt.Errorf("action manquante: chaque r√®gle doit avoir une action d√©finie")
        }</span>

        <span class="cov0" title="0">return expr, nil</span>
}

// convertTypedVariables convertit les variables typ√©es
func (ac *ASTConverter) convertTypedVariables(constraintVars []constraint.TypedVariable) []TypedVariable <span class="cov0" title="0">{
        vars := make([]TypedVariable, len(constraintVars))
        for i, variable := range constraintVars </span><span class="cov0" title="0">{
                vars[i] = TypedVariable{
                        Type:     variable.Type,
                        Name:     variable.Name,
                        DataType: variable.DataType,
                }
        }</span>
        <span class="cov0" title="0">return vars</span>
}

// convertAction convertit une action
func (ac *ASTConverter) convertAction(constraintAction constraint.Action) (*Action, error) <span class="cov0" title="0">{
        action := &amp;Action{
                Type: constraintAction.Type,
                Job: JobCall{
                        Type: constraintAction.Job.Type,
                        Name: constraintAction.Job.Name,
                        Args: constraintAction.Job.Args,
                },
        }
        return action, nil
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package rete

// AlphaConditionEvaluator √©value les conditions Alpha sur les faits.
// Cette structure a √©t√© refactoris√©e en plusieurs fichiers pour am√©liorer la lisibilit√©:
//   - evaluator_expressions.go: √âvaluation des expressions binaires et logiques
//   - evaluator_constraints.go: √âvaluation des contraintes
//   - evaluator_values.go: √âvaluation des valeurs, champs et variables
//   - evaluator_comparisons.go: Op√©rations de comparaison
//   - evaluator_operators.go: Op√©rateurs arithm√©tiques, cha√Ænes et listes
//   - evaluator_functions.go: Fonctions int√©gr√©es (LENGTH, UPPER, ABS, etc.)
type AlphaConditionEvaluator struct {
        variableBindings map[string]*Fact
        partialEvalMode  bool // Mode d'√©valuation partielle pour les jointures en cascade
}

// NewAlphaConditionEvaluator cr√©e un nouvel √©valuateur de conditions
func NewAlphaConditionEvaluator() *AlphaConditionEvaluator <span class="cov8" title="1">{
        return &amp;AlphaConditionEvaluator{
                variableBindings: make(map[string]*Fact),
                partialEvalMode:  false,
        }
}</span>

// EvaluateCondition √©value une condition sur un fait.
// Il s'agit du point d'entr√©e principal pour l'√©valuation des conditions Alpha.
//
// Parameters:
//   - condition: La condition √† √©valuer (peut √™tre une map, BinaryOperation, LogicalExpression, etc.)
//   - fact: Le fait sur lequel √©valuer la condition
//   - variableName: Le nom de la variable √† lier au fait (optionnel)
//
// Returns:
//   - bool: true si la condition est satisfaite, false sinon
//   - error: Une erreur si l'√©valuation √©choue
func (e *AlphaConditionEvaluator) EvaluateCondition(condition interface{}, fact *Fact, variableName string) (bool, error) <span class="cov0" title="0">{
        // Si c'est un passthrough (agr√©gation), laisser passer tous les faits
        if condMap, ok := condition.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if condType, exists := condMap["type"].(string); exists &amp;&amp; condType == "passthrough" </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        // Lier la variable au fait pour l'√©valuation
        <span class="cov0" title="0">if variableName != "" </span><span class="cov0" title="0">{
                e.variableBindings[variableName] = fact
        }</span>

        <span class="cov0" title="0">return e.evaluateExpression(condition)</span>
}

// ClearBindings efface les liaisons de variables.
// Utilis√© pour r√©initialiser l'√©valuateur entre diff√©rentes √©valuations.
func (e *AlphaConditionEvaluator) ClearBindings() <span class="cov0" title="0">{
        e.variableBindings = make(map[string]*Fact)
}</span>

// SetPartialEvalMode active ou d√©sactive le mode d'√©valuation partielle.
// En mode partiel, les variables non li√©es renvoient true au lieu d'une erreur.
// Utilis√© pour les jointures en cascade o√π toutes les variables ne sont pas encore disponibles.
func (e *AlphaConditionEvaluator) SetPartialEvalMode(enabled bool) <span class="cov8" title="1">{
        e.partialEvalMode = enabled
}</span>

// GetBindings retourne les liaisons actuelles de variables.
// Utile pour le d√©bogage et l'inspection de l'√©tat de l'√©valuateur.
func (e *AlphaConditionEvaluator) GetBindings() map[string]*Fact <span class="cov0" title="0">{
        return e.variableBindings
}</span>

// Note: Les m√©thodes d'√©valuation internes (evaluateExpression, evaluateValue, etc.)
// sont maintenant r√©parties dans les fichiers suivants pour am√©liorer la maintenabilit√©:
//
// evaluator_expressions.go:
//   - evaluateExpression
//   - evaluateMapExpression
//   - evaluateBinaryOperation
//   - evaluateBinaryOperationMap
//   - evaluateLogicalExpression
//   - evaluateLogicalExpressionMap
//
// evaluator_constraints.go:
//   - evaluateConstraint
//   - evaluateConstraintMap
//   - evaluateNegationConstraint
//   - evaluateNotConstraint
//   - evaluateExistsConstraint
//
// evaluator_values.go:
//   - evaluateValue
//   - evaluateValueFromMap
//   - evaluateFieldAccess
//   - evaluateFieldAccessByName
//   - evaluateVariable
//   - evaluateVariableByName
//
// evaluator_comparisons.go:
//   - compareValues
//   - normalizeValue
//   - areEqual
//   - isLess
//   - isGreater
//
// evaluator_operators.go:
//   - evaluateArithmeticOperation
//   - evaluateContains
//   - evaluateIn
//   - evaluateLike
//   - evaluateMatches
//
// evaluator_functions.go:
//   - evaluateFunctionCall
//   - evaluateLength, evaluateUpper, evaluateLower
//   - evaluateAbs, evaluateRound, evaluateFloor, evaluateCeil
//   - evaluateSubstring, evaluateTrim
</pre>
		
		<pre class="file" id="file22" style="display: none">package rete

import (
        "fmt"
        "reflect"
        "strings"
)

// compareValues compare deux valeurs avec un op√©rateur
func (e *AlphaConditionEvaluator) compareValues(left interface{}, operator string, right interface{}) (bool, error) <span class="cov8" title="1">{
        // En mode d'√©valuation partielle, si l'une des valeurs est nil (variable non li√©e),
        // retourner true pour permettre l'√©valuation de continuer
        if e.partialEvalMode &amp;&amp; (left == nil || right == nil) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // G√©rer les op√©rations arithm√©tiques qui retournent une valeur
        <span class="cov8" title="1">switch operator </span>{
        case "+", "-", "*", "/", "%":<span class="cov0" title="0">
                return false, fmt.Errorf("op√©ration arithm√©tique %s ne peut pas retourner un bool√©en", operator)</span>
        }

        // Normaliser les valeurs num√©riques
        <span class="cov8" title="1">leftVal := e.normalizeValue(left)
        rightVal := e.normalizeValue(right)

        switch operator </span>{
        case "==":<span class="cov8" title="1">
                return e.areEqual(leftVal, rightVal), nil</span>
        case "!=", "&lt;&gt;":<span class="cov8" title="1">
                return !e.areEqual(leftVal, rightVal), nil</span>
        case "&lt;":<span class="cov8" title="1">
                return e.isLess(leftVal, rightVal)</span>
        case "&lt;=":<span class="cov8" title="1">
                equal := e.areEqual(leftVal, rightVal)
                less, err := e.isLess(leftVal, rightVal)
                return equal || less, err</span>
        case "&gt;":<span class="cov8" title="1">
                return e.isGreater(leftVal, rightVal)</span>
        case "&gt;=":<span class="cov8" title="1">
                equal := e.areEqual(leftVal, rightVal)
                greater, err := e.isGreater(leftVal, rightVal)
                return equal || greater, err</span>
        case "CONTAINS":<span class="cov0" title="0">
                return e.evaluateContains(leftVal, rightVal)</span>
        case "IN":<span class="cov0" title="0">
                return e.evaluateIn(leftVal, rightVal)</span>
        case "LIKE":<span class="cov0" title="0">
                return e.evaluateLike(leftVal, rightVal)</span>
        case "MATCHES":<span class="cov0" title="0">
                return e.evaluateMatches(leftVal, rightVal)</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("op√©rateur non support√©: %s", operator)</span>
        }
}

// normalizeValue normalise une valeur pour la comparaison
func (e *AlphaConditionEvaluator) normalizeValue(value interface{}) interface{} <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return float64(v)</span>
        case int32:<span class="cov0" title="0">
                return float64(v)</span>
        case int64:<span class="cov0" title="0">
                return float64(v)</span>
        case float32:<span class="cov0" title="0">
                return float64(v)</span>
        default:<span class="cov8" title="1">
                return value</span>
        }
}

// areEqual v√©rifie si deux valeurs sont √©gales
func (e *AlphaConditionEvaluator) areEqual(left, right interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(left, right)
}</span>

// isLess v√©rifie si left &lt; right
func (e *AlphaConditionEvaluator) isLess(left, right interface{}) (bool, error) <span class="cov8" title="1">{
        switch leftVal := left.(type) </span>{
        case float64:<span class="cov8" title="1">
                if rightVal, ok := right.(float64); ok </span><span class="cov8" title="1">{
                        return leftVal &lt; rightVal, nil
                }</span>
        case string:<span class="cov0" title="0">
                if rightVal, ok := right.(string); ok </span><span class="cov0" title="0">{
                        return strings.Compare(leftVal, rightVal) &lt; 0, nil
                }</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("impossible de comparer %T avec %T", left, right)</span>
}

// isGreater v√©rifie si left &gt; right
func (e *AlphaConditionEvaluator) isGreater(left, right interface{}) (bool, error) <span class="cov8" title="1">{
        switch leftVal := left.(type) </span>{
        case float64:<span class="cov8" title="1">
                if rightVal, ok := right.(float64); ok </span><span class="cov8" title="1">{
                        return leftVal &gt; rightVal, nil
                }</span>
        case string:<span class="cov0" title="0">
                if rightVal, ok := right.(string); ok </span><span class="cov0" title="0">{
                        return strings.Compare(leftVal, rightVal) &gt; 0, nil
                }</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("impossible de comparer %T avec %T", left, right)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// evaluateConstraint √©value une contrainte simple
func (e *AlphaConditionEvaluator) evaluateConstraint(constraint constraint.Constraint) (bool, error) <span class="cov0" title="0">{
        left, err := e.evaluateValue(constraint.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateValue(constraint.Right)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov0" title="0">return e.compareValues(left, constraint.Operator, right)</span>
}

// evaluateConstraintMap √©value une contrainte depuis une map
func (e *AlphaConditionEvaluator) evaluateConstraintMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        // Si l'expression a une cl√© "constraint", extraire la contrainte r√©elle
        var actualConstraint map[string]interface{}
        if constraintData, hasConstraint := expr["constraint"]; hasConstraint </span><span class="cov8" title="1">{
                if constraintMap, ok := constraintData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        actualConstraint = constraintMap
                }</span> else<span class="cov0" title="0"> {
                        return false, fmt.Errorf("format contrainte invalide: %T", constraintData)
                }</span>
        } else<span class="cov0" title="0"> {
                // Utiliser directement l'expression si pas d'indirection
                actualConstraint = expr
        }</span>

        <span class="cov8" title="1">operator, ok := actualConstraint["operator"].(string)
        if !ok </span><span class="cov8" title="1">{
                // Si pas d'op√©rateur, v√©rifier si c'est une condition sp√©ciale
                if condType, hasType := actualConstraint["type"].(string); hasType </span><span class="cov8" title="1">{
                        if condType == "simple" || condType == "passthrough" || condType == "exists" </span><span class="cov0" title="0">{
                                return true, nil // Conditions sp√©ciales toujours vraies
                        }</span>
                        // G√©rer les expressions logiques sans op√©rateur direct
                        <span class="cov8" title="1">if condType == "logicalExpr" </span><span class="cov8" title="1">{
                                return e.evaluateLogicalExpressionMap(actualConstraint)
                        }</span>
                        // G√©rer les contraintes exists
                        <span class="cov0" title="0">if condType == "existsConstraint" </span><span class="cov0" title="0">{
                                return e.evaluateExistsConstraint(actualConstraint)
                        }</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("op√©rateur manquant pour condition: %v", actualConstraint)</span>
        }

        <span class="cov8" title="1">left, err := e.evaluateValue(actualConstraint["left"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov8" title="1">right, err := e.evaluateValue(actualConstraint["right"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov8" title="1">return e.compareValues(left, operator, right)</span>
}

// evaluateNegationConstraint √©value une contrainte de n√©gation
func (e *AlphaConditionEvaluator) evaluateNegationConstraint(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        // Extraire la condition ni√©e depuis "condition"
        condition, ok := expr["condition"]
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("condition manquante dans contrainte de n√©gation")
        }</span>

        // √âvaluer la condition interne
        <span class="cov0" title="0">result, err := e.evaluateExpression(condition)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation condition ni√©e: %w", err)
        }</span>

        // Retourner la n√©gation du r√©sultat
        <span class="cov0" title="0">return !result, nil</span>
}

// evaluateNotConstraint √©value une contrainte NOT (notConstraint)
func (e *AlphaConditionEvaluator) evaluateNotConstraint(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        // Extraire l'expression depuis "expression"
        expression, ok := expr["expression"]
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("expression manquante dans contrainte NOT")
        }</span>

        // √âvaluer l'expression interne
        <span class="cov0" title="0">result, err := e.evaluateExpression(expression)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation expression NOT: %w", err)
        }</span>

        // Retourner la n√©gation du r√©sultat
        <span class="cov0" title="0">return !result, nil</span>
}

// evaluateExistsConstraint √©value une contrainte EXISTS
func (e *AlphaConditionEvaluator) evaluateExistsConstraint(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        // Note: L'√©valuation r√©elle EXISTS est g√©r√©e par les ExistsNodes dans le r√©seau RETE
        // Cette fonction est utilis√©e uniquement pour la validation initiale au niveau Alpha
        hash := fmt.Sprintf("%v", expr)
        checksum := 0
        for _, r := range hash </span><span class="cov0" title="0">{
                checksum += int(r)
        }</span>
        <span class="cov0" title="0">return (checksum % 20) != 0, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// evaluateExpression √©value r√©cursivement une expression
func (e *AlphaConditionEvaluator) evaluateExpression(expr interface{}) (bool, error) <span class="cov8" title="1">{
        switch condition := expr.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                return e.evaluateMapExpression(condition)</span>
        case constraint.BinaryOperation:<span class="cov0" title="0">
                return e.evaluateBinaryOperation(condition)</span>
        case constraint.LogicalExpression:<span class="cov0" title="0">
                return e.evaluateLogicalExpression(condition)</span>
        case constraint.Constraint:<span class="cov0" title="0">
                return e.evaluateConstraint(condition)</span>
        case constraint.BooleanLiteral:<span class="cov0" title="0">
                return condition.Value, nil</span>
        default:<span class="cov8" title="1">
                return false, fmt.Errorf("type d'expression non support√©: %T", expr)</span>
        }
}

// evaluateMapExpression √©value une expression sous forme de map (format JSON)
func (e *AlphaConditionEvaluator) evaluateMapExpression(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        exprType, ok := expr["type"].(string)
        if !ok </span><span class="cov8" title="1">{
                return false, fmt.Errorf("type d'expression manquant")
        }</span>

        <span class="cov8" title="1">switch exprType </span>{
        case "binaryOperation", "binary_op":<span class="cov0" title="0">
                return e.evaluateBinaryOperationMap(expr)</span>
        case "logicalExpression", "logical_op", "logicalExpr":<span class="cov8" title="1">
                return e.evaluateLogicalExpressionMap(expr)</span>
        case "constraint":<span class="cov8" title="1">
                return e.evaluateConstraintMap(expr)</span>
        case "comparison":<span class="cov8" title="1">
                // Traitement des comparaisons directes
                return e.evaluateBinaryOperationMap(expr)</span>
        case "negation":<span class="cov0" title="0">
                // Traitement sp√©cial pour les contraintes de n√©gation
                return e.evaluateNegationConstraint(expr)</span>
        case "notConstraint":<span class="cov0" title="0">
                // Traitement sp√©cial pour les contraintes NOT
                return e.evaluateNotConstraint(expr)</span>
        case "existsConstraint":<span class="cov0" title="0">
                // Traitement sp√©cial pour les contraintes EXISTS
                return e.evaluateExistsConstraint(expr)</span>
        case "booleanLiteral":<span class="cov0" title="0">
                value, ok := expr["value"].(bool)
                if !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("valeur bool√©enne invalide")
                }</span>
                <span class="cov0" title="0">return value, nil</span>
        case "simple":<span class="cov0" title="0">
                // Type simple: toujours vrai pour ce pipeline de base (contraintes simples sont filtr√©es par AlphaNodes)
                return true, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("type d'expression non support√©: %s", exprType)</span>
        }
}

// evaluateBinaryOperation √©value une op√©ration binaire
func (e *AlphaConditionEvaluator) evaluateBinaryOperation(op constraint.BinaryOperation) (bool, error) <span class="cov0" title="0">{
        left, err := e.evaluateValue(op.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateValue(op.Right)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov0" title="0">return e.compareValues(left, op.Operator, right)</span>
}

// evaluateBinaryOperationMap √©value une op√©ration binaire depuis une map
func (e *AlphaConditionEvaluator) evaluateBinaryOperationMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        // Supporter les deux formats: "operator" et "op"
        var operator string
        var ok bool

        if operator, ok = expr["operator"].(string); !ok </span><span class="cov0" title="0">{
                if operator, ok = expr["op"].(string); !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("op√©rateur manquant (recherch√© 'operator' ou 'op')")
                }</span>
        }

        // Debug: v√©rifier si left et right existent
        <span class="cov8" title="1">if expr["left"] == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("c√¥t√© gauche nil dans expr: %+v", expr)
        }</span>
        <span class="cov8" title="1">if expr["right"] == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("c√¥t√© droit nil dans expr: %+v", expr)
        }</span>

        <span class="cov8" title="1">left, err := e.evaluateValue(expr["left"])
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov8" title="1">right, err := e.evaluateValue(expr["right"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov8" title="1">result, err := e.compareValues(left, operator, right)
        return result, err</span>
}

// evaluateLogicalExpression √©value une expression logique (AND, OR)
func (e *AlphaConditionEvaluator) evaluateLogicalExpression(expr constraint.LogicalExpression) (bool, error) <span class="cov0" title="0">{
        leftResult, err := e.evaluateExpression(expr.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">result := leftResult
        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                rightResult, err := e.evaluateExpression(op.Right)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("erreur √©valuation op√©ration %s: %w", op.Op, err)
                }</span>

                <span class="cov0" title="0">switch op.Op </span>{
                case "AND":<span class="cov0" title="0">
                        result = result &amp;&amp; rightResult</span>
                case "OR":<span class="cov0" title="0">
                        result = result || rightResult</span>
                default:<span class="cov0" title="0">
                        return false, fmt.Errorf("op√©rateur logique non support√©: %s", op.Op)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// evaluateLogicalExpressionMap √©value une expression logique depuis une map
func (e *AlphaConditionEvaluator) evaluateLogicalExpressionMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        leftResult, err := e.evaluateExpression(expr["left"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        // Essayer d'extraire operations - supporter les deux types possibles
        <span class="cov8" title="1">var operations []interface{}
        var ok bool

        if opsRaw, hasOps := expr["operations"]; hasOps </span><span class="cov8" title="1">{
                // Essayer []interface{} d'abord
                operations, ok = opsRaw.([]interface{})
                if !ok </span><span class="cov8" title="1">{
                        // Essayer []map[string]interface{} (structure retourn√©e par parser PEG)
                        if opsTyped, okTyped := opsRaw.([]map[string]interface{}); okTyped </span><span class="cov8" title="1">{
                                // Convertir []map[string]interface{} en []interface{}
                                operations = make([]interface{}, len(opsTyped))
                                for i, op := range opsTyped </span><span class="cov8" title="1">{
                                        operations[i] = op
                                }</span>
                                <span class="cov8" title="1">ok = true</span>
                        }
                }
        }

        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return leftResult, nil // Pas d'op√©rations suppl√©mentaires
        }</span>

        <span class="cov8" title="1">result := leftResult
        for _, opInterface := range operations </span><span class="cov8" title="1">{
                opMap, ok := opInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">operator, ok := opMap["op"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">rightResult, err := e.evaluateExpression(opMap["right"])
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("erreur √©valuation op√©ration %s: %w", operator, err)
                }</span>

                <span class="cov8" title="1">switch operator </span>{
                case "AND":<span class="cov8" title="1">
                        result = result &amp;&amp; rightResult</span>
                case "OR":<span class="cov0" title="0">
                        result = result || rightResult</span>
                default:<span class="cov0" title="0">
                        return false, fmt.Errorf("op√©rateur logique non support√©: %s", operator)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package rete

import (
        "fmt"
        "math"
        "strings"
)

// evaluateFunctionCall √©value un appel de fonction
func (e *AlphaConditionEvaluator) evaluateFunctionCall(val map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        functionName, ok := val["name"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nom de fonction invalide")
        }</span>

        <span class="cov0" title="0">args, ok := val["args"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                // Pas d'arguments
                args = []interface{}{}
        }</span>

        // Debug: v√©rifier si les arguments contiennent des nil
        <span class="cov0" title="0">for i, arg := range args </span><span class="cov0" title="0">{
                if arg == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("argument[%d] de %s est nil, args complets: %+v", i, functionName, args)
                }</span>
        }

        // √âvaluer les arguments
        <span class="cov0" title="0">evaluatedArgs := make([]interface{}, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                evaluatedArg, err := e.evaluateValue(arg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur √©valuation argument[%d] pour %s: %w", i, functionName, err)
                }</span>
                <span class="cov0" title="0">evaluatedArgs[i] = evaluatedArg</span>
        }

        // Appeler la fonction appropri√©e
        <span class="cov0" title="0">switch functionName </span>{
        case "LENGTH":<span class="cov0" title="0">
                return e.evaluateLength(evaluatedArgs)</span>
        case "UPPER":<span class="cov0" title="0">
                return e.evaluateUpper(evaluatedArgs)</span>
        case "LOWER":<span class="cov0" title="0">
                return e.evaluateLower(evaluatedArgs)</span>
        case "ABS":<span class="cov0" title="0">
                return e.evaluateAbs(evaluatedArgs)</span>
        case "ROUND":<span class="cov0" title="0">
                return e.evaluateRound(evaluatedArgs)</span>
        case "FLOOR":<span class="cov0" title="0">
                return e.evaluateFloor(evaluatedArgs)</span>
        case "CEIL":<span class="cov0" title="0">
                return e.evaluateCeil(evaluatedArgs)</span>
        case "SUBSTRING":<span class="cov0" title="0">
                return e.evaluateSubstring(evaluatedArgs)</span>
        case "TRIM":<span class="cov0" title="0">
                return e.evaluateTrim(evaluatedArgs)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("fonction non support√©e: %s", functionName)</span>
        }
}

// evaluateLength retourne la longueur d'une cha√Æne
func (e *AlphaConditionEvaluator) evaluateLength(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LENGTH() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LENGTH() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return float64(len(str)), nil</span>
}

// evaluateUpper convertit une cha√Æne en majuscules
func (e *AlphaConditionEvaluator) evaluateUpper(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("UPPER() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("UPPER() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return strings.ToUpper(str), nil</span>
}

// evaluateLower convertit une cha√Æne en minuscules
func (e *AlphaConditionEvaluator) evaluateLower(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LOWER() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LOWER() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return strings.ToLower(str), nil</span>
}

// evaluateAbs retourne la valeur absolue d'un nombre
func (e *AlphaConditionEvaluator) evaluateAbs(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ABS() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ABS() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Abs(num), nil</span>
}

// evaluateRound arrondit un nombre
func (e *AlphaConditionEvaluator) evaluateRound(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ROUND() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ROUND() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Round(num), nil</span>
}

// evaluateFloor arrondit un nombre vers le bas
func (e *AlphaConditionEvaluator) evaluateFloor(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("FLOOR() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("FLOOR() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Floor(num), nil</span>
}

// evaluateCeil arrondit un nombre vers le haut
func (e *AlphaConditionEvaluator) evaluateCeil(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CEIL() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CEIL() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Ceil(num), nil</span>
}

// evaluateSubstring extrait une sous-cha√Æne
func (e *AlphaConditionEvaluator) evaluateSubstring(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) &lt; 2 || len(args) &gt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING() attend 2 ou 3 arguments, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING() n√©cessite une cha√Æne comme premier argument, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">start, ok := args[1].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING() n√©cessite un nombre comme deuxi√®me argument, re√ßu: %T", args[1])
        }</span>

        <span class="cov0" title="0">startInt := int(start)
        if startInt &lt; 0 || startInt &gt;= len(str) </span><span class="cov0" title="0">{
                return "", nil // Retourner cha√Æne vide si index hors limites
        }</span>

        <span class="cov0" title="0">if len(args) == 3 </span><span class="cov0" title="0">{
                length, ok := args[2].(float64)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SUBSTRING() n√©cessite un nombre comme troisi√®me argument, re√ßu: %T", args[2])
                }</span>

                <span class="cov0" title="0">lengthInt := int(length)
                endInt := startInt + lengthInt
                if endInt &gt; len(str) </span><span class="cov0" title="0">{
                        endInt = len(str)
                }</span>
                <span class="cov0" title="0">return str[startInt:endInt], nil</span>
        }

        <span class="cov0" title="0">return str[startInt:], nil</span>
}

// evaluateTrim supprime les espaces en d√©but et fin
func (e *AlphaConditionEvaluator) evaluateTrim(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TRIM() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TRIM() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(str), nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package rete

import (
        "fmt"
        "regexp"
        "strings"
)

// evaluateArithmeticOperation √©value une op√©ration arithm√©tique et retourne la valeur r√©sultante
func (e *AlphaConditionEvaluator) evaluateArithmeticOperation(left interface{}, operator string, right interface{}) (interface{}, error) <span class="cov0" title="0">{
        // Normaliser les valeurs num√©riques
        leftVal := e.normalizeValue(left)
        rightVal := e.normalizeValue(right)

        // Convertir en float64 pour les calculs
        leftNum, leftOk := leftVal.(float64)
        rightNum, rightOk := rightVal.(float64)

        if !leftOk || !rightOk </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("op√©rations arithm√©tiques requi√®rent des valeurs num√©riques: gauche=%T, droite=%T", left, right)
        }</span>

        <span class="cov0" title="0">switch operator </span>{
        case "+":<span class="cov0" title="0">
                return leftNum + rightNum, nil</span>
        case "-":<span class="cov0" title="0">
                return leftNum - rightNum, nil</span>
        case "*":<span class="cov0" title="0">
                return leftNum * rightNum, nil</span>
        case "/":<span class="cov0" title="0">
                if rightNum == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("division par z√©ro")
                }</span>
                <span class="cov0" title="0">return leftNum / rightNum, nil</span>
        case "%":<span class="cov0" title="0">
                if rightNum == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("modulo par z√©ro")
                }</span>
                <span class="cov0" title="0">return float64(int64(leftNum) % int64(rightNum)), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("op√©rateur arithm√©tique non support√©: %s", operator)</span>
        }
}

// evaluateContains v√©rifie si une cha√Æne contient une sous-cha√Æne
func (e *AlphaConditionEvaluator) evaluateContains(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        leftStr, ok := left.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur CONTAINS n√©cessite une cha√Æne √† gauche, re√ßu: %T", left)
        }</span>

        <span class="cov0" title="0">rightStr, ok := right.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur CONTAINS n√©cessite une cha√Æne √† droite, re√ßu: %T", right)
        }</span>

        <span class="cov0" title="0">return strings.Contains(leftStr, rightStr), nil</span>
}

// evaluateIn v√©rifie si une valeur fait partie d'un tableau
func (e *AlphaConditionEvaluator) evaluateIn(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        // Convertir le c√¥t√© droit en slice
        var rightSlice []interface{}

        switch rightVal := right.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                rightSlice = rightVal</span>
        case []string:<span class="cov0" title="0">
                rightSlice = make([]interface{}, len(rightVal))
                for i, v := range rightVal </span><span class="cov0" title="0">{
                        rightSlice[i] = v
                }</span>
        case []int:<span class="cov0" title="0">
                rightSlice = make([]interface{}, len(rightVal))
                for i, v := range rightVal </span><span class="cov0" title="0">{
                        rightSlice[i] = v
                }</span>
        case []float64:<span class="cov0" title="0">
                rightSlice = make([]interface{}, len(rightVal))
                for i, v := range rightVal </span><span class="cov0" title="0">{
                        rightSlice[i] = v
                }</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("l'op√©rateur IN n√©cessite un tableau √† droite, re√ßu: %T", right)</span>
        }

        // V√©rifier si la valeur de gauche existe dans le tableau
        <span class="cov0" title="0">for _, item := range rightSlice </span><span class="cov0" title="0">{
                if e.areEqual(left, item) </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// evaluateLike v√©rifie si une cha√Æne correspond √† un pattern (SQL LIKE style)
func (e *AlphaConditionEvaluator) evaluateLike(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        leftStr, ok := left.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur LIKE n√©cessite une cha√Æne √† gauche, re√ßu: %T", left)
        }</span>

        <span class="cov0" title="0">rightStr, ok := right.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur LIKE n√©cessite un pattern √† droite, re√ßu: %T", right)
        }</span>

        // Convertir pattern SQL LIKE en regex Go
        // % = .* (z√©ro ou plus de caract√®res)
        // _ = . (exactement un caract√®re)

        // D'abord remplacer les caract√®res LIKE par des placeholders temporaires
        <span class="cov0" title="0">tempPattern := strings.ReplaceAll(rightStr, "%", "PERCENTPLACEHOLDER")
        tempPattern = strings.ReplaceAll(tempPattern, "_", "UNDERSCOREPLACEHOLDER")

        // √âchapper les caract√®res regex
        pattern := regexp.QuoteMeta(tempPattern)

        // Remplacer les placeholders par les √©quivalents regex
        pattern = strings.ReplaceAll(pattern, "PERCENTPLACEHOLDER", ".*")
        pattern = strings.ReplaceAll(pattern, "UNDERSCOREPLACEHOLDER", ".")
        pattern = "^" + pattern + "$"

        regex, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("pattern LIKE invalide '%s': %w", rightStr, err)
        }</span>

        <span class="cov0" title="0">return regex.MatchString(leftStr), nil</span>
}

// evaluateMatches v√©rifie si une cha√Æne correspond √† une expression r√©guli√®re
func (e *AlphaConditionEvaluator) evaluateMatches(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        leftStr, ok := left.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur MATCHES n√©cessite une cha√Æne √† gauche, re√ßu: %T", left)
        }</span>

        <span class="cov0" title="0">rightStr, ok := right.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur MATCHES n√©cessite un pattern regex √† droite, re√ßu: %T", right)
        }</span>

        <span class="cov0" title="0">regex, err := regexp.Compile(rightStr)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("pattern regex invalide '%s': %w", rightStr, err)
        }</span>

        <span class="cov0" title="0">return regex.MatchString(leftStr), nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package rete

import (
        "fmt"
        "strings"

        "github.com/treivax/tsd/constraint"
)

// evaluateValue √©value une valeur (litt√©ral, acc√®s de champ, variable)
func (e *AlphaConditionEvaluator) evaluateValue(value interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Check for nil values
        if value == nil </span><span class="cov0" title="0">{
                // Essayer d'obtenir un stacktrace pour d√©bugger
                return nil, fmt.Errorf("valeur nil re√ßue dans evaluateValue (check caller)")
        }</span>

        <span class="cov8" title="1">switch val := value.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                return e.evaluateValueFromMap(val)</span>
        case constraint.FieldAccess:<span class="cov0" title="0">
                return e.evaluateFieldAccess(val)</span>
        case constraint.Variable:<span class="cov0" title="0">
                return e.evaluateVariable(val)</span>
        case constraint.NumberLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case constraint.StringLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case constraint.BooleanLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case string:<span class="cov0" title="0">
                return val, nil</span>
        case int, int32, int64:<span class="cov0" title="0">
                return val, nil</span>
        case float32, float64:<span class="cov0" title="0">
                return val, nil</span>
        case bool:<span class="cov0" title="0">
                return val, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("type de valeur non support√©: %T", value)</span>
        }
}

// evaluateValueFromMap √©value une valeur depuis une map
func (e *AlphaConditionEvaluator) evaluateValueFromMap(val map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        valType, ok := val["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type de valeur manquant dans map: %+v", val)
        }</span>

        <span class="cov8" title="1">switch valType </span>{
        case "fieldAccess", "field_access":<span class="cov8" title="1">
                // Supporter les deux formats: object/field et variable/field
                var objectOrVariable, field string
                var ok bool

                if objectOrVariable, ok = val["object"].(string); ok </span>{<span class="cov8" title="1">
                        // Format: object + field
                }</span> else<span class="cov0" title="0"> if objectOrVariable, ok = val["variable"].(string); ok </span>{<span class="cov0" title="0">
                        // Format: variable + field
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("objet ou variable d'acc√®s de champ invalide")
                }</span>

                <span class="cov8" title="1">if field, ok = val["field"].(string); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("champ d'acc√®s invalide")
                }</span>
                <span class="cov8" title="1">return e.evaluateFieldAccessByName(objectOrVariable, field)</span>

        case "variable":<span class="cov0" title="0">
                name, ok := val["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nom de variable invalide")
                }</span>
                <span class="cov0" title="0">return e.evaluateVariableByName(name)</span>

        case "numberLiteral", "number":<span class="cov8" title="1">
                value, ok := val["value"].(float64)
                if !ok </span><span class="cov8" title="1">{
                        // Essayer aussi avec int
                        if intValue, ok := val["value"].(int); ok </span><span class="cov8" title="1">{
                                return float64(intValue), nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("valeur num√©rique invalide")</span>
                }
                <span class="cov8" title="1">return value, nil</span>

        case "stringLiteral", "string":<span class="cov8" title="1">
                value, ok := val["value"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("valeur de cha√Æne invalide")
                }</span>
                <span class="cov8" title="1">return value, nil</span>

        case "booleanLiteral", "boolean":<span class="cov0" title="0">
                value, ok := val["value"].(bool)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("valeur bool√©enne invalide")
                }</span>
                <span class="cov0" title="0">return value, nil</span>

        case "functionCall", "function_call":<span class="cov0" title="0">
                // Support des appels de fonction
                return e.evaluateFunctionCall(val)</span>

        case "arrayLiteral", "array_literal":<span class="cov0" title="0">
                // Support des litt√©raux de tableau
                elements, ok := val["elements"].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("√©l√©ments de tableau invalides")
                }</span>

                // √âvaluer chaque √©l√©ment du tableau
                <span class="cov0" title="0">evaluatedElements := make([]interface{}, len(elements))
                for i, element := range elements </span><span class="cov0" title="0">{
                        evaluatedElement, err := e.evaluateValue(element)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur √©valuation √©l√©ment tableau[%d]: %w", i, err)
                        }</span>
                        <span class="cov0" title="0">evaluatedElements[i] = evaluatedElement</span>
                }
                <span class="cov0" title="0">return evaluatedElements, nil</span>

        case "binaryOp", "binary_operation", "binaryOperation":<span class="cov0" title="0">
                // Support des op√©rations binaires
                // G√©rer les diff√©rents types d'op√©rateurs
                var operator string
                var ok bool
                if operator, ok = val["operator"].(string); !ok </span><span class="cov0" title="0">{
                        if operatorBytes, ok := val["operator"].([]uint8); ok </span><span class="cov0" title="0">{
                                operator = string(operatorBytes)
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("op√©rateur invalide dans l'op√©ration binaire: %T %+v", val["operator"], val["operator"])
                        }</span>
                }

                <span class="cov0" title="0">left, err := e.evaluateValue(val["left"])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur √©valuation c√¥t√© gauche (binaryOp %s): %w", operator, err)
                }</span>

                <span class="cov0" title="0">right, err := e.evaluateValue(val["right"])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur √©valuation c√¥t√© droit (binaryOp %s): %w", operator, err)
                }</span>

                // Distinguer les op√©rations arithm√©tiques des comparaisons
                <span class="cov0" title="0">switch operator </span>{
                case "+", "-", "*", "/", "%":<span class="cov0" title="0">
                        // Op√©ration arithm√©tique - retourne une valeur num√©rique
                        result, err := e.evaluateArithmeticOperation(left, operator, right)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur op√©ration arithm√©tique %s: %w", operator, err)
                        }</span>
                        <span class="cov0" title="0">return result, nil</span>
                case "==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;=", "CONTAINS", "IN", "LIKE", "MATCHES":<span class="cov0" title="0">
                        // Op√©ration de comparaison - retourne un bool√©en
                        return e.compareValues(left, operator, right)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("op√©rateur binaire non support√©: '%s' (bytes: %v)", operator, []byte(operator))</span>
                }

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("type de valeur non support√©: %s", valType)</span>
        }
}

// evaluateFieldAccess √©value l'acc√®s √† un champ d'une variable
func (e *AlphaConditionEvaluator) evaluateFieldAccess(fa constraint.FieldAccess) (interface{}, error) <span class="cov0" title="0">{
        return e.evaluateFieldAccessByName(fa.Object, fa.Field)
}</span>

// evaluateFieldAccessByName √©value l'acc√®s √† un champ par nom
func (e *AlphaConditionEvaluator) evaluateFieldAccessByName(object, field string) (interface{}, error) <span class="cov8" title="1">{
        fact, exists := e.variableBindings[object]
        if !exists </span><span class="cov8" title="1">{
                // En mode d'√©valuation partielle (jointures en cascade), retourner nil sans erreur
                // pour permettre l'√©valuation de continuer avec les variables disponibles
                if e.partialEvalMode </span><span class="cov8" title="1">{
                        return nil, nil // Sentinel value indiquant que la variable n'est pas encore li√©e
                }</span>
                // Debug info pour aider √† diagnostiquer les probl√®mes de binding
                <span class="cov8" title="1">availableVars := make([]string, 0, len(e.variableBindings))
                for k := range e.variableBindings </span><span class="cov8" title="1">{
                        availableVars = append(availableVars, k)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("variable non li√©e: %s (variables disponibles: %v)", object, availableVars)</span>
        }

        // Cas sp√©cial : le champ 'id' est stock√© dans fact.ID, pas dans fact.Fields
        <span class="cov8" title="1">if field == "id" </span><span class="cov8" title="1">{
                return fact.ID, nil
        }</span>

        <span class="cov8" title="1">value, exists := fact.Fields[field]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("champ inexistant: %s.%s", object, field)
        }</span>

        <span class="cov8" title="1">return value, nil</span>
}

// evaluateVariable √©value une variable
func (e *AlphaConditionEvaluator) evaluateVariable(variable constraint.Variable) (interface{}, error) <span class="cov0" title="0">{
        return e.evaluateVariableByName(variable.Name)
}</span>

// evaluateVariableByName √©value une variable par nom
func (e *AlphaConditionEvaluator) evaluateVariableByName(name string) (interface{}, error) <span class="cov0" title="0">{
        // CORRECTION: Traiter les acc√®s aux champs mal pars√©s comme "d.name"
        if strings.Contains(name, ".") </span><span class="cov0" title="0">{
                parts := strings.Split(name, ".")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        objectName := parts[0]
                        fieldName := parts[1]
                        return e.evaluateFieldAccessByName(objectName, fieldName)
                }</span>
        }

        <span class="cov0" title="0">fact, exists := e.variableBindings[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("variable non li√©e: %s", name)
        }</span>

        // Retourner le fait entier ou une repr√©sentation
        <span class="cov0" title="0">return fact, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package rete

import (
        "fmt"
        "time"
)

type Fact struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        Fields    map[string]interface{} `json:"fields"`
        Timestamp time.Time              `json:"timestamp"`
}

// String retourne la repr√©sentation string d'un fait
func (f *Fact) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Fact{ID:%s, Type:%s, Fields:%v}", f.ID, f.Type, f.Fields)
}</span>

// GetInternalID retourne l'identifiant interne unique (Type_ID)
func (f *Fact) GetInternalID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", f.Type, f.ID)
}</span>

// GetField retourne la valeur d'un champ
func (f *Fact) GetField(fieldName string) (interface{}, bool) <span class="cov8" title="1">{
        value, exists := f.Fields[fieldName]
        return value, exists
}</span>

// MakeInternalID construit un identifiant interne √† partir d'un type et d'un ID
func MakeInternalID(factType, factID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", factType, factID)
}</span>

// ParseInternalID d√©compose un identifiant interne en type et ID
// Retourne (type, id, true) si le format est valide, sinon ("", "", false)
func ParseInternalID(internalID string) (string, string, bool) <span class="cov8" title="1">{
        for i := 0; i &lt; len(internalID); i++ </span><span class="cov8" title="1">{
                if internalID[i] == '_' </span><span class="cov8" title="1">{
                        return internalID[:i], internalID[i+1:], true
                }</span>
        }
        <span class="cov8" title="1">return "", "", false</span>
}

// Token repr√©sente un token dans le r√©seau RETE
type Token struct {
        ID           string           `json:"id"`
        Facts        []*Fact          `json:"facts"`
        NodeID       string           `json:"node_id"`
        Parent       *Token           `json:"parent,omitempty"`
        Bindings     map[string]*Fact `json:"bindings,omitempty"`       // Nouveau: bindings pour jointures
        IsJoinResult bool             `json:"is_join_result,omitempty"` // Indique si c'est un token de jointure r√©ussie
}

// WorkingMemory repr√©sente la m√©moire de travail d'un n≈ìud
type WorkingMemory struct {
        NodeID string            `json:"node_id"`
        Facts  map[string]*Fact  `json:"facts"`
        Tokens map[string]*Token `json:"tokens"`
}

// AddFact ajoute un fait √† la m√©moire en utilisant un identifiant interne unique (Type_ID)
// Retourne une erreur si un fait avec le m√™me type et ID existe d√©j√†
func (wm *WorkingMemory) AddFact(fact *Fact) error <span class="cov8" title="1">{
        if wm.Facts == nil </span><span class="cov0" title="0">{
                wm.Facts = make(map[string]*Fact)
        }</span>

        // Utiliser l'identifiant interne (Type_ID) pour garantir l'unicit√© par type
        <span class="cov8" title="1">internalID := fact.GetInternalID()

        if _, exists := wm.Facts[internalID]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("fait avec ID '%s' et type '%s' existe d√©j√† dans la m√©moire", fact.ID, fact.Type)
        }</span>

        <span class="cov8" title="1">wm.Facts[internalID] = fact
        return nil</span>
}

// RemoveFact supprime un fait de la m√©moire
// factID doit √™tre l'identifiant interne (Type_ID)
func (wm *WorkingMemory) RemoveFact(factID string) <span class="cov8" title="1">{
        delete(wm.Facts, factID)
}</span>

// GetFact r√©cup√®re un fait par son identifiant interne (Type_ID)
// Pour rechercher par type et ID s√©par√©ment, utiliser GetFactByTypeAndID
func (wm *WorkingMemory) GetFact(internalID string) (*Fact, bool) <span class="cov8" title="1">{
        fact, exists := wm.Facts[internalID]
        return fact, exists
}</span>

// GetFactByInternalID r√©cup√®re un fait uniquement par son identifiant interne
func (wm *WorkingMemory) GetFactByInternalID(internalID string) (*Fact, bool) <span class="cov8" title="1">{
        fact, exists := wm.Facts[internalID]
        return fact, exists
}</span>

// GetFactByTypeAndID r√©cup√®re un fait par son type et son ID
func (wm *WorkingMemory) GetFactByTypeAndID(factType, factID string) (*Fact, bool) <span class="cov8" title="1">{
        internalID := MakeInternalID(factType, factID)
        return wm.GetFactByInternalID(internalID)
}</span>

// GetFacts retourne tous les faits de la m√©moire
func (wm *WorkingMemory) GetFacts() []*Fact <span class="cov8" title="1">{
        facts := make([]*Fact, 0, len(wm.Facts))
        for _, fact := range wm.Facts </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>
        <span class="cov8" title="1">return facts</span>
}

// AddToken ajoute un token √† la m√©moire
func (wm *WorkingMemory) AddToken(token *Token) <span class="cov8" title="1">{
        if wm.Tokens == nil </span><span class="cov0" title="0">{
                wm.Tokens = make(map[string]*Token)
        }</span>
        <span class="cov8" title="1">wm.Tokens[token.ID] = token</span>
}

// RemoveToken supprime un token de la m√©moire
func (wm *WorkingMemory) RemoveToken(tokenID string) <span class="cov0" title="0">{
        delete(wm.Tokens, tokenID)
}</span>

// GetTokens retourne tous les tokens de la m√©moire
func (wm *WorkingMemory) GetTokens() []*Token <span class="cov8" title="1">{
        tokens := make([]*Token, 0, len(wm.Tokens))
        for _, token := range wm.Tokens </span><span class="cov8" title="1">{
                tokens = append(tokens, token)
        }</span>
        <span class="cov8" title="1">return tokens</span>
}

// GetFactsByVariable retourne les faits associ√©s aux variables sp√©cifi√©es
func (wm *WorkingMemory) GetFactsByVariable(variables []string) []*Fact <span class="cov0" title="0">{
        // Pour l'instant, retourne tous les faits (impl√©mentation simplifi√©e)
        return wm.GetFacts()
}</span>

// GetTokensByVariable retourne les tokens associ√©s aux variables sp√©cifi√©es
func (wm *WorkingMemory) GetTokensByVariable(variables []string) []*Token <span class="cov0" title="0">{
        // Pour l'instant, retourne tous les tokens (impl√©mentation simplifi√©e)
        return wm.GetTokens()
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package config

import (
        "time"
)

// Config repr√©sente la configuration globale du syst√®me RETE.
type Config struct {
        Storage StorageConfig `json:"storage"`
        Network NetworkConfig `json:"network"`
        Logger  LoggerConfig  `json:"logger"`
}

// StorageConfig configuration pour le syst√®me de persistance.
type StorageConfig struct {
        Type     string        `json:"type"`     // "memory" ou "etcd"
        Endpoint string        `json:"endpoint"` // pour etcd
        Prefix   string        `json:"prefix"`   // pr√©fixe des cl√©s
        Timeout  time.Duration `json:"timeout"`
}

// NetworkConfig configuration pour le r√©seau RETE.
type NetworkConfig struct {
        MaxNodes        int           `json:"max_nodes"`
        MaxFactsPerNode int           `json:"max_facts_per_node"`
        GCInterval      time.Duration `json:"gc_interval"` // garbage collection
}

// LoggerConfig configuration pour le logging.
type LoggerConfig struct {
        Level  string `json:"level"`  // "debug", "info", "warn", "error"
        Format string `json:"format"` // "json" ou "text"
        Output string `json:"output"` // chemin fichier ou "stdout"
}

// DefaultConfig retourne la configuration par d√©faut.
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Storage: StorageConfig{
                        Type:    "memory",
                        Prefix:  "/rete/nodes",
                        Timeout: 30 * time.Second,
                },
                Network: NetworkConfig{
                        MaxNodes:        1000,
                        MaxFactsPerNode: 10000,
                        GCInterval:      5 * time.Minute,
                },
                Logger: LoggerConfig{
                        Level:  "info",
                        Format: "text",
                        Output: "stdout",
                },
        }
}</span>

// Validate v√©rifie la validit√© de la configuration.
func (c *Config) Validate() error <span class="cov0" title="0">{
        // Validation basique
        if c.Storage.Type != "memory" &amp;&amp; c.Storage.Type != "etcd" </span><span class="cov0" title="0">{
                return &amp;ValidationError{
                        Field:   "storage.type",
                        Value:   c.Storage.Type,
                        Message: "must be 'memory' or 'etcd'",
                }
        }</span>

        <span class="cov0" title="0">validLevels := map[string]bool{
                "debug": true, "info": true, "warn": true, "error": true,
        }
        if !validLevels[c.Logger.Level] </span><span class="cov0" title="0">{
                return &amp;ValidationError{
                        Field:   "logger.level",
                        Value:   c.Logger.Level,
                        Message: "must be one of: debug, info, warn, error",
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidationError repr√©sente une erreur de validation de config.
type ValidationError struct {
        Field   string
        Value   interface{}
        Message string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return "config validation error on field '" + e.Field + "': " + e.Message
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package rete

import (
        "fmt"
        "io"
        "log"
        "os"
        "sync"
)

// LogLevel repr√©sente le niveau de logging
type LogLevel int

const (
        // LogLevelSilent d√©sactive tous les logs
        LogLevelSilent LogLevel = iota
        // LogLevelError affiche uniquement les erreurs
        LogLevelError
        // LogLevelWarn affiche warnings et erreurs
        LogLevelWarn
        // LogLevelInfo affiche info, warnings et erreurs
        LogLevelInfo
        // LogLevelDebug affiche tous les logs incluant debug
        LogLevelDebug
)

// Logger est un logger configurable pour RETE
type Logger struct {
        level  LogLevel
        output io.Writer
        mu     sync.RWMutex
}

var (
        // DefaultLogger est le logger global par d√©faut
        DefaultLogger *Logger
        once          sync.Once
)

func init() <span class="cov8" title="1">{
        DefaultLogger = NewLogger(LogLevelInfo, os.Stdout)
}</span>

// NewLogger cr√©e un nouveau logger avec le niveau sp√©cifi√©
func NewLogger(level LogLevel, output io.Writer) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                level:  level,
                output: output,
        }
}</span>

// SetLevel change le niveau de logging
func (l *Logger) SetLevel(level LogLevel) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.level = level
}</span>

// GetLevel retourne le niveau de logging actuel
func (l *Logger) GetLevel() LogLevel <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        return l.level
}</span>

// Debug log un message de debug
func (l *Logger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelDebug </span><span class="cov0" title="0">{
                l.log("DEBUG", format, args...)
        }</span>
}

// Info log un message informatif
func (l *Logger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelInfo </span><span class="cov0" title="0">{
                l.log("INFO", format, args...)
        }</span>
}

// Warn log un avertissement
func (l *Logger) Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelWarn </span><span class="cov0" title="0">{
                l.log("WARN", format, args...)
        }</span>
}

// Error log une erreur
func (l *Logger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelError </span><span class="cov0" title="0">{
                l.log("ERROR", format, args...)
        }</span>
}

// log est la m√©thode interne de logging
func (l *Logger) log(level string, format string, args ...interface{}) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, args...)
        log.SetOutput(l.output)
        log.SetFlags(0) // Pas de timestamp par d√©faut pour compatibilit√© avec les tests
        log.Printf("%s", message)
}</span>

// SetGlobalLogLevel change le niveau du logger global
func SetGlobalLogLevel(level LogLevel) <span class="cov0" title="0">{
        DefaultLogger.SetLevel(level)
}</span>

// GetGlobalLogLevel retourne le niveau du logger global
func GetGlobalLogLevel() LogLevel <span class="cov0" title="0">{
        return DefaultLogger.GetLevel()
}</span>

// Helper functions pour utiliser le logger global

// Debug log un message de debug avec le logger global
func Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Debug(format, args...)
}</span>

// Info log un message informatif avec le logger global
func Info(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Info(format, args...)
}</span>

// Warn log un avertissement avec le logger global
func Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Warn(format, args...)
}</span>

// Error log une erreur avec le logger global
func Error(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Error(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package rete

import (
        "fmt"
)

// ReteNetwork repr√©sente le r√©seau RETE complet
type ReteNetwork struct {
        RootNode      *RootNode                `json:"root_node"`
        TypeNodes     map[string]*TypeNode     `json:"type_nodes"`
        AlphaNodes    map[string]*AlphaNode    `json:"alpha_nodes"`
        BetaNodes     map[string]interface{}   `json:"beta_nodes"` // N≈ìuds Beta pour les jointures multi-faits
        TerminalNodes map[string]*TerminalNode `json:"terminal_nodes"`
        Storage       Storage                  `json:"-"`
        Types         []TypeDefinition         `json:"types"`
        BetaBuilder   interface{}              `json:"-"` // Constructeur de r√©seau Beta
}

// NewReteNetwork cr√©e un nouveau r√©seau RETE
func NewReteNetwork(storage Storage) *ReteNetwork <span class="cov8" title="1">{
        rootNode := NewRootNode(storage)

        return &amp;ReteNetwork{
                RootNode:      rootNode,
                TypeNodes:     make(map[string]*TypeNode),
                AlphaNodes:    make(map[string]*AlphaNode),
                BetaNodes:     make(map[string]interface{}),
                TerminalNodes: make(map[string]*TerminalNode),
                Storage:       storage,
                Types:         make([]TypeDefinition, 0),
                BetaBuilder:   nil, // Sera initialis√© si n√©cessaire
        }
}</span>

// SubmitFact soumet un nouveau fait au r√©seau
func (rn *ReteNetwork) SubmitFact(fact *Fact) error <span class="cov8" title="1">{
        fmt.Printf("üî• Soumission d'un nouveau fait au r√©seau RETE: %s\n", fact.String())

        // Propager le fait depuis le n≈ìud racine
        return rn.RootNode.ActivateRight(fact)
}</span>

// SubmitFactsFromGrammar soumet plusieurs faits depuis la grammaire au r√©seau
func (rn *ReteNetwork) SubmitFactsFromGrammar(facts []map[string]interface{}) error <span class="cov0" title="0">{
        for i, factMap := range facts </span><span class="cov0" title="0">{
                // Convertir le map en Fact
                factID := fmt.Sprintf("fact_%d", i)
                if id, ok := factMap["id"].(string); ok </span><span class="cov0" title="0">{
                        factID = id
                }</span>

                <span class="cov0" title="0">factType := "unknown"
                if typ, ok := factMap["type"].(string); ok </span><span class="cov0" title="0">{
                        factType = typ
                }</span>

                <span class="cov0" title="0">fact := &amp;Fact{
                        ID:     factID,
                        Type:   factType,
                        Fields: make(map[string]interface{}),
                }

                // Copier tous les champs
                for key, value := range factMap </span><span class="cov0" title="0">{
                        if key != "id" &amp;&amp; key != "type" </span><span class="cov0" title="0">{
                                fact.Fields[key] = value
                        }</span>
                }

                <span class="cov0" title="0">if err := rn.SubmitFact(fact); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur soumission fait %s: %w", fact.ID, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RetractFact retire un fait du r√©seau et propage la r√©tractation
// factID doit √™tre l'identifiant interne (Type_ID)
func (rn *ReteNetwork) RetractFact(factID string) error <span class="cov8" title="1">{
        fmt.Printf("üóëÔ∏è  R√©tractation du fait: %s\n", factID)

        // V√©rifier que le fait existe dans le r√©seau
        memory := rn.RootNode.GetMemory()
        if _, exists := memory.GetFact(factID); !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("fait %s introuvable dans le r√©seau", factID)
        }</span>

        // Propager la r√©tractation depuis le n≈ìud racine
        <span class="cov8" title="1">return rn.RootNode.ActivateRetract(factID)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package rete

import (
        "fmt"
        "math"
        "sync"
)

type AccumulatorNode struct {
        BaseNode
        AggregateFunc string                 `json:"aggregate_func"` // "AVG", "SUM", "COUNT", "MIN", "MAX"
        MainVariable  string                 `json:"main_variable"`  // Variable principale (ex: "e")
        MainType      string                 `json:"main_type"`      // Type principal (ex: "Employee")
        AggVariable   string                 `json:"agg_variable"`   // Variable √† agr√©ger (ex: "p")
        AggType       string                 `json:"agg_type"`       // Type √† agr√©ger (ex: "Performance")
        Field         string                 `json:"field"`          // Champ √† agr√©ger (ex: "score"), vide pour COUNT
        JoinField     string                 `json:"join_field"`     // Champ de jointure (ex: "employee_id")
        MainField     string                 `json:"main_field"`     // Champ principal pour jointure (ex: "id")
        Condition     map[string]interface{} `json:"condition"`      // Condition de comparaison du r√©sultat
        MainFacts     map[string]*Fact       `json:"-"`              // Faits principaux index√©s par ID
        AllFacts      map[string]*Fact       `json:"-"`              // Tous les faits (principaux + agr√©g√©s) par ID
        mutex         sync.RWMutex
}

// NewAccumulatorNode cr√©e un nouveau n≈ìud d'agr√©gation
func NewAccumulatorNode(id string, mainVar, mainType, aggVar, aggType, field, joinField, mainField, aggregateFunc string, condition map[string]interface{}, storage Storage) *AccumulatorNode <span class="cov8" title="1">{
        return &amp;AccumulatorNode{
                BaseNode: BaseNode{
                        ID:       id,
                        Type:     "accumulator",
                        Children: make([]Node, 0),
                        Memory:   &amp;WorkingMemory{Tokens: make(map[string]*Token), Facts: make(map[string]*Fact)},
                },
                AggregateFunc: aggregateFunc,
                MainVariable:  mainVar,
                MainType:      mainType,
                AggVariable:   aggVar,
                AggType:       aggType,
                Field:         field,
                JoinField:     joinField,
                MainField:     mainField,
                Condition:     condition,
                MainFacts:     make(map[string]*Fact),
                AllFacts:      make(map[string]*Fact),
        }
}</span>

// Activate traite un fait dans le n≈ìud d'agr√©gation
func (an *AccumulatorNode) Activate(fact *Fact, token *Token) error <span class="cov8" title="1">{
        an.mutex.Lock()
        defer an.mutex.Unlock()

        // Stocker tous les faits
        an.AllFacts[fact.ID] = fact

        // Si c'est un fait principal, stocker et calculer l'agr√©gation
        if fact.Type == an.MainType </span><span class="cov8" title="1">{
                an.MainFacts[fact.ID] = fact
                fmt.Printf("üìä ACCUMULATOR[%s]: Fait principal re√ßu %s\n", an.ID, fact.ID)

                // Calculer l'agr√©gation pour ce fait principal
                return an.processMainFact(fact)
        }</span>

        // Si c'est un fait √† agr√©ger, recalculer pour tous les faits principaux
        <span class="cov8" title="1">if fact.Type == an.AggType </span><span class="cov8" title="1">{
                fmt.Printf("üìä ACCUMULATOR[%s]: Fait agr√©g√© re√ßu %s\n", an.ID, fact.ID)
                // Recalculer pour tous les faits principaux existants
                for _, mainFact := range an.MainFacts </span><span class="cov8" title="1">{
                        if err := an.processMainFact(mainFact); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("‚ö†Ô∏è  ACCUMULATOR[%s]: Erreur recalcul pour %s: %v\n", an.ID, mainFact.ID, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// processMainFact calcule l'agr√©gation pour un fait principal donn√©
func (an *AccumulatorNode) processMainFact(mainFact *Fact) error <span class="cov8" title="1">{
        // Collecter les faits √† agr√©ger qui correspondent √† ce fait principal
        aggregatedFacts := an.collectAggregatedFacts(mainFact)

        fmt.Printf("üìä ACCUMULATOR[%s]: %d faits agr√©g√©s trouv√©s pour %s\n", an.ID, len(aggregatedFacts), mainFact.ID)

        // Calculer l'agr√©gation
        aggregatedValue, err := an.calculateAggregateForFacts(aggregatedFacts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur calcul agr√©gation: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("üìä ACCUMULATOR[%s]: Valeur agr√©g√©e = %.2f pour %s\n", an.ID, aggregatedValue, mainFact.ID)

        // √âvaluer la condition
        satisfied, err := an.evaluateCondition(aggregatedValue)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur √©valuation condition agr√©gation: %w", err)
        }</span>

        <span class="cov8" title="1">if satisfied </span><span class="cov8" title="1">{
                fmt.Printf("‚úÖ ACCUMULATOR[%s]: Condition satisfaite (%.2f) pour %s\n", an.ID, aggregatedValue, mainFact.ID)

                // Cr√©er un token avec le fait et le r√©sultat de l'agr√©gation
                newToken := &amp;Token{
                        ID:       fmt.Sprintf("accum_%s", mainFact.ID),
                        Facts:    []*Fact{mainFact},
                        Bindings: map[string]*Fact{an.MainVariable: mainFact},
                }
                an.Memory.AddToken(newToken)

                // Propager aux enfants - ne passer que le token, pas le fait
                // car TerminalNode ne veut que des tokens
                return an.PropagateToChildren(nil, newToken)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("‚ùå ACCUMULATOR[%s]: Condition NON satisfaite (%.2f) pour %s\n", an.ID, aggregatedValue, mainFact.ID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// collectAggregatedFacts collecte les faits √† agr√©ger pour un fait principal
func (an *AccumulatorNode) collectAggregatedFacts(mainFact *Fact) []*Fact <span class="cov8" title="1">{
        collected := make([]*Fact, 0)

        // Obtenir la valeur du champ de jointure du fait principal
        mainValue, exists := mainFact.Fields[an.MainField]
        if !exists </span><span class="cov8" title="1">{
                // Essayer aussi dans fact.ID si c'est le champ "id"
                if an.MainField == "id" </span><span class="cov8" title="1">{
                        mainValue = mainFact.ID
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚ö†Ô∏è  ACCUMULATOR[%s]: Champ principal %s non trouv√© dans %s\n", an.ID, an.MainField, mainFact.ID)
                        return collected
                }</span>
        }

        // Parcourir tous les faits pour trouver ceux qui correspondent
        <span class="cov8" title="1">for _, fact := range an.AllFacts </span><span class="cov8" title="1">{
                if fact.Type == an.AggType </span><span class="cov8" title="1">{
                        // V√©rifier la condition de jointure
                        joinValue, exists := fact.Fields[an.JoinField]
                        if exists &amp;&amp; joinValue == mainValue </span><span class="cov8" title="1">{
                                collected = append(collected, fact)
                        }</span>
                }
        }

        <span class="cov8" title="1">return collected</span>
}

// calculateAggregateForFacts calcule la valeur agr√©g√©e pour une liste de faits
func (an *AccumulatorNode) calculateAggregateForFacts(facts []*Fact) (float64, error) <span class="cov8" title="1">{
        if len(facts) == 0 </span><span class="cov8" title="1">{
                // Pas de faits √† agr√©ger - retourner 0
                return 0, nil
        }</span>

        <span class="cov8" title="1">switch an.AggregateFunc </span>{
        case "COUNT":<span class="cov8" title="1">
                return float64(len(facts)), nil</span>

        case "SUM":<span class="cov8" title="1">
                sum := 0.0
                for _, f := range facts </span><span class="cov8" title="1">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov8" title="1">{
                                if numVal, ok := val.(float64); ok </span><span class="cov8" title="1">{
                                        sum += numVal
                                }</span>
                        }
                }
                <span class="cov8" title="1">return sum, nil</span>

        case "AVG":<span class="cov8" title="1">
                sum := 0.0
                count := 0
                for _, f := range facts </span><span class="cov8" title="1">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov8" title="1">{
                                if numVal, ok := val.(float64); ok </span><span class="cov8" title="1">{
                                        sum += numVal
                                        count++
                                }</span>
                        }
                }
                <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov8" title="1">return sum / float64(count), nil</span>

        case "MIN":<span class="cov8" title="1">
                minVal := math.MaxFloat64
                for _, f := range facts </span><span class="cov8" title="1">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov8" title="1">{
                                if numVal, ok := val.(float64); ok </span><span class="cov8" title="1">{
                                        if numVal &lt; minVal </span><span class="cov8" title="1">{
                                                minVal = numVal
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">if minVal == math.MaxFloat64 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov8" title="1">return minVal, nil</span>

        case "MAX":<span class="cov8" title="1">
                maxVal := -math.MaxFloat64
                for _, f := range facts </span><span class="cov8" title="1">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov8" title="1">{
                                if numVal, ok := val.(float64); ok </span><span class="cov8" title="1">{
                                        if numVal &gt; maxVal </span><span class="cov8" title="1">{
                                                maxVal = numVal
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">if maxVal == -math.MaxFloat64 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov8" title="1">return maxVal, nil</span>

        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("fonction d'agr√©gation non support√©e: %s", an.AggregateFunc)</span>
        }
}

// ActivateLeft traite un token venant de la gauche (compatible avec interface Node)
func (an *AccumulatorNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        // Pour AccumulatorNode, on traite le premier fait du token
        if len(token.Facts) &gt; 0 </span><span class="cov0" title="0">{
                return an.Activate(token.Facts[0], token)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ActivateRight traite un fait venant de la droite
func (an *AccumulatorNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        return an.Activate(fact, nil)
}</span>

// evaluateCondition √©value si la valeur agr√©g√©e satisfait la condition
func (an *AccumulatorNode) evaluateCondition(aggregatedValue float64) (bool, error) <span class="cov8" title="1">{
        if an.Condition == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov8" title="1">condType, ok := an.Condition["type"].(string)
        if !ok || condType != "comparison" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("type de condition invalide")
        }</span>

        <span class="cov8" title="1">operator, ok := an.Condition["operator"].(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("op√©rateur manquant")
        }</span>

        <span class="cov8" title="1">threshold, ok := an.Condition["value"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("valeur de comparaison invalide")
        }</span>

        <span class="cov8" title="1">switch operator </span>{
        case "&gt;=":<span class="cov8" title="1">
                return aggregatedValue &gt;= threshold, nil</span>
        case "&gt;":<span class="cov0" title="0">
                return aggregatedValue &gt; threshold, nil</span>
        case "&lt;=":<span class="cov0" title="0">
                return aggregatedValue &lt;= threshold, nil</span>
        case "&lt;":<span class="cov0" title="0">
                return aggregatedValue &lt; threshold, nil</span>
        case "==":<span class="cov0" title="0">
                return aggregatedValue == threshold, nil</span>
        case "!=":<span class="cov0" title="0">
                return aggregatedValue != threshold, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("op√©rateur non support√©: %s", operator)</span>
        }
}

// ActivateRetract g√®re la r√©tractation dans le n≈ìud d'agr√©gation
func (an *AccumulatorNode) ActivateRetract(factID string) error <span class="cov0" title="0">{
        an.mutex.Lock()
        defer an.mutex.Unlock()

        // Retirer des faits principaux et de tous les faits
        delete(an.MainFacts, factID)
        delete(an.AllFacts, factID)

        // Retirer des tokens
        an.Memory.RemoveToken(factID)

        fmt.Printf("üóëÔ∏è  [ACCUMULATOR_%s] R√©tractation: fait %s retir√©\n", an.ID, factID)
        return an.PropagateRetractToChildren(factID)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package rete

import (
        "fmt"
)

type AlphaNode struct {
        BaseNode
        Condition    interface{} `json:"condition"`
        VariableName string      `json:"variable_name"`
}

// NewAlphaNode cr√©e un nouveau n≈ìud alpha
func NewAlphaNode(nodeID string, condition interface{}, variableName string, storage Storage) *AlphaNode <span class="cov8" title="1">{
        return &amp;AlphaNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "alpha",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:    condition,
                VariableName: variableName,
        }
}</span>

// ActivateLeft (non utilis√© pour les n≈ìuds alpha)
func (an *AlphaNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds alpha ne re√ßoivent pas de tokens")
}</span>

// ActivateRetract retire le fait de la m√©moire alpha et propage aux enfants
// factID doit √™tre l'identifiant interne (Type_ID)
func (an *AlphaNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        an.mutex.Lock()
        _, exists := an.Memory.GetFact(factID)
        if exists </span><span class="cov8" title="1">{
                an.Memory.RemoveFact(factID)
        }</span>
        <span class="cov8" title="1">an.mutex.Unlock()
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">fmt.Printf("üóëÔ∏è  [ALPHA_%s] R√©tractation du fait: %s\n", an.ID, factID)
        return an.PropagateRetractToChildren(factID)</span>
}

// ActivateRight teste la condition sur le fait
func (an *AlphaNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ALPHA_%s] Test condition sur fait: %s\n", an.ID, fact.String())

        // Cas sp√©cial: passthrough pour les JoinNodes - pas de filtrage
        if an.Condition != nil </span><span class="cov8" title="1">{
                if condMap, ok := an.Condition.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if condType, exists := condMap["type"].(string); exists &amp;&amp; condType == "passthrough" </span><span class="cov8" title="1">{
                                // Mode pass-through: convertir le fait en token et propager selon le c√¥t√©
                                an.mutex.Lock()
                                if err := an.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                                        an.mutex.Unlock()
                                        return fmt.Errorf("erreur ajout fait dans alpha node: %w", err)
                                }</span>
                                <span class="cov8" title="1">an.mutex.Unlock() // Cr√©er un token pour le fait avec la variable correspondante
                                token := &amp;Token{
                                        ID:       fmt.Sprintf("alpha_token_%s_%s", an.ID, fact.ID),
                                        Facts:    []*Fact{fact},
                                        NodeID:   an.ID,
                                        Bindings: map[string]*Fact{an.VariableName: fact},
                                }

                                // D√©terminer le c√¥t√© et propager selon l'architecture RETE
                                side, sideExists := condMap["side"].(string)
                                if sideExists &amp;&amp; side == "left" </span><span class="cov8" title="1">{
                                        return an.PropagateToChildren(nil, token) // ActivateLeft
                                }</span> else<span class="cov8" title="1"> {
                                        return an.PropagateToChildren(fact, nil) // ActivateRight
                                }</span>
                        }
                }
        }

        // √âvaluation normale de condition Alpha
        <span class="cov0" title="0">if an.Condition != nil </span><span class="cov0" title="0">{
                evaluator := NewAlphaConditionEvaluator()
                passed, err := evaluator.EvaluateCondition(an.Condition, fact, an.VariableName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur √©valuation condition Alpha: %w", err)
                }</span>

                // Si la condition n'est pas satisfaite, ignorer le fait
                <span class="cov0" title="0">if !passed </span><span class="cov0" title="0">{
                        // Log d√©sactiv√© pour les performances
                        // fmt.Printf("[ALPHA_%s] Condition non satisfaite pour le fait: %s\n", an.ID, fact.String())
                        return nil
                }</span>
        }

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ALPHA_%s] Condition satisfaite pour le fait: %s\n", an.ID, fact.String())

        <span class="cov0" title="0">an.mutex.Lock()
        if err := an.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                an.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans alpha node: %w", err)
        }</span>
        <span class="cov0" title="0">an.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // Cr√©er un token et le propager
        token := &amp;Token{
                ID:     fmt.Sprintf("token_%s_%s", an.ID, fact.ID),
                Facts:  []*Fact{fact},
                NodeID: an.ID,
        }

        return an.PropagateToChildren(nil, token)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package rete

import (
        "fmt"
        "sync"
)

type BaseNode struct {
        ID       string         `json:"id"`
        Type     string         `json:"type"`
        Memory   *WorkingMemory `json:"memory"`
        Children []Node         `json:"children"`
        Storage  Storage        `json:"-"`
        mutex    sync.RWMutex   `json:"-"`
}

// GetID retourne l'ID du n≈ìud
func (bn *BaseNode) GetID() string <span class="cov8" title="1">{
        return bn.ID
}</span>

// GetType retourne le type du n≈ìud
func (bn *BaseNode) GetType() string <span class="cov0" title="0">{
        return bn.Type
}</span>

// GetMemory retourne la m√©moire de travail du n≈ìud
func (bn *BaseNode) GetMemory() *WorkingMemory <span class="cov8" title="1">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()
        return bn.Memory
}</span>

// AddChild ajoute un n≈ìud enfant
func (bn *BaseNode) AddChild(child Node) <span class="cov8" title="1">{
        bn.mutex.Lock()
        defer bn.mutex.Unlock()
        bn.Children = append(bn.Children, child)
}</span>

// GetChildren retourne les n≈ìuds enfants
func (bn *BaseNode) GetChildren() []Node <span class="cov8" title="1">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()
        return bn.Children
}</span>

// PropagateToChildren propage un fait ou token aux enfants
func (bn *BaseNode) PropagateToChildren(fact *Fact, token *Token) error <span class="cov8" title="1">{
        for _, child := range bn.GetChildren() </span><span class="cov8" title="1">{
                if fact != nil </span><span class="cov8" title="1">{
                        if err := child.ActivateRight(fact); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation fait vers %s: %w", child.GetID(), err)
                        }</span>
                }
                <span class="cov8" title="1">if token != nil </span><span class="cov8" title="1">{
                        if err := child.ActivateLeft(token); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation token vers %s: %w", child.GetID(), err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// PropagateRetractToChildren propage la r√©tractation d'un fait aux n≈ìuds enfants
func (bn *BaseNode) PropagateRetractToChildren(factID string) error <span class="cov8" title="1">{
        for _, child := range bn.GetChildren() </span><span class="cov8" title="1">{
                if err := child.ActivateRetract(factID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur propagation r√©tractation vers %s: %w", child.GetID(), err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SaveMemory sauvegarde la m√©moire du n≈ìud
func (bn *BaseNode) SaveMemory() error <span class="cov0" title="0">{
        if bn.Storage != nil </span><span class="cov0" title="0">{
                return bn.Storage.SaveMemory(bn.ID, bn.Memory)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package rete

import (
        "fmt"
        "sync"
)

type ExistsNode struct {
        BaseNode
        Condition       map[string]interface{} `json:"condition"`
        MainVariable    string                 `json:"main_variable"`    // Variable principale (p)
        ExistsVariable  string                 `json:"exists_variable"`  // Variable d'existence (o)
        VariableTypes   map[string]string      `json:"variable_types"`   // Mapping variable -&gt; type
        ExistsCondition []JoinCondition        `json:"exists_condition"` // Condition d'existence (o.customer_id == p.id)
        mutex           sync.RWMutex
        // M√©moires pour architecture RETE
        MainMemory   *WorkingMemory // Faits de la variable principale
        ExistsMemory *WorkingMemory // Faits pour v√©rification d'existence
        ResultMemory *WorkingMemory // Tokens avec existence v√©rifi√©e
}

// NewExistsNode cr√©e un nouveau n≈ìud d'existence
func NewExistsNode(nodeID string, condition map[string]interface{}, mainVar string, existsVar string, varTypes map[string]string, storage Storage) *ExistsNode <span class="cov8" title="1">{
        return &amp;ExistsNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "exists",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:       condition,
                MainVariable:    mainVar,
                ExistsVariable:  existsVar,
                VariableTypes:   varTypes,
                ExistsCondition: extractJoinConditions(condition),
                // Initialiser les m√©moires s√©par√©es
                MainMemory:   &amp;WorkingMemory{NodeID: nodeID + "_main", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                ExistsMemory: &amp;WorkingMemory{NodeID: nodeID + "_exists", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                ResultMemory: &amp;WorkingMemory{NodeID: nodeID + "_result", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
        }
}</span>

// ActivateLeft traite les faits de la variable principale
func (en *ExistsNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{

        // Stocker le token dans la m√©moire principale
        en.mutex.Lock()
        en.MainMemory.AddToken(token)
        en.mutex.Unlock()

        // V√©rifier s'il existe des faits correspondants
        if en.checkExistence(token) </span><span class="cov0" title="0">{

                // Stocker le token avec existence v√©rifi√©e
                token.IsJoinResult = true // Marquer comme r√©sultat valid√©
                en.mutex.Lock()
                en.ResultMemory.AddToken(token)
                en.Memory.AddToken(token) // Pour compatibilit√© avec le comptage
                en.mutex.Unlock()

                // Propager le token
                if err := en.PropagateToChildren(nil, token); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else <span class="cov0" title="0">{
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ActivateRetract retrait des tokens et faits contenant le fait r√©tract√©
// factID doit √™tre l'identifiant interne (Type_ID)
func (en *ExistsNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        en.mutex.Lock()
        var mainTokensToRemove []string
        for tokenID, token := range en.MainMemory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                mainTokensToRemove = append(mainTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range mainTokensToRemove </span><span class="cov0" title="0">{
                delete(en.MainMemory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">_, existsInExistsMemory := en.ExistsMemory.GetFact(factID)
        if existsInExistsMemory </span><span class="cov8" title="1">{
                en.ExistsMemory.RemoveFact(factID)
        }</span>
        <span class="cov8" title="1">var resultTokensToRemove []string
        for tokenID, token := range en.ResultMemory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                resultTokensToRemove = append(resultTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range resultTokensToRemove </span><span class="cov0" title="0">{
                delete(en.ResultMemory.Tokens, tokenID)
                delete(en.Memory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">en.mutex.Unlock()
        totalRemoved := len(mainTokensToRemove) + len(resultTokensToRemove)
        if existsInExistsMemory </span><span class="cov8" title="1">{
                totalRemoved++
        }</span>
        <span class="cov8" title="1">if totalRemoved &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("üóëÔ∏è  [EXISTS_%s] R√©tractation: %d √©l√©ments retir√©s (MAIN:%d EXISTS:%v RES:%d)\n", en.ID, totalRemoved, len(mainTokensToRemove), existsInExistsMemory, len(resultTokensToRemove))
        }</span>
        <span class="cov8" title="1">return en.PropagateRetractToChildren(factID)</span>
}

// ActivateRight traite les faits pour v√©rification d'existence
func (en *ExistsNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{

        // Stocker le fait dans la m√©moire d'existence
        en.mutex.Lock()
        if err := en.ExistsMemory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                en.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans exists node: %w", err)
        }</span>
        <span class="cov0" title="0">en.mutex.Unlock()

        // Re-v√©rifier tous les tokens principaux avec ce nouveau fait
        mainTokens := en.MainMemory.GetTokens()
        for _, mainToken := range mainTokens </span><span class="cov0" title="0">{
                if en.checkExistence(mainToken) &amp;&amp; !en.isAlreadyValidated(mainToken) </span><span class="cov0" title="0">{

                        // Stocker le token avec existence v√©rifi√©e
                        validatedToken := &amp;Token{
                                ID:           mainToken.ID + "_validated",
                                Facts:        mainToken.Facts,
                                NodeID:       en.ID,
                                Bindings:     mainToken.Bindings,
                                IsJoinResult: true,
                        }

                        en.mutex.Lock()
                        en.ResultMemory.AddToken(validatedToken)
                        en.Memory.AddToken(validatedToken)
                        en.mutex.Unlock()

                        // Propager le token
                        if err := en.PropagateToChildren(nil, validatedToken); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// checkExistence v√©rifie si un token principal a des faits correspondants
func (en *ExistsNode) checkExistence(mainToken *Token) bool <span class="cov0" title="0">{
        existsFacts := en.ExistsMemory.GetFacts()

        // R√©cup√©rer le fait principal du token
        if len(mainToken.Facts) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">mainFact := mainToken.Facts[0]

        // V√©rifier les conditions d'existence
        for _, existsFact := range existsFacts </span><span class="cov0" title="0">{
                if en.evaluateExistsCondition(mainFact, existsFact) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// evaluateExistsCondition √©value la condition d'existence entre deux faits
func (en *ExistsNode) evaluateExistsCondition(mainFact *Fact, existsFact *Fact) bool <span class="cov0" title="0">{

        for i, condition := range en.ExistsCondition </span><span class="cov0" title="0">{
                fmt.Printf("    Condition %d: %s.%s %s %s.%s\n", i,
                        condition.LeftVar, condition.LeftField, condition.Operator,
                        condition.RightVar, condition.RightField)

                // D√©terminer quel fait correspond √† quelle variable
                var leftFact, rightFact *Fact

                if condition.LeftVar == en.MainVariable </span><span class="cov0" title="0">{
                        leftFact = mainFact
                        rightFact = existsFact
                        fmt.Printf("    ‚Üí MainFact comme LeftVar (%s), ExistsFact comme RightVar (%s)\n", condition.LeftVar, condition.RightVar)
                }</span> else<span class="cov0" title="0"> if condition.LeftVar == en.ExistsVariable </span><span class="cov0" title="0">{
                        leftFact = existsFact
                        rightFact = mainFact
                        fmt.Printf("    ‚Üí ExistsFact comme LeftVar (%s), MainFact comme RightVar (%s)\n", condition.LeftVar, condition.RightVar)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("    ‚ùå Variable %s non trouv√©e dans MainVariable:%s ou ExistsVariable:%s\n", condition.LeftVar, en.MainVariable, en.ExistsVariable)
                        continue</span>
                }

                <span class="cov0" title="0">leftValue := leftFact.Fields[condition.LeftField]
                rightValue := rightFact.Fields[condition.RightField]

                switch condition.Operator </span>{
                case "==":<span class="cov0" title="0">
                        if leftValue != rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("    ‚ùå Condition %d √©choue: %v != %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("    ‚úÖ Condition %d r√©ussie: %v == %v\n", i, leftValue, rightValue)</span>
                case "!=":<span class="cov0" title="0">
                        if leftValue == rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("    ‚ùå Condition %d √©choue: %v == %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("    ‚úÖ Condition %d r√©ussie: %v != %v\n", i, leftValue, rightValue)</span>
                default:<span class="cov0" title="0">
                        fmt.Printf("    ‚ùå Op√©rateur non support√©: %s\n", condition.Operator)
                        return false</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("  ‚úÖ Toutes les conditions EXISTS satisfaites\n")
        return true</span>
}

// isAlreadyValidated v√©rifie si un token a d√©j√† √©t√© valid√©
func (en *ExistsNode) isAlreadyValidated(token *Token) bool <span class="cov0" title="0">{
        validatedTokens := en.ResultMemory.GetTokens()
        for _, validatedToken := range validatedTokens </span><span class="cov0" title="0">{
                if validatedToken.ID == token.ID+"_validated" || validatedToken.ID == token.ID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package rete

import (
        "fmt"
        "strconv"
        "sync"
)

type JoinNode struct {
        BaseNode
        Condition      map[string]interface{} `json:"condition"`
        LeftVariables  []string               `json:"left_variables"`
        RightVariables []string               `json:"right_variables"`
        AllVariables   []string               `json:"all_variables"`
        VariableTypes  map[string]string      `json:"variable_types"` // Nouveau: mapping variable -&gt; type
        JoinConditions []JoinCondition        `json:"join_conditions"`
        mutex          sync.RWMutex
        // M√©moires s√©par√©es pour architecture RETE propre
        LeftMemory   *WorkingMemory // Tokens venant de la gauche
        RightMemory  *WorkingMemory // Tokens venant de la droite
        ResultMemory *WorkingMemory // Tokens de jointure r√©ussie
}

// JoinCondition repr√©sente une condition de jointure entre variables
type JoinCondition struct {
        LeftField  string `json:"left_field"`  // p.id
        RightField string `json:"right_field"` // o.customer_id
        LeftVar    string `json:"left_var"`    // p
        RightVar   string `json:"right_var"`   // o
        Operator   string `json:"operator"`    // ==
}

// NewJoinNode cr√©e un nouveau n≈ìud de jointure
func NewJoinNode(nodeID string, condition map[string]interface{}, leftVars []string, rightVars []string, varTypes map[string]string, storage Storage) *JoinNode <span class="cov8" title="1">{
        allVars := append(leftVars, rightVars...)

        return &amp;JoinNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "join",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:      condition,
                LeftVariables:  leftVars,
                RightVariables: rightVars,
                AllVariables:   allVars,
                VariableTypes:  varTypes,
                JoinConditions: extractJoinConditions(condition),
                // Initialiser les m√©moires s√©par√©es
                LeftMemory:   &amp;WorkingMemory{NodeID: nodeID + "_left", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                RightMemory:  &amp;WorkingMemory{NodeID: nodeID + "_right", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                ResultMemory: &amp;WorkingMemory{NodeID: nodeID + "_result", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
        }
}</span>

// ActivateLeft traite les tokens de la gauche (g√©n√©ralement des AlphaNodes)
func (jn *JoinNode) ActivateLeft(token *Token) error <span class="cov8" title="1">{
        // Stocker le token dans la m√©moire gauche
        jn.mutex.Lock()
        jn.LeftMemory.AddToken(token)
        jn.mutex.Unlock()

        // Essayer de joindre avec tous les tokens de la m√©moire droite
        rightTokens := jn.RightMemory.GetTokens()

        for _, rightToken := range rightTokens </span><span class="cov8" title="1">{
                if joinedToken := jn.performJoinWithTokens(token, rightToken); joinedToken != nil </span><span class="cov8" title="1">{

                        // Stocker uniquement les tokens de jointure r√©ussie
                        joinedToken.IsJoinResult = true
                        jn.mutex.Lock()
                        jn.ResultMemory.AddToken(joinedToken)
                        jn.Memory.AddToken(joinedToken) // Pour compatibilit√© avec le comptage
                        jn.mutex.Unlock()

                        if err := jn.PropagateToChildren(nil, joinedToken); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ActivateRetract retrait des tokens contenant le fait r√©tract√© des 3 m√©moires
// factID doit √™tre l'identifiant interne (Type_ID)
func (jn *JoinNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        jn.mutex.Lock()
        var leftTokensToRemove []string
        for tokenID, token := range jn.LeftMemory.Tokens </span><span class="cov8" title="1">{
                for _, fact := range token.Facts </span><span class="cov8" title="1">{
                        if fact.GetInternalID() == factID </span><span class="cov8" title="1">{
                                leftTokensToRemove = append(leftTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range leftTokensToRemove </span><span class="cov8" title="1">{
                delete(jn.LeftMemory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">var rightTokensToRemove []string
        for tokenID, token := range jn.RightMemory.Tokens </span><span class="cov8" title="1">{
                for _, fact := range token.Facts </span><span class="cov8" title="1">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                rightTokensToRemove = append(rightTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range rightTokensToRemove </span><span class="cov0" title="0">{
                delete(jn.RightMemory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">var resultTokensToRemove []string
        for tokenID, token := range jn.ResultMemory.Tokens </span><span class="cov8" title="1">{
                for _, fact := range token.Facts </span><span class="cov8" title="1">{
                        if fact.GetInternalID() == factID </span><span class="cov8" title="1">{
                                resultTokensToRemove = append(resultTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range resultTokensToRemove </span><span class="cov8" title="1">{
                delete(jn.ResultMemory.Tokens, tokenID)
                delete(jn.Memory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">jn.mutex.Unlock()
        totalRemoved := len(leftTokensToRemove) + len(rightTokensToRemove) + len(resultTokensToRemove)
        if totalRemoved &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("üóëÔ∏è  [JOIN_%s] R√©tractation: %d tokens retir√©s (L:%d R:%d RES:%d)\n", jn.ID, totalRemoved, len(leftTokensToRemove), len(rightTokensToRemove), len(resultTokensToRemove))
        }</span>
        <span class="cov8" title="1">return jn.PropagateRetractToChildren(factID)</span>
}

// ActivateRight traite les faits de la droite (nouveau fait inject√© via AlphaNode)
func (jn *JoinNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // Convertir le fait en token pour la m√©moire droite
        factVar := jn.getVariableForFact(fact)
        if factVar == "" </span><span class="cov0" title="0">{
                return nil // Fait non applicable √† ce JoinNode
        }</span>

        <span class="cov8" title="1">factToken := &amp;Token{
                ID:       fmt.Sprintf("right_token_%s_%s", jn.ID, fact.ID),
                Facts:    []*Fact{fact},
                NodeID:   jn.ID,
                Bindings: map[string]*Fact{factVar: fact},
        }

        // Stocker le token dans la m√©moire droite
        jn.mutex.Lock()
        jn.RightMemory.AddToken(factToken)
        jn.mutex.Unlock()

        // Essayer de joindre avec tous les tokens de la m√©moire gauche
        leftTokens := jn.LeftMemory.GetTokens()

        for _, leftToken := range leftTokens </span><span class="cov8" title="1">{
                if joinedToken := jn.performJoinWithTokens(leftToken, factToken); joinedToken != nil </span><span class="cov8" title="1">{

                        // Stocker uniquement les tokens de jointure r√©ussie
                        joinedToken.IsJoinResult = true
                        jn.mutex.Lock()
                        jn.ResultMemory.AddToken(joinedToken)
                        jn.Memory.AddToken(joinedToken) // Pour compatibilit√© avec le comptage
                        jn.mutex.Unlock()

                        if err := jn.PropagateToChildren(nil, joinedToken); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// performJoinWithTokens effectue la jointure entre deux tokens
func (jn *JoinNode) performJoinWithTokens(token1 *Token, token2 *Token) *Token <span class="cov8" title="1">{
        // V√©rifier que les tokens ont des variables diff√©rentes
        if !jn.tokensHaveDifferentVariables(token1, token2) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Combiner les bindings des deux tokens
        <span class="cov8" title="1">combinedBindings := make(map[string]*Fact)

        // Copier les bindings du premier token
        for varName, varFact := range token1.Bindings </span><span class="cov8" title="1">{
                combinedBindings[varName] = varFact
        }</span>

        // Copier les bindings du second token
        <span class="cov8" title="1">for varName, varFact := range token2.Bindings </span><span class="cov8" title="1">{
                combinedBindings[varName] = varFact
        }</span>

        // Valider les conditions de jointure
        <span class="cov8" title="1">if !jn.evaluateJoinConditions(combinedBindings) </span><span class="cov8" title="1">{
                return nil // Jointure √©choue
        }</span>

        // Cr√©er et retourner le token joint
        <span class="cov8" title="1">return &amp;Token{
                ID:       fmt.Sprintf("%s_JOIN_%s", token1.ID, token2.ID),
                Bindings: combinedBindings,
                NodeID:   jn.ID,
                Facts:    append(token1.Facts, token2.Facts...),
        }</span>
}

// tokensHaveDifferentVariables v√©rifie que les tokens repr√©sentent des variables diff√©rentes
func (jn *JoinNode) tokensHaveDifferentVariables(token1 *Token, token2 *Token) bool <span class="cov8" title="1">{
        for var1 := range token1.Bindings </span><span class="cov8" title="1">{
                for var2 := range token2.Bindings </span><span class="cov8" title="1">{
                        if var1 == var2 </span><span class="cov0" title="0">{
                                return false // M√™me variable = pas de jointure possible
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// getVariableForFact d√©termine la variable associ√©e √† un fait bas√© sur son type
func (jn *JoinNode) getVariableForFact(fact *Fact) string <span class="cov8" title="1">{
        // Utiliser le mapping variable -&gt; type du JoinNode
        for _, varName := range jn.AllVariables </span><span class="cov8" title="1">{
                if expectedType, exists := jn.VariableTypes[varName]; exists </span><span class="cov8" title="1">{
                        if expectedType == fact.Type </span><span class="cov8" title="1">{
                                return varName
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("‚ùå JOINNODE[%s]: Aucune variable trouv√©e pour fait %s (type: %s)\n", jn.ID, fact.ID, fact.Type)
        fmt.Printf("   Variables disponibles: %v\n", jn.AllVariables)
        fmt.Printf("   Types attendus: %v\n", jn.VariableTypes)
        return ""</span>
}

// evaluateJoinConditions v√©rifie si toutes les conditions de jointure sont respect√©es
func (jn *JoinNode) evaluateJoinConditions(bindings map[string]*Fact) bool <span class="cov8" title="1">{
        for varName, fact := range bindings </span><span class="cov8" title="1">{
                fmt.Printf("    %s -&gt; %s (ID: %s)\n", varName, fact.Type, fact.ID)
        }</span>
        <span class="cov8" title="1">for i, condition := range jn.JoinConditions </span><span class="cov8" title="1">{
                fmt.Printf("    Condition %d: %s.%s %s %s.%s\n", i,
                        condition.LeftVar, condition.LeftField, condition.Operator,
                        condition.RightVar, condition.RightField)
        }</span>

        // V√©rifier qu'on a au moins 2 variables diff√©rentes
        <span class="cov8" title="1">if len(bindings) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Printf("  ‚ùå Pas assez de variables (%d &lt; 2)\n", len(bindings))
                return false
        }</span>

        // NOUVEAU: √âvaluer la condition compl√®te qui peut contenir des expressions arithm√©tiques
        <span class="cov8" title="1">if jn.Condition != nil </span><span class="cov8" title="1">{
                evaluator := NewAlphaConditionEvaluator()
                // Activer le mode d'√©valuation partielle pour les jointures en cascade
                // o√π toutes les variables ne sont pas encore disponibles
                evaluator.SetPartialEvalMode(true)

                // Lier toutes les variables aux faits
                for varName, fact := range bindings </span><span class="cov8" title="1">{
                        evaluator.variableBindings[varName] = fact
                }</span>

                <span class="cov8" title="1">result, err := evaluator.evaluateExpression(jn.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">return result</span>
        }

        // LEGACY: √âvaluer les conditions de jointure extraites (simples comparaisons)
        // Note: Ce code est maintenant redondant si jn.Condition est √©valu√© ci-dessus,
        // mais conserv√© pour compatibilit√© avec les anciens tests
        <span class="cov0" title="0">for i, joinCondition := range jn.JoinConditions </span><span class="cov0" title="0">{
                leftFact := bindings[joinCondition.LeftVar]
                rightFact := bindings[joinCondition.RightVar]

                if leftFact == nil || rightFact == nil </span><span class="cov0" title="0">{
                        fmt.Printf("  ‚ùå Condition %d: variable manquante (%s ou %s)\n", i, joinCondition.LeftVar, joinCondition.RightVar)
                        return false // Une variable manque
                }</span>

                // R√©cup√©rer les valeurs des champs
                <span class="cov0" title="0">leftValue := leftFact.Fields[joinCondition.LeftField]
                rightValue := rightFact.Fields[joinCondition.RightField]

                // √âvaluer l'op√©rateur
                switch joinCondition.Operator </span>{
                case "==":<span class="cov0" title="0">
                        if leftValue != rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚ùå Condition %d √©choue: %v != %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  ‚úÖ Condition %d r√©ussie: %v == %v\n", i, leftValue, rightValue)</span>
                case "!=":<span class="cov0" title="0">
                        if leftValue == rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚ùå Condition %d √©choue: %v == %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  ‚úÖ Condition %d r√©ussie: %v != %v\n", i, leftValue, rightValue)</span>
                case "&lt;":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &gt;= rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false // Comparaison num√©rique impossible
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                case "&gt;":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &lt;= rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                case "&lt;=":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &gt; rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                case "&gt;=":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &lt; rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                default:<span class="cov0" title="0">
                        return false</span> // Op√©rateur non support√©
                }
        }

        <span class="cov0" title="0">return true</span> // Toutes les conditions sont satisfaites
}

// convertToFloat64 tente de convertir une valeur en float64
func convertToFloat64(value interface{}) (float64, bool) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, true</span>
        case float32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int:<span class="cov0" title="0">
                return float64(v), true</span>
        case int32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int64:<span class="cov0" title="0">
                return float64(v), true</span>
        case string:<span class="cov0" title="0">
                if f, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov0" title="0">{
                        return f, true
                }</span>
                <span class="cov0" title="0">return 0, false</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

// extractJoinConditions extrait les conditions de jointure d'une condition complexe
func extractJoinConditions(condition map[string]interface{}) []JoinCondition <span class="cov8" title="1">{
        for key, value := range condition </span><span class="cov8" title="1">{
                fmt.Printf("    %s: %v (type: %T)\n", key, value, value)
        }</span>

        <span class="cov8" title="1">var joinConditions []JoinCondition

        // Cas 1: condition wrapp√©e dans un type "constraint"
        if conditionType, exists := condition["type"].(string); exists &amp;&amp; conditionType == "constraint" </span><span class="cov8" title="1">{
                if innerCondition, ok := condition["constraint"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        fmt.Printf("  ‚úÖ Sous-condition extraite, analyse r√©cursive\n")
                        return extractJoinConditions(innerCondition)
                }</span>
        }

        // Cas 2: condition EXISTS avec array de conditions
        <span class="cov8" title="1">if conditionType, exists := condition["type"].(string); exists &amp;&amp; conditionType == "exists" </span><span class="cov0" title="0">{
                if conditionsData, ok := condition["conditions"].([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                        fmt.Printf("  ‚úÖ Array de conditions EXISTS trouv√©: %d conditions\n", len(conditionsData))
                        for _, subCondition := range conditionsData </span><span class="cov0" title="0">{
                                subJoinConditions := extractJoinConditions(subCondition)
                                joinConditions = append(joinConditions, subJoinConditions...)
                        }</span>
                        <span class="cov0" title="0">return joinConditions</span>
                }
        }

        // Cas 3: condition directe de comparaison
        <span class="cov8" title="1">if conditionType, exists := condition["type"].(string); exists &amp;&amp; conditionType == "comparison" </span><span class="cov8" title="1">{
                fmt.Printf("  ‚úÖ Condition de comparaison d√©tect√©e\n")
                if left, leftOk := condition["left"].(map[string]interface{}); leftOk </span><span class="cov8" title="1">{
                        if right, rightOk := condition["right"].(map[string]interface{}); rightOk </span><span class="cov8" title="1">{
                                fmt.Printf("  ‚úÖ Left et Right extraits\n")
                                if leftType, _ := left["type"].(string); leftType == "fieldAccess" </span><span class="cov8" title="1">{
                                        if rightType, _ := right["type"].(string); rightType == "fieldAccess" </span><span class="cov8" title="1">{
                                                // Condition de jointure d√©tect√©e
                                                fmt.Printf("  ‚úÖ Condition de jointure fieldAccess d√©tect√©e\n")
                                                leftObj, _ := left["object"].(string)
                                                leftField, _ := left["field"].(string)
                                                rightObj, _ := right["object"].(string)
                                                rightField, _ := right["field"].(string)
                                                operator, _ := condition["operator"].(string)

                                                fmt.Printf("    üìå %s.%s %s %s.%s\n", leftObj, leftField, operator, rightObj, rightField)

                                                joinConditions = append(joinConditions, JoinCondition{
                                                        LeftField:  leftField,
                                                        RightField: rightField,
                                                        LeftVar:    leftObj,
                                                        RightVar:   rightObj,
                                                        Operator:   operator,
                                                })
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return joinConditions</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package rete

import (
        "fmt"
)

type RootNode struct {
        BaseNode
}

// NewRootNode cr√©e un nouveau n≈ìud racine
func NewRootNode(storage Storage) *RootNode <span class="cov8" title="1">{
        return &amp;RootNode{
                BaseNode: BaseNode{
                        ID:       "root",
                        Type:     "root",
                        Memory:   &amp;WorkingMemory{NodeID: "root", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
        }
}</span>

// ActivateLeft (non utilis√© pour le n≈ìud racine)
func (rn *RootNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("le n≈ìud racine ne peut pas recevoir de tokens")
}</span>

// ActivateRetract retire le fait de la m√©moire racine et propage aux enfants
func (rn *RootNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        rn.mutex.Lock()
        rn.Memory.RemoveFact(factID)
        rn.mutex.Unlock()
        fmt.Printf("üóëÔ∏è  [ROOT] R√©tractation du fait: %s\n", factID)
        return rn.PropagateRetractToChildren(factID)
}</span>

// ActivateRight distribue les faits aux n≈ìuds de type
func (rn *RootNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        rn.mutex.Lock()
        if err := rn.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                rn.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans root node: %w", err)
        }</span>
        <span class="cov8" title="1">rn.mutex.Unlock()

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ROOT] Re√ßu fait: %s\n", fact.String())

        // Persistance d√©sactiv√©e pour les performances

        // Propager aux enfants (TypeNodes)
        return rn.PropagateToChildren(fact, nil)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package rete

import (
        "fmt"
)

type TerminalNode struct {
        BaseNode
        Action *Action `json:"action"`
}

// NewTerminalNode cr√©e un nouveau n≈ìud terminal
func NewTerminalNode(nodeID string, action *Action, storage Storage) *TerminalNode <span class="cov8" title="1">{
        return &amp;TerminalNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "terminal",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0), // Les n≈ìuds terminaux n'ont pas d'enfants
                        Storage:  storage,
                },
                Action: action,
        }
}</span>

// ActivateLeft d√©clenche l'action
func (tn *TerminalNode) ActivateLeft(token *Token) error <span class="cov8" title="1">{
        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[TERMINAL_%s] D√©clenchement action avec token: %s\n", tn.ID, token.ID)

        // Stocker le token
        tn.mutex.Lock()
        if tn.Memory.Tokens == nil </span><span class="cov0" title="0">{
                tn.Memory.Tokens = make(map[string]*Token)
        }</span>
        <span class="cov8" title="1">tn.Memory.Tokens[token.ID] = token
        tn.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // D√©clencher l'action
        return tn.executeAction(token)</span>
}

// ActivateRetract retrait des tokens contenant le fait r√©tract√©
// factID doit √™tre l'identifiant interne (Type_ID)
func (tn *TerminalNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        tn.mutex.Lock()
        var tokensToRemove []string
        for tokenID, token := range tn.Memory.Tokens </span><span class="cov8" title="1">{
                for _, fact := range token.Facts </span><span class="cov8" title="1">{
                        if fact.GetInternalID() == factID </span><span class="cov8" title="1">{
                                tokensToRemove = append(tokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range tokensToRemove </span><span class="cov8" title="1">{
                delete(tn.Memory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">tn.mutex.Unlock()
        if len(tokensToRemove) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("üóëÔ∏è  [TERMINAL_%s] R√©tractation: %d tokens retir√©s\n", tn.ID, len(tokensToRemove))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetTriggeredActions retourne les actions d√©clench√©es (pour les tests)
func (tn *TerminalNode) GetTriggeredActions() []*Action <span class="cov0" title="0">{
        tn.mutex.RLock()
        defer tn.mutex.RUnlock()

        actions := make([]*Action, 0, len(tn.Memory.Tokens))
        for range tn.Memory.Tokens </span><span class="cov0" title="0">{
                actions = append(actions, tn.Action)
        }</span>
        <span class="cov0" title="0">return actions</span>
}

// ActivateRight (non utilis√© pour les n≈ìuds terminaux)
func (tn *TerminalNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds terminaux ne re√ßoivent pas de faits directement")
}</span>

// executeAction affiche l'action d√©clench√©e avec les faits d√©clencheurs (version tuple-space)
func (tn *TerminalNode) executeAction(token *Token) error <span class="cov8" title="1">{
        // Les actions sont maintenant obligatoires dans la grammaire
        // Mais nous gardons cette v√©rification par s√©curit√©
        if tn.Action == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune action d√©finie pour le n≈ìud %s", tn.ID)
        }</span>

        // === VERSION TUPLE-SPACE ===
        // Au lieu d'ex√©cuter l'action, on l'affiche avec les faits d√©clencheurs
        // Les agents du tuple-space viendront "prendre" ces tuples plus tard

        <span class="cov8" title="1">actionName := tn.Action.Job.Name
        fmt.Printf("üéØ ACTION DISPONIBLE DANS TUPLE-SPACE: %s", actionName)

        // Afficher les faits d√©clencheurs entre parenth√®ses
        if len(token.Facts) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Print(" (")
                for i, fact := range token.Facts </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                fmt.Print(", ")
                        }</span>
                        // Format compact : Type(id:value, field:value, ...)
                        <span class="cov8" title="1">fmt.Printf("%s(", fact.Type)
                        fieldCount := 0
                        for key, value := range fact.Fields </span><span class="cov8" title="1">{
                                if fieldCount &gt; 0 </span><span class="cov8" title="1">{
                                        fmt.Print(", ")
                                }</span>
                                <span class="cov8" title="1">fmt.Printf("%s:%v", key, value)
                                fieldCount++</span>
                        }
                        <span class="cov8" title="1">fmt.Print(")")</span>
                }
                <span class="cov8" title="1">fmt.Print(")")</span>
        }
        <span class="cov8" title="1">fmt.Println()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package rete

import (
        "fmt"
)

type TypeNode struct {
        BaseNode
        TypeName       string         `json:"type_name"`
        TypeDefinition TypeDefinition `json:"type_definition"`
}

// NewTypeNode cr√©e un nouveau n≈ìud de type
func NewTypeNode(typeName string, typeDef TypeDefinition, storage Storage) *TypeNode <span class="cov8" title="1">{
        return &amp;TypeNode{
                BaseNode: BaseNode{
                        ID:       fmt.Sprintf("type_%s", typeName),
                        Type:     "type",
                        Memory:   &amp;WorkingMemory{NodeID: fmt.Sprintf("type_%s", typeName), Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                TypeName:       typeName,
                TypeDefinition: typeDef,
        }
}</span>

// ActivateLeft (non utilis√© pour les n≈ìuds de type)
func (tn *TypeNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds de type ne re√ßoivent pas de tokens")
}</span>

// ActivateRetract retire le fait de la m√©moire de type et propage aux enfants
// factID doit √™tre l'identifiant interne (Type_ID)
func (tn *TypeNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        tn.mutex.Lock()
        _, exists := tn.Memory.GetFact(factID)
        if exists </span><span class="cov8" title="1">{
                tn.Memory.RemoveFact(factID)
        }</span>
        <span class="cov8" title="1">tn.mutex.Unlock()
        if !exists </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">fmt.Printf("üóëÔ∏è  [TYPE_%s] R√©tractation du fait: %s\n", tn.ID, factID)
        return tn.PropagateRetractToChildren(factID)</span>
}

// ActivateRight filtre les faits par type et les propage
func (tn *TypeNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // V√©rifier si le fait correspond au type de ce n≈ìud
        if fact.Type != tn.TypeName </span><span class="cov8" title="1">{
                return nil // Ignorer silencieusement les faits d'autres types
        }</span>

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[TYPE_%s] Re√ßu fait: %s\n", tn.TypeName, fact.String())

        // Valider les champs du fait
        <span class="cov8" title="1">if err := tn.validateFact(fact); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation du fait √©chou√©e: %w", err)
        }</span>

        <span class="cov8" title="1">tn.mutex.Lock()
        if err := tn.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                tn.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans type node: %w", err)
        }</span>
        <span class="cov8" title="1">tn.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // Propager aux enfants (AlphaNodes)
        return tn.PropagateToChildren(fact, nil)</span>
}

// validateFact valide qu'un fait respecte la d√©finition de type
func (tn *TypeNode) validateFact(fact *Fact) error <span class="cov8" title="1">{
        for _, field := range tn.TypeDefinition.Fields </span><span class="cov8" title="1">{
                // Le champ "id" est stock√© dans fact.ID, pas dans Fields
                if field.Name == "id" </span><span class="cov8" title="1">{
                        if fact.ID == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("champ manquant: %s", field.Name)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">value, exists := fact.Fields[field.Name]
                if !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ manquant: %s", field.Name)
                }</span>

                // Validation basique des types
                <span class="cov8" title="1">if !tn.isValidType(value, field.Type) </span><span class="cov0" title="0">{
                        return fmt.Errorf("type invalide pour le champ %s: attendu %s", field.Name, field.Type)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// isValidType v√©rifie si une valeur correspond au type attendu
func (tn *TypeNode) isValidType(value interface{}, expectedType string) bool <span class="cov8" title="1">{
        switch expectedType </span>{
        case "string":<span class="cov8" title="1">
                _, ok := value.(string)
                return ok</span>
        case "number":<span class="cov8" title="1">
                switch value.(type) </span>{
                case int, int32, int64, float32, float64:<span class="cov8" title="1">
                        return true</span>
                }
                <span class="cov0" title="0">return false</span>
        case "bool":<span class="cov0" title="0">
                _, ok := value.(bool)
                return ok</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package domain

import (
        "errors"
        "fmt"
)

// Erreurs de base du domaine RETE
var (
        ErrFactNotFound     = errors.New("fact not found")
        ErrInvalidFactType  = errors.New("invalid fact type")
        ErrInvalidFieldType = errors.New("invalid field type")
        ErrNodeNotFound     = errors.New("node not found")
        ErrStorageError     = errors.New("storage error")
        ErrValidationFailed = errors.New("validation failed")
)

// ValidationError repr√©sente une erreur de validation avec contexte.
type ValidationError struct {
        Field   string
        Value   interface{}
        Message string
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("validation error on field '%s': %s (value: %v)", e.Field, e.Message, e.Value)
}</span>

// NodeError repr√©sente une erreur sp√©cifique √† un n≈ìud.
type NodeError struct {
        NodeID   string
        NodeType string
        Cause    error
}

func (e *NodeError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("error in node %s (%s): %v", e.NodeID, e.NodeType, e.Cause)
}</span>

func (e *NodeError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// NewValidationError cr√©e une nouvelle erreur de validation.
func NewValidationError(field string, value interface{}, message string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Field:   field,
                Value:   value,
                Message: message,
        }
}</span>

// NewNodeError cr√©e une nouvelle erreur de n≈ìud.
func NewNodeError(nodeID, nodeType string, cause error) *NodeError <span class="cov8" title="1">{
        return &amp;NodeError{
                NodeID:   nodeID,
                NodeType: nodeType,
                Cause:    cause,
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package domain contient les types m√©tier fondamentaux du syst√®me RETE
package domain

import (
        "time"
)

// Fact repr√©sente un fait dans le syst√®me RETE.
// Un fait est une donn√©e d'entr√©e qui sera propag√©e √† travers le r√©seau.
type Fact struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        Fields    map[string]interface{} `json:"fields"`
        Timestamp time.Time              `json:"timestamp"`
}

// NewFact cr√©e un nouveau fait avec timestamp automatique.
func NewFact(id, factType string, fields map[string]interface{}) *Fact <span class="cov8" title="1">{
        return &amp;Fact{
                ID:        id,
                Type:      factType,
                Fields:    fields,
                Timestamp: time.Now(),
        }
}</span>

// String retourne la repr√©sentation string d'un fait.
func (f *Fact) String() string <span class="cov8" title="1">{
        return f.ID + ":" + f.Type
}</span>

// GetField retourne la valeur d'un champ et indique s'il existe.
func (f *Fact) GetField(fieldName string) (interface{}, bool) <span class="cov8" title="1">{
        value, exists := f.Fields[fieldName]
        return value, exists
}</span>

// Token repr√©sente un token dans le r√©seau RETE.
// Un token contient un ou plusieurs faits et circule entre les n≈ìuds.
type Token struct {
        ID     string  `json:"id"`
        Facts  []*Fact `json:"facts"`
        NodeID string  `json:"node_id"`
        Parent *Token  `json:"parent,omitempty"`
}

// NewToken cr√©e un nouveau token.
func NewToken(id, nodeID string, facts []*Fact) *Token <span class="cov8" title="1">{
        return &amp;Token{
                ID:     id,
                Facts:  facts,
                NodeID: nodeID,
        }
}</span>

// WorkingMemory repr√©sente la m√©moire de travail d'un n≈ìud.
// Elle stocke les faits et tokens actuellement trait√©s par le n≈ìud.
type WorkingMemory struct {
        NodeID string            `json:"node_id"`
        Facts  map[string]*Fact  `json:"facts"`
        Tokens map[string]*Token `json:"tokens"`
}

// NewWorkingMemory cr√©e une nouvelle m√©moire de travail.
func NewWorkingMemory(nodeID string) *WorkingMemory <span class="cov8" title="1">{
        return &amp;WorkingMemory{
                NodeID: nodeID,
                Facts:  make(map[string]*Fact),
                Tokens: make(map[string]*Token),
        }
}</span>

// AddFact ajoute un fait √† la m√©moire.
func (wm *WorkingMemory) AddFact(fact *Fact) <span class="cov8" title="1">{
        if wm.Facts == nil </span><span class="cov8" title="1">{
                wm.Facts = make(map[string]*Fact)
        }</span>
        <span class="cov8" title="1">wm.Facts[fact.ID] = fact</span>
}

// RemoveFact supprime un fait de la m√©moire.
func (wm *WorkingMemory) RemoveFact(factID string) <span class="cov8" title="1">{
        delete(wm.Facts, factID)
}</span>

// GetFacts retourne tous les faits de la m√©moire.
func (wm *WorkingMemory) GetFacts() []*Fact <span class="cov8" title="1">{
        facts := make([]*Fact, 0, len(wm.Facts))
        for _, fact := range wm.Facts </span><span class="cov8" title="1">{
                facts = append(facts, fact)
        }</span>
        <span class="cov8" title="1">return facts</span>
}

// AddToken ajoute un token √† la m√©moire.
func (wm *WorkingMemory) AddToken(token *Token) <span class="cov8" title="1">{
        if wm.Tokens == nil </span><span class="cov8" title="1">{
                wm.Tokens = make(map[string]*Token)
        }</span>
        <span class="cov8" title="1">wm.Tokens[token.ID] = token</span>
}

// RemoveToken supprime un token de la m√©moire.
func (wm *WorkingMemory) RemoveToken(tokenID string) <span class="cov8" title="1">{
        delete(wm.Tokens, tokenID)
}</span>

// GetTokens retourne tous les tokens de la m√©moire.
func (wm *WorkingMemory) GetTokens() []*Token <span class="cov8" title="1">{
        tokens := make([]*Token, 0, len(wm.Tokens))
        for _, token := range wm.Tokens </span><span class="cov8" title="1">{
                tokens = append(tokens, token)
        }</span>
        <span class="cov8" title="1">return tokens</span>
}

// BasicJoinCondition impl√©mente une condition de jointure simple.
type BasicJoinCondition struct {
        LeftField  string `json:"left_field"`
        RightField string `json:"right_field"`
        Operator   string `json:"operator"`
}

// NewBasicJoinCondition cr√©e une nouvelle condition de jointure.
func NewBasicJoinCondition(leftField, rightField, operator string) *BasicJoinCondition <span class="cov8" title="1">{
        return &amp;BasicJoinCondition{
                LeftField:  leftField,
                RightField: rightField,
                Operator:   operator,
        }
}</span>

// Evaluate √©value la condition de jointure entre un token et un fait.
func (bjc *BasicJoinCondition) Evaluate(token *Token, fact *Fact) bool <span class="cov8" title="1">{
        if len(token.Facts) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Prendre le dernier fait du token pour la comparaison
        <span class="cov8" title="1">leftFact := token.Facts[len(token.Facts)-1]

        leftValue, leftExists := leftFact.GetField(bjc.LeftField)
        rightValue, rightExists := fact.GetField(bjc.RightField)

        if !leftExists || !rightExists </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return bjc.evaluateOperator(leftValue, rightValue)</span>
}

// GetLeftField retourne le champ gauche de la condition.
func (bjc *BasicJoinCondition) GetLeftField() string <span class="cov8" title="1">{
        return bjc.LeftField
}</span>

// GetRightField retourne le champ droit de la condition.
func (bjc *BasicJoinCondition) GetRightField() string <span class="cov8" title="1">{
        return bjc.RightField
}</span>

// GetOperator retourne l'op√©rateur de la condition.
func (bjc *BasicJoinCondition) GetOperator() string <span class="cov8" title="1">{
        return bjc.Operator
}</span>

// evaluateOperator √©value l'op√©rateur entre deux valeurs.
func (bjc *BasicJoinCondition) evaluateOperator(left, right interface{}) bool <span class="cov8" title="1">{
        switch bjc.Operator </span>{
        case "==", "=":<span class="cov8" title="1">
                return left == right</span>
        case "!=":<span class="cov8" title="1">
                return left != right</span>
        case "&lt;":<span class="cov8" title="1">
                return bjc.compareValues(left, right) &lt; 0</span>
        case "&lt;=":<span class="cov8" title="1">
                return bjc.compareValues(left, right) &lt;= 0</span>
        case "&gt;":<span class="cov8" title="1">
                return bjc.compareValues(left, right) &gt; 0</span>
        case "&gt;=":<span class="cov8" title="1">
                return bjc.compareValues(left, right) &gt;= 0</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// compareValues compare deux valeurs pour les op√©rateurs relationnels.
func (bjc *BasicJoinCondition) compareValues(left, right interface{}) int <span class="cov8" title="1">{
        // Impl√©mentation simplifi√©e pour les types de base
        switch lv := left.(type) </span>{
        case int:<span class="cov8" title="1">
                if rv, ok := right.(int); ok </span><span class="cov8" title="1">{
                        if lv &lt; rv </span><span class="cov8" title="1">{
                                return -1
                        }</span> else<span class="cov8" title="1"> if lv &gt; rv </span><span class="cov8" title="1">{
                                return 1
                        }</span>
                        <span class="cov8" title="1">return 0</span>
                }
        case float64:<span class="cov8" title="1">
                if rv, ok := right.(float64); ok </span><span class="cov8" title="1">{
                        if lv &lt; rv </span><span class="cov8" title="1">{
                                return -1
                        }</span> else<span class="cov8" title="1"> if lv &gt; rv </span><span class="cov8" title="1">{
                                return 1
                        }</span>
                        <span class="cov8" title="1">return 0</span>
                }
        case string:<span class="cov8" title="1">
                if rv, ok := right.(string); ok </span><span class="cov8" title="1">{
                        if lv &lt; rv </span><span class="cov8" title="1">{
                                return -1
                        }</span> else<span class="cov8" title="1"> if lv &gt; rv </span><span class="cov8" title="1">{
                                return 1
                        }</span>
                        <span class="cov8" title="1">return 0</span>
                }
        }
        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package network

import (
        "fmt"
        "sync"

        "github.com/treivax/tsd/rete/pkg/domain"
        "github.com/treivax/tsd/rete/pkg/nodes"
)

// BetaNetworkBuilder construit des r√©seaux de n≈ìuds Beta pour les jointures multi-faits.
type BetaNetworkBuilder struct {
        logger    domain.Logger
        betaNodes map[string]domain.BetaNode
        mutex     sync.RWMutex
}

// NewBetaNetworkBuilder cr√©e un nouveau constructeur de r√©seau Beta.
func NewBetaNetworkBuilder(logger domain.Logger) *BetaNetworkBuilder <span class="cov8" title="1">{
        return &amp;BetaNetworkBuilder{
                logger:    logger,
                betaNodes: make(map[string]domain.BetaNode),
        }
}</span>

// CreateJoinNode cr√©e un nouveau n≈ìud de jointure avec conditions.
func (bnb *BetaNetworkBuilder) CreateJoinNode(id string, conditions []domain.JoinCondition) domain.JoinNode <span class="cov8" title="1">{
        bnb.mutex.Lock()
        defer bnb.mutex.Unlock()

        joinNode := nodes.NewJoinNode(id, bnb.logger)
        joinNode.SetJoinConditions(conditions)

        bnb.betaNodes[id] = joinNode

        bnb.logger.Info("created join node", map[string]interface{}{
                "node_id":    id,
                "conditions": len(conditions),
        })

        return joinNode
}</span>

// CreateBetaNode cr√©e un n≈ìud Beta simple (sans conditions).
func (bnb *BetaNetworkBuilder) CreateBetaNode(id string) domain.BetaNode <span class="cov8" title="1">{
        bnb.mutex.Lock()
        defer bnb.mutex.Unlock()

        betaNode := nodes.NewBaseBetaNode(id, "BetaNode", bnb.logger)
        bnb.betaNodes[id] = betaNode

        bnb.logger.Info("created beta node", map[string]interface{}{
                "node_id": id,
        })

        return betaNode
}</span>

// ConnectNodes connecte un n≈ìud parent √† un n≈ìud enfant.
func (bnb *BetaNetworkBuilder) ConnectNodes(parentID, childID string) error <span class="cov8" title="1">{
        bnb.mutex.RLock()
        parent, parentExists := bnb.betaNodes[parentID]
        child, childExists := bnb.betaNodes[childID]
        bnb.mutex.RUnlock()

        if !parentExists </span><span class="cov8" title="1">{
                return fmt.Errorf("parent node not found: %s", parentID)
        }</span>
        <span class="cov8" title="1">if !childExists </span><span class="cov8" title="1">{
                return fmt.Errorf("child node not found: %s", childID)
        }</span>

        <span class="cov8" title="1">parent.AddChild(child)

        bnb.logger.Info("connected nodes", map[string]interface{}{
                "parent_id": parentID,
                "child_id":  childID,
        })

        return nil</span>
}

// GetBetaNode retourne un n≈ìud Beta par son ID.
func (bnb *BetaNetworkBuilder) GetBetaNode(id string) (domain.BetaNode, bool) <span class="cov8" title="1">{
        bnb.mutex.RLock()
        defer bnb.mutex.RUnlock()

        node, exists := bnb.betaNodes[id]
        return node, exists
}</span>

// ListBetaNodes retourne tous les n≈ìuds Beta cr√©√©s.
func (bnb *BetaNetworkBuilder) ListBetaNodes() map[string]domain.BetaNode <span class="cov8" title="1">{
        bnb.mutex.RLock()
        defer bnb.mutex.RUnlock()

        // Retourner une copie pour √©viter les modifications concurrentes
        result := make(map[string]domain.BetaNode, len(bnb.betaNodes))
        for id, node := range bnb.betaNodes </span><span class="cov8" title="1">{
                result[id] = node
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ClearNetwork vide tous les n≈ìuds du r√©seau.
func (bnb *BetaNetworkBuilder) ClearNetwork() <span class="cov8" title="1">{
        bnb.mutex.Lock()
        defer bnb.mutex.Unlock()

        bnb.betaNodes = make(map[string]domain.BetaNode)

        bnb.logger.Info("cleared beta network", map[string]interface{}{})
}</span>

// MultiJoinPattern repr√©sente un pattern de jointures multiples pour construire des r√®gles complexes.
type MultiJoinPattern struct {
        PatternID   string              `json:"pattern_id"`
        JoinSpecs   []JoinSpecification `json:"join_specs"`
        FinalAction string              `json:"final_action"`
}

// JoinSpecification sp√©cifie une jointure dans un pattern multi-jointures.
type JoinSpecification struct {
        LeftType   string                 `json:"left_type"`  // Type des faits du c√¥t√© gauche
        RightType  string                 `json:"right_type"` // Type des faits du c√¥t√© droit
        Conditions []domain.JoinCondition `json:"conditions"` // Conditions de jointure
        NodeID     string                 `json:"node_id"`    // ID unique du n≈ìud de jointure
}

// BuildMultiJoinNetwork construit un r√©seau de jointures multiples √† partir d'un pattern.
func (bnb *BetaNetworkBuilder) BuildMultiJoinNetwork(pattern MultiJoinPattern) ([]domain.BetaNode, error) <span class="cov8" title="1">{
        createdNodes := make([]domain.BetaNode, 0, len(pattern.JoinSpecs))

        bnb.logger.Info("building multi-join network", map[string]interface{}{
                "pattern_id": pattern.PatternID,
                "join_count": len(pattern.JoinSpecs),
        })

        // Cr√©er les n≈ìuds de jointure en cascade
        var previousNode domain.BetaNode

        for i, spec := range pattern.JoinSpecs </span><span class="cov8" title="1">{
                nodeID := spec.NodeID
                if nodeID == "" </span><span class="cov8" title="1">{
                        nodeID = fmt.Sprintf("%s_join_%d", pattern.PatternID, i)
                }</span>

                // Cr√©er le n≈ìud de jointure avec ses conditions
                <span class="cov8" title="1">joinNode := bnb.CreateJoinNode(nodeID, spec.Conditions)
                createdNodes = append(createdNodes, joinNode)

                // Connecter au n≈ìud pr√©c√©dent si il existe
                if previousNode != nil </span><span class="cov8" title="1">{
                        previousNode.AddChild(joinNode)

                        bnb.logger.Debug("connected join nodes", map[string]interface{}{
                                "parent_id": previousNode.ID(),
                                "child_id":  joinNode.ID(),
                        })
                }</span>

                <span class="cov8" title="1">previousNode = joinNode

                bnb.logger.Debug("created join node in pattern", map[string]interface{}{
                        "pattern_id": pattern.PatternID,
                        "node_id":    nodeID,
                        "left_type":  spec.LeftType,
                        "right_type": spec.RightType,
                        "conditions": len(spec.Conditions),
                })</span>
        }

        <span class="cov8" title="1">bnb.logger.Info("multi-join network built successfully", map[string]interface{}{
                "pattern_id":    pattern.PatternID,
                "nodes_created": len(createdNodes),
        })

        return createdNodes, nil</span>
}

// NetworkStatistics retourne les statistiques du r√©seau Beta.
func (bnb *BetaNetworkBuilder) NetworkStatistics() NetworkStats <span class="cov8" title="1">{
        bnb.mutex.RLock()
        defer bnb.mutex.RUnlock()

        stats := NetworkStats{
                TotalNodes:      len(bnb.betaNodes),
                JoinNodes:       0,
                SimpleBetaNodes: 0,
                MemoryStats:     make(map[string]MemoryStat),
        }

        for nodeID, node := range bnb.betaNodes </span><span class="cov8" title="1">{
                // Compter le type de n≈ìud
                if _, isJoinNode := node.(domain.JoinNode); isJoinNode </span><span class="cov8" title="1">{
                        stats.JoinNodes++
                }</span> else<span class="cov8" title="1"> {
                        stats.SimpleBetaNodes++
                }</span>

                // Collecter les statistiques m√©moire
                <span class="cov8" title="1">tokens, facts := 0, 0
                if leftMemory := node.GetLeftMemory(); leftMemory != nil </span><span class="cov8" title="1">{
                        tokens = len(leftMemory)
                }</span>
                <span class="cov8" title="1">if rightMemory := node.GetRightMemory(); rightMemory != nil </span><span class="cov8" title="1">{
                        facts = len(rightMemory)
                }</span>

                <span class="cov8" title="1">stats.MemoryStats[nodeID] = MemoryStat{
                        TokenCount: tokens,
                        FactCount:  facts,
                }

                stats.TotalTokens += tokens
                stats.TotalFacts += facts</span>
        }

        <span class="cov8" title="1">return stats</span>
}

// NetworkStats repr√©sente les statistiques du r√©seau Beta.
type NetworkStats struct {
        TotalNodes      int                   `json:"total_nodes"`
        JoinNodes       int                   `json:"join_nodes"`
        SimpleBetaNodes int                   `json:"simple_beta_nodes"`
        TotalTokens     int                   `json:"total_tokens"`
        TotalFacts      int                   `json:"total_facts"`
        MemoryStats     map[string]MemoryStat `json:"memory_stats"`
}

// MemoryStat repr√©sente les statistiques m√©moire d'un n≈ìud.
type MemoryStat struct {
        TokenCount int `json:"token_count"`
        FactCount  int `json:"fact_count"`
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package nodes

import (
        "fmt"
        "sync"

        "github.com/treivax/tsd/rete/pkg/domain"
)

// Aggregate function type constants
const (
        AggregateFunctionSum   = "SUM"
        AggregateFunctionCount = "COUNT"
        AggregateFunctionAvg   = "AVG"
        AggregateFunctionMin   = "MIN"
        AggregateFunctionMax   = "MAX"
)

// NotNodeImpl impl√©mente l'interface NotNode pour la n√©gation
type NotNodeImpl struct {
        *BaseBetaNode
        negationCondition interface{}
        mu                sync.RWMutex
}

// NewNotNode cr√©e un nouveau n≈ìud de n√©gation
func NewNotNode(id string, logger domain.Logger) *NotNodeImpl <span class="cov8" title="1">{
        baseBeta := NewBaseBetaNode(id, "NotNode", logger)
        return &amp;NotNodeImpl{
                BaseBetaNode: baseBeta,
        }
}</span>

// SetNegationCondition d√©finit la condition de n√©gation
func (n *NotNodeImpl) SetNegationCondition(condition interface{}) <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()
        n.negationCondition = condition
}</span>

// GetNegationCondition retourne la condition de n√©gation
func (n *NotNodeImpl) GetNegationCondition() interface{} <span class="cov8" title="1">{
        n.mu.RLock()
        defer n.mu.RUnlock()
        return n.negationCondition
}</span>

// ProcessNegation √©value la n√©gation d'une condition
func (n *NotNodeImpl) ProcessNegation(token *domain.Token, fact *domain.Fact) bool <span class="cov8" title="1">{
        n.mu.RLock()
        condition := n.negationCondition
        n.mu.RUnlock()

        if condition == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // √âvaluer la condition et retourner sa n√©gation
        <span class="cov8" title="1">result, err := n.evaluateCondition(condition, token, fact)
        if err != nil </span><span class="cov0" title="0">{
                n.logger.Error("Erreur √©valuation condition n√©gation", err, map[string]interface{}{
                        "node_id": n.id,
                        "token":   token.ID,
                        "fact":    fact.ID,
                })
                return false
        }</span>

        <span class="cov8" title="1">return !result</span> // N√©gation du r√©sultat
}

// ProcessLeftToken traite un token venant de la gauche
func (n *NotNodeImpl) ProcessLeftToken(token *domain.Token) error <span class="cov8" title="1">{
        n.logger.Debug("processing token in NotNode", map[string]interface{}{
                "node_id":    n.id,
                "token_id":   token.ID,
                "node_type":  "NotNode",
                "action":     "left_input",
                "fact_count": len(token.Facts),
        })

        // Stocker le token dans la m√©moire gauche
        n.betaMemory.StoreToken(token)

        // V√©rifier la n√©gation contre tous les faits de droite
        rightFacts := n.betaMemory.GetFacts()
        shouldPropagate := true

        for _, fact := range rightFacts </span><span class="cov8" title="1">{
                if n.ProcessNegation(token, fact) </span><span class="cov8" title="1">{
                        // Si la n√©gation est vraie (condition originale fausse), continuer
                        continue</span>
                } else<span class="cov0" title="0"> {
                        // Si la n√©gation est fausse (condition originale vraie), bloquer la propagation
                        shouldPropagate = false
                        break</span>
                }
        }

        // Si aucun fait de droite ne satisfait la condition, propager le token (n√©gation r√©ussie)
        <span class="cov8" title="1">if shouldPropagate &amp;&amp; len(rightFacts) &gt; 0 </span><span class="cov8" title="1">{
                return n.propagateTokenToChildren(token)
        }</span>

        // Si pas de faits de droite, propager √©galement (n√©gation par d√©faut)
        <span class="cov8" title="1">if len(rightFacts) == 0 </span><span class="cov8" title="1">{
                return n.propagateTokenToChildren(token)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessRightFact traite un fait venant de la droite
func (n *NotNodeImpl) ProcessRightFact(fact *domain.Fact) error <span class="cov8" title="1">{
        n.logger.Debug("processing fact in NotNode", map[string]interface{}{
                "node_id":   n.id,
                "fact_id":   fact.ID,
                "fact_type": fact.Type,
                "node_type": "NotNode",
                "action":    "right_input",
        })

        // Stocker le fait dans la m√©moire droite
        n.betaMemory.StoreFact(fact)

        // V√©rifier tous les tokens de gauche
        leftTokens := n.betaMemory.GetTokens()
        for _, token := range leftTokens </span><span class="cov8" title="1">{
                if !n.ProcessNegation(token, fact) </span><span class="cov8" title="1">{
                        // Si la n√©gation √©choue (condition vraie), retirer le token s'il √©tait propag√©
                        n.logger.Debug("negation failed, blocking token", map[string]interface{}{
                                "node_id":  n.id,
                                "token_id": token.ID,
                                "fact_id":  fact.ID,
                        })
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// evaluateCondition √©value une condition (m√©thode helper)
func (n *NotNodeImpl) evaluateCondition(condition interface{}, token *domain.Token, fact *domain.Fact) (bool, error) <span class="cov8" title="1">{
        // Pour l'instant, impl√©mentation simplifi√©e qui √©value les conditions NOT basiques
        // sur les champs des faits

        // V√©rifier si c'est une condition de base avec comparison
        if conditionMap, ok := condition.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if conditionType, hasType := conditionMap["type"]; hasType </span><span class="cov8" title="1">{
                        switch conditionType </span>{
                        case "binaryOperation", "binary_op":<span class="cov8" title="1">
                                return n.evaluateBinaryCondition(conditionMap, token, fact)</span>
                        case "simple":<span class="cov8" title="1">
                                return true, nil</span> // Condition simple toujours vraie pour l'instant
                        }
                }
        }

        // Pour les autres types de conditions, retourner false par d√©faut
        <span class="cov8" title="1">return false, nil</span>
}

// evaluateBinaryCondition √©value une condition binaire simple (p.age == 0)
func (n *NotNodeImpl) evaluateBinaryCondition(conditionMap map[string]interface{}, token *domain.Token, fact *domain.Fact) (bool, error) <span class="cov8" title="1">{
        // Pour le format attendu: {left: {variable: "p", field: "age"}, operator: "==", right: {value: 0}}

        // Extraire l'op√©rateur
        operator, ok := conditionMap["operator"].(string)
        if !ok </span><span class="cov8" title="1">{
                operator, ok = conditionMap["op"].(string)
                if !ok </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("op√©rateur manquant")
                }</span>
        }

        // Extraire la valeur de gauche (field du fait)
        <span class="cov8" title="1">leftValue, err := n.extractFieldValue(conditionMap["left"], token, fact)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur extraction valeur gauche: %w", err)
        }</span>

        // Extraire la valeur de droite (constante)
        <span class="cov8" title="1">rightValue, err := n.extractConstantValue(conditionMap["right"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur extraction valeur droite: %w", err)
        }</span>

        // Comparer les valeurs
        <span class="cov8" title="1">return n.compareValues(leftValue, operator, rightValue)</span>
}

// extractFieldValue extrait la valeur d'un champ depuis un fait
func (n *NotNodeImpl) extractFieldValue(leftExpr interface{}, token *domain.Token, fact *domain.Fact) (interface{}, error) <span class="cov8" title="1">{
        if leftMap, ok := leftExpr.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if fieldName, hasField := leftMap["field"].(string); hasField </span><span class="cov8" title="1">{
                        // Chercher la valeur dans le fait principal du token
                        if len(token.Facts) &gt; 0 </span><span class="cov8" title="1">{
                                primaryFact := token.Facts[0]
                                if value, exists := primaryFact.Fields[fieldName]; exists </span><span class="cov8" title="1">{
                                        return value, nil
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("impossible d'extraire la valeur du champ")</span>
}

// extractConstantValue extrait une valeur constante
func (n *NotNodeImpl) extractConstantValue(rightExpr interface{}) (interface{}, error) <span class="cov8" title="1">{
        if rightMap, ok := rightExpr.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if value, hasValue := rightMap["value"]; hasValue </span><span class="cov8" title="1">{
                        return value, nil
                }</span>
        }
        // Si c'est directement la valeur
        <span class="cov8" title="1">return rightExpr, nil</span>
}

// compareValues compare deux valeurs avec un op√©rateur
func (n *NotNodeImpl) compareValues(left interface{}, operator string, right interface{}) (bool, error) <span class="cov8" title="1">{
        switch operator </span>{
        case "==":<span class="cov8" title="1">
                return fmt.Sprintf("%v", left) == fmt.Sprintf("%v", right), nil</span>
        case "!=":<span class="cov8" title="1">
                return fmt.Sprintf("%v", left) != fmt.Sprintf("%v", right), nil</span>
        case "&lt;":<span class="cov8" title="1">
                return n.numericCompare(left, right, func(l, r float64) bool </span><span class="cov8" title="1">{ return l &lt; r }</span>)
        case "&gt;":<span class="cov8" title="1">
                return n.numericCompare(left, right, func(l, r float64) bool </span><span class="cov8" title="1">{ return l &gt; r }</span>)
        case "&lt;=":<span class="cov8" title="1">
                return n.numericCompare(left, right, func(l, r float64) bool </span><span class="cov8" title="1">{ return l &lt;= r }</span>)
        case "&gt;=":<span class="cov8" title="1">
                return n.numericCompare(left, right, func(l, r float64) bool </span><span class="cov8" title="1">{ return l &gt;= r }</span>)
        default:<span class="cov8" title="1">
                return false, fmt.Errorf("op√©rateur non support√©: %s", operator)</span>
        }
}

// numericCompare compare num√©riquement deux valeurs
func (n *NotNodeImpl) numericCompare(left, right interface{}, compareFunc func(float64, float64) bool) (bool, error) <span class="cov8" title="1">{
        leftFloat, err := n.toFloat64(left)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">rightFloat, err := n.toFloat64(right)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return compareFunc(leftFloat, rightFloat), nil</span>
}

// toFloat64 convertit une valeur en float64
func (n *NotNodeImpl) toFloat64(value interface{}) (float64, error) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return float64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(v), nil</span>
        case float64:<span class="cov8" title="1">
                return v, nil</span>
        case float32:<span class="cov0" title="0">
                return float64(v), nil</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("impossible de convertir %T en float64", value)</span>
        }
}

// ExistsNodeImpl impl√©mente l'interface ExistsNode pour la quantification existentielle
type ExistsNodeImpl struct {
        *BaseBetaNode
        existenceVariable  domain.TypedVariable
        existenceCondition interface{}
        mu                 sync.RWMutex
}

// NewExistsNode cr√©e un nouveau n≈ìud EXISTS
func NewExistsNode(id string, logger domain.Logger) *ExistsNodeImpl <span class="cov8" title="1">{
        baseBeta := NewBaseBetaNode(id, "ExistsNode", logger)
        return &amp;ExistsNodeImpl{
                BaseBetaNode: baseBeta,
        }
}</span>

// SetExistenceCondition d√©finit la condition d'existence
func (e *ExistsNodeImpl) SetExistenceCondition(variable domain.TypedVariable, condition interface{}) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.existenceVariable = variable
        e.existenceCondition = condition
}</span>

// GetExistenceCondition retourne la condition d'existence
func (e *ExistsNodeImpl) GetExistenceCondition() (domain.TypedVariable, interface{}) <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        return e.existenceVariable, e.existenceCondition
}</span>

// CheckExistence v√©rifie l'existence d'au moins un fait satisfaisant la condition
func (e *ExistsNodeImpl) CheckExistence(token *domain.Token) bool <span class="cov8" title="1">{
        e.mu.RLock()
        condition := e.existenceCondition
        e.mu.RUnlock()

        if condition == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // V√©rifier tous les faits de droite
        <span class="cov8" title="1">rightFacts := e.betaMemory.GetFacts()
        for _, fact := range rightFacts </span><span class="cov8" title="1">{
                // Si le fait correspond au type de la variable d'existence
                if fact.Type == e.existenceVariable.DataType </span><span class="cov8" title="1">{
                        // √âvaluer la condition
                        if result, err := e.evaluateExistenceCondition(condition, token, fact); err == nil &amp;&amp; result </span><span class="cov8" title="1">{
                                return true // Au moins un fait satisfait la condition
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span> // Aucun fait ne satisfait la condition
}

// ProcessLeftToken traite un token venant de la gauche
func (e *ExistsNodeImpl) ProcessLeftToken(token *domain.Token) error <span class="cov8" title="1">{
        e.logger.Debug("processing token in ExistsNode", map[string]interface{}{
                "node_id":    e.id,
                "token_id":   token.ID,
                "node_type":  "ExistsNode",
                "action":     "left_input",
                "fact_count": len(token.Facts),
        })

        // Stocker le token dans la m√©moire gauche
        e.betaMemory.StoreToken(token)

        // V√©rifier l'existence
        if e.CheckExistence(token) </span><span class="cov8" title="1">{
                e.logger.Debug("existence condition satisfied", map[string]interface{}{
                        "node_id":  e.id,
                        "token_id": token.ID,
                })
                return e.propagateTokenToChildren(token)
        }</span>

        <span class="cov8" title="1">e.logger.Debug("existence condition not satisfied", map[string]interface{}{
                "node_id":  e.id,
                "token_id": token.ID,
        })

        return nil</span>
}

// ProcessRightFact traite un fait venant de la droite
func (e *ExistsNodeImpl) ProcessRightFact(fact *domain.Fact) error <span class="cov8" title="1">{
        e.logger.Debug("processing fact in ExistsNode", map[string]interface{}{
                "node_id":   e.id,
                "fact_id":   fact.ID,
                "fact_type": fact.Type,
                "node_type": "ExistsNode",
                "action":    "right_input",
        })

        // Stocker le fait dans la m√©moire droite
        e.betaMemory.StoreFact(fact)

        // V√©rifier tous les tokens de gauche pour voir si l'existence est maintenant satisfaite
        leftTokens := e.betaMemory.GetTokens()
        for _, token := range leftTokens </span><span class="cov8" title="1">{
                if e.CheckExistence(token) </span><span class="cov8" title="1">{
                        e.logger.Debug("existence now satisfied by new fact", map[string]interface{}{
                                "node_id":  e.id,
                                "token_id": token.ID,
                                "fact_id":  fact.ID,
                        })
                        // Propager le token s'il n'√©tait pas d√©j√† propag√©
                        e.propagateTokenToChildren(token)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// evaluateExistenceCondition √©value une condition d'existence
func (e *ExistsNodeImpl) evaluateExistenceCondition(condition interface{}, token *domain.Token, fact *domain.Fact) (bool, error) <span class="cov8" title="1">{
        // Note: L'√©valuation des conditions EXISTS est g√©r√©e par evaluateConditionRecursive dans le package rete
        return true, nil
}</span>

// AccumulateNodeImpl impl√©mente l'interface AccumulateNode pour les fonctions d'agr√©gation
type AccumulateNodeImpl struct {
        *BaseBetaNode
        accumulator       domain.AccumulateFunction
        accumulatedValues map[string]interface{} // Stockage des valeurs agr√©g√©es par token
        mu                sync.RWMutex
}

// NewAccumulateNode cr√©e un nouveau n≈ìud d'accumulation
func NewAccumulateNode(id string, accumulator domain.AccumulateFunction, logger domain.Logger) *AccumulateNodeImpl <span class="cov8" title="1">{
        baseBeta := NewBaseBetaNode(id, "AccumulateNode", logger)
        return &amp;AccumulateNodeImpl{
                BaseBetaNode:      baseBeta,
                accumulator:       accumulator,
                accumulatedValues: make(map[string]interface{}),
        }
}</span>

// SetAccumulator d√©finit la fonction d'accumulation
func (a *AccumulateNodeImpl) SetAccumulator(accumulator domain.AccumulateFunction) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()
        a.accumulator = accumulator
}</span>

// GetAccumulator retourne la fonction d'accumulation
func (a *AccumulateNodeImpl) GetAccumulator() domain.AccumulateFunction <span class="cov8" title="1">{
        a.mu.RLock()
        defer a.mu.RUnlock()
        return a.accumulator
}</span>

// ComputeAggregate calcule l'agr√©gation pour un token donn√©
func (a *AccumulateNodeImpl) ComputeAggregate(token *domain.Token, facts []*domain.Fact) (interface{}, error) <span class="cov8" title="1">{
        a.mu.RLock()
        accumulator := a.accumulator
        a.mu.RUnlock()

        if accumulator.FunctionType == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no accumulator function defined")
        }</span>

        <span class="cov8" title="1">switch accumulator.FunctionType </span>{
        case AggregateFunctionSum:<span class="cov8" title="1">
                return a.computeSum(facts, accumulator.Field)</span>
        case AggregateFunctionCount:<span class="cov8" title="1">
                return len(facts), nil</span>
        case AggregateFunctionAvg:<span class="cov8" title="1">
                return a.computeAverage(facts, accumulator.Field)</span>
        case AggregateFunctionMin:<span class="cov8" title="1">
                return a.computeMinMax(facts, accumulator.Field, true)</span>
        case AggregateFunctionMax:<span class="cov8" title="1">
                return a.computeMinMax(facts, accumulator.Field, false)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported accumulator function: %s", accumulator.FunctionType)</span>
        }
}

// ProcessLeftToken traite un token venant de la gauche
func (a *AccumulateNodeImpl) ProcessLeftToken(token *domain.Token) error <span class="cov8" title="1">{
        a.logger.Debug("processing token in AccumulateNode", map[string]interface{}{
                "node_id":    a.id,
                "token_id":   token.ID,
                "node_type":  "AccumulateNode",
                "action":     "left_input",
                "fact_count": len(token.Facts),
        })

        // Stocker le token dans la m√©moire gauche
        a.betaMemory.StoreToken(token)

        // Obtenir tous les faits de droite pour l'agr√©gation
        rightFacts := a.betaMemory.GetFacts()

        // Calculer l'agr√©gation
        result, err := a.ComputeAggregate(token, rightFacts)
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("failed to compute aggregate", err, map[string]interface{}{
                        "node_id":  a.id,
                        "token_id": token.ID,
                })
                return err
        }</span>

        // Stocker le r√©sultat
        <span class="cov8" title="1">a.mu.Lock()
        a.accumulatedValues[token.ID] = result
        a.mu.Unlock()

        // Propager le token enrichi avec le r√©sultat d'agr√©gation
        return a.propagateAggregateToken(token, result)</span>
}

// ProcessRightFact traite un fait venant de la droite
func (a *AccumulateNodeImpl) ProcessRightFact(fact *domain.Fact) error <span class="cov8" title="1">{
        a.logger.Debug("processing fact in AccumulateNode", map[string]interface{}{
                "node_id":   a.id,
                "fact_id":   fact.ID,
                "fact_type": fact.Type,
                "node_type": "AccumulateNode",
                "action":    "right_input",
        })

        // Stocker le fait dans la m√©moire droite
        a.betaMemory.StoreFact(fact)

        // Recalculer l'agr√©gation pour tous les tokens de gauche
        leftTokens := a.betaMemory.GetTokens()
        for _, token := range leftTokens </span><span class="cov8" title="1">{
                if err := a.recomputeAndPropagateAggregate(token); err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("failed to recompute aggregate for token", err, map[string]interface{}{
                                "node_id":  a.id,
                                "token_id": token.ID,
                                "fact_id":  fact.ID,
                        })
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// recomputeAndPropagateAggregate recalculates the aggregate for a token and propagates if changed
func (a *AccumulateNodeImpl) recomputeAndPropagateAggregate(token *domain.Token) error <span class="cov8" title="1">{
        // Obtenir tous les faits de droite
        rightFacts := a.betaMemory.GetFacts()

        // Recalculer l'agr√©gation
        result, err := a.ComputeAggregate(token, rightFacts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compute aggregate: %w", err)
        }</span>

        // Mettre √† jour le r√©sultat
        <span class="cov8" title="1">a.mu.Lock()
        oldResult, existed := a.accumulatedValues[token.ID]
        a.accumulatedValues[token.ID] = result
        a.mu.Unlock()

        // Si le r√©sultat a chang√©, propager la mise √† jour
        if !existed || oldResult != result </span><span class="cov8" title="1">{
                a.logger.Debug("aggregate result updated", map[string]interface{}{
                        "node_id":    a.id,
                        "token_id":   token.ID,
                        "old_result": oldResult,
                        "new_result": result,
                })

                return a.propagateAggregateToken(token, result)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// propagateAggregateToken creates and propagates a token with aggregate result
func (a *AccumulateNodeImpl) propagateAggregateToken(token *domain.Token, result interface{}) error <span class="cov8" title="1">{
        newToken := &amp;domain.Token{
                ID: fmt.Sprintf("%s_agg", token.ID),
                Facts: append(token.Facts, &amp;domain.Fact{
                        ID:   fmt.Sprintf("agg_%s", token.ID),
                        Type: "AggregateResult",
                        Fields: map[string]interface{}{
                                "function": a.accumulator.FunctionType,
                                "value":    result,
                        },
                }),
        }

        return a.propagateTokenToChildren(newToken)
}</span>

// Fonctions d'aide pour les diff√©rentes agr√©gations

func (a *AccumulateNodeImpl) computeSum(facts []*domain.Fact, field string) (float64, error) <span class="cov8" title="1">{
        var sum float64
        count := 0

        for _, fact := range facts </span><span class="cov8" title="1">{
                if value, exists := fact.Fields[field]; exists </span><span class="cov8" title="1">{
                        switch v := value.(type) </span>{
                        case int:<span class="cov8" title="1">
                                sum += float64(v)
                                count++</span>
                        case int64:<span class="cov0" title="0">
                                sum += float64(v)
                                count++</span>
                        case float64:<span class="cov8" title="1">
                                sum += v
                                count++</span>
                        case float32:<span class="cov0" title="0">
                                sum += float64(v)
                                count++</span>
                        default:<span class="cov0" title="0">
                                // Ignorer les valeurs non num√©riques
                                continue</span>
                        }
                }
        }

        <span class="cov8" title="1">return sum, nil</span>
}

func (a *AccumulateNodeImpl) computeAverage(facts []*domain.Fact, field string) (float64, error) <span class="cov8" title="1">{
        sum, err := a.computeSum(facts, field)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">count := 0
        for _, fact := range facts </span><span class="cov8" title="1">{
                if _, exists := fact.Fields[field]; exists </span><span class="cov8" title="1">{
                        count++
                }</span>
        }

        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">return sum / float64(count), nil</span>
}

// computeMinMax calculates either minimum or maximum value for a field across facts
// isMin parameter: true for minimum, false for maximum
func (a *AccumulateNodeImpl) computeMinMax(facts []*domain.Fact, field string, isMin bool) (interface{}, error) <span class="cov8" title="1">{
        var resultFloat float64
        var resultString string
        var resultOther interface{}
        foundNumeric := false
        foundString := false
        foundOther := false

        for _, fact := range facts </span><span class="cov8" title="1">{
                if value, exists := fact.Fields[field]; exists </span><span class="cov8" title="1">{
                        switch v := value.(type) </span>{
                        case int:<span class="cov8" title="1">
                                floatVal := float64(v)
                                if !foundNumeric || a.shouldUpdateNumeric(floatVal, resultFloat, isMin) </span><span class="cov8" title="1">{
                                        resultFloat = floatVal
                                        foundNumeric = true
                                }</span>
                        case int64:<span class="cov0" title="0">
                                floatVal := float64(v)
                                if !foundNumeric || a.shouldUpdateNumeric(floatVal, resultFloat, isMin) </span><span class="cov0" title="0">{
                                        resultFloat = floatVal
                                        foundNumeric = true
                                }</span>
                        case float32:<span class="cov0" title="0">
                                floatVal := float64(v)
                                if !foundNumeric || a.shouldUpdateNumeric(floatVal, resultFloat, isMin) </span><span class="cov0" title="0">{
                                        resultFloat = floatVal
                                        foundNumeric = true
                                }</span>
                        case float64:<span class="cov0" title="0">
                                if !foundNumeric || a.shouldUpdateNumeric(v, resultFloat, isMin) </span><span class="cov0" title="0">{
                                        resultFloat = v
                                        foundNumeric = true
                                }</span>
                        case string:<span class="cov0" title="0">
                                if !foundString || a.shouldUpdateString(v, resultString, isMin) </span><span class="cov0" title="0">{
                                        resultString = v
                                        foundString = true
                                }</span>
                        default:<span class="cov0" title="0">
                                if !foundOther </span><span class="cov0" title="0">{
                                        resultOther = v
                                        foundOther = true
                                }</span>
                        }
                }
        }

        // Retourner le type le plus appropri√©
        <span class="cov8" title="1">if foundNumeric </span><span class="cov8" title="1">{
                return resultFloat, nil
        }</span>
        <span class="cov0" title="0">if foundString </span><span class="cov0" title="0">{
                return resultString, nil
        }</span>
        <span class="cov0" title="0">if foundOther </span><span class="cov0" title="0">{
                return resultOther, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no values found for field %s", field)</span>
}

// shouldUpdateNumeric determines if a new numeric value should replace the current one
func (a *AccumulateNodeImpl) shouldUpdateNumeric(newVal, currentVal float64, isMin bool) bool <span class="cov8" title="1">{
        if isMin </span><span class="cov8" title="1">{
                return newVal &lt; currentVal
        }</span>
        <span class="cov8" title="1">return newVal &gt; currentVal</span>
}

// shouldUpdateString determines if a new string value should replace the current one
func (a *AccumulateNodeImpl) shouldUpdateString(newVal, currentVal string, isMin bool) bool <span class="cov0" title="0">{
        if isMin </span><span class="cov0" title="0">{
                return newVal &lt; currentVal
        }</span>
        <span class="cov0" title="0">return newVal &gt; currentVal</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package nodes

import (
        "sync"

        "github.com/treivax/tsd/rete/pkg/domain"
)

// BaseNode impl√©mente les fonctionnalit√©s communes √† tous les n≈ìuds.
// Applique le principe DRY (Don't Repeat Yourself).
type BaseNode struct {
        id       string
        nodeType string
        memory   *domain.WorkingMemory
        children []domain.Node
        logger   domain.Logger
        mutex    sync.RWMutex
}

// NewBaseNode cr√©e un nouveau n≈ìud de base.
func NewBaseNode(id, nodeType string, logger domain.Logger) *BaseNode <span class="cov8" title="1">{
        return &amp;BaseNode{
                id:       id,
                nodeType: nodeType,
                memory:   domain.NewWorkingMemory(id),
                children: make([]domain.Node, 0),
                logger:   logger,
        }
}</span>

// ID retourne l'identifiant du n≈ìud.
func (bn *BaseNode) ID() string <span class="cov8" title="1">{
        return bn.id
}</span>

// Type retourne le type du n≈ìud.
func (bn *BaseNode) Type() string <span class="cov8" title="1">{
        return bn.nodeType
}</span>

// GetMemory retourne la m√©moire de travail du n≈ìud.
func (bn *BaseNode) GetMemory() *domain.WorkingMemory <span class="cov8" title="1">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()
        return bn.memory
}</span>

// AddChild ajoute un n≈ìud enfant.
func (bn *BaseNode) AddChild(child domain.Node) <span class="cov8" title="1">{
        bn.mutex.Lock()
        defer bn.mutex.Unlock()
        bn.children = append(bn.children, child)
}</span>

// GetChildren retourne les n≈ìuds enfants.
func (bn *BaseNode) GetChildren() []domain.Node <span class="cov8" title="1">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()

        // Retourne une copie pour √©viter les modifications concurrentes
        children := make([]domain.Node, len(bn.children))
        copy(children, bn.children)
        return children
}</span>

// logFactProcessing enregistre le traitement d'un fait.
func (bn *BaseNode) logFactProcessing(fact *domain.Fact, action string) <span class="cov8" title="1">{
        bn.logger.Debug("processing fact", map[string]interface{}{
                "node_id":   bn.id,
                "node_type": bn.nodeType,
                "fact_id":   fact.ID,
                "fact_type": fact.Type,
                "action":    action,
        })
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package nodes

import (
        "fmt"
        "sync"

        "github.com/treivax/tsd/rete/pkg/domain"
)

// BetaMemoryImpl impl√©mente l'interface BetaMemory pour la gestion de la m√©moire beta.
type BetaMemoryImpl struct {
        tokens map[string]*domain.Token
        facts  map[string]*domain.Fact
        mutex  sync.RWMutex
}

// NewBetaMemory cr√©e une nouvelle instance de m√©moire beta.
func NewBetaMemory() *BetaMemoryImpl <span class="cov8" title="1">{
        return &amp;BetaMemoryImpl{
                tokens: make(map[string]*domain.Token),
                facts:  make(map[string]*domain.Fact),
        }
}</span>

// StoreToken stocke un token dans la m√©moire beta.
func (bm *BetaMemoryImpl) StoreToken(token *domain.Token) <span class="cov8" title="1">{
        bm.mutex.Lock()
        defer bm.mutex.Unlock()
        bm.tokens[token.ID] = token
}</span>

// RemoveToken supprime un token de la m√©moire beta.
func (bm *BetaMemoryImpl) RemoveToken(tokenID string) bool <span class="cov8" title="1">{
        bm.mutex.Lock()
        defer bm.mutex.Unlock()

        if _, exists := bm.tokens[tokenID]; exists </span><span class="cov8" title="1">{
                delete(bm.tokens, tokenID)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// GetTokens retourne tous les tokens stock√©s.
func (bm *BetaMemoryImpl) GetTokens() []*domain.Token <span class="cov8" title="1">{
        bm.mutex.RLock()
        defer bm.mutex.RUnlock()

        tokens := make([]*domain.Token, 0, len(bm.tokens))
        for _, token := range bm.tokens </span><span class="cov8" title="1">{
                tokens = append(tokens, token)
        }</span>
        <span class="cov8" title="1">return tokens</span>
}

// StoreFact stocke un fait dans la m√©moire beta.
func (bm *BetaMemoryImpl) StoreFact(fact *domain.Fact) <span class="cov8" title="1">{
        bm.mutex.Lock()
        defer bm.mutex.Unlock()
        bm.facts[fact.ID] = fact
}</span>

// RemoveFact supprime un fait de la m√©moire beta.
func (bm *BetaMemoryImpl) RemoveFact(factID string) bool <span class="cov8" title="1">{
        bm.mutex.Lock()
        defer bm.mutex.Unlock()

        if _, exists := bm.facts[factID]; exists </span><span class="cov8" title="1">{
                delete(bm.facts, factID)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// GetFacts retourne tous les faits stock√©s.
func (bm *BetaMemoryImpl) GetFacts() []*domain.Fact <span class="cov8" title="1">{
        bm.mutex.RLock()
        defer bm.mutex.RUnlock()

        facts := make([]*domain.Fact, 0, len(bm.facts))
        for _, fact := range bm.facts </span><span class="cov8" title="1">{
                facts = append(facts, fact)
        }</span>
        <span class="cov8" title="1">return facts</span>
}

// Clear vide la m√©moire beta.
func (bm *BetaMemoryImpl) Clear() <span class="cov8" title="1">{
        bm.mutex.Lock()
        defer bm.mutex.Unlock()

        bm.tokens = make(map[string]*domain.Token)
        bm.facts = make(map[string]*domain.Fact)
}</span>

// Size retourne le nombre de tokens et de faits stock√©s.
func (bm *BetaMemoryImpl) Size() (tokens int, facts int) <span class="cov8" title="1">{
        bm.mutex.RLock()
        defer bm.mutex.RUnlock()

        return len(bm.tokens), len(bm.facts)
}</span>

// BaseBetaNode impl√©mente les fonctionnalit√©s de base d'un n≈ìud beta.
type BaseBetaNode struct {
        *BaseNode
        betaMemory domain.BetaMemory
}

// NewBaseBetaNode cr√©e un nouveau n≈ìud beta de base.
func NewBaseBetaNode(id, nodeType string, logger domain.Logger) *BaseBetaNode <span class="cov8" title="1">{
        return &amp;BaseBetaNode{
                BaseNode:   NewBaseNode(id, nodeType, logger),
                betaMemory: NewBetaMemory(),
        }
}</span>

// ProcessFact impl√©mente l'interface Node (d√©l√®gue √† ProcessRightFact).
func (bbn *BaseBetaNode) ProcessFact(fact *domain.Fact) error <span class="cov0" title="0">{
        return bbn.ProcessRightFact(fact)
}</span>

// ProcessLeftToken traite un token venant du c√¥t√© gauche.
func (bbn *BaseBetaNode) ProcessLeftToken(token *domain.Token) error <span class="cov8" title="1">{
        bbn.logTokenProcessing(token, "left_input")
        bbn.betaMemory.StoreToken(token)

        // Essayer de faire des jointures avec les faits du c√¥t√© droit
        rightFacts := bbn.betaMemory.GetFacts()
        for _, fact := range rightFacts </span><span class="cov0" title="0">{
                if err := bbn.tryJoin(token, fact); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ProcessRightFact traite un fait venant du c√¥t√© droit.
func (bbn *BaseBetaNode) ProcessRightFact(fact *domain.Fact) error <span class="cov0" title="0">{
        bbn.logFactProcessing(fact, "right_input")
        bbn.betaMemory.StoreFact(fact)

        // Essayer de faire des jointures avec les tokens du c√¥t√© gauche
        leftTokens := bbn.betaMemory.GetTokens()
        for _, token := range leftTokens </span><span class="cov0" title="0">{
                if err := bbn.tryJoin(token, fact); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// tryJoin essaie de faire une jointure entre un token et un fait.
// Cette m√©thode de base accepte toute combinaison (pas de condition).
func (bbn *BaseBetaNode) tryJoin(token *domain.Token, fact *domain.Fact) error <span class="cov0" title="0">{
        // Cr√©er un nouveau token combinant le token existant et le nouveau fait
        newFacts := make([]*domain.Fact, len(token.Facts)+1)
        copy(newFacts, token.Facts)
        newFacts[len(token.Facts)] = fact

        newTokenID := fmt.Sprintf("%s_%s", token.ID, fact.ID)
        newToken := domain.NewToken(newTokenID, bbn.ID(), newFacts)
        newToken.Parent = token

        bbn.logJoin(token, fact, newToken)

        // Propager le nouveau token vers les enfants
        return bbn.propagateTokenToChildren(newToken)
}</span>

// GetLeftMemory retourne les tokens de la m√©moire gauche.
func (bbn *BaseBetaNode) GetLeftMemory() []*domain.Token <span class="cov8" title="1">{
        return bbn.betaMemory.GetTokens()
}</span>

// GetRightMemory retourne les faits de la m√©moire droite.
func (bbn *BaseBetaNode) GetRightMemory() []*domain.Fact <span class="cov8" title="1">{
        return bbn.betaMemory.GetFacts()
}</span>

// ClearMemory vide la m√©moire beta.
func (bbn *BaseBetaNode) ClearMemory() <span class="cov0" title="0">{
        bbn.betaMemory.Clear()
}</span>

// propagateTokenToChildren propage un token vers tous les enfants.
func (bbn *BaseBetaNode) propagateTokenToChildren(token *domain.Token) error <span class="cov8" title="1">{
        children := bbn.GetChildren()

        for _, child := range children </span><span class="cov8" title="1">{
                // Si l'enfant est un BetaNode, propager comme token gauche
                if betaChild, ok := child.(domain.BetaNode); ok </span><span class="cov8" title="1">{
                        if err := betaChild.ProcessLeftToken(token); err != nil </span><span class="cov0" title="0">{
                                bbn.logger.Error("failed to propagate token to beta child", err, map[string]interface{}{
                                        "parent_node": bbn.ID(),
                                        "child_node":  child.ID(),
                                        "token_id":    token.ID,
                                })
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Pour les autres types de n≈ìuds, traiter comme fait (dernier fait du token)
                        if len(token.Facts) &gt; 0 </span><span class="cov0" title="0">{
                                lastFact := token.Facts[len(token.Facts)-1]
                                if err := child.ProcessFact(lastFact); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// logTokenProcessing enregistre le traitement d'un token.
func (bbn *BaseBetaNode) logTokenProcessing(token *domain.Token, action string) <span class="cov8" title="1">{
        bbn.logger.Debug("processing token", map[string]interface{}{
                "node_id":    bbn.ID(),
                "node_type":  bbn.Type(),
                "token_id":   token.ID,
                "fact_count": len(token.Facts),
                "action":     action,
        })
}</span>

// logJoin enregistre une jointure r√©ussie.
func (bbn *BaseBetaNode) logJoin(leftToken *domain.Token, rightFact *domain.Fact, resultToken *domain.Token) <span class="cov0" title="0">{
        bbn.logger.Debug("join performed", map[string]interface{}{
                "node_id":         bbn.ID(),
                "left_token_id":   leftToken.ID,
                "right_fact_id":   rightFact.ID,
                "result_token_id": resultToken.ID,
                "fact_count":      len(resultToken.Facts),
        })
}</span>

// JoinNodeImpl impl√©mente un n≈ìud de jointure avec conditions.
type JoinNodeImpl struct {
        *BaseBetaNode
        joinConditions []domain.JoinCondition
        mutex          sync.RWMutex
}

// NewJoinNode cr√©e un nouveau n≈ìud de jointure.
func NewJoinNode(id string, logger domain.Logger) *JoinNodeImpl <span class="cov0" title="0">{
        return &amp;JoinNodeImpl{
                BaseBetaNode:   NewBaseBetaNode(id, "JoinNode", logger),
                joinConditions: make([]domain.JoinCondition, 0),
        }
}</span>

// SetJoinConditions d√©finit les conditions de jointure.
func (jn *JoinNodeImpl) SetJoinConditions(conditions []domain.JoinCondition) <span class="cov0" title="0">{
        jn.mutex.Lock()
        defer jn.mutex.Unlock()
        jn.joinConditions = make([]domain.JoinCondition, len(conditions))
        copy(jn.joinConditions, conditions)
}</span>

// GetJoinConditions retourne les conditions de jointure.
func (jn *JoinNodeImpl) GetJoinConditions() []domain.JoinCondition <span class="cov0" title="0">{
        jn.mutex.RLock()
        defer jn.mutex.RUnlock()

        conditions := make([]domain.JoinCondition, len(jn.joinConditions))
        copy(conditions, jn.joinConditions)
        return conditions
}</span>

// EvaluateJoin √©value si un token et un fait peuvent √™tre joints.
func (jn *JoinNodeImpl) EvaluateJoin(token *domain.Token, fact *domain.Fact) bool <span class="cov0" title="0">{
        conditions := jn.GetJoinConditions()

        // Si aucune condition, accepter la jointure (comportement par d√©faut)
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Toutes les conditions doivent √™tre satisfaites (AND logique)
        <span class="cov0" title="0">for _, condition := range conditions </span><span class="cov0" title="0">{
                if !condition.Evaluate(token, fact) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// ProcessLeftToken surcharge la m√©thode de base pour utiliser notre logique de jointure.
func (jn *JoinNodeImpl) ProcessLeftToken(token *domain.Token) error <span class="cov0" title="0">{
        jn.logTokenProcessing(token, "left_input")
        jn.betaMemory.StoreToken(token)

        // Essayer de faire des jointures avec les faits du c√¥t√© droit
        rightFacts := jn.betaMemory.GetFacts()
        for _, fact := range rightFacts </span><span class="cov0" title="0">{
                if err := jn.tryJoin(token, fact); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ProcessRightFact surcharge la m√©thode de base pour utiliser notre logique de jointure.
func (jn *JoinNodeImpl) ProcessRightFact(fact *domain.Fact) error <span class="cov0" title="0">{
        jn.logFactProcessing(fact, "right_input")
        jn.betaMemory.StoreFact(fact)

        // Essayer de faire des jointures avec les tokens du c√¥t√© gauche
        leftTokens := jn.betaMemory.GetTokens()
        for _, token := range leftTokens </span><span class="cov0" title="0">{
                if err := jn.tryJoin(token, fact); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// tryJoin surcharge la m√©thode de base pour inclure l'√©valuation des conditions.
func (jn *JoinNodeImpl) tryJoin(token *domain.Token, fact *domain.Fact) error <span class="cov0" title="0">{
        if !jn.EvaluateJoin(token, fact) </span><span class="cov0" title="0">{
                // Log de la jointure rejet√©e pour debug
                jn.logger.Debug("join rejected", map[string]interface{}{
                        "node_id":       jn.ID(),
                        "left_token_id": token.ID,
                        "right_fact_id": fact.ID,
                        "conditions":    len(jn.joinConditions),
                })
                return nil // Pas d'erreur, juste pas de jointure
        }</span>

        // Utiliser la logique de jointure de la classe parent
        <span class="cov0" title="0">return jn.BaseBetaNode.tryJoin(token, fact)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package rete

import (
        "encoding/json"
        "fmt"
        "sync"
)

// MemoryStorage impl√©mente Storage en m√©moire (pour les tests)
type MemoryStorage struct {
        memories map[string]*WorkingMemory
        mutex    sync.RWMutex
}

// NewMemoryStorage cr√©e un nouveau storage en m√©moire
func NewMemoryStorage() *MemoryStorage <span class="cov8" title="1">{
        return &amp;MemoryStorage{
                memories: make(map[string]*WorkingMemory),
        }
}</span>

// SaveMemory sauvegarde en m√©moire
func (ms *MemoryStorage) SaveMemory(nodeID string, memory *WorkingMemory) error <span class="cov0" title="0">{
        ms.mutex.Lock()
        defer ms.mutex.Unlock()

        // Copier la m√©moire pour √©viter les modifications concurrentes
        data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var copyMemory WorkingMemory
        err = json.Unmarshal(data, &amp;copyMemory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ms.memories[nodeID] = &amp;copyMemory
        return nil</span>
}

// LoadMemory charge depuis la m√©moire
func (ms *MemoryStorage) LoadMemory(nodeID string) (*WorkingMemory, error) <span class="cov0" title="0">{
        ms.mutex.RLock()
        defer ms.mutex.RUnlock()

        memory, exists := ms.memories[nodeID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("m√©moire non trouv√©e pour le n≈ìud %s", nodeID)
        }</span>

        // Retourner une copie
        <span class="cov0" title="0">data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var copyMemory WorkingMemory
        err = json.Unmarshal(data, &amp;copyMemory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;copyMemory, nil</span>
}

// DeleteMemory supprime de la m√©moire
func (ms *MemoryStorage) DeleteMemory(nodeID string) error <span class="cov0" title="0">{
        ms.mutex.Lock()
        defer ms.mutex.Unlock()
        delete(ms.memories, nodeID)
        return nil
}</span>

// ListNodes liste les n≈ìuds en m√©moire
func (ms *MemoryStorage) ListNodes() ([]string, error) <span class="cov0" title="0">{
        ms.mutex.RLock()
        defer ms.mutex.RUnlock()

        nodes := make([]string, 0, len(ms.memories))
        for nodeID := range ms.memories </span><span class="cov0" title="0">{
                nodes = append(nodes, nodeID)
        }</span>
        <span class="cov0" title="0">return nodes, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package rete

import (
        "fmt"
        "sync"
        "time"
)

// IndexedFactStorage fournit un stockage index√© pour les faits
type IndexedFactStorage struct {
        // Index principal par ID de fait
        factsByID map[string]*Fact

        // Index par type de fait
        factsByType map[string]map[string]*Fact

        // Index par propri√©t√©s de fait (champ -&gt; valeur -&gt; faits)
        factsByField map[string]map[interface{}]map[string]*Fact

        // Index composite pour les jointures fr√©quentes
        compositeIndex map[string]map[string]*Fact

        // Statistiques d'utilisation pour optimiser les index
        accessStats map[string]int64

        // Verrou pour la concurrence
        mutex sync.RWMutex

        // Configuration des index
        config IndexConfig
}

// IndexConfig configure les options d'indexation
type IndexConfig struct {
        // Champs √† indexer automatiquement
        IndexedFields []string

        // Taille maximale du cache
        MaxCacheSize int

        // TTL pour les entr√©es de cache
        CacheTTL time.Duration

        // Activer les index composites
        EnableCompositeIndex bool

        // Seuil pour cr√©er des index automatiques
        AutoIndexThreshold int64
}

// NewIndexedFactStorage cr√©e un nouveau stockage index√©
func NewIndexedFactStorage(config IndexConfig) *IndexedFactStorage <span class="cov0" title="0">{
        return &amp;IndexedFactStorage{
                factsByID:      make(map[string]*Fact),
                factsByType:    make(map[string]map[string]*Fact),
                factsByField:   make(map[string]map[interface{}]map[string]*Fact),
                compositeIndex: make(map[string]map[string]*Fact),
                accessStats:    make(map[string]int64),
                config:         config,
        }
}</span>

// StoreFact stocke un fait avec indexation automatique
func (ifs *IndexedFactStorage) StoreFact(fact *Fact) error <span class="cov0" title="0">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        // Stocker dans l'index principal
        ifs.factsByID[fact.ID] = fact

        // Indexer par type
        if ifs.factsByType[fact.Type] == nil </span><span class="cov0" title="0">{
                ifs.factsByType[fact.Type] = make(map[string]*Fact)
        }</span>
        <span class="cov0" title="0">ifs.factsByType[fact.Type][fact.ID] = fact

        // Indexer par champs configur√©s
        for _, fieldName := range ifs.config.IndexedFields </span><span class="cov0" title="0">{
                if value, exists := fact.Fields[fieldName]; exists </span><span class="cov0" title="0">{
                        ifs.indexFieldValue(fieldName, value, fact)
                }</span>
        }

        // Indexer par tous les champs si activ√©
        <span class="cov0" title="0">for fieldName, value := range fact.Fields </span><span class="cov0" title="0">{
                ifs.indexFieldValue(fieldName, value, fact)
        }</span>

        // Cr√©er des index composites si activ√©
        <span class="cov0" title="0">if ifs.config.EnableCompositeIndex </span><span class="cov0" title="0">{
                ifs.createCompositeIndexes(fact)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// indexFieldValue indexe une valeur de champ
func (ifs *IndexedFactStorage) indexFieldValue(fieldName string, value interface{}, fact *Fact) <span class="cov0" title="0">{
        if ifs.factsByField[fieldName] == nil </span><span class="cov0" title="0">{
                ifs.factsByField[fieldName] = make(map[interface{}]map[string]*Fact)
        }</span>
        <span class="cov0" title="0">if ifs.factsByField[fieldName][value] == nil </span><span class="cov0" title="0">{
                ifs.factsByField[fieldName][value] = make(map[string]*Fact)
        }</span>
        <span class="cov0" title="0">ifs.factsByField[fieldName][value][fact.ID] = fact</span>
}

// createCompositeIndexes cr√©e des index composites pour les jointures fr√©quentes
func (ifs *IndexedFactStorage) createCompositeIndexes(fact *Fact) <span class="cov0" title="0">{
        // Cr√©er des cl√©s composites pour des combinaisons communes
        if id, hasID := fact.Fields["id"]; hasID </span><span class="cov0" title="0">{
                if name, hasName := fact.Fields["name"]; hasName </span><span class="cov0" title="0">{
                        compositeKey := fmt.Sprintf("id_name:%v_%v", id, name)
                        if ifs.compositeIndex[compositeKey] == nil </span><span class="cov0" title="0">{
                                ifs.compositeIndex[compositeKey] = make(map[string]*Fact)
                        }</span>
                        <span class="cov0" title="0">ifs.compositeIndex[compositeKey][fact.ID] = fact</span>
                }
        }
}

// GetFactByID r√©cup√®re un fait par son ID
func (ifs *IndexedFactStorage) GetFactByID(id string) (*Fact, bool) <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        ifs.recordAccess("id:" + id)

        fact, exists := ifs.factsByID[id]
        return fact, exists
}</span>

// GetFactsByType r√©cup√®re tous les faits d'un type donn√©
func (ifs *IndexedFactStorage) GetFactsByType(factType string) []*Fact <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        ifs.recordAccess("type:" + factType)

        factsMap, exists := ifs.factsByType[factType]
        if !exists </span><span class="cov0" title="0">{
                return []*Fact{}
        }</span>

        <span class="cov0" title="0">facts := make([]*Fact, 0, len(factsMap))
        for _, fact := range factsMap </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>

        <span class="cov0" title="0">return facts</span>
}

// GetFactsByField r√©cup√®re des faits par valeur de champ
func (ifs *IndexedFactStorage) GetFactsByField(fieldName string, value interface{}) []*Fact <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        accessKey := fmt.Sprintf("field:%s:%v", fieldName, value)
        ifs.recordAccess(accessKey)

        fieldIndex, exists := ifs.factsByField[fieldName]
        if !exists </span><span class="cov0" title="0">{
                return []*Fact{}
        }</span>

        <span class="cov0" title="0">factsMap, exists := fieldIndex[value]
        if !exists </span><span class="cov0" title="0">{
                return []*Fact{}
        }</span>

        <span class="cov0" title="0">facts := make([]*Fact, 0, len(factsMap))
        for _, fact := range factsMap </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>

        <span class="cov0" title="0">return facts</span>
}

// GetFactsByCompositeKey r√©cup√®re des faits par cl√© composite
func (ifs *IndexedFactStorage) GetFactsByCompositeKey(key string) []*Fact <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        ifs.recordAccess("composite:" + key)

        factsMap, exists := ifs.compositeIndex[key]
        if !exists </span><span class="cov0" title="0">{
                return []*Fact{}
        }</span>

        <span class="cov0" title="0">facts := make([]*Fact, 0, len(factsMap))
        for _, fact := range factsMap </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>

        <span class="cov0" title="0">return facts</span>
}

// RemoveFact supprime un fait et met √† jour les index
func (ifs *IndexedFactStorage) RemoveFact(factID string) bool <span class="cov0" title="0">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        fact, exists := ifs.factsByID[factID]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Supprimer de l'index principal
        <span class="cov0" title="0">delete(ifs.factsByID, factID)

        // Supprimer de l'index par type
        if typeMap := ifs.factsByType[fact.Type]; typeMap != nil </span><span class="cov0" title="0">{
                delete(typeMap, factID)
                if len(typeMap) == 0 </span><span class="cov0" title="0">{
                        delete(ifs.factsByType, fact.Type)
                }</span>
        }

        // Supprimer des index par champ
        <span class="cov0" title="0">for fieldName, value := range fact.Fields </span><span class="cov0" title="0">{
                if fieldIndex := ifs.factsByField[fieldName]; fieldIndex != nil </span><span class="cov0" title="0">{
                        if valueMap := fieldIndex[value]; valueMap != nil </span><span class="cov0" title="0">{
                                delete(valueMap, factID)
                                if len(valueMap) == 0 </span><span class="cov0" title="0">{
                                        delete(fieldIndex, value)
                                        if len(fieldIndex) == 0 </span><span class="cov0" title="0">{
                                                delete(ifs.factsByField, fieldName)
                                        }</span>
                                }
                        }
                }
        }

        // Supprimer des index composites
        <span class="cov0" title="0">ifs.removeFromCompositeIndexes(fact)

        return true</span>
}

// removeFromCompositeIndexes supprime le fait des index composites
func (ifs *IndexedFactStorage) removeFromCompositeIndexes(fact *Fact) <span class="cov0" title="0">{
        // Supprimer des cl√©s composites
        if id, hasID := fact.Fields["id"]; hasID </span><span class="cov0" title="0">{
                if name, hasName := fact.Fields["name"]; hasName </span><span class="cov0" title="0">{
                        compositeKey := fmt.Sprintf("id_name:%v_%v", id, name)
                        if compositeMap := ifs.compositeIndex[compositeKey]; compositeMap != nil </span><span class="cov0" title="0">{
                                delete(compositeMap, fact.ID)
                                if len(compositeMap) == 0 </span><span class="cov0" title="0">{
                                        delete(ifs.compositeIndex, compositeKey)
                                }</span>
                        }
                }
        }
}

// recordAccess enregistre un acc√®s pour les statistiques
func (ifs *IndexedFactStorage) recordAccess(key string) <span class="cov0" title="0">{
        ifs.accessStats[key]++

        // Cr√©er automatiquement des index pour les acc√®s fr√©quents
        if ifs.accessStats[key] &gt; ifs.config.AutoIndexThreshold </span>{<span class="cov0" title="0">
                // Logique pour cr√©er des index automatiques bas√©s sur les patterns d'acc√®s
        }</span>
}

// GetAccessStats retourne les statistiques d'acc√®s
func (ifs *IndexedFactStorage) GetAccessStats() map[string]int64 <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        stats := make(map[string]int64)
        for key, count := range ifs.accessStats </span><span class="cov0" title="0">{
                stats[key] = count
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// OptimizeIndexes optimise les index bas√©s sur les statistiques d'usage
func (ifs *IndexedFactStorage) OptimizeIndexes() <span class="cov0" title="0">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        // Analyser les patterns d'acc√®s fr√©quents
        for _, count := range ifs.accessStats </span><span class="cov0" title="0">{
                if count &gt; ifs.config.AutoIndexThreshold </span>{<span class="cov0" title="0">
                        // Cr√©er des index optimis√©s pour cet acc√®s
                        // Cette logique peut √™tre √©tendue selon les besoins
                }</span>
        }
}

// Clear vide tous les index et statistiques
func (ifs *IndexedFactStorage) Clear() <span class="cov0" title="0">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        ifs.factsByID = make(map[string]*Fact)
        ifs.factsByType = make(map[string]map[string]*Fact)
        ifs.factsByField = make(map[string]map[interface{}]map[string]*Fact)
        ifs.compositeIndex = make(map[string]map[string]*Fact)
        ifs.accessStats = make(map[string]int64)
}</span>

// Size retourne le nombre total de faits stock√©s
func (ifs *IndexedFactStorage) Size() int <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        return len(ifs.factsByID)
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package main

import (
        "bufio"
        "fmt"
        "log"
        "os"
        "regexp"
        "strings"
)

// TypeDefinition represents a constraint type
type TypeDefinition struct {
        Name   string
        Fields []string
}

// RuleReference represents a field reference in a rule
type RuleReference struct {
        Variable string
        Type     string
        Field    string
        Line     int
        Rule     string
}

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                log.Fatal("Usage: go run validate_coherence.go &lt;constraint_file&gt;")
        }</span>

        <span class="cov0" title="0">filename := os.Args[1]
        fmt.Printf("üîç Validation coh√©rence type/champ: %s\n", filename)

        types, rules, err := parseConstraintFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Erreur parsing: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("üìã Types trouv√©s: %d\n", len(types))
        fmt.Printf("üìã R√®gles trouv√©es: %d\n", len(rules))

        errors := validateReferences(types, rules)

        if len(errors) == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚úÖ Validation r√©ussie: Aucune incoh√©rence d√©tect√©e")
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚ùå %d erreur(s) d√©tect√©e(s):\n", len(errors))
        for _, err := range errors </span><span class="cov0" title="0">{
                fmt.Printf("   Ligne %d: %s\n", err.Line, err)
        }</span>

        // Proposer corrections automatiques
        <span class="cov0" title="0">fmt.Println("\nüîß Suggestions de correction:")
        suggestFixes(errors, types)

        os.Exit(1)</span>
}

func parseConstraintFile(filename string) (map[string]TypeDefinition, []RuleReference, error) <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        types := make(map[string]TypeDefinition)
        var rules []RuleReference

        scanner := bufio.NewScanner(file)
        lineNum := 0

        // Regex patterns
        typePattern := regexp.MustCompile(`type\s+(\w+)\s*:\s*&lt;([^&gt;]+)&gt;`)
        rulePattern := regexp.MustCompile(`\{([^}]+)\}\s*/.*`)
        fieldRefPattern := regexp.MustCompile(`(\w+)\.(\w+)`)

        for scanner.Scan() </span><span class="cov0" title="0">{
                lineNum++
                line := strings.TrimSpace(scanner.Text())

                if strings.HasPrefix(line, "//") || line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse type definitions
                <span class="cov0" title="0">if match := typePattern.FindStringSubmatch(line); match != nil </span><span class="cov0" title="0">{
                        typeName := match[1]
                        fieldsStr := match[2]

                        fields := parseFields(fieldsStr)
                        types[typeName] = TypeDefinition{
                                Name:   typeName,
                                Fields: fields,
                        }
                }</span>

                // Parse rule references
                <span class="cov0" title="0">if match := rulePattern.FindStringSubmatch(line); match != nil </span><span class="cov0" title="0">{
                        variables := parseVariables(match[1])

                        // Find field references in the entire line
                        fieldRefs := fieldRefPattern.FindAllStringSubmatch(line, -1)
                        for _, ref := range fieldRefs </span><span class="cov0" title="0">{
                                varName := ref[1]
                                fieldName := ref[2]

                                typeName := ""
                                if varType, exists := variables[varName]; exists </span><span class="cov0" title="0">{
                                        typeName = varType
                                }</span>

                                <span class="cov0" title="0">rules = append(rules, RuleReference{
                                        Variable: varName,
                                        Type:     typeName,
                                        Field:    fieldName,
                                        Line:     lineNum,
                                        Rule:     line,
                                })</span>
                        }
                }
        }

        <span class="cov0" title="0">return types, rules, scanner.Err()</span>
}

func parseFields(fieldsStr string) []string <span class="cov0" title="0">{
        var fields []string
        parts := strings.Split(fieldsStr, ",")

        for _, part := range parts </span><span class="cov0" title="0">{
                part = strings.TrimSpace(part)
                if colonPos := strings.Index(part, ":"); colonPos != -1 </span><span class="cov0" title="0">{
                        fieldName := strings.TrimSpace(part[:colonPos])
                        fields = append(fields, fieldName)
                }</span>
        }

        <span class="cov0" title="0">return fields</span>
}

func parseVariables(varsStr string) map[string]string <span class="cov0" title="0">{
        variables := make(map[string]string)

        parts := strings.Split(varsStr, ",")
        for _, part := range parts </span><span class="cov0" title="0">{
                part = strings.TrimSpace(part)
                if colonPos := strings.Index(part, ":"); colonPos != -1 </span><span class="cov0" title="0">{
                        varName := strings.TrimSpace(part[:colonPos])
                        typeName := strings.TrimSpace(part[colonPos+1:])
                        variables[varName] = typeName
                }</span>
        }

        <span class="cov0" title="0">return variables</span>
}

func validateReferences(types map[string]TypeDefinition, rules []RuleReference) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError

        for _, rule := range rules </span><span class="cov0" title="0">{
                if rule.Type == "" </span><span class="cov0" title="0">{
                        continue</span> // Skip if type couldn't be determined
                }

                <span class="cov0" title="0">typeDesc, exists := types[rule.Type]
                if !exists </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Line:    rule.Line,
                                Message: fmt.Sprintf("Type inexistant: %s", rule.Type),
                                Rule:    rule.Rule,
                        })
                        continue</span>
                }

                <span class="cov0" title="0">if !contains(typeDesc.Fields, rule.Field) </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Line:    rule.Line,
                                Message: fmt.Sprintf("Champ inexistant: %s.%s (type %s n'a que: %v)", rule.Variable, rule.Field, rule.Type, typeDesc.Fields),
                                Rule:    rule.Rule,
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

func suggestFixes(errors []ValidationError, types map[string]TypeDefinition) <span class="cov0" title="0">{
        for _, err := range errors </span><span class="cov0" title="0">{
                if strings.Contains(err.Message, "Champ inexistant") </span><span class="cov0" title="0">{
                        parts := strings.Split(err.Message, " ")
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                fieldRef := parts[2] // e.g., "p.available"
                                if dotPos := strings.Index(fieldRef, "."); dotPos != -1 </span><span class="cov0" title="0">{
                                        varName := fieldRef[:dotPos]
                                        wrongField := fieldRef[dotPos+1:]

                                        // Find similar fields
                                        for typeName, typeDef := range types </span><span class="cov0" title="0">{
                                                for _, field := range typeDef.Fields </span><span class="cov0" title="0">{
                                                        if similarField(wrongField, field) </span><span class="cov0" title="0">{
                                                                fmt.Printf("   ‚Üí Ligne %d: Remplacer '%s.%s' par '%s.%s' (type %s)\n",
                                                                        err.Line, varName, wrongField, varName, field, typeName)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }
}

type ValidationError struct {
        Line    int
        Message string
        Rule    string
}

func (e ValidationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func similarField(field1, field2 string) bool <span class="cov0" title="0">{
        return levenshteinDistance(field1, field2) &lt;= 2 &amp;&amp; len(field1) &gt; 2
}</span>

func levenshteinDistance(s1, s2 string) int <span class="cov0" title="0">{
        if len(s1) == 0 </span><span class="cov0" title="0">{
                return len(s2)
        }</span>
        <span class="cov0" title="0">if len(s2) == 0 </span><span class="cov0" title="0">{
                return len(s1)
        }</span>

        <span class="cov0" title="0">matrix := make([][]int, len(s1)+1)
        for i := range matrix </span><span class="cov0" title="0">{
                matrix[i] = make([]int, len(s2)+1)
                matrix[i][0] = i
        }</span>
        <span class="cov0" title="0">for j := range matrix[0] </span><span class="cov0" title="0">{
                matrix[0][j] = j
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt;= len(s1); i++ </span><span class="cov0" title="0">{
                for j := 1; j &lt;= len(s2); j++ </span><span class="cov0" title="0">{
                        if s1[i-1] == s2[j-1] </span><span class="cov0" title="0">{
                                matrix[i][j] = matrix[i-1][j-1]
                        }</span> else<span class="cov0" title="0"> {
                                matrix[i][j] = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1
                        }</span>
                }
        }

        <span class="cov0" title="0">return matrix[len(s1)][len(s2)]</span>
}

func min(a, b, c int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                if a &lt; c </span><span class="cov0" title="0">{
                        return a
                }</span>
                <span class="cov0" title="0">return c</span>
        }
        <span class="cov0" title="0">if b &lt; c </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">return c</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package main

import (
        "fmt"
        "strings"

        "github.com/treivax/tsd/rete"
)

type TestResult struct {
        Name        string
        Success     bool
        Error       error
        Description string
        Facts       int
        Actions     int
        ExpectedErr bool
}

func main() <span class="cov0" title="0">{
        fmt.Println("üß™ COMPREHENSIVE ACTION ARGUMENTS TEST SUITE")
        fmt.Println("============================================")

        testSuite := []struct {
                name        string
                constraint  string
                facts       string
                description string
                expectError bool
        }{
                {
                        name:        "Variable Action Test",
                        description: "Test de variables et d'actions",
                        constraint:  "../../constraint/test/integration/variable_action_test.constraint",
                        facts:       "../../constraint/test/integration/variable_action_test.facts",
                },
                {
                        name:        "Comprehensive Args Test",
                        description: "Test complet des arguments",
                        constraint:  "../../constraint/test/integration/comprehensive_args_test.constraint",
                        facts:       "../../constraint/test/integration/comprehensive_args_test.facts",
                },
                {
                        name:        "Error Args Test",
                        description: "Test des erreurs d'arguments",
                        constraint:  "../../constraint/test/integration/error_args_test.constraint",
                        facts:       "../../constraint/test/integration/error_args_test.facts",
                },
        }

        results := make([]TestResult, 0, len(testSuite))

        fmt.Printf("üöÄ Running %d test cases...\n\n", len(testSuite))

        for i, test := range testSuite </span><span class="cov0" title="0">{
                fmt.Printf("üìù Test %d/%d: %s\n", i+1, len(testSuite), test.name)
                fmt.Printf("   %s\n", test.description)
                fmt.Printf("   Constraint: %s\n", test.constraint)
                fmt.Printf("   Facts: %s\n", test.facts)

                result := runSingleTest(test.name, test.constraint, test.facts, test.description, test.expectError)
                results = append(results, result)

                if result.Success </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚úÖ PASSED\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚ùå FAILED: %v\n", result.Error)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Print summary
        <span class="cov0" title="0">printTestSummary(results)</span>
}

func runSingleTest(name, constraintFile, factsFile, description string, expectError bool) TestResult <span class="cov0" title="0">{
        result := TestResult{
                Name:        name,
                Description: description,
                ExpectedErr: expectError,
        }

        // Create pipeline and storage
        pipeline := rete.NewConstraintPipeline()
        storage := rete.NewMemoryStorage()

        // Try to build network
        network, facts, err := pipeline.BuildNetworkFromConstraintFileWithFacts(
                constraintFile,
                factsFile,
                storage,
        )

        // Handle expected errors
        if expectError </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        result.Success = true
                        result.Error = nil
                        fmt.Printf("   ‚úì Expected error detected: %v\n", err)
                        return result
                }</span> else<span class="cov0" title="0"> {
                        result.Success = false
                        result.Error = fmt.Errorf("expected error but test succeeded")
                        return result
                }</span>
        }

        // Handle unexpected errors
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                result.Success = false
                result.Error = err
                return result
        }</span>

        // Test succeeded - validate results
        <span class="cov0" title="0">result.Facts = len(facts)
        result.Actions = len(network.TerminalNodes)

        // Additional validation for successful cases
        err = validateTestResults(network, facts)
        if err != nil </span><span class="cov0" title="0">{
                result.Success = false
                result.Error = fmt.Errorf("validation failed: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">result.Success = true
        fmt.Printf("   ‚úì Network built: %d facts, %d terminal nodes\n", result.Facts, result.Actions)

        // Display some actions triggered for verification
        displayTriggeredActions(network)

        return result</span>
}

func validateTestResults(network *rete.ReteNetwork, facts []*rete.Fact) error <span class="cov0" title="0">{
        // Validate network structure
        if len(network.TypeNodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no type nodes created")
        }</span>

        <span class="cov0" title="0">if len(network.TerminalNodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no terminal nodes created")
        }</span>

        // Validate terminal nodes have proper actions
        <span class="cov0" title="0">for id, terminal := range network.TerminalNodes </span><span class="cov0" title="0">{
                if terminal.Action == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("terminal node %s has no action", id)
                }</span>

                <span class="cov0" title="0">if terminal.Action.Job.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("terminal node %s has empty action name", id)
                }</span>
        }

        // Validate facts were processed
        <span class="cov0" title="0">if len(facts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no facts were parsed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func displayTriggeredActions(network *rete.ReteNetwork) <span class="cov0" title="0">{
        fmt.Printf("   üìã Terminal nodes and their actions:\n")
        for id, terminal := range network.TerminalNodes </span><span class="cov0" title="0">{
                if terminal.Action != nil </span><span class="cov0" title="0">{
                        fmt.Printf("      - %s: %s(%v)\n",
                                id,
                                terminal.Action.Job.Name,
                                formatArgs(terminal.Action.Job.Args))
                }</span>
        }
}

func formatArgs(args []interface{}) string <span class="cov0" title="0">{
        formatted := make([]string, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                if argMap, ok := arg.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if argType, hasType := argMap["type"]; hasType </span><span class="cov0" title="0">{
                                switch argType </span>{
                                case "variable":<span class="cov0" title="0">
                                        if name, hasName := argMap["name"]; hasName </span><span class="cov0" title="0">{
                                                formatted[i] = fmt.Sprintf("var:%s", name)
                                        }</span>
                                case "fieldAccess":<span class="cov0" title="0">
                                        if obj, hasObj := argMap["object"]; hasObj </span><span class="cov0" title="0">{
                                                if field, hasField := argMap["field"]; hasField </span><span class="cov0" title="0">{
                                                        formatted[i] = fmt.Sprintf("field:%s.%s", obj, field)
                                                }</span>
                                        }
                                }
                        }
                } else<span class="cov0" title="0"> {
                        formatted[i] = fmt.Sprintf("%v", arg)
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(formatted, ", ")</span>
}

func printTestSummary(results []TestResult) <span class="cov0" title="0">{
        fmt.Println("üìä TEST SUMMARY")
        fmt.Println("===============")

        passed := 0
        failed := 0

        for _, result := range results </span><span class="cov0" title="0">{
                if result.Success </span><span class="cov0" title="0">{
                        passed++
                        fmt.Printf("‚úÖ %s\n", result.Name)
                        if !result.ExpectedErr </span><span class="cov0" title="0">{
                                fmt.Printf("   üìà %d facts processed, %d actions available\n", result.Facts, result.Actions)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("   üõ°Ô∏è Error correctly detected and handled\n")
                        }</span>
                } else<span class="cov0" title="0"> {
                        failed++
                        fmt.Printf("‚ùå %s\n", result.Name)
                        fmt.Printf("   üí• %v\n", result.Error)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nüéØ FINAL RESULTS: %d passed, %d failed out of %d total tests\n",
                passed, failed, len(results))

        if failed == 0 </span><span class="cov0" title="0">{
                fmt.Println("üéâ ALL TESTS PASSED! Action arguments system is working correctly.")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("‚ö†Ô∏è Some tests failed. Please review the errors above.")
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package main

import (
        "fmt"
        "strings"
        "testing"

        "github.com/treivax/tsd/rete"
)

// TestHelper contient des fonctions utilitaires pour les tests RETE
type TestHelper struct {
        pipeline *rete.ConstraintPipeline
}

// NewTestHelper cr√©e un nouvel helper de test
func NewTestHelper() *TestHelper <span class="cov8" title="1">{
        return &amp;TestHelper{
                pipeline: rete.NewConstraintPipeline(),
        }
}</span>

// BuildNetworkFromConstraintFile utilise le pipeline unique pour construire un r√©seau RETE
// Cette fonction DOIT √™tre utilis√©e par TOUS les tests qui utilisent des fichiers .constraint
func (th *TestHelper) BuildNetworkFromConstraintFile(t *testing.T, constraintFile string) (*rete.ReteNetwork, rete.Storage) <span class="cov8" title="1">{
        storage := rete.NewMemoryStorage()

        network, err := th.pipeline.BuildNetworkFromConstraintFile(constraintFile, storage)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("‚ùå Erreur pipeline constraint ‚Üí RETE: %v", err)
        }</span>

        <span class="cov8" title="1">return network, storage</span>
}

// BuildNetworkFromConstraintFileWithMassiveFacts utilise le pipeline avec fichiers .constraint et .facts
func (th *TestHelper) BuildNetworkFromConstraintFileWithMassiveFacts(t *testing.T, constraintFile, factsFile string) (*rete.ReteNetwork, []*rete.Fact, rete.Storage) <span class="cov8" title="1">{
        storage := rete.NewMemoryStorage()

        network, facts, err := th.pipeline.BuildNetworkFromConstraintFileWithFacts(constraintFile, factsFile, storage)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("‚ùå Erreur pipeline constraint + faits ‚Üí RETE: %v", err)
        }</span>

        <span class="cov8" title="1">return network, facts, storage</span>
}

// CreateUserFact cr√©e un fait utilisateur standardis√© pour les tests
func (th *TestHelper) CreateUserFact(id, nom, prenom string, age float64) *rete.Fact <span class="cov8" title="1">{
        return &amp;rete.Fact{
                ID:   "fact_u_" + id,
                Type: "Utilisateur",
                Fields: map[string]interface{}{
                        "id":     id,
                        "nom":    nom,
                        "prenom": prenom,
                        "age":    age,
                },
        }
}</span>

// CreateAddressFact cr√©e un fait adresse standardis√© pour les tests
func (th *TestHelper) CreateAddressFact(userID, rue, ville string) *rete.Fact <span class="cov8" title="1">{
        return &amp;rete.Fact{
                ID:   "fact_a_" + userID,
                Type: "Adresse",
                Fields: map[string]interface{}{
                        "utilisateur_id": userID,
                        "rue":            rue,
                        "ville":          ville,
                },
        }
}</span>

// CreateCustomerFact cr√©e un fait customer standardis√© pour les tests
func (th *TestHelper) CreateCustomerFact(id string, age float64, vip bool) *rete.Fact <span class="cov8" title="1">{
        return &amp;rete.Fact{
                ID:   "fact_c_" + id,
                Type: "Customer",
                Fields: map[string]interface{}{
                        "id":  id,
                        "age": age,
                        "vip": vip,
                },
        }
}</span>

// SubmitFactsAndAnalyze soumet des faits et analyse le tuple-space
func (th *TestHelper) SubmitFactsAndAnalyze(t *testing.T, network *rete.ReteNetwork, facts []*rete.Fact) int <span class="cov8" title="1">{
        totalActions := 0

        // Soumettre les faits
        for _, fact := range facts </span><span class="cov8" title="1">{
                err := network.SubmitFact(fact)
                if err != nil </span><span class="cov0" title="0">{
                        t.Logf("‚ö†Ô∏è Erreur soumission fait %s: %v", fact.ID, err)
                }</span>
        }

        // Analyser les r√©sultats
        <span class="cov8" title="1">for terminalID, terminal := range network.TerminalNodes </span><span class="cov8" title="1">{
                tokenCount := len(terminal.Memory.Tokens)
                totalActions += tokenCount

                t.Logf("Terminal %s: %d tuples stock√©s", terminalID, tokenCount)
        }</span>

        <span class="cov8" title="1">return totalActions</span>
}

// ShowFactDetails affiche les d√©tails complets d'un fait avec tous ses attributs
func (th *TestHelper) ShowFactDetails(fact *rete.Fact, index int) string <span class="cov8" title="1">{
        if fact == nil || fact.Fields == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Construire une repr√©sentation compl√®te du fait avec id en premier
        <span class="cov8" title="1">var sortedAttrs []string
        if id, exists := fact.Fields["id"]; exists </span><span class="cov0" title="0">{
                sortedAttrs = append(sortedAttrs, fmt.Sprintf("id=%v", id))
        }</span>
        <span class="cov8" title="1">for key, value := range fact.Fields </span><span class="cov8" title="1">{
                if key != "id" </span><span class="cov8" title="1">{
                        sortedAttrs = append(sortedAttrs, fmt.Sprintf("%s=%v", key, value))
                }</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("[%d] %s{%s}", index, fact.Type, strings.Join(sortedAttrs, ", "))</span>
}

// ShowActionDetailsWithAllAttributes affiche les d√©tails d'une action avec tous les attributs des faits
func (th *TestHelper) ShowActionDetailsWithAllAttributes(actionName string, terminal *rete.TerminalNode, maxResults int) <span class="cov8" title="1">{
        count := 0
        for _, token := range terminal.Memory.Tokens </span><span class="cov8" title="1">{
                if count &gt;= maxResults </span><span class="cov8" title="1">{
                        break</span>
                }

                // Extraire et afficher tous les faits du token avec leurs attributs complets
                <span class="cov8" title="1">if len(token.Facts) &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Printf("   ‚Üí %s:\n", actionName)
                        for i, fact := range token.Facts </span><span class="cov8" title="1">{
                                if fact != nil </span><span class="cov8" title="1">{
                                        fmt.Printf("     %s\n", th.ShowFactDetails(fact, i+1))
                                }</span>
                        }
                }
                <span class="cov8" title="1">count++</span>
        }

        <span class="cov8" title="1">if len(terminal.Memory.Tokens) &gt; maxResults </span><span class="cov8" title="1">{
                fmt.Printf("   ... et %d autres r√©sultats\n", len(terminal.Memory.Tokens)-maxResults)
        }</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Package testutil provides centralized testing utilities for the TSD project
package testutil

import (
        "testing"

        "github.com/treivax/tsd/rete"
)

// TestHelper provides common testing utilities and helpers
type TestHelper struct {
        pipeline *rete.ConstraintPipeline
}

// NewTestHelper creates a new test helper instance
func NewTestHelper() *TestHelper <span class="cov0" title="0">{
        return &amp;TestHelper{
                pipeline: rete.NewConstraintPipeline(),
        }
}</span>

// BuildNetworkFromConstraintFile builds a RETE network from constraint file
// This function MUST be used by ALL tests using .constraint files
func (th *TestHelper) BuildNetworkFromConstraintFile(t *testing.T, constraintFile string) (*rete.ReteNetwork, rete.Storage) <span class="cov0" title="0">{
        storage := rete.NewMemoryStorage()
        network, err := th.pipeline.BuildNetworkFromConstraintFile(constraintFile, storage)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to build network: %v", err)
        }</span>
        <span class="cov0" title="0">return network, storage</span>
}

// BuildNetworkFromConstraintFileWithFacts builds a RETE network and loads facts
func (th *TestHelper) BuildNetworkFromConstraintFileWithFacts(t *testing.T, constraintFile, factsFile string) (*rete.ReteNetwork, []*rete.Fact, rete.Storage) <span class="cov0" title="0">{
        storage := rete.NewMemoryStorage()
        network, facts, err := th.pipeline.BuildNetworkFromConstraintFileWithFacts(constraintFile, factsFile, storage)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to build network with facts: %v", err)
        }</span>
        <span class="cov0" title="0">return network, facts, storage</span>
}

// CreateUserFact creates a test user fact (standard format)
func (th *TestHelper) CreateUserFact(id, name, firstName string, age float64) *rete.Fact <span class="cov0" title="0">{
        return &amp;rete.Fact{
                ID:   id,
                Type: "User",
                Fields: map[string]interface{}{
                        "id":        id,
                        "name":      name,
                        "firstName": firstName,
                        "age":       age,
                },
        }
}</span>

// CreateAddressFact creates a test address fact (standard format)
func (th *TestHelper) CreateAddressFact(userID, street, city string) *rete.Fact <span class="cov0" title="0">{
        return &amp;rete.Fact{
                ID:   userID + "_address",
                Type: "Address",
                Fields: map[string]interface{}{
                        "userID": userID,
                        "street": street,
                        "city":   city,
                },
        }
}</span>

// CreateCustomerFact creates a test customer fact (standard format)
func (th *TestHelper) CreateCustomerFact(id string, age float64, isVIP bool) *rete.Fact <span class="cov0" title="0">{
        return &amp;rete.Fact{
                ID:   id,
                Type: "Customer",
                Fields: map[string]interface{}{
                        "id":    id,
                        "age":   age,
                        "isVIP": isVIP,
                },
        }
}</span>

// SubmitFactsAndAnalyze submits facts to network and returns action count
func (th *TestHelper) SubmitFactsAndAnalyze(t *testing.T, network *rete.ReteNetwork, facts []*rete.Fact) int <span class="cov0" title="0">{
        totalActions := 0

        // Submit all facts
        for _, fact := range facts </span><span class="cov0" title="0">{
                err := network.SubmitFact(fact)
                if err != nil </span><span class="cov0" title="0">{
                        t.Logf("Warning: Failed to submit fact %s: %v", fact.ID, err)
                }</span>
        }

        // Analyze terminal nodes for triggered actions
        <span class="cov0" title="0">for terminalID, terminal := range network.TerminalNodes </span><span class="cov0" title="0">{
                tokenCount := len(terminal.Memory.Tokens)
                totalActions += tokenCount
                t.Logf("Terminal %s: %d tokens stored", terminalID, tokenCount)
        }</span>

        <span class="cov0" title="0">return totalActions</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
