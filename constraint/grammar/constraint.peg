// Grammaire PEG Complète et Cohérente avec le Réseau RETE
// Cette grammaire supporte tous les constructs nécessaires pour une intégration complète
// avec les noeuds du réseau RETE : AlphaNode, BetaNode, NotNode, ExistsNode, AccumulateNode, TerminalNode
//
// Commande pour générer le parser: pigeon -o parser.go constraint.peg
{
package constraint

import (
    "fmt"
    "strconv"
    "strings"
)
}

Start <- _ statements:StatementList _ EOF {
    // Séparer types, actions, xupleSpaces, expressions, faits, factAssignments, retractions, ruleRemovals et reset
    types := []interface{}{}
    actions := []interface{}{}
    xupleSpaces := []interface{}{}
    expressions := []interface{}{}
    facts := []interface{}{}
    factAssignments := []interface{}{}
    retractions := []interface{}{}
    ruleRemovals := []interface{}{}
    resets := []interface{}{}

    if statements != nil {
        for _, stmt := range statements.([]interface{}) {
            if stmtMap, ok := stmt.(map[string]interface{}); ok {
                if stmtMap["type"] == "typeDefinition" {
                    types = append(types, stmt)
                } else if stmtMap["type"] == "actionDefinition" {
                    actions = append(actions, stmt)
                } else if stmtMap["type"] == "xupleSpaceDeclaration" {
                    xupleSpaces = append(xupleSpaces, stmt)
                } else if stmtMap["type"] == "expression" {
                    expressions = append(expressions, stmt)
                } else if stmtMap["type"] == "fact" {
                    facts = append(facts, stmt)
                } else if stmtMap["type"] == "factAssignment" {
                    factAssignments = append(factAssignments, stmt)
                } else if stmtMap["type"] == "retraction" {
                    retractions = append(retractions, stmt)
                } else if stmtMap["type"] == "ruleRemoval" {
                    ruleRemovals = append(ruleRemovals, stmt)
                } else if stmtMap["type"] == "reset" {
                    resets = append(resets, stmt)
                }
            }
        }
    }

    return map[string]interface{}{
        "types": types,
        "actions": actions,
        "xupleSpaces": xupleSpaces,
        "expressions": expressions,
        "facts": facts,
        "factAssignments": factAssignments,
        "retractions": retractions,
        "ruleRemovals": ruleRemovals,
        "resets": resets,
    }, nil
}

StatementList <- statements:(Statement _)* {
    result := []interface{}{}
    if statements != nil {
        for _, stmt := range statements.([]interface{}) {
            result = append(result, stmt.([]interface{})[0])
        }
    }
    return result, nil
}

Statement <- TypeDefinition / ActionDefinition / XupleSpaceDeclaration / Expression / RemoveRule / RemoveFact / FactAssignment / Fact / Reset

Reset <- "reset" {
    return map[string]interface{}{
        "type": "reset",
    }, nil
}

TypeDefinition <- "type" _ name:IdentName _ "(" _ fields:FieldList _ ")" {
    return map[string]interface{}{
        "type": "typeDefinition",
        "name": name,
        "fields": fields,
    }, nil
}

FieldList <- first:Field rest:(_ "," _ Field)* {
    fields := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            fields = append(fields, item.([]interface{})[3])
        }
    }
    return fields, nil
}

Field <- primaryKey:"#"? name:IdentName _ ":" _ fieldType:FieldType {
    // Validation : interdire l'utilisation de _id_ comme nom de champ
    nameStr := name.(string)
    if nameStr == "_id_" {
        return nil, fmt.Errorf("le champ '_id_' est réservé au système et ne peut pas être utilisé")
    }

    result := map[string]interface{}{
        "name": name,
        "type": fieldType,
        "isPrimaryKey": false,
    }

    if primaryKey != nil {
        result["isPrimaryKey"] = true
    }

    return result, nil
}

FieldType <- PrimitiveType / UserDefinedType

PrimitiveType <- "string" { return "string", nil } /
                "number" { return "number", nil } /
                "bool"   { return "bool", nil }

UserDefinedType <- !ReservedWord name:IdentName {
    return name, nil
}

ActionDefinition <- "action" _ name:IdentName _ "(" _ params:ParameterList? _ ")" {
    if params == nil {
        params = []interface{}{}
    }
    return map[string]interface{}{
        "type": "actionDefinition",
        "name": name,
        "parameters": params,
    }, nil
}

XupleSpaceDeclaration <- "xuple-space" _ name:IdentName _ "{" _ props:XupleSpaceProperties? _ "}" {
    // Valeurs par défaut (constantes définies dans constraint/xuplespace_constants.go)
    selection := "fifo"
    consumption := map[string]interface{}{
        "type": "once",
        "limit": 0,
    }
    retention := map[string]interface{}{
        "type": "unlimited",
        "duration": 0,
    }
    maxSize := 0 // 0 = illimité

    // Appliquer les propriétés parsées
    if props != nil {
        propMap := props.(map[string]interface{})
        if sel, ok := propMap["selection"]; ok {
            selection = sel.(string)
        }
        if cons, ok := propMap["consumption"]; ok {
            consumption = cons.(map[string]interface{})
        }
        if ret, ok := propMap["retention"]; ok {
            retention = ret.(map[string]interface{})
        }
        if ms, ok := propMap["maxSize"]; ok {
            maxSize = ms.(int)
        }
    }

    result := map[string]interface{}{
        "type": "xupleSpaceDeclaration",
        "name": name,
        "selectionPolicy": selection,
        "consumptionPolicy": consumption,
        "retentionPolicy": retention,
        "maxSize": maxSize,
    }

    // Note: Validation sera faite après parsing via ValidateProgram
    return result, nil
}

XupleSpaceProperties <- first:XupleSpaceProperty rest:(_ XupleSpaceProperty)* {
    result := make(map[string]interface{})

    // Ajouter première propriété
    if firstMap, ok := first.(map[string]interface{}); ok {
        for k, v := range firstMap {
            result[k] = v
        }
    }

    // Ajouter propriétés suivantes
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            propMap := item.([]interface{})[1].(map[string]interface{})
            for k, v := range propMap {
                result[k] = v
            }
        }
    }

    return result, nil
}

XupleSpaceProperty <- SelectionProperty / ConsumptionProperty / RetentionProperty / MaxSizeProperty

SelectionProperty <- "selection" _ ":" _ value:SelectionValue {
    return map[string]interface{}{
        "selection": value,
    }, nil
}

SelectionValue <- "random" { return "random", nil } /
                  "fifo"   { return "fifo", nil } /
                  "lifo"   { return "lifo", nil }

ConsumptionProperty <- "consumption" _ ":" _ value:ConsumptionValue {
    return map[string]interface{}{
        "consumption": value,
    }, nil
}

ConsumptionValue <- "once" {
    return map[string]interface{}{
        "type": "once",
        "limit": 0,
    }, nil
} / "per-agent" {
    return map[string]interface{}{
        "type": "per-agent",
        "limit": 0,
    }, nil
} / "limited" _ "(" _ limit:Integer _ ")" {
    limitVal := limit.(int)
    if limitVal <= 0 {
        return nil, fmt.Errorf("consumption limit must be greater than zero, got %d", limitVal)
    }
    return map[string]interface{}{
        "type": "limited",
        "limit": limitVal,
    }, nil
}

RetentionProperty <- "retention" _ ":" _ value:RetentionValue {
    return map[string]interface{}{
        "retention": value,
    }, nil
}

RetentionValue <- "unlimited" {
    return map[string]interface{}{
        "type": "unlimited",
        "duration": 0,
    }, nil
} / "duration" _ "(" _ dur:Duration _ ")" {
    return map[string]interface{}{
        "type": "duration",
        "duration": dur,
    }, nil
}

Duration <- value:Integer unit:TimeUnit {
    val := value.(int)
    unitStr := unit.(string)

    if val <= 0 {
        return nil, fmt.Errorf("duration must be positive, got %d", val)
    }

    const (
        SecondsPerMinute = 60
        SecondsPerHour   = 3600
        SecondsPerDay    = 86400
    )

    var seconds int
    switch unitStr {
    case "s":
        seconds = val
    case "m":
        seconds = val * SecondsPerMinute
    case "h":
        seconds = val * SecondsPerHour
    case "d":
        seconds = val * SecondsPerDay
    default:
        return nil, fmt.Errorf("invalid time unit '%s', expected s, m, h or d", unitStr)
    }

    return seconds, nil
}

TimeUnit <- "s" { return "s", nil } /
            "m" { return "m", nil } /
            "h" { return "h", nil } /
            "d" { return "d", nil }

MaxSizeProperty <- "max-size" _ ":" _ value:Integer {
    val := value.(int)
    if val < 0 {
        return nil, fmt.Errorf("max-size must be >= 0, got %d", val)
    }
    return map[string]interface{}{
        "maxSize": val,
    }, nil
}


ParameterList <- first:Parameter rest:(_ "," _ Parameter)* {
    parameters := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            parameters = append(parameters, item.([]interface{})[3])
        }
    }
    return parameters, nil
}

Parameter <- name:IdentName _ ":" _ paramType:ParameterType optional:"?"? _ defaultValue:(_ "=" _ ParameterDefaultValue)? {
    result := map[string]interface{}{
        "name": name,
        "type": paramType,
        "optional": optional != nil,
    }
    if defaultValue != nil {
        result["defaultValue"] = defaultValue.([]interface{})[3]
    }
    return result, nil
}

ParameterType <- IdentName { return string(c.text), nil }

ParameterDefaultValue <- Number / StringLiteral / BooleanLiteral

Expression <- "rule" _ ruleId:IdentName _ ":" _ patterns:PatternBlocks _ "/" _ constraints:Constraints _ "==>" _ action:Action {
    // If only one pattern block, use old structure for backward compatibility
    patternList := patterns.([]interface{})
    if len(patternList) == 1 {
        return map[string]interface{}{
            "type": "expression",
            "ruleId": ruleId,
            "set": patternList[0],
            "constraints": constraints,
            "action": action,
        }, nil
    }

    // Multiple pattern blocks (aggregation with joins)
    return map[string]interface{}{
        "type": "expression",
        "ruleId": ruleId,
        "patterns": patterns,
        "constraints": constraints,
        "action": action,
    }, nil
} / "rule" _ ruleId:IdentName _ ":" _ patterns:PatternBlocks _ "/" _ "==>" _ action:Action {
    // Rule without constraints - match on pattern only
    // If only one pattern block, use old structure for backward compatibility
    patternList := patterns.([]interface{})
    if len(patternList) == 1 {
        return map[string]interface{}{
            "type": "expression",
            "ruleId": ruleId,
            "set": patternList[0],
            "constraints": nil,
            "action": action,
        }, nil
    }

    // Multiple pattern blocks without constraints
    return map[string]interface{}{
        "type": "expression",
        "ruleId": ruleId,
        "patterns": patterns,
        "constraints": nil,
        "action": action,
    }, nil
}

PatternBlocks <- first:Set rest:(_ "/" _ Set)* {
    blocks := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            blocks = append(blocks, item.([]interface{})[3])
        }
    }
    return blocks, nil
}

Set <- "{" _ variables:TypedVariableList _ "}" {
    return map[string]interface{}{
        "type": "set",
        "variables": variables,
    }, nil
}

TypedVariableList <- first:TypedVariable rest:(_ "," _ TypedVariable)* {
    variables := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            variables = append(variables, item.([]interface{})[3])
        }
    }
    return variables, nil
}

TypedVariable <- AggregationVariable / SimpleTypedVariable

SimpleTypedVariable <- name:IdentName _ ":" _ dataType:IdentName {
    return map[string]interface{}{
        "type": "typedVariable",
        "name": name,
        "dataType": dataType,
    }, nil
}

AggregationVariable <- name:IdentName _ ":" _ aggFunc:AccumulateFunction _ "(" _ fieldAccess:FieldAccess _ ")" {
    return map[string]interface{}{
        "type": "aggregationVariable",
        "name": name,
        "function": aggFunc,
        "field": fieldAccess,
    }, nil
}

Constraints <- first:Constraint rest:(_ LogicalOp _ Constraint)* {
    if rest == nil || len(rest.([]interface{})) == 0 {
        return first, nil
    }

    operations := []map[string]interface{}{}
    for _, item := range rest.([]interface{}) {
        op := item.([]interface{})[1]
        right := item.([]interface{})[3]
        operations = append(operations, map[string]interface{}{
            "op": op,
            "right": right,
        })
    }

    return map[string]interface{}{
        "type": "logicalExpr",
        "left": first,
        "operations": operations,
    }, nil
}

Constraint <- "(" _ expr:Constraints _ ")" { return expr, nil } /
              NotConstraint /
              ExistsConstraint /
              AccumulateConstraint /
              left:ArithmeticExpr _ op:ComparisonOp _ right:ArithmeticExpr {
    return map[string]interface{}{
        "type": "comparison",
        "left": left,
        "operator": op,
        "right": right,
    }, nil
}

NotConstraint <- ("NOT" / "not" / "Not") _ "(" _ expr:Constraints _ ")" {
    return map[string]interface{}{
        "type": "notConstraint",
        "expression": expr,
    }, nil
}

ExistsConstraint <- ("EXISTS" / "exists" / "Exists") _ "(" _ variable:TypedVariable _ "/" _ condition:Constraints _ ")" {
    return map[string]interface{}{
        "type": "existsConstraint",
        "variable": variable,
        "condition": condition,
    }, nil
}

AccumulateConstraint <- accumFunc:AccumulateFunction _ "(" _ accumVar:TypedVariable _ "/" _ accumCond:Constraints _ accumField:(_ ";" _ FieldAccess)? _ ")" _ accumOp:ComparisonOp _ accumThreshold:ArithmeticExpr {
    fieldValue := ""
    if accumField != nil {
        fieldAccess := accumField.([]interface{})[3].(map[string]interface{})
        fieldValue = fieldAccess["field"].(string)
    }

    return map[string]interface{}{
        "type": "accumulateConstraint",
        "function": accumFunc,
        "variable": accumVar,
        "condition": accumCond,
        "field": fieldValue,
        "operator": accumOp,
        "threshold": accumThreshold,
    }, nil
}

AccumulateFunction <- ("AVG" / "avg" / "Avg") { return "AVG", nil } /
                     ("COUNT" / "count" / "Count") { return "COUNT", nil } /
                     ("SUM" / "sum" / "Sum") { return "SUM", nil } /
                     ("MIN" / "min" / "Min") { return "MIN", nil } /
                     ("MAX" / "max" / "Max") { return "MAX", nil }


ArithmeticExpr <- first:Term rest:(_ ("+" / "-") _ Term)* {
    if rest == nil || len(rest.([]interface{})) == 0 {
        return first, nil
    }

    result := first
    for _, item := range rest.([]interface{}) {
        op := item.([]interface{})[1]
        right := item.([]interface{})[3]
        result = map[string]interface{}{
            "type": "binaryOp",
            "left": result,
            "operator": op,
            "right": right,
        }
    }
    return result, nil
}

Term <- first:Factor rest:(_ ("*" / "/" / "%") _ Factor)* {
    if rest == nil || len(rest.([]interface{})) == 0 {
        return first, nil
    }

    result := first
    for _, item := range rest.([]interface{}) {
        op := item.([]interface{})[1]
        right := item.([]interface{})[3]
        result = map[string]interface{}{
            "type": "binaryOp",
            "left": result,
            "operator": op,
            "right": right,
        }
    }
    return result, nil
}

Factor <- "(" _ expr:ArithmeticExpr _ ")" { return expr, nil } /
          CastExpression /
          InlineFact /
          FunctionCall /
          FieldAccess /
          Number /
          StringLiteral /
          BooleanLiteral /
          ArrayLiteral /
          Variable

CastExpression <- "(" _ castType:CastType _ ")" _ expr:Factor {
    return map[string]interface{}{
        "type": "cast",
        "castType": castType,
        "expression": expr,
    }, nil
}

CastType <- "number" { return "number", nil } /
            "string" { return "string", nil } /
            "bool"   { return "bool", nil }

FieldAccess <- object:IdentName "." field:IdentName {
    return map[string]interface{}{
        "type": "fieldAccess",
        "object": object,
        "field": field,
    }, nil
}

InlineFact <- typeName:IdentName "(" _ fields:InlineFactFieldList _ ")" {
    return map[string]interface{}{
        "type": "inlineFact",
        "typeName": typeName,
        "fields": fields,
    }, nil
}

InlineFactFieldList <- first:InlineFactField rest:(_ "," _ InlineFactField)* {
    fields := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            fields = append(fields, item.([]interface{})[3])
        }
    }
    return fields, nil
}

InlineFactField <- name:IdentName _ ":" _ value:ArithmeticExpr {
    return map[string]interface{}{
        "name": name,
        "value": value,
    }, nil
}

Variable <- name:IdentName {
    return map[string]interface{}{
        "type": "variable",
        "name": name,
    }, nil
}

ArrayLiteral <- "[" _ elements:ArrayElementList? _ "]" {
    if elements == nil {
        elements = []interface{}{}
    }
    return map[string]interface{}{
        "type": "arrayLiteral",
        "elements": elements,
    }, nil
}

ArrayElementList <- first:ArithmeticExpr rest:(_ "," _ ArithmeticExpr)* {
    elements := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            elements = append(elements, item.([]interface{})[3])
        }
    }
    return elements, nil
}

FunctionCall <- name:FunctionName _ "(" _ args:FunctionArgList? _ ")" {
    if args == nil {
        args = []interface{}{}
    }
    return map[string]interface{}{
        "type": "functionCall",
        "name": name,
        "args": args,
    }, nil
}

FunctionName <- ("LENGTH" / "length" / "Length") { return "LENGTH", nil } /
                ("SUBSTRING" / "substring" / "Substring") { return "SUBSTRING", nil } /
                ("UPPER" / "upper" / "Upper") { return "UPPER", nil } /
                ("LOWER" / "lower" / "Lower") { return "LOWER", nil } /
                ("TRIM" / "trim" / "Trim") { return "TRIM", nil } /
                ("ABS" / "abs" / "Abs") { return "ABS", nil } /
                ("ROUND" / "round" / "Round") { return "ROUND", nil } /
                ("FLOOR" / "floor" / "Floor") { return "FLOOR", nil } /
                ("CEIL" / "ceil" / "Ceil") { return "CEIL", nil }

FunctionArgList <- first:ArithmeticExpr rest:(_ "," _ ArithmeticExpr)* {
    args := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            args = append(args, item.([]interface{})[3])
        }
    }
    return args, nil
}

Action <- first:JobCall rest:(_ "," _ JobCall)* {
    jobs := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            jobs = append(jobs, item.([]interface{})[3])
        }
    }
    return map[string]interface{}{
        "type": "action",
        "jobs": jobs,
    }, nil
}

JobCall <- name:IdentName _ "(" _ args:ArgumentList? _ ")" {
    if args == nil {
        args = []interface{}{}
    }
    return map[string]interface{}{
        "type": "jobCall",
        "name": name,
        "args": args,
    }, nil
}

ArgumentList <- first:ArithmeticExpr rest:(_ "," _ ArithmeticExpr)* {
    arguments := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            arguments = append(arguments, item.([]interface{})[3])
        }
    }
    return arguments, nil
}

ComparisonOp <- "==" { return "==", nil } /
                "!=" { return "!=", nil } /
                "<=" { return "<=", nil } /
                ">=" { return ">=", nil } /
                "<"  { return "<", nil } /
                ">"  { return ">", nil } /
                ("IN" / "in" / "In") { return "IN", nil } /
                ("LIKE" / "like" / "Like") { return "LIKE", nil } /
                ("MATCHES" / "matches" / "Matches") { return "MATCHES", nil } /
                ("CONTAINS" / "contains" / "Contains") { return "CONTAINS", nil }

LogicalOp <- ("AND" / "and" / "And") { return "AND", nil } /
             ("OR" / "or" / "Or")  { return "OR", nil }

BooleanLiteral <- "true" {
        return map[string]interface{}{
            "type": "boolean",
            "value": true,
        }, nil
    } /
    "false" {
        return map[string]interface{}{
            "type": "boolean",
            "value": false,
        }, nil
    }

Integer <- digits:[0-9]+ {
    val, err := strconv.Atoi(string(c.text))
    if err != nil {
        return nil, err
    }
    return val, nil
}

Number <- sign:"-"? digits:[0-9]+ decimal:("." [0-9]+)? {
    val, err := strconv.ParseFloat(string(c.text), 64)
    if err != nil {
        return nil, err
    }
    return map[string]interface{}{
        "type": "number",
        "value": val,
    }, nil
}

StringLiteral <- "\"" chars:DoubleStringChar* "\"" {
        var builder strings.Builder
        if chars != nil {
            for _, char := range chars.([]interface{}) {
                builder.WriteString(char.(string))
            }
        }
        return map[string]interface{}{
            "type": "string",
            "value": builder.String(),
        }, nil
    } /
    "'" chars:SingleStringChar* "'" {
        var builder strings.Builder
        if chars != nil {
            for _, char := range chars.([]interface{}) {
                builder.WriteString(char.(string))
            }
        }
        return map[string]interface{}{
            "type": "string",
            "value": builder.String(),
        }, nil
    }

DoubleStringChar <- EscapeSequence / (!'"' UnicodeChar) {
    return string(c.text), nil
}

SingleStringChar <- EscapeSequence / (!'\'' UnicodeChar) {
    return string(c.text), nil
}

EscapeSequence <- "\\" char:EscapeChar {
    var charStr string
    switch v := char.(type) {
    case string:
        charStr = v
    case []uint8:
        charStr = string(v)
    default:
        charStr = fmt.Sprintf("%v", char)
    }

    switch charStr {
    case "n":
        return "\n", nil
    case "t":
        return "\t", nil
    case "r":
        return "\r", nil
    case "\\":
        return "\\", nil
    case "\"":
        return "\"", nil
    case "'":
        return "'", nil
    default:
        return "\\" + charStr, nil
    }
}

EscapeChar <- "n" { return "n", nil } /
              "t" { return "t", nil } /
              "r" { return "r", nil } /
              "\\" { return "\\", nil } /
              "\"" { return "\"", nil } /
              "'" { return "'", nil } /
              . { return string(c.text), nil }

UnicodeChar <- .

// RemoveRule définit le parsing d'une suppression de règle avec le format: remove rule <ruleID>
RemoveRule <- "remove" _ "rule" _ ruleID:IdentName {
    return map[string]interface{}{
        "type": "ruleRemoval",
        "ruleID": ruleID,
    }, nil
}

// RemoveFact définit le parsing d'une rétractation de fait avec le format: remove fact TypeName ID
RemoveFact <- "remove" _ "fact" _ typeName:IdentName _ factID:FactID {
    return map[string]interface{}{
        "type": "retraction",
        "typeName": typeName,
        "factID": factID,
    }, nil
}

// FactID est un identifiant pour un fait (peut contenir des caractères spéciaux)
FactID <- chars:([a-zA-Z0-9_-] / SpecialFactChar)+ {
    return string(c.text), nil
}

// FactAssignment permet d'assigner un fait à une variable : variable = Fact(...)
FactAssignment <- variable:IdentName _ "=" _ fact:Fact {
    return map[string]interface{}{
        "type": "factAssignment",
        "variable": variable,
        "fact": fact,
    }, nil
}

// Fact définit le parsing d'un fait avec le nouveau format TypeName(field:value, ...)
// S'assure de ne pas matcher si c'est une affectation (présence de =)
Fact <- typeName:IdentName _ !("=" _) "(" _ fields:FactFieldList _ ")" {
    return map[string]interface{}{
        "type": "fact",
        "typeName": typeName,
        "fields": fields,
    }, nil
}

FactFieldList <- first:FactField rest:(_ "," _ FactField)* {
    fields := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            fields = append(fields, item.([]interface{})[3])
        }
    }
    return fields, nil
}

FactField <- name:IdentName ":" _ value:FactValue {
    // Validation : interdire l'utilisation de _id_ comme nom de champ
    nameStr := name.(string)
    if nameStr == "_id_" {
        return nil, fmt.Errorf("le champ '_id_' est réservé au système et ne peut pas être assigné")
    }

    return map[string]interface{}{
        "name": name,
        "value": value,
    }, nil
}

FactValue <- StringLiteral / Number / BooleanLiteral / VariableReference / ComplexIdentifier {
    // ComplexIdentifier pour les valeurs non-quotées complexes comme des IDs
    return map[string]interface{}{
        "type": "identifier",
        "value": string(c.text),
    }, nil
}

VariableReference <- !ReservedWord name:IdentName &(_ ("," / ")")) {
    // La référence de variable doit être suivie de "," ou ")" pour la distinguer d'un identifiant
    return map[string]interface{}{
        "type": "variableReference",
        "value": name,  // Mettre name directement dans value pour cohérence avec les autres types
    }, nil
}

ComplexIdentifier <- ComplexIdentStart ComplexIdentContinue* {
    return string(c.text), nil
}

ComplexIdentStart <- [a-zA-Z0-9_] / UnicodeLetterStart

ComplexIdentContinue <- [a-zA-Z0-9_-] / UnicodeLetterContinue / SpecialFactChar

// Caractères spéciaux autorisés dans les valeurs de faits
SpecialFactChar <- [-_:.]

IdentName <- IdentStart IdentContinue* {
    return string(c.text), nil
}

IdentStart <- [a-zA-Z_] / UnicodeLetterStart

IdentContinue <- [a-zA-Z0-9_-] / UnicodeLetterContinue / PunctuationChar

// Support pour les caractères Unicode étendus (tous les scripts majeurs)
// Latin étendu, Grec, Cyrillique, Hébreu, Arabe, CJK (Chinois, Japonais, Coréen), etc.
UnicodeLetterStart <- [\u00C0-\u00D6] / [\u00D8-\u00F6] / [\u00F8-\u017F] /
                      [\u0100-\u024F] / [\u1E00-\u1EFF] / [\u0370-\u03FF] /
                      [\u0400-\u04FF] / [\u0590-\u05FF] / [\u0600-\u06FF] /
                      [\u3040-\u309F] / [\u30A0-\u30FF] / [\u3400-\u4DBF] /
                      [\u4E00-\u9FFF] / [\uAC00-\uD7AF] / [\uF900-\uFAFF]

UnicodeLetterContinue <- [\u00C0-\u00D6] / [\u00D8-\u00F6] / [\u00F8-\u017F] /
                         [\u0100-\u024F] / [\u1E00-\u1EFF] / [\u0370-\u03FF] /
                         [\u0400-\u04FF] / [\u0590-\u05FF] / [\u0600-\u06FF] /
                         [\u0300-\u036F] / [\u1AB0-\u1AFF] / [\u1DC0-\u1DFF] /
                         [\u3040-\u309F] / [\u30A0-\u30FF] / [\u3400-\u4DBF] /
                         [\u4E00-\u9FFF] / [\uAC00-\uD7AF] / [\uF900-\uFAFF]

PunctuationChar <- [-_] / ['] / [\u2010-\u2015] / [\u2032-\u2037]

// ReservedWord définit les mots réservés qui ne peuvent pas être utilisés comme identifiants
ReservedWord <- ("type" / "action" / "rule" / "when" / "then" / "remove" / "fact" / "reset" /
                "xuple-space" / "selection" / "consumption" / "retention" / "max-size" /
                "AND" / "and" / "OR" / "or" / "NOT" / "not" / "EXISTS" / "exists" /
                "true" / "false" / "IN" / "in" / "LIKE" / "like" / "CONTAINS" / "contains" /
                "MATCHES" / "matches" / "AVG" / "avg" / "COUNT" / "count" / "SUM" / "sum" /
                "MIN" / "min" / "MAX" / "max" / "_id_") !IdentContinue

_ <- (Whitespace / Comment)*

Whitespace <- [ \t\r\n]

Comment <- LineComment / BlockComment

LineComment <- "//" CommentText:(![\r\n] .)* {
    return nil, nil  // Les commentaires ne retournent rien
}

BlockComment <- "/*" CommentText:(!"*/" .)* "*/" {
    return nil, nil  // Les commentaires ne retournent rien
}

EOF <- !.
