// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
	"testing"
)

// TestJoinNode_ActivateLeft_PreservesAllBindings v√©rifie que ActivateLeft
// pr√©serve TOUS les bindings lors de la jointure avec un fait du c√¥t√© droit.
func TestJoinNode_ActivateLeft_PreservesAllBindings(t *testing.T) {
	t.Log("üß™ TEST JoinNode - ActivateLeft pr√©serve tous les bindings")
	t.Log("===========================================================")

	// Setup : Faits
	userFact := &Fact{
		ID:     "u1",
		Type:   "User",
		Fields: map[string]interface{}{"id": 1, "name": "Alice"},
	}
	orderFact := &Fact{
		ID:     "o1",
		Type:   "Order",
		Fields: map[string]interface{}{"id": 100, "user_id": 1},
	}
	productFact := &Fact{
		ID:     "p1",
		Type:   "Product",
		Fields: map[string]interface{}{"id": 200},
	}

	// Setup : JoinNode configur√© pour [user, order] ‚Üí [user, order, product]
	joinNode := &JoinNode{
		BaseNode: BaseNode{
			ID:       "join_test",
			Children: []Node{},
			Memory:   &WorkingMemory{NodeID: "join_test", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
		},
		LeftVariables:  []string{"user", "order"},
		RightVariables: []string{"product"},
		AllVariables:   []string{"user", "order", "product"},
		VariableTypes: map[string]string{
			"user":    "User",
			"order":   "Order",
			"product": "Product",
		},
		LeftMemory:     &WorkingMemory{NodeID: "join_test_left", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
		RightMemory:    &WorkingMemory{NodeID: "join_test_right", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
		ResultMemory:   &WorkingMemory{NodeID: "join_test_result", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
		JoinConditions: nil, // Pas de conditions pour ce test
		Debug:          true,
	}

	// Ajouter le fait Product dans Right Memory (via token)
	productToken := &Token{
		ID:       "t_product",
		Facts:    []*Fact{productFact},
		Bindings: NewBindingChainWith("product", productFact),
		NodeID:   "product_node",
		Metadata: TokenMetadata{JoinLevel: 0},
	}
	joinNode.RightMemory.AddToken(productToken)

	// Cr√©er un token du c√¥t√© gauche avec [user, order]
	leftToken := &Token{
		ID:    "t_left",
		Facts: []*Fact{userFact, orderFact},
		Bindings: NewBindingChain().
			Add("user", userFact).
			Add("order", orderFact),
		NodeID:   "upstream_node",
		Metadata: TokenMetadata{JoinLevel: 1},
	}

	// Mock du n≈ìud enfant pour capturer le token propag√©
	var capturedToken *Token
	mockChild := &MockNode{
		activateLeft: func(token *Token) error {
			capturedToken = token
			return nil
		},
	}
	joinNode.Children = append(joinNode.Children, mockChild)

	// Act
	err := joinNode.ActivateLeft(leftToken)

	// Assert
	if err != nil {
		t.Fatalf("‚ùå ActivateLeft retourn√© erreur: %v", err)
	}

	if capturedToken == nil {
		t.Fatal("‚ùå Aucun token propag√© au n≈ìud enfant")
	}

	// V√©rifier que le token propag√© contient TOUS les bindings
	if capturedToken.Bindings.Len() != 3 {
		t.Errorf("‚ùå Attendu 3 bindings, got %d", capturedToken.Bindings.Len())
	}

	expectedVars := []string{"user", "order", "product"}
	for _, v := range expectedVars {
		if !capturedToken.HasBinding(v) {
			t.Errorf("‚ùå Variable '%s' manquante dans le token propag√©", v)
		}
	}

	// V√©rifier les valeurs
	if capturedToken.GetBinding("user") != userFact {
		t.Errorf("‚ùå Binding 'user' incorrect")
	}
	if capturedToken.GetBinding("order") != orderFact {
		t.Errorf("‚ùå Binding 'order' incorrect")
	}
	if capturedToken.GetBinding("product") != productFact {
		t.Errorf("‚ùå Binding 'product' incorrect")
	}

	t.Log("‚úÖ ActivateLeft pr√©serve bien tous les bindings")
}

// TestJoinNode_ActivateRight_CreatesCorrectToken v√©rifie que ActivateRight
// cr√©e un token avec le bon binding et joint correctement avec les tokens de la gauche.
func TestJoinNode_ActivateRight_CreatesCorrectToken(t *testing.T) {
	t.Log("üß™ TEST JoinNode - ActivateRight cr√©e le bon token")
	t.Log("==================================================")

	// Setup
	userFact := &Fact{
		ID:     "u1",
		Type:   "User",
		Fields: map[string]interface{}{"id": 1},
	}
	orderFact := &Fact{
		ID:     "o1",
		Type:   "Order",
		Fields: map[string]interface{}{"id": 100, "user_id": 1},
	}

	joinNode := &JoinNode{
		BaseNode: BaseNode{
			ID:       "join_test",
			Children: []Node{},
			Memory:   &WorkingMemory{NodeID: "join_test", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
		},
		LeftVariables:  []string{"user"},
		RightVariables: []string{"order"},
		AllVariables:   []string{"user", "order"},
		VariableTypes: map[string]string{
			"user":  "User",
			"order": "Order",
		},
		LeftMemory:     &WorkingMemory{NodeID: "join_test_left", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
		RightMemory:    &WorkingMemory{NodeID: "join_test_right", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
		ResultMemory:   &WorkingMemory{NodeID: "join_test_result", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
		JoinConditions: nil,
		Debug:          true,
	}

	// Ajouter un token dans Left Memory
	leftToken := &Token{
		ID:       "t_user",
		Facts:    []*Fact{userFact},
		Bindings: NewBindingChainWith("user", userFact),
		NodeID:   "upstream",
		Metadata: TokenMetadata{JoinLevel: 0},
	}
	joinNode.LeftMemory.AddToken(leftToken)

	// Mock pour capturer
	var capturedToken *Token
	mockChild := &MockNode{
		activateLeft: func(token *Token) error {
			capturedToken = token
			return nil
		},
	}
	joinNode.Children = append(joinNode.Children, mockChild)

	// Act
	err := joinNode.ActivateRight(orderFact)

	// Assert
	if err != nil {
		t.Fatalf("‚ùå ActivateRight retourn√© erreur: %v", err)
	}

	if capturedToken == nil {
		t.Fatal("‚ùå Aucun token propag√©")
	}

	if capturedToken.Bindings.Len() != 2 {
		t.Errorf("‚ùå Attendu 2 bindings, got %d", capturedToken.Bindings.Len())
	}

	if !capturedToken.HasBinding("user") || !capturedToken.HasBinding("order") {
		t.Errorf("‚ùå Bindings manquants")
	}

	t.Log("‚úÖ ActivateRight fonctionne correctement")
}

// TestJoinNode_CreateTokenForRightFact v√©rifie la cr√©ation de tokens pour les faits du c√¥t√© droit.
func TestJoinNode_CreateTokenForRightFact(t *testing.T) {
	t.Log("üß™ TEST JoinNode - createTokenForRightFact")
	t.Log("===========================================")

	productFact := &Fact{
		ID:     "p1",
		Type:   "Product",
		Fields: map[string]interface{}{"id": 200, "name": "Widget"},
	}

	joinNode := &JoinNode{
		BaseNode:       BaseNode{ID: "join_test"},
		RightVariables: []string{"product"},
		VariableTypes: map[string]string{
			"product": "Product",
		},
		Debug: true,
	}

	// Act
	token, err := joinNode.createTokenForRightFact(productFact)

	// Assert
	if err != nil {
		t.Fatalf("‚ùå createTokenForRightFact retourn√© erreur: %v", err)
	}

	if token == nil {
		t.Fatal("‚ùå Token est nil")
	}

	if token.Bindings.Len() != 1 {
		t.Errorf("‚ùå Attendu 1 binding, got %d", token.Bindings.Len())
	}

	if !token.HasBinding("product") {
		t.Error("‚ùå Binding 'product' manquant")
	}

	if token.GetBinding("product") != productFact {
		t.Error("‚ùå Binding 'product' incorrect")
	}

	if len(token.Facts) != 1 || token.Facts[0] != productFact {
		t.Error("‚ùå Facts incorrect")
	}

	t.Log("‚úÖ createTokenForRightFact fonctionne correctement")
}

// TestJoinNode_CreateTokenForRightFact_NoMatchingVariable teste le cas o√π aucune variable ne correspond.
func TestJoinNode_CreateTokenForRightFact_NoMatchingVariable(t *testing.T) {
	t.Log("üß™ TEST JoinNode - createTokenForRightFact sans variable correspondante")
	t.Log("======================================================================")

	unknownFact := &Fact{
		ID:     "x1",
		Type:   "Unknown",
		Fields: map[string]interface{}{"id": 999},
	}

	joinNode := &JoinNode{
		BaseNode:       BaseNode{ID: "join_test"},
		RightVariables: []string{"product"},
		VariableTypes: map[string]string{
			"product": "Product",
		},
		Debug: true,
	}

	// Act
	token, err := joinNode.createTokenForRightFact(unknownFact)

	// Assert
	if err == nil {
		t.Error("‚ùå Attendu une erreur, got nil")
	}

	if token != nil {
		t.Error("‚ùå Attendu token nil, got non-nil")
	}

	t.Log("‚úÖ Gestion correcte du cas sans variable correspondante")
}
