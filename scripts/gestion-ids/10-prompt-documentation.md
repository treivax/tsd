# Prompt 10 : Documentation finale

**Objectif** : Compl√©ter la documentation du projet pour expliquer la fonctionnalit√© de cl√©s primaires et g√©n√©ration automatique d'IDs. Mettre √† jour tous les documents techniques et guides utilisateur.

**Pr√©requis** : Prompts 01-09 compl√©t√©s et valid√©s.

---

## Contexte

La fonctionnalit√© de cl√©s primaires et g√©n√©ration automatique d'IDs est maintenant compl√®tement impl√©ment√©e et test√©e. Il faut documenter :

1. La syntaxe et l'utilisation des cl√©s primaires
2. Le m√©canisme de g√©n√©ration d'IDs
3. Les cas d'usage et bonnes pratiques
4. L'API pour les d√©veloppeurs
5. Les changements par rapport aux versions pr√©c√©dentes

---

## T√¢ches

### 10.1. Documentation utilisateur : Syntaxe des cl√©s primaires

**Fichier** : `docs/syntax.md` ou `docs/language-reference.md`

**Action** : Ajouter une section compl√®te sur les cl√©s primaires.

**Contenu √† ajouter** :

```markdown
## Primary Keys and Automatic ID Generation

### Overview

TSD automatically generates unique identifiers (IDs) for all facts. You can influence how these IDs are generated by marking fields as primary keys using the `#` prefix.

### Syntax

#### Simple Primary Key

Mark a single field as the primary key by prefixing it with `#`:

```tsd
type Person(#username: string, email: string, age: number)
```

When you assert a fact of this type, the ID will be generated from the primary key value:

```tsd
assert Person(username: "alice", email: "alice@example.com", age: 30)
// Generated ID: "Person~alice"
```

#### Composite Primary Key

Mark multiple fields as primary keys to create a composite key:

```tsd
type Product(#category: string, #name: string, price: number)
```

The ID will be generated by concatenating the primary key values with `_`:

```tsd
assert Product(category: "Electronics", name: "Laptop", price: 1200)
// Generated ID: "Product~Electronics_Laptop"
```

The order of fields in the type definition determines the order in the ID.

#### No Primary Key (Hash-Based)

If no fields are marked with `#`, TSD generates an ID using a deterministic hash of all field values:

```tsd
type Event(timestamp: number, level: string, message: string)
```

```tsd
assert Event(timestamp: 1704067200, level: "INFO", message: "App started")
// Generated ID: "Event~a1b2c3d4e5f6g7h8" (16-character hex hash)
```

The hash is deterministic: the same field values always produce the same ID.

### ID Format

IDs follow the format: `TypeName~identifier`

- **With primary key**: `identifier` = primary key values joined by `_`
- **Without primary key**: `identifier` = 16-character hexadecimal hash

Special characters in primary key values are percent-encoded:
- `~` ‚Üí `%7E`
- `_` ‚Üí `%5F`
- `%` ‚Üí `%25`
- `/` ‚Üí `%2F`
- space ‚Üí `%20`

Example:
```tsd
type File(#path: string)
assert File(path: "/home/user~backup_v1")
// Generated ID: "File~%2Fhome%2Fuser%7Ebackup%5Fv1"
```

### Accessing IDs in Rules

The `id` field is automatically available on all facts and is of type `string`:

```tsd
rule PrintUserID {
    when {
        u: User()
    }
    then {
        print("User ID: " + u.id)
    }
}
```

You can use `id` in conditions:

```tsd
rule SpecificUser {
    when {
        u: User()
        u.id == "User~alice"
    }
    then {
        print("Found Alice")
    }
}
```

And in joins:

```tsd
type User(#username: string, email: string)
type Session(#session_id: string, user_id: string, active: bool)

rule ActiveUserSessions {
    when {
        u: User()
        s: Session()
        s.user_id == u.id
        s.active == true
    }
    then {
        print("Active session for " + u.username)
    }
}
```

### Constraints

1. **Primary key fields must be primitive types**: string, number, or bool
2. **Primary key fields are required**: All primary key fields must be present in assertions
3. **The `id` field is reserved**: You cannot set `id` explicitly in assertions

```tsd
// ‚ùå ERROR: Cannot set id explicitly
assert Person(id: "custom_id", username: "alice", email: "alice@example.com")

// ‚úÖ CORRECT: Let TSD generate the ID
assert Person(username: "alice", email: "alice@example.com")
```

### Best Practices

#### Choose Natural Keys

Select fields that naturally identify the entity:

```tsd
// Good: username is a natural unique identifier
type User(#username: string, email: string)

// Good: order_number is a natural unique identifier
type Order(#order_number: string, customer: string, total: number)

// Good: composite key for many-to-many relationships
type Enrollment(#student_id: string, #course_id: string, grade: number)
```

#### Use Meaningful Field Names

Instead of generic `id` fields, use descriptive names:

```tsd
// ‚ùå Less clear
type Product(#id: string, name: string)

// ‚úÖ More descriptive
type Product(#sku: string, name: string)
```

#### Use Hash for Immutable Events

For event logs or audit trails where there's no natural key:

```tsd
type AuditLog(timestamp: number, user: string, action: string, details: string)
// No primary key ‚Üí uses hash
```

#### Be Consistent Across Related Types

When types reference each other, use consistent naming:

```tsd
type User(#username: string, email: string)
type Post(#post_id: string, author_username: string, title: string)
// Post.author_username references User.username
```

### Examples

See the `examples/` directory for complete examples:
- `examples/basic.tsd` - Simple primary key
- `examples/composite_key.tsd` - Composite primary key
- `examples/no_primary_key.tsd` - Hash-based IDs
- `examples/relationships.tsd` - Relations between types
```

### 10.2. Documentation d√©veloppeur : Architecture interne

**Fichier** : `docs/architecture/id-generation.md` (cr√©er)

**Contenu** :

```markdown
# ID Generation Architecture

This document describes the internal architecture of the automatic ID generation feature.

## Overview

The ID generation system consists of several components:

1. **Grammar**: Parses `#` prefix to mark primary key fields
2. **Type System**: Stores primary key metadata in `Field.IsPrimaryKey`
3. **Validation**: Ensures primary key constraints are met
4. **ID Generator**: Generates deterministic IDs from field values
5. **RETE Integration**: Uses generated IDs in the runtime

## Components

### Grammar (`constraint/grammar/constraint.peg`)

The PEG grammar recognizes the `#` prefix in field definitions:

```peg
Field <- "#"? name:Identifier ":" type:TypeName {
    return map[string]interface{}{
        "name": name,
        "type": type,
        "isPrimaryKey": /* true if # was present */
    }
}
```

The parser is generated using pigeon and outputs Go code in `constraint/parser.go`.

### Type System (`constraint/constraint_types.go`)

The `Field` struct includes a primary key flag:

```go
type Field struct {
    Name         string `json:"name"`
    Type         string `json:"type"`
    IsPrimaryKey bool   `json:"isPrimaryKey,omitempty"`
}
```

Helper methods on `TypeDefinition`:

```go
func (td *TypeDefinition) HasPrimaryKey() bool
func (td *TypeDefinition) GetPrimaryKeyFields() []Field
func (td *TypeDefinition) GetPrimaryKeyFieldNames() []string
```

### Validation (`constraint/primary_key_validation.go`)

Validation functions ensure:

1. Primary key fields are primitive types (string, number, bool)
2. Primary key fields are present in fact assertions
3. The `id` field is not set explicitly

```go
func ValidatePrimaryKeyTypes(typeDef *TypeDefinition) error
func ValidatePrimaryKeyFieldsPresent(fact *Fact, typeDef *TypeDefinition) error
func ValidateNoExplicitID(fact *Fact) error
```

### ID Generator (`constraint/id_generator.go`)

The ID generator creates deterministic IDs based on primary keys or hashes.

#### Key Functions

**`GenerateFactID(fact *Fact, typeDef *TypeDefinition) (string, error)`**

Main entry point. Determines whether to use primary key or hash-based generation.

**`generateIDFromPrimaryKey(fact *Fact, typeDef *TypeDefinition) (string, error)`**

Generates IDs from primary key values:
1. Extracts primary key field values in order
2. Converts each value to string using `valueToString`
3. Escapes special characters using `escapeIDValue`
4. Joins with `_` separator
5. Prefixes with `TypeName~`

**`generateIDFromHash(fact *Fact, typeDef *TypeDefinition) string`**

Generates IDs from hash:
1. Sorts all fields by name (deterministic order)
2. Concatenates field names and values
3. Computes MD5 hash
4. Truncates to 16 hex characters
5. Prefixes with `TypeName~`

**`valueToString(value interface{}) string`**

Converts values to deterministic string representations:
- Integers: `fmt.Sprintf("%d", intValue)`
- Floats: `strconv.FormatFloat(f, 'f', -1, 64)`
- Booleans: `"true"` or `"false"`
- Strings: as-is

**`escapeIDValue(s string) string`** and **`unescapeIDValue(s string) string`**

Percent-encode special characters to avoid ambiguity in IDs:
- `%` ‚Üí `%25` (escape first!)
- `~` ‚Üí `%7E` (separator between type and ID)
- `_` ‚Üí `%5F` (separator between PK values)

### RETE Integration

#### Fact Structure (`rete/fact_token.go`)

The RETE `Fact` struct contains the generated ID:

```go
type Fact struct {
    ID     string                 // Generated ID
    Type   string                 // Type name
    Fields map[string]interface{} // Field values
}
```

#### ID Access in Evaluator (`rete/evaluator.go`)

The evaluator allows access to the special `id` field:

```go
func (e *Evaluator) getFieldValue(fact *Fact, fieldName string) (interface{}, error) {
    if fieldName == "id" {
        return fact.ID, nil
    }
    // ... normal field access
}
```

#### Working Memory (`rete/working_memory.go`)

Facts are indexed using internal IDs of the format `Type_ID`:

```go
internalID := MakeInternalID(fact.Type, fact.ID)
// Example: "Person_Person~alice"
wm.facts[internalID] = fact
```

## Data Flow

1. **Parsing**:
   ```
   Source Code ‚Üí PEG Parser ‚Üí AST (with isPrimaryKey flags)
   ```

2. **Type Conversion**:
   ```
   AST ‚Üí ConvertResultToProgram ‚Üí Program (Field.IsPrimaryKey set)
   ```

3. **Validation**:
   ```
   Program ‚Üí ValidatePrimaryKeyTypes ‚Üí Error or Success
   Program ‚Üí ValidateFacts ‚Üí ValidateNoExplicitID, ValidatePrimaryKeyFieldsPresent
   ```

4. **ID Generation**:
   ```
   Fact + TypeDef ‚Üí GenerateFactID ‚Üí ID string
   ```

5. **RETE Conversion**:
   ```
   constraint.Fact ‚Üí ConvertFactsToReteFormat ‚Üí rete.Fact (with ID)
   ```

6. **Runtime**:
   ```
   rete.Fact ‚Üí WorkingMemory (indexed by internal ID)
   Rule Conditions ‚Üí Evaluator (can access fact.id)
   ```

## Design Decisions

### Why MD5 for Hashing?

- **Deterministic**: Same input always produces same hash
- **Fast**: MD5 is much faster than SHA-256 for this use case
- **Collision Risk**: Acceptable for typical fact counts (< millions)
- **Not for Security**: We're not using it for cryptographic purposes

### Why Percent-Encoding?

- **Unambiguous Parsing**: Can split IDs on `~` and `_` safely
- **Reversible**: Can extract original values if needed
- **Standard**: Well-understood encoding scheme

### Why 16-Character Hash?

- **Balance**: Good collision resistance for typical use cases
- **Readability**: Not too long for debugging
- **Storage**: Reasonable size for IDs

### Field Order for Composite Keys

Primary key fields are ordered **as they appear in the type definition**, not alphabetically. This gives users control over the ID format.

## Performance Considerations

### ID Generation

- **Primary Key**: O(k) where k = number of PK fields
  - String concatenation and escaping
  - Very fast (microseconds)

- **Hash**: O(n log n) where n = number of fields
  - Field sorting for determinism
  - MD5 computation
  - Still fast (< millisecond for typical facts)

### Working Memory Lookups

- **Indexing**: O(1) hash map lookup by internal ID
- **No Impact**: ID format doesn't affect lookup performance

### Memory

- **PK-based IDs**: Variable length, typically 20-50 bytes
- **Hash-based IDs**: Fixed length, ~32 bytes (TypeName + 16 chars)

## Testing Strategy

### Unit Tests

- `id_generator_test.go`: Test all ID generation functions
- `primary_key_validation_test.go`: Test validation rules
- `parser_test.go`: Test parsing of `#` syntax

### Integration Tests

- `constraint/integration_test.go`: Test full parsing ‚Üí validation ‚Üí ID generation
- `rete/evaluator_test.go`: Test `id` field access in expressions
- `rete/working_memory_test.go`: Test fact storage with generated IDs

### End-to-End Tests

- `integration_test.go`: Test complete programs with rules
- `testdata/integration/*.tsd`: Real-world scenario files

## Future Enhancements

Potential improvements:

1. **Custom ID Functions**: Allow users to define custom ID generation logic
2. **UUID Option**: Support UUID generation for types without natural keys
3. **ID Validation**: Validate ID format when parsing existing facts from storage
4. **Performance**: Cache computed hashes for immutable facts

## References

- [PLAN.md](../../scripts/gestion-ids/00-PLAN.md) - Original implementation plan
- [MIGRATION_IDS.md](MIGRATION_IDS.md) - User migration guide
- [syntax.md](syntax.md) - Language syntax reference
```

### 10.3. Documentation API

**Fichier** : `docs/api/constraint.md` (cr√©er ou mettre √† jour)

**Contenu** :

```markdown
# Constraint Package API

## Types

### Field

```go
type Field struct {
    Name         string `json:"name"`
    Type         string `json:"type"`
    IsPrimaryKey bool   `json:"isPrimaryKey,omitempty"`
}
```

Represents a field in a type definition.

- `Name`: Field name
- `Type`: Field type (string, number, bool, object, array)
- `IsPrimaryKey`: True if this field is part of the primary key

### TypeDefinition

```go
type TypeDefinition struct {
    Name   string  `json:"name"`
    Fields []Field `json:"fields"`
}
```

Represents a type definition.

#### Methods

**`HasPrimaryKey() bool`**

Returns true if the type has at least one primary key field.

**`GetPrimaryKeyFields() []Field`**

Returns all fields marked as primary keys, in the order they appear in the type definition.

**`GetPrimaryKeyFieldNames() []string`**

Returns the names of all primary key fields.

**Example:**

```go
typeDef := &TypeDefinition{
    Name: "Person",
    Fields: []Field{
        {Name: "username", Type: "string", IsPrimaryKey: true},
        {Name: "email", Type: "string", IsPrimaryKey: false},
    },
}

typeDef.HasPrimaryKey() // true
typeDef.GetPrimaryKeyFieldNames() // ["username"]
```

## Functions

### GenerateFactID

```go
func GenerateFactID(fact *Fact, typeDef *TypeDefinition) (string, error)
```

Generates a unique ID for a fact based on its type definition and field values.

- If the type has primary keys: generates ID from primary key values
- Otherwise: generates ID from hash of all field values

**Returns:**
- `string`: The generated ID in format `TypeName~identifier`
- `error`: If primary key fields are missing or invalid

**Example:**

```go
typeDef := &TypeDefinition{
    Name: "Person",
    Fields: []Field{
        {Name: "username", Type: "string", IsPrimaryKey: true},
        {Name: "age", Type: "number"},
    },
}

fact := &Fact{
    Type: "Person",
    Fields: []FactField{
        {Name: "username", Value: FactValue{StringValue: ptr("alice")}},
        {Name: "age", Value: FactValue{NumberValue: ptr(30.0)}},
    },
}

id, err := GenerateFactID(fact, typeDef)
// id = "Person~alice"
```

### ValidatePrimaryKeyTypes

```go
func ValidatePrimaryKeyTypes(typeDef *TypeDefinition) error
```

Validates that all primary key fields are primitive types (string, number, bool).

**Returns:**
- `nil`: If validation passes
- `error`: If any primary key field is not a primitive type

### ValidatePrimaryKeyFieldsPresent

```go
func ValidatePrimaryKeyFieldsPresent(fact *Fact, typeDef *TypeDefinition) error
```

Validates that all primary key fields defined in the type are present in the fact.

**Returns:**
- `nil`: If all primary key fields are present
- `error`: If any primary key field is missing

### ValidateNoExplicitID

```go
func ValidateNoExplicitID(fact *Fact) error
```

Validates that the fact does not explicitly set the `id` field.

**Returns:**
- `nil`: If `id` is not set
- `error`: If `id` field is present

## RETE Package API

### Fact

```go
type Fact struct {
    ID     string                 // Unique identifier (auto-generated)
    Type   string                 // Type name
    Fields map[string]interface{} // Field values
}
```

#### Methods

**`GetInternalID() string`**

Returns the internal ID used for indexing in working memory.

Format: `Type_ID`

**Example:**

```go
fact := &Fact{
    ID:   "Person~alice",
    Type: "Person",
    Fields: map[string]interface{}{"username": "alice"},
}

fact.GetInternalID() // "Person_Person~alice"
```

### Helper Functions

**`MakeInternalID(factType, factID string) string`**

Creates an internal ID from a type and ID.

**`ParseInternalID(internalID string) (factType, factID string, err error)`**

Parses an internal ID into its components.

**Example:**

```go
internalID := MakeInternalID("Person", "Person~alice")
// internalID = "Person_Person~alice"

factType, factID, err := ParseInternalID(internalID)
// factType = "Person"
// factID = "Person~alice"
```
```

### 10.4. Changelog

**Fichier** : `CHANGELOG.md`

**Action** : Ajouter une entr√©e pour cette nouvelle fonctionnalit√©.

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added

- **Primary Key Support**: Fields can now be marked as primary keys using the `#` prefix
  - Simple primary keys: `type Person(#username: string, age: number)`
  - Composite primary keys: `type Product(#category: string, #name: string, price: number)`
  - See [docs/syntax.md](docs/syntax.md) for details

- **Automatic ID Generation**: Fact IDs are now generated automatically
  - Based on primary key values when defined: `Person~alice`
  - Based on deterministic hash when no primary key: `Event~a1b2c3d4e5f6g7h8`
  - Special characters are percent-encoded to avoid conflicts
  - See [docs/architecture/id-generation.md](docs/architecture/id-generation.md) for implementation details

- **ID Field Access**: The `id` field is now accessible in all rule expressions
  - Type: `string`
  - Read-only (cannot be set in assertions)
  - Available for comparisons and joins
  - Example: `u.id == "User~alice"`

- **Primary Key Validation**: Compiler validates primary key constraints
  - Primary key fields must be primitive types (string, number, bool)
  - Primary key fields must be present in all fact assertions
  - Explicit `id` setting in assertions is now forbidden

- **Examples**: New example files demonstrating primary key usage
  - `examples/composite_key.tsd`: Composite primary keys
  - `examples/no_primary_key.tsd`: Hash-based ID generation
  - `examples/relationships.tsd`: Relations between types
  - `examples/escaping.tsd`: Special character handling

- **Migration Guide**: Comprehensive guide for updating existing programs
  - See [docs/MIGRATION_IDS.md](docs/MIGRATION_IDS.md)

### Changed

- **Breaking**: Explicit `id` field in assertions is no longer allowed
  - Before: `assert Person(id: "p1", name: "Alice")`
  - After: `assert Person(name: "Alice")` (ID auto-generated)
  - See migration guide for upgrade path

- **ID Format**: IDs now follow the format `TypeName~identifier`
  - Replaces sequential format `parsed_fact_N`
  - Deterministic and meaningful
  - Backward compatibility maintained for types without primary keys

### Fixed

- Deterministic ID generation ensures same facts produce same IDs across runs

## [Previous versions]

...
```

### 10.5. README principal

**Fichier** : `README.md`

**Action** : Mettre √† jour avec une section sur les cl√©s primaires.

**Ajouter apr√®s la section "Features" ou similaire** :

```markdown
## Features

- **Type System**: Define custom types with fields and constraints
- **Rules Engine**: Declarative rules with pattern matching
- **RETE Algorithm**: Efficient rule evaluation
- **Primary Keys**: Automatic ID generation based on primary keys ‚ú® NEW
  - Mark fields with `#` to define primary keys
  - IDs generated automatically from key values
  - Deterministic and human-readable IDs
- **Fact Management**: Add, retract, and query facts
- **Expression Language**: Rich expression syntax for conditions

...

## Quick Start

```tsd
// Define a type with a primary key
type User(#username: string, email: string, role: string)

// Assert facts (IDs generated automatically)
assert User(username: "alice", email: "alice@example.com", role: "admin")
assert User(username: "bob", email: "bob@example.com", role: "user")

// Write rules that use the generated IDs
rule AdminUsers {
    when {
        u: User()
        u.role == "admin"
    }
    then {
        print("Admin user: " + u.username + " (ID: " + u.id + ")")
    }
}
```

### Primary Keys

TSD supports automatic ID generation based on primary keys:

```tsd
// Simple primary key
type Person(#name: string, age: number)
assert Person(name: "Alice", age: 30)  // ID: Person~Alice

// Composite primary key
type Product(#category: string, #name: string, price: number)
assert Product(category: "Electronics", name: "Laptop", price: 1200)
// ID: Product~Electronics_Laptop

// No primary key (hash-based)
type Event(timestamp: number, message: string)
assert Event(timestamp: 1704067200, message: "App started")
// ID: Event~a1b2c3d4e5f6g7h8
```

For more details, see [Primary Keys Documentation](docs/syntax.md#primary-keys-and-automatic-id-generation).

...
```

### 10.6. Commentaires de code

**Action** : S'assurer que tous les fichiers modifi√©s ont des commentaires appropri√©s.

**V√©rifier** :

1. `constraint/id_generator.go` : Commentaires GoDoc complets
2. `constraint/primary_key_validation.go` : Commentaires GoDoc complets
3. `constraint/constraint_types.go` : Commentaires sur les nouveaux champs et m√©thodes
4. `rete/evaluator.go` : Commentaire sur l'acc√®s au champ `id`

**Exemple de bon commentaire GoDoc** :

```go
// GenerateFactID generates a unique identifier for a fact based on its type definition.
//
// If the type has primary key fields (marked with #), the ID is generated by
// concatenating the primary key values with underscores and prefixing with the type name:
//   - Format: "TypeName~value1_value2_..."
//   - Example: "Person~Alice_Dupont"
//
// If the type has no primary keys, the ID is generated using a deterministic hash
// of all field values:
//   - Format: "TypeName~<16-char-hex-hash>"
//   - Example: "Event~a1b2c3d4e5f6g7h8"
//
// Special characters in primary key values are percent-encoded to avoid ambiguity.
//
// Returns an error if:
//   - Primary key fields are missing from the fact
//   - Primary key field values cannot be converted to strings
func GenerateFactID(fact *Fact, typeDef *TypeDefinition) (string, error) {
    // ...
}
```

### 10.7. Documentation en ligne (optionnel)

**Si le projet utilise godoc ou pkgsite** :

```bash
# G√©n√©rer la documentation
go doc -all ./constraint | grep -A 20 "GenerateFactID"
go doc -all ./constraint | grep -A 10 "type TypeDefinition"

# V√©rifier que les commentaires sont corrects
```

### 10.8. Tutoriel complet (optionnel)

**Fichier** : `docs/tutorial/primary-keys.md` (cr√©er)

**Contenu** : Un tutoriel pas-√†-pas montrant comment utiliser les cl√©s primaires dans un projet r√©el.

```markdown
# Tutorial: Using Primary Keys in TSD

This tutorial walks you through using primary keys and automatic ID generation in a real-world scenario.

## Scenario: Blog Management System

We'll build a simple blog system with users, posts, and comments.

### Step 1: Define Types with Primary Keys

```tsd
// Users have a unique username
type User(#username: string, email: string, join_date: number)

// Posts have a unique post_id
type Post(#post_id: number, author_username: string, title: string, content: string, published: bool)

// Comments have a unique comment_id
type Comment(#comment_id: number, post_id: number, author_username: string, text: string)

// Likes use a composite key (user + post)
type Like(#username: string, #post_id: number)
```

### Step 2: Add Sample Data

```tsd
// Create users
assert User(username: "alice", email: "alice@blog.com", join_date: 1704067200)
assert User(username: "bob", email: "bob@blog.com", join_date: 1704153600)

// Create posts
assert Post(post_id: 1, author_username: "alice", title: "Hello World", content: "My first post", published: true)
assert Post(post_id: 2, author_username: "alice", title: "TSD Tutorial", content: "Learn TSD", published: true)
assert Post(post_id: 3, author_username: "bob", title: "Draft Post", content: "Work in progress", published: false)

// Add comments
assert Comment(comment_id: 1, post_id: 1, author_username: "bob", text: "Great post!")
assert Comment(comment_id: 2, post_id: 1, author_username: "alice", text: "Thanks!")

// Add likes
assert Like(username: "bob", post_id: 1)
assert Like(username: "bob", post_id: 2)
assert Like(username: "alice", post_id: 1)
```

### Step 3: Write Rules

```tsd
// Find published posts with their authors
rule PublishedPostsWithAuthors {
    when {
        p: Post()
        u: User()
        p.published == true
        p.author_username == u.username
    }
    then {
        print("Post: '" + p.title + "' by " + u.email)
        print("  Post ID: " + p.id)
        print("  User ID: " + u.id)
    }
}

// Count comments per post
rule PostsWithMultipleComments {
    when {
        p: Post()
        c1: Comment()
        c2: Comment()
        c1.post_id == p.post_id
        c2.post_id == p.post_id
        c1.id != c2.id  // Different comments
    }
    then {
        print("Post '" + p.title + "' has multiple comments")
    }
}

// Find users who liked their own posts
rule SelfLikes {
    when {
        p: Post()
        l: Like()
        l.post_id == p.post_id
        l.username == p.author_username
    }
    then {
        print("User " + l.username + " liked their own post!")
    }
}
```

### Step 4: Understand the Generated IDs

When you run this program, TSD generates the following IDs:

**Users:**
- `User~alice`
- `User~bob`

**Posts:**
- `Post~1`
- `Post~2`
- `Post~3`

**Comments:**
- `Comment~1`
- `Comment~2`

**Likes:**
- `Like~bob_1`
- `Like~bob_2`
- `Like~alice_1`

Notice how:
- Simple keys produce simple IDs: `User~alice`
- Numeric keys work too: `Post~1`
- Composite keys join values: `Like~bob_1`

### Step 5: Query and Debug

You can use the IDs for debugging and querying:

```tsd
rule DebugSpecificPost {
    when {
        p: Post()
        p.id == "Post~1"
    }
    then {
        print("Found post 1: " + p.title)
        print("Author: " + p.author_username)
    }
}
```

### Best Practices Learned

1. **Use natural keys**: `username` for users, `post_id` for posts
2. **Composite keys for relationships**: `Like(#username, #post_id)`
3. **IDs are strings**: Always compare with string literals
4. **IDs are deterministic**: Same data = same ID every time

## Next Steps

- Read [Syntax Reference](../syntax.md) for complete documentation
- See [Examples](../../examples/) for more use cases
- Check [Migration Guide](../MIGRATION_IDS.md) if updating existing code
```

---

## Validation

### √âtape 1 : V√©rifier tous les documents

```bash
cd /home/resinsec/dev/tsd

# Lister tous les fichiers de documentation
find docs/ -name "*.md" -type f
cat README.md
cat CHANGELOG.md
```

### √âtape 2 : V√©rifier les commentaires GoDoc

```bash
# V√©rifier que tous les exports sont document√©s
go doc ./constraint | less
go doc ./rete | less

# V√©rifier sp√©cifiquement les nouvelles fonctions
go doc constraint.GenerateFactID
go doc constraint.TypeDefinition.HasPrimaryKey
```

### √âtape 3 : G√©n√©rer la documentation (si applicable)

```bash
# G√©n√©rer avec godoc (si install√©)
godoc -http=:6060 &
# Ouvrir http://localhost:6060/pkg/github.com/sekiatech/tsd/

# Ou avec pkgsite
go install golang.org/x/pkgsite/cmd/pkgsite@latest
pkgsite -open .
```

### √âtape 4 : V√©rifier les liens dans la documentation

```bash
# Script pour v√©rifier les liens internes
grep -r "\[.*\](.*\.md)" docs/ | grep -v "http" | while read line; do
    file=$(echo "$line" | cut -d: -f1)
    link=$(echo "$line" | grep -oP '\(.*?\.md\)' | tr -d '()')
    
    # R√©soudre le chemin relatif
    dir=$(dirname "$file")
    target="$dir/$link"
    
    if [ ! -f "$target" ]; then
        echo "Broken link in $file: $link"
    fi
done
```

### √âtape 5 : Relire et corriger

Relire tous les documents cr√©√©s/modifi√©s pour :
- Orthographe et grammaire
- Coh√©rence de la terminologie
- Exactitude technique
- Clart√© des exemples
- Compl√©tude des explications

### √âtape 6 : Validation finale

```bash
make validate
make test-complete
```

---

## Checklist

- [ ] `docs/syntax.md` mis √† jour avec section Primary Keys
- [ ] `docs/architecture/id-generation.md` cr√©√© (architecture interne)
- [ ] `docs/api/constraint.md` cr√©√© ou mis √† jour (API)
- [ ] `docs/MIGRATION_IDS.md` v√©rifi√© (cr√©√© au prompt 09)
- [ ] `CHANGELOG.md` mis √† jour avec nouvelle fonctionnalit√©
- [ ] `README.md` mis √† jour avec exemples de primary keys
- [ ] Commentaires GoDoc ajout√©s/v√©rifi√©s sur tous les exports
- [ ] `docs/tutorial/primary-keys.md` cr√©√© (optionnel)
- [ ] Documentation g√©n√©r√©e avec godoc/pkgsite v√©rifi√©e
- [ ] Liens internes dans docs/ v√©rifi√©s
- [ ] Orthographe et grammaire relues
- [ ] Coh√©rence terminologique v√©rifi√©e
- [ ] Exemples de code test√©s
- [ ] `make validate` r√©ussit
- [ ] `make test-complete` r√©ussit

---

## Rapport

Une fois toutes les t√¢ches compl√©t√©es :

1. Lister tous les documents cr√©√©s/modifi√©s
2. R√©sumer les sections ajout√©es
3. Indiquer le nombre de pages/lignes de documentation ajout√©es
4. Copier les sorties de validation
5. Commit :

```bash
git add docs/ README.md CHANGELOG.md
git commit -m "docs: documentation compl√®te pour cl√©s primaires et g√©n√©ration d'IDs

Documentation utilisateur:
- docs/syntax.md: section compl√®te sur les primary keys
- docs/MIGRATION_IDS.md: guide de migration (v√©rifi√©)
- README.md: quick start avec exemples de PK
- docs/tutorial/primary-keys.md: tutoriel complet

Documentation d√©veloppeur:
- docs/architecture/id-generation.md: architecture interne
- docs/api/constraint.md: API publique document√©e
- Commentaires GoDoc ajout√©s sur tous les exports

Changelog:
- CHANGELOG.md: entr√©e compl√®te pour la nouvelle fonctionnalit√©

Couverture:
- Syntaxe et utilisation
- Architecture et design
- API et exemples de code
- Migration depuis version pr√©c√©dente
- Tutoriel pas-√†-pas
- Bonnes pratiques

Tous les liens v√©rifi√©s, exemples test√©s, et validation pass√©e.

Refs #<issue_number>"
```

---

## D√©pendances

- **Bloque** : Rien (dernier prompt de la s√©rie)
- **Bloqu√© par** : Prompts 01-09

---

## Notes importantes

1. **Coh√©rence** : Maintenir une terminologie coh√©rente dans toute la documentation :
   - "primary key" (pas "PK" sauf dans les noms de fichiers d'exemples)
   - "ID" (pas "id" ou "identifier" sauf dans les contextes appropri√©s)
   - "fact" (pas "instance" ou "object")

2. **Exemples** : Tous les exemples de code dans la documentation doivent :
   - √ätre syntaxiquement corrects
   - Fonctionner r√©ellement (tester si possible)
   - Montrer les bonnes pratiques
   - Inclure des commentaires explicatifs

3. **Niveaux de d√©tail** :
   - Documentation utilisateur : Focalis√©e sur "comment utiliser"
   - Documentation d√©veloppeur : Focalis√©e sur "comment √ßa marche"
   - API : R√©f√©rence technique pr√©cise

4. **Accessibilit√©** : √âcrire pour diff√©rents niveaux :
   - D√©butants : README, tutoriel
   - Utilisateurs avanc√©s : Syntax reference, migration guide
   - Contributeurs : Architecture, API

5. **Maintenance** : Inclure des notes sur :
   - O√π trouver plus d'informations
   - Comment reporter des bugs
   - Comment contribuer

6. **Internationalisation** : Si le projet supporte plusieurs langues, documenter en anglais en priorit√© (langue universelle pour le code).

7. **Versioning** : Indiquer clairement quelle version introduit cette fonctionnalit√©.

---

## Conclusion

Une fois ce prompt compl√©t√©, la fonctionnalit√© de cl√©s primaires et g√©n√©ration automatique d'IDs est compl√®tement impl√©ment√©e, test√©e et document√©e.

**V√©rification finale compl√®te** :

```bash
# Tous les tests
make test-complete

# Toutes les validations
make validate

# Couverture de code
go test ./... -cover

# Documentation g√©n√©r√©e
go doc ./...
```

**Prochaines √©tapes recommand√©es** :

1. Ouvrir une PR avec tous les changements
2. Faire une revue de code compl√®te
3. Tester manuellement avec des programmes r√©els
4. Obtenir des retours utilisateurs sur la documentation
5. Planifier la release avec cette fonctionnalit√©

**üéâ F√©licitations ! La fonctionnalit√© est compl√®te.**