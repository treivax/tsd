
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rete: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/treivax/tsd/rete/alpha_builder.go (0.0%)</option>
				
				<option value="file1">github.com/treivax/tsd/rete/constraint_pipeline.go (19.8%)</option>
				
				<option value="file2">github.com/treivax/tsd/rete/constraint_pipeline_builder.go (64.7%)</option>
				
				<option value="file3">github.com/treivax/tsd/rete/constraint_pipeline_helpers.go (45.1%)</option>
				
				<option value="file4">github.com/treivax/tsd/rete/constraint_pipeline_parser.go (77.3%)</option>
				
				<option value="file5">github.com/treivax/tsd/rete/constraint_pipeline_validator.go (6.5%)</option>
				
				<option value="file6">github.com/treivax/tsd/rete/converter.go (0.0%)</option>
				
				<option value="file7">github.com/treivax/tsd/rete/evaluator.go (20.0%)</option>
				
				<option value="file8">github.com/treivax/tsd/rete/evaluator_comparisons.go (63.4%)</option>
				
				<option value="file9">github.com/treivax/tsd/rete/evaluator_constraints.go (30.6%)</option>
				
				<option value="file10">github.com/treivax/tsd/rete/evaluator_expressions.go (50.0%)</option>
				
				<option value="file11">github.com/treivax/tsd/rete/evaluator_functions.go (0.0%)</option>
				
				<option value="file12">github.com/treivax/tsd/rete/evaluator_operators.go (0.0%)</option>
				
				<option value="file13">github.com/treivax/tsd/rete/evaluator_values.go (33.7%)</option>
				
				<option value="file14">github.com/treivax/tsd/rete/fact_token.go (83.8%)</option>
				
				<option value="file15">github.com/treivax/tsd/rete/logger.go (5.3%)</option>
				
				<option value="file16">github.com/treivax/tsd/rete/network.go (39.1%)</option>
				
				<option value="file17">github.com/treivax/tsd/rete/node_accumulate.go (74.1%)</option>
				
				<option value="file18">github.com/treivax/tsd/rete/node_alpha.go (52.6%)</option>
				
				<option value="file19">github.com/treivax/tsd/rete/node_base.go (73.1%)</option>
				
				<option value="file20">github.com/treivax/tsd/rete/node_exists.go (18.4%)</option>
				
				<option value="file21">github.com/treivax/tsd/rete/node_join.go (60.4%)</option>
				
				<option value="file22">github.com/treivax/tsd/rete/node_root.go (76.9%)</option>
				
				<option value="file23">github.com/treivax/tsd/rete/node_terminal.go (80.9%)</option>
				
				<option value="file24">github.com/treivax/tsd/rete/node_type.go (73.2%)</option>
				
				<option value="file25">github.com/treivax/tsd/rete/store_base.go (88.6%)</option>
				
				<option value="file26">github.com/treivax/tsd/rete/store_indexed.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package rete

import (
        "fmt"
)

// AlphaConditionBuilder aide √† construire des conditions Alpha
type AlphaConditionBuilder struct{}

// NewAlphaConditionBuilder cr√©e un nouveau constructeur de conditions
func NewAlphaConditionBuilder() *AlphaConditionBuilder <span class="cov0" title="0">{
        return &amp;AlphaConditionBuilder{}
}</span>

// FieldEquals cr√©e une condition d'√©galit√© sur un champ
func (acb *AlphaConditionBuilder) FieldEquals(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "==",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldNotEquals cr√©e une condition d'in√©galit√© sur un champ
func (acb *AlphaConditionBuilder) FieldNotEquals(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "!=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldLessThan cr√©e une condition de comparaison inf√©rieure sur un champ
func (acb *AlphaConditionBuilder) FieldLessThan(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&lt;",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldLessOrEqual cr√©e une condition de comparaison inf√©rieure ou √©gale sur un champ
func (acb *AlphaConditionBuilder) FieldLessOrEqual(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&lt;=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldGreaterThan cr√©e une condition de comparaison sup√©rieure sur un champ
func (acb *AlphaConditionBuilder) FieldGreaterThan(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&gt;",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldGreaterOrEqual cr√©e une condition de comparaison sup√©rieure ou √©gale sur un champ
func (acb *AlphaConditionBuilder) FieldGreaterOrEqual(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&gt;=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// And cr√©e une condition logique AND
func (acb *AlphaConditionBuilder) And(left, right interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "logicalExpression",
                "left": left,
                "operations": []interface{}{
                        map[string]interface{}{
                                "op":    "AND",
                                "right": right,
                        },
                },
        }
}</span>

// Or cr√©e une condition logique OR
func (acb *AlphaConditionBuilder) Or(left, right interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "logicalExpression",
                "left": left,
                "operations": []interface{}{
                        map[string]interface{}{
                                "op":    "OR",
                                "right": right,
                        },
                },
        }
}</span>

// AndMultiple cr√©e une condition logique AND avec plusieurs conditions
func (acb *AlphaConditionBuilder) AndMultiple(conditions ...interface{}) interface{} <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return acb.True()
        }</span>
        <span class="cov0" title="0">if len(conditions) == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>

        <span class="cov0" title="0">operations := make([]interface{}, 0, len(conditions)-1)
        for _, condition := range conditions[1:] </span><span class="cov0" title="0">{
                operations = append(operations, map[string]interface{}{
                        "op":    "AND",
                        "right": condition,
                })
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type":       "logicalExpression",
                "left":       conditions[0],
                "operations": operations,
        }</span>
}

// OrMultiple cr√©e une condition logique OR avec plusieurs conditions
func (acb *AlphaConditionBuilder) OrMultiple(conditions ...interface{}) interface{} <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return acb.False()
        }</span>
        <span class="cov0" title="0">if len(conditions) == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>

        <span class="cov0" title="0">operations := make([]interface{}, 0, len(conditions)-1)
        for _, condition := range conditions[1:] </span><span class="cov0" title="0">{
                operations = append(operations, map[string]interface{}{
                        "op":    "OR",
                        "right": condition,
                })
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type":       "logicalExpression",
                "left":       conditions[0],
                "operations": operations,
        }</span>
}

// True cr√©e une condition toujours vraie
func (acb *AlphaConditionBuilder) True() interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "booleanLiteral",
                "value": true,
        }
}</span>

// False cr√©e une condition toujours fausse
func (acb *AlphaConditionBuilder) False() interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "booleanLiteral",
                "value": false,
        }
}</span>

// FieldRange cr√©e une condition de plage pour un champ (min &lt;= field &lt;= max)
func (acb *AlphaConditionBuilder) FieldRange(variable, field string, min, max interface{}) interface{} <span class="cov0" title="0">{
        minCondition := acb.FieldGreaterOrEqual(variable, field, min)
        maxCondition := acb.FieldLessOrEqual(variable, field, max)
        return acb.And(minCondition, maxCondition)
}</span>

// FieldIn cr√©e une condition de pr√©sence dans une liste de valeurs
func (acb *AlphaConditionBuilder) FieldIn(variable, field string, values ...interface{}) interface{} <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return acb.False()
        }</span>

        <span class="cov0" title="0">conditions := make([]interface{}, len(values))
        for i, value := range values </span><span class="cov0" title="0">{
                conditions[i] = acb.FieldEquals(variable, field, value)
        }</span>

        <span class="cov0" title="0">return acb.OrMultiple(conditions...)</span>
}

// FieldNotIn cr√©e une condition d'absence dans une liste de valeurs
func (acb *AlphaConditionBuilder) FieldNotIn(variable, field string, values ...interface{}) interface{} <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return acb.True()
        }</span>

        <span class="cov0" title="0">conditions := make([]interface{}, len(values))
        for i, value := range values </span><span class="cov0" title="0">{
                conditions[i] = acb.FieldNotEquals(variable, field, value)
        }</span>

        <span class="cov0" title="0">return acb.AndMultiple(conditions...)</span>
}

// createLiteral cr√©e un litt√©ral typ√©
func (acb *AlphaConditionBuilder) createLiteral(value interface{}) map[string]interface{} <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "stringLiteral",
                        "value": v,
                }</span>
        case int:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case int32:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case int64:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case float32:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case float64:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": v,
                }</span>
        case bool:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "booleanLiteral",
                        "value": v,
                }</span>
        default:<span class="cov0" title="0">
                // Fallback vers string
                return map[string]interface{}{
                        "type":  "stringLiteral",
                        "value": fmt.Sprintf("%v", v),
                }</span>
        }
}

// CreateConstraintFromAST cr√©e une condition √† partir d'un AST de contrainte
func (acb *AlphaConditionBuilder) CreateConstraintFromAST(constraint interface{}) interface{} <span class="cov0" title="0">{
        // Si c'est d√©j√† une map, la retourner telle quelle
        if constraintMap, ok := constraint.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                return constraintMap
        }</span>

        // Sinon, retourner tel quel (sera trait√© par l'√©valuateur)
        <span class="cov0" title="0">return constraint</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// AggregationInfo contient les informations extraites d'une agr√©gation
type AggregationInfo struct {
        Function      string      // AVG, SUM, COUNT, MIN, MAX
        MainVariable  string      // Variable principale (ex: "e" pour Employee)
        MainType      string      // Type principal (ex: "Employee")
        AggVariable   string      // Variable √† agr√©ger (ex: "p" pour Performance)
        AggType       string      // Type √† agr√©ger (ex: "Performance")
        Field         string      // Champ √† agr√©ger (ex: "score")
        Operator      string      // Op√©rateur de comparaison (&gt;=, &gt;, etc.)
        Threshold     float64     // Valeur de seuil
        JoinField     string      // Champ de jointure dans faits agr√©g√©s (ex: "employee_id")
        MainField     string      // Champ de jointure dans fait principal (ex: "id")
        JoinCondition interface{} // Condition de jointure compl√®te
}

// ConstraintPipeline impl√©mente le pipeline complet :
// fichier .constraint ‚Üí parseur PEG ‚Üí conversion AST ‚Üí r√©seau RETE
type ConstraintPipeline struct{}

// NewConstraintPipeline cr√©e une nouvelle instance du pipeline
func NewConstraintPipeline() *ConstraintPipeline <span class="cov8" title="1">{
        return &amp;ConstraintPipeline{}
}</span>

// BuildNetworkFromConstraintFile construit un r√©seau RETE complet √† partir d'un fichier .constraint
// Cette fonction impl√©mente le pipeline unique utilis√© par TOUS les tests
func (cp *ConstraintPipeline) BuildNetworkFromConstraintFile(constraintFile string, storage Storage) (*ReteNetwork, error) <span class="cov8" title="1">{
        fmt.Printf("========================================\n")
        fmt.Printf("üìÅ Fichier: %s\n", constraintFile)

        // √âTAPE 1: Parsing avec le vrai parseur PEG
        parsedAST, err := constraint.ParseConstraintFile(constraintFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur parsing fichier %s: %w", constraintFile, err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Parsing r√©ussi\n")

        // √âTAPE 1.5: Validation s√©mantique du programme
        err = constraint.ValidateConstraintProgram(parsedAST)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur validation s√©mantique: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Validation s√©mantique r√©ussie\n")

        // Valider que c'est un map[string]interface{}
        resultMap, ok := parsedAST.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format AST non reconnu: %T", parsedAST)
        }</span>

        // √âTAPE 2: Extraction et validation des composants
        <span class="cov8" title="1">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // √âTAPE 3: Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // √âTAPE 4: Validation finale
        err = cp.validateNetwork(network)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur validation r√©seau: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Validation r√©ussie\n")

        fmt.Printf("üéØ PIPELINE TERMIN√â AVEC SUCC√àS\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// BuildNetworkFromMultipleFiles construit un r√©seau RETE en parsant plusieurs fichiers de mani√®re it√©rative
// Cette fonction permet de parser des types, r√®gles et faits r√©partis dans diff√©rents fichiers
func (cp *ConstraintPipeline) BuildNetworkFromMultipleFiles(filenames []string, storage Storage) (*ReteNetwork, error) <span class="cov0" title="0">{
        fmt.Printf("========================================\n")
        fmt.Printf("üìÅ Fichiers: %v\n", filenames)

        // Cr√©er un parser it√©ratif
        parser := constraint.NewIterativeParser()

        // Parser tous les fichiers de mani√®re it√©rative
        for i, filename := range filenames </span><span class="cov0" title="0">{
                fmt.Printf("  üìÑ Parsing fichier %d/%d: %s\n", i+1, len(filenames), filename)
                err := parser.ParseFile(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("‚ùå Erreur parsing fichier %s: %w", filename, err)
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("‚úÖ Parsing it√©ratif r√©ussi\n")

        // Obtenir le programme combin√©
        program := parser.GetProgram()

        // Convertir au format RETE
        reteProgram := constraint.ConvertToReteProgram(program)
        resultMap, ok := reteProgram.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format programme RETE invalide: %T", reteProgram)
        }</span>

        // Extraire les composants
        <span class="cov0" title="0">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // Injection des faits dans le r√©seau
        if len(program.Facts) &gt; 0 </span><span class="cov0" title="0">{
                factsForRete := constraint.ConvertFactsToReteFormat(*program)

                err := network.SubmitFactsFromGrammar(factsForRete)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Erreur injection faits: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚úÖ Injection termin√©e: %d faits inject√©s\n", len(factsForRete))
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üéØ PIPELINE MULTIFILES TERMIN√â\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// BuildNetworkFromIterativeParser construit un r√©seau RETE √† partir d'un parser it√©ratif existant
// Cette m√©thode est utile quand le parsing a d√©j√† √©t√© fait et qu'on veut juste construire le r√©seau
func (cp *ConstraintPipeline) BuildNetworkFromIterativeParser(parser *constraint.IterativeParser, storage Storage) (*ReteNetwork, error) <span class="cov0" title="0">{
        fmt.Printf("========================================\n")

        // Obtenir le programme combin√©
        program := parser.GetProgram()

        // Convertir au format RETE
        reteProgram := constraint.ConvertToReteProgram(program)
        resultMap, ok := reteProgram.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format programme RETE invalide: %T", reteProgram)
        }</span>

        // Extraire les composants
        <span class="cov0" title="0">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // Injection des faits dans le r√©seau
        if len(program.Facts) &gt; 0 </span><span class="cov0" title="0">{
                factsForRete := constraint.ConvertFactsToReteFormat(*program)

                err := network.SubmitFactsFromGrammar(factsForRete)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Erreur injection faits: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚úÖ Injection termin√©e: %d faits inject√©s\n", len(factsForRete))
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üéØ PIPELINE DEPUIS PARSER TERMIN√â\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// BuildNetworkFromConstraintFileWithFacts construit un r√©seau et soumet imm√©diatement des faits
func (cp *ConstraintPipeline) BuildNetworkFromConstraintFileWithFacts(constraintFile, factsFile string, storage Storage) (*ReteNetwork, []*Fact, error) <span class="cov0" title="0">{
        fmt.Printf("========================================\n")
        fmt.Printf("üìÅ Fichier contraintes: %s\n", constraintFile)
        fmt.Printf("üìÅ Fichier faits: %s\n", factsFile)

        // √âTAPE 1: Construire le r√©seau depuis le fichier de contraintes
        network, err := cp.BuildNetworkFromConstraintFile(constraintFile, storage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>

        // √âTAPE 2: Parser et soumettre les faits
        <span class="cov0" title="0">fmt.Printf("üìä Parsing des faits depuis %s\n", factsFile)

        parsedFacts, err := constraint.ParseFactsFile(factsFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("‚ùå Erreur parsing faits: %w", err)
        }</span>

        // Extraire les faits du programme pars√©
        <span class="cov0" title="0">factsList, err := constraint.ExtractFactsFromProgram(parsedFacts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("‚ùå Erreur extraction faits: %w", err)
        }</span>

        // Convertir et soumettre chaque fait
        <span class="cov0" title="0">submittedFacts := []*Fact{}
        for _, factMap := range factsList </span><span class="cov0" title="0">{
                // ExtractFactsFromProgram retourne des maps avec 'reteType' et tous les champs directement
                factID := getStringField(factMap, "id", "")
                factType := getStringField(factMap, "reteType", "") // Utiliser 'reteType' au lieu de 'type'

                if factID == "" || factType == "" </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è Fait ignor√©: id='%s', type='%s'\n", factID, factType)
                        continue</span>
                }

                // Les champs sont directement dans factMap (pas de sous-cl√© 'fields')
                <span class="cov0" title="0">fields := make(map[string]interface{})
                for key, value := range factMap </span><span class="cov0" title="0">{
                        // Exclure les m√©tadonn√©es RETE (id, reteType)
                        if key != "id" &amp;&amp; key != "reteType" </span><span class="cov0" title="0">{
                                fields[key] = value
                        }</span>
                }

                <span class="cov0" title="0">fact := &amp;Fact{
                        ID:     factID,
                        Type:   factType,
                        Fields: fields,
                }

                err := network.SubmitFact(fact)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è Erreur soumission fait %s: %v\n", factID, err)
                }</span>
                <span class="cov0" title="0">submittedFacts = append(submittedFacts, fact)</span>
        }

        <span class="cov0" title="0">fmt.Printf("‚úÖ %d faits soumis au r√©seau\n", len(submittedFacts))
        fmt.Printf("üéØ PIPELINE AVEC FAITS TERMIN√â\n")
        fmt.Printf("========================================\n\n")

        return network, submittedFacts, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package rete

import (
        "fmt"
        "strings"
)

// Node condition type constants
const (
        ConditionTypePassthrough = "passthrough"
        ConditionTypeSimple      = "simple"
        ConditionTypeExists      = "exists"
        ConditionTypeComparison  = "comparison"
)

// Node side constants for beta nodes
const (
        NodeSideLeft  = "left"
        NodeSideRight = "right"
)

// buildNetwork construit le r√©seau RETE √† partir des types et expressions pars√©s
func (cp *ConstraintPipeline) buildNetwork(storage Storage, types []interface{}, expressions []interface{}) (*ReteNetwork, error) <span class="cov8" title="1">{
        // Cr√©er le r√©seau
        network := NewReteNetwork(storage)

        // √âTAPE 1: Cr√©er les TypeNodes
        err := cp.createTypeNodes(network, types, storage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur cr√©ation TypeNodes: %w", err)
        }</span>

        // √âTAPE 2: Cr√©er les r√®gles (AlphaNodes, BetaNodes, TerminalNodes)
        <span class="cov8" title="1">err = cp.createRuleNodes(network, expressions, storage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur cr√©ation r√®gles: %w", err)
        }</span>

        <span class="cov8" title="1">return network, nil</span>
}

// createTypeNodes cr√©e les TypeNodes √† partir des d√©finitions de types
func (cp *ConstraintPipeline) createTypeNodes(network *ReteNetwork, types []interface{}, storage Storage) error <span class="cov8" title="1">{
        for _, typeInterface := range types </span><span class="cov8" title="1">{
                typeMap, ok := typeInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("format type invalide: %T", typeInterface)
                }</span>

                // Extraire le nom du type
                <span class="cov8" title="1">typeName, ok := typeMap["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("nom de type non trouv√©")
                }</span>

                // Cr√©er la d√©finition de type
                <span class="cov8" title="1">typeDef := cp.createTypeDefinition(typeName, typeMap)

                // Cr√©er le TypeNode
                typeNode := NewTypeNode(typeName, typeDef, storage)
                network.TypeNodes[typeName] = typeNode

                // CRUCIAL: Connecter le TypeNode au RootNode pour permettre la propagation des faits
                network.RootNode.AddChild(typeNode)

                fmt.Printf("   ‚úì TypeNode cr√©√©: %s\n", typeName)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createTypeDefinition cr√©e une d√©finition de type √† partir d'une map
func (cp *ConstraintPipeline) createTypeDefinition(typeName string, typeMap map[string]interface{}) TypeDefinition <span class="cov8" title="1">{
        typeDef := TypeDefinition{
                Type:   "type",
                Name:   typeName,
                Fields: []Field{},
        }

        // Extraire les champs
        fieldsData, hasFields := typeMap["fields"]
        if !hasFields </span><span class="cov0" title="0">{
                return typeDef
        }</span>

        <span class="cov8" title="1">fields, ok := fieldsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return typeDef
        }</span>

        <span class="cov8" title="1">for _, fieldInterface := range fields </span><span class="cov8" title="1">{
                fieldMap, ok := fieldInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">fieldName := getStringField(fieldMap, "name", "")
                fieldType := getStringField(fieldMap, "type", "")

                if fieldName != "" &amp;&amp; fieldType != "" </span><span class="cov8" title="1">{
                        typeDef.Fields = append(typeDef.Fields, Field{
                                Name: fieldName,
                                Type: fieldType,
                        })
                }</span>
        }

        <span class="cov8" title="1">return typeDef</span>
}

// createRuleNodes cr√©e les n≈ìuds de r√®gles (Alpha, Beta, Terminal) √† partir des expressions
func (cp *ConstraintPipeline) createRuleNodes(network *ReteNetwork, expressions []interface{}, storage Storage) error <span class="cov8" title="1">{
        for i, exprInterface := range expressions </span><span class="cov8" title="1">{
                exprMap, ok := exprInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("format expression invalide: %T", exprInterface)
                }</span>

                // G√©n√©rer un ID de r√®gle
                <span class="cov8" title="1">ruleID := fmt.Sprintf("rule_%d", i)

                // Cr√©er la r√®gle
                err := cp.createSingleRule(network, ruleID, exprMap, storage)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur cr√©ation r√®gle %s: %w", ruleID, err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("   ‚úì R√®gle cr√©√©e: %s\n", ruleID)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createSingleRule cr√©e une r√®gle unique (refactoris√©e en petites fonctions)
func (cp *ConstraintPipeline) createSingleRule(network *ReteNetwork, ruleID string, exprMap map[string]interface{}, storage Storage) error <span class="cov8" title="1">{
        // √âtape 1: Extraire l'action
        action, err := cp.extractActionFromExpression(exprMap, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // √âtape 2: Extraire et analyser les contraintes
        <span class="cov8" title="1">constraintsData, hasConstraints := exprMap["constraints"]
        var condition map[string]interface{}
        var hasAggregation bool

        if hasConstraints </span><span class="cov8" title="1">{
                // D√©tecter si c'est une agr√©gation
                hasAggregation = cp.detectAggregation(constraintsData)

                // Construire la condition appropri√©e
                condition, err = cp.buildConditionFromConstraints(constraintsData)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur construction condition pour r√®gle %s: %w", ruleID, err)
                }</span>
        } else<span class="cov0" title="0"> {
                condition = map[string]interface{}{
                        "type": ConditionTypeSimple,
                }
        }</span>

        // √âtape 3: Extraire les variables
        <span class="cov8" title="1">variables, variableNames, variableTypes := cp.extractVariablesFromExpression(exprMap)

        // √âtape 4: D√©terminer le type de r√®gle et la cr√©er
        ruleType := cp.determineRuleType(exprMap, len(variables), hasAggregation)
        cp.logRuleCreation(ruleType, ruleID, variableNames)

        switch ruleType </span>{
        case "exists":<span class="cov0" title="0">
                return cp.createExistsRule(network, ruleID, exprMap, condition, action, storage)</span>

        case "accumulator":<span class="cov8" title="1">
                aggInfo, err := cp.extractAggregationInfo(constraintsData)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ö†Ô∏è  Impossible d'extraire info agr√©gation: %v, utilisation JoinNode standard\n", err)
                        return cp.createJoinRule(network, ruleID, variables, variableNames, variableTypes, condition, action, storage)
                }</span>
                <span class="cov8" title="1">return cp.createAccumulatorRule(network, ruleID, variables, variableNames, variableTypes, aggInfo, action, storage)</span>

        case "join":<span class="cov8" title="1">
                return cp.createJoinRule(network, ruleID, variables, variableNames, variableTypes, condition, action, storage)</span>

        case "alpha":<span class="cov0" title="0">
                return cp.createAlphaRule(network, ruleID, variables, variableNames, variableTypes, condition, action, storage)</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("type de r√®gle inconnu: %s", ruleType)</span>
        }
}

// createAlphaRule cr√©e une r√®gle alpha simple avec une seule variable
func (cp *ConstraintPipeline) createAlphaRule(
        network *ReteNetwork,
        ruleID string,
        variables []map[string]interface{},
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Extraire les informations de la variable
        variableName, variableType := cp.getVariableInfo(variables, variableTypes)

        // Cr√©er l'AlphaNode avec son terminal
        return cp.createAlphaNodeWithTerminal(
                network,
                ruleID,
                condition,
                variableName,
                variableType,
                action,
                storage,
        )
}</span>

// createJoinRule cr√©e une r√®gle de jointure avec JoinNode
func (cp *ConstraintPipeline) createJoinRule(
        network *ReteNetwork,
        ruleID string,
        variables []map[string]interface{},
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        action *Action,
        storage Storage,
) error <span class="cov8" title="1">{
        // Cr√©er le n≈ìud terminal pour cette r√®gle
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // D√©l√©guer √† la fonction appropri√©e selon le nombre de variables
        if len(variableNames) &gt; 2 </span><span class="cov8" title="1">{
                return cp.createCascadeJoinRule(network, ruleID, variableNames, variableTypes, condition, terminalNode, storage)
        }</span>

        <span class="cov8" title="1">return cp.createBinaryJoinRule(network, ruleID, variableNames, variableTypes, condition, terminalNode, storage)</span>
}

// createExistsRule cr√©e une r√®gle EXISTS avec ExistsNode
func (cp *ConstraintPipeline) createExistsRule(
        network *ReteNetwork,
        ruleID string,
        exprMap map[string]interface{},
        condition map[string]interface{},
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Cr√©er le n≈ìud terminal pour cette r√®gle
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // Extraire les variables
        mainVariable, existsVariable, mainVarType, existsVarType, err := cp.extractExistsVariables(exprMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extraire les conditions d'EXISTS
        <span class="cov0" title="0">existsConditions, err := cp.extractExistsConditions(exprMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Cr√©er l'objet condition pour l'ExistsNode
        <span class="cov0" title="0">existsConditionObj := map[string]interface{}{
                "type":       ConditionTypeExists,
                "conditions": existsConditions,
        }

        // Cr√©er le mapping variable -&gt; type pour l'ExistsNode
        varTypes := make(map[string]string)
        varTypes[mainVariable] = mainVarType
        varTypes[existsVariable] = existsVarType

        // Cr√©er l'ExistsNode avec les vraies conditions
        existsNode := NewExistsNode(ruleID+"_exists", existsConditionObj, mainVariable, existsVariable, varTypes, storage)
        existsNode.AddChild(terminalNode)

        // Stocker l'ExistsNode dans les BetaNodes du r√©seau
        network.BetaNodes[existsNode.ID] = existsNode

        // Cr√©er des AlphaNodes pass-through pour les deux variables
        cp.connectExistsNodeToTypeNodes(network, ruleID, existsNode, mainVariable, mainVarType, existsVariable, existsVarType)

        fmt.Printf("   ‚úÖ ExistsNode %s cr√©√© pour %s EXISTS %s\n", existsNode.ID, mainVariable, existsVariable)
        return nil</span>
}

// extractExistsVariables extrait les variables d'une r√®gle EXISTS
func (cp *ConstraintPipeline) extractExistsVariables(exprMap map[string]interface{}) (string, string, string, string, error) <span class="cov0" title="0">{
        var mainVariable, existsVariable string
        var mainVarType, existsVarType string

        // Extraire la variable principale depuis "set"
        if setData, hasSet := exprMap["set"]; hasSet </span><span class="cov0" title="0">{
                if setMap, ok := setData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if varsData, hasVars := setMap["variables"]; hasVars </span><span class="cov0" title="0">{
                                if varsList, ok := varsData.([]interface{}); ok &amp;&amp; len(varsList) &gt; 0 </span><span class="cov0" title="0">{
                                        if varMap, ok := varsList[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if name, ok := varMap["name"].(string); ok </span><span class="cov0" title="0">{
                                                        mainVariable = name
                                                }</span>
                                                <span class="cov0" title="0">if dataType, ok := varMap["dataType"].(string); ok </span><span class="cov0" title="0">{
                                                        mainVarType = dataType
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Extraire la variable d'existence depuis les contraintes
        <span class="cov0" title="0">if constraintsData, hasConstraints := exprMap["constraints"]; hasConstraints </span><span class="cov0" title="0">{
                if constraintMap, ok := constraintsData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if variable, hasVar := constraintMap["variable"]; hasVar </span><span class="cov0" title="0">{
                                if varMap, ok := variable.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if name, ok := varMap["name"].(string); ok </span><span class="cov0" title="0">{
                                                existsVariable = name
                                        }</span>
                                        <span class="cov0" title="0">if dataType, ok := varMap["dataType"].(string); ok </span><span class="cov0" title="0">{
                                                existsVarType = dataType
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">if mainVariable == "" || existsVariable == "" </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("variables EXISTS non trouv√©es: main=%s, exists=%s", mainVariable, existsVariable)
        }</span>

        <span class="cov0" title="0">return mainVariable, existsVariable, mainVarType, existsVarType, nil</span>
}

// extractExistsConditions extrait les conditions d'une r√®gle EXISTS
func (cp *ConstraintPipeline) extractExistsConditions(exprMap map[string]interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var existsConditions []map[string]interface{}

        if constraintsData, hasConstraints := exprMap["constraints"]; hasConstraints </span><span class="cov0" title="0">{
                if constraintMap, ok := constraintsData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Essayer d'abord "condition" (au singulier)
                        if conditionData, hasCondition := constraintMap["condition"]; hasCondition </span><span class="cov0" title="0">{
                                if conditionObj, ok := conditionData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        existsConditions = append(existsConditions, conditionObj)
                                }</span>
                        }
                        // Puis essayer "conditions" (au pluriel) si pas trouv√©
                        <span class="cov0" title="0">if len(existsConditions) == 0 </span><span class="cov0" title="0">{
                                if conditionsData, hasConditions := constraintMap["conditions"]; hasConditions </span><span class="cov0" title="0">{
                                        if conditionsList, ok := conditionsData.([]interface{}); ok </span><span class="cov0" title="0">{
                                                for _, conditionData := range conditionsList </span><span class="cov0" title="0">{
                                                        if conditionObj, ok := conditionData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                                existsConditions = append(existsConditions, conditionObj)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return existsConditions, nil</span>
}

// connectExistsNodeToTypeNodes connecte un ExistsNode aux TypeNodes appropri√©s
func (cp *ConstraintPipeline) connectExistsNodeToTypeNodes(
        network *ReteNetwork,
        ruleID string,
        existsNode *ExistsNode,
        mainVariable string,
        mainVarType string,
        existsVariable string,
        existsVarType string,
) <span class="cov0" title="0">{
        // Connecter les variables principale et d'existence √† l'ExistsNode
        if mainVarType != "" </span><span class="cov0" title="0">{
                cp.connectTypeNodeToBetaNode(network, ruleID, mainVariable, mainVarType, existsNode, NodeSideLeft)
        }</span>
        <span class="cov0" title="0">if existsVarType != "" </span><span class="cov0" title="0">{
                cp.connectTypeNodeToBetaNode(network, ruleID, existsVariable, existsVarType, existsNode, NodeSideRight)
        }</span>
}

// createAccumulatorRule cr√©e une r√®gle avec AccumulatorNode
func (cp *ConstraintPipeline) createAccumulatorRule(
        network *ReteNetwork,
        ruleID string,
        variables []map[string]interface{},
        variableNames []string,
        variableTypes []string,
        aggInfo *AggregationInfo,
        action *Action,
        storage Storage,
) error <span class="cov8" title="1">{
        // Extraire la variable principale et son type depuis variables
        if len(variables) == 0 || len(variableTypes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune variable principale trouv√©e")
        }</span>

        <span class="cov8" title="1">mainVariable := variableNames[0]
        mainType := variableTypes[0]

        // Stocker dans aggInfo
        aggInfo.MainVariable = mainVariable
        aggInfo.MainType = mainType

        // Cr√©er le n≈ìud terminal
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // Cr√©er la condition de comparaison
        condition := map[string]interface{}{
                "type":     ConditionTypeComparison,
                "operator": aggInfo.Operator,
                "value":    aggInfo.Threshold,
        }

        // Cr√©er l'AccumulatorNode avec tous les param√®tres
        accumNode := NewAccumulatorNode(
                ruleID+"_accum",
                aggInfo.MainVariable, // "e"
                aggInfo.MainType,     // "Employee"
                aggInfo.AggVariable,  // "p"
                aggInfo.AggType,      // "Performance"
                aggInfo.Field,        // "score"
                aggInfo.JoinField,    // "employee_id"
                aggInfo.MainField,    // "id"
                aggInfo.Function,     // "AVG"
                condition,
                storage,
        )
        accumNode.AddChild(terminalNode)
        network.BetaNodes[accumNode.ID] = accumNode

        // Connecter les TypeNodes √† l'AccumulatorNode
        cp.connectTypeNodeToBetaNode(network, ruleID, mainVariable, mainType, accumNode, "")
        fmt.Printf("   ‚úì %s -&gt; PassthroughAlpha -&gt; AccumulatorNode[%s]\n", mainType, aggInfo.Function)

        cp.connectTypeNodeToBetaNode(network, ruleID, aggInfo.AggVariable, aggInfo.AggType, accumNode, "")
        fmt.Printf("   ‚úì %s -&gt; PassthroughAlpha -&gt; AccumulatorNode[%s] (pour agr√©gation)\n", aggInfo.AggType, aggInfo.Function)

        fmt.Printf("   ‚úÖ AccumulatorNode %s cr√©√© pour %s(%s.%s) %s %.2f\n",
                accumNode.ID, aggInfo.Function, aggInfo.AggVariable, aggInfo.Field, aggInfo.Operator, aggInfo.Threshold)
        return nil</span>
}

// createPassthroughAlphaNode creates a passthrough AlphaNode with optional side specification
func (cp *ConstraintPipeline) createPassthroughAlphaNode(ruleID, varName, side string, storage Storage) *AlphaNode <span class="cov8" title="1">{
        passCondition := map[string]interface{}{
                "type": ConditionTypePassthrough,
        }
        if side != "" </span><span class="cov8" title="1">{
                passCondition["side"] = side
        }</span>
        <span class="cov8" title="1">return NewAlphaNode(ruleID+"_pass_"+varName, passCondition, varName, storage)</span>
}

// connectTypeNodeToBetaNode connects a TypeNode to a BetaNode via a passthrough AlphaNode
func (cp *ConstraintPipeline) connectTypeNodeToBetaNode(
        network *ReteNetwork,
        ruleID string,
        varName string,
        varType string,
        betaNode Node,
        side string,
) <span class="cov8" title="1">{
        if typeNode, exists := network.TypeNodes[varType]; exists </span><span class="cov8" title="1">{
                alphaNode := cp.createPassthroughAlphaNode(ruleID, varName, side, network.Storage)
                typeNode.AddChild(alphaNode)
                alphaNode.AddChild(betaNode)

                sideInfo := ""
                if side != "" </span><span class="cov8" title="1">{
                        sideInfo = fmt.Sprintf(" (%s)", strings.ToUpper(side))
                }</span>
                <span class="cov8" title="1">fmt.Printf("   ‚úì %s -&gt; PassthroughAlpha_%s -&gt; %s%s\n", varType, varName, betaNode.GetID(), sideInfo)</span>
        }
}

// createBinaryJoinRule creates a simple binary join rule (2 variables)
func (cp *ConstraintPipeline) createBinaryJoinRule(
        network *ReteNetwork,
        ruleID string,
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        terminalNode *TerminalNode,
        storage Storage,
) error <span class="cov8" title="1">{
        leftVars := []string{variableNames[0]}
        rightVars := []string{variableNames[1]}

        // Cr√©er le mapping variable -&gt; type
        varTypes := make(map[string]string)
        for i, varName := range variableNames </span><span class="cov8" title="1">{
                varTypes[varName] = variableTypes[i]
        }</span>

        <span class="cov8" title="1">joinNode := NewJoinNode(ruleID+"_join", condition, leftVars, rightVars, varTypes, storage)
        joinNode.AddChild(terminalNode)

        // Stocker le JoinNode dans les BetaNodes du r√©seau
        network.BetaNodes[joinNode.ID] = joinNode

        // Connecter les TypeNodes via des AlphaNodes pass-through
        for i, varName := range variableNames </span><span class="cov8" title="1">{
                varType := variableTypes[i]
                if varType != "" </span><span class="cov8" title="1">{
                        side := NodeSideRight
                        if i == 0 </span><span class="cov8" title="1">{
                                side = NodeSideLeft
                        }</span>
                        <span class="cov8" title="1">cp.connectTypeNodeToBetaNode(network, ruleID, varName, varType, joinNode, side)</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚ö†Ô∏è Type vide pour variable %s\n", varName)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("   ‚úÖ JoinNode %s cr√©√© pour jointure %s\n", joinNode.ID, strings.Join(variableNames, " ‚ãà "))
        return nil</span>
}

// createCascadeJoinRule creates a cascade of join nodes for multi-variable rules (3+ variables)
func (cp *ConstraintPipeline) createCascadeJoinRule(
        network *ReteNetwork,
        ruleID string,
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        terminalNode *TerminalNode,
        storage Storage,
) error <span class="cov8" title="1">{
        fmt.Printf("   üìç R√®gle multi-variables d√©tect√©e (%d variables): %v\n", len(variableNames), variableNames)
        fmt.Printf("   üîß Construction d'architecture en cascade de JoinNodes\n")

        // Cr√©er le mapping variable -&gt; type
        varTypes := make(map[string]string)
        for i, varName := range variableNames </span><span class="cov8" title="1">{
                varTypes[varName] = variableTypes[i]
        }</span>

        // √âtape 1: Cr√©er le premier JoinNode pour les 2 premi√®res variables
        <span class="cov8" title="1">leftVars := []string{variableNames[0]}
        rightVars := []string{variableNames[1]}
        currentVarTypes := map[string]string{
                variableNames[0]: variableTypes[0],
                variableNames[1]: variableTypes[1],
        }

        currentJoinNode := NewJoinNode(
                fmt.Sprintf("%s_join_%d_%d", ruleID, 0, 1),
                condition,
                leftVars,
                rightVars,
                currentVarTypes,
                storage,
        )
        network.BetaNodes[currentJoinNode.ID] = currentJoinNode

        // Connecter les 2 premi√®res variables au premier JoinNode
        for i := 0; i &lt; 2; i++ </span><span class="cov8" title="1">{
                varName := variableNames[i]
                varType := variableTypes[i]
                side := NodeSideRight
                if i == 0 </span><span class="cov8" title="1">{
                        side = NodeSideLeft
                }</span>
                <span class="cov8" title="1">cp.connectTypeNodeToBetaNode(network, ruleID, varName, varType, currentJoinNode, side)
                fmt.Printf("   ‚úì Cascade level 1 connection\n")</span>
        }

        <span class="cov8" title="1">fmt.Printf("   ‚úÖ JoinNode cascade level 1: %s ‚ãà %s\n", variableNames[0], variableNames[1])

        // √âtape 2+: Joindre chaque variable suivante au r√©sultat pr√©c√©dent
        for i := 2; i &lt; len(variableNames); i++ </span><span class="cov8" title="1">{
                nextVarName := variableNames[i]
                nextVarType := variableTypes[i]

                // Variables accumul√©es jusqu'ici
                accumulatedVars := variableNames[0:i]
                accumulatedVarTypes := make(map[string]string)
                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                        accumulatedVarTypes[variableNames[j]] = variableTypes[j]
                }</span>
                <span class="cov8" title="1">accumulatedVarTypes[nextVarName] = nextVarType

                // Cr√©er le prochain JoinNode
                nextJoinNode := NewJoinNode(
                        fmt.Sprintf("%s_join_%d", ruleID, i),
                        condition,
                        accumulatedVars,
                        []string{nextVarName},
                        accumulatedVarTypes,
                        storage,
                )
                network.BetaNodes[nextJoinNode.ID] = nextJoinNode

                // Connecter le JoinNode pr√©c√©dent au nouveau JoinNode
                currentJoinNode.AddChild(nextJoinNode)

                // Connecter la nouvelle variable au JoinNode
                cp.connectTypeNodeToBetaNode(network, ruleID, nextVarName, nextVarType, nextJoinNode, NodeSideRight)
                fmt.Printf("   ‚úì Cascade level %d connection\n", i)

                fmt.Printf("   ‚úÖ JoinNode cascade level %d: (%s) ‚ãà %s\n", i, strings.Join(accumulatedVars, " ‚ãà "), nextVarName)

                currentJoinNode = nextJoinNode</span>
        }

        // Connecter le dernier JoinNode au terminal
        <span class="cov8" title="1">currentJoinNode.AddChild(terminalNode)
        fmt.Printf("   ‚úÖ Architecture en cascade compl√®te: %s\n", strings.Join(variableNames, " ‚ãà "))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package rete

import (
        "fmt"
)

// createAction cr√©e une action RETE √† partir d'une map d'action pars√©e
func (cp *ConstraintPipeline) createAction(actionMap map[string]interface{}) *Action <span class="cov8" title="1">{
        actionType := getStringField(actionMap, "type", "print")

        // Extraire le job depuis l'action
        jobData, hasJob := actionMap["job"]
        if !hasJob </span><span class="cov0" title="0">{
                // Fallback: action simple sans job (ne devrait pas arriver avec le nouveau parser)
                return &amp;Action{
                        Type: actionType,
                        Job: JobCall{
                                Name: actionType,
                                Args: []interface{}{},
                        },
                }
        }</span>

        <span class="cov8" title="1">jobMap, ok := jobData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;Action{
                        Type: actionType,
                        Job: JobCall{
                                Name: actionType,
                                Args: []interface{}{},
                        },
                }
        }</span>

        // Extraire le nom du job
        <span class="cov8" title="1">jobName := getStringField(jobMap, "name", actionType)

        action := &amp;Action{
                Type: actionType,
                Job: JobCall{
                        Name: jobName,
                        Args: []interface{}{},
                },
        }

        // Extraire les arguments du job (pas de l'action)
        if argsData, hasArgs := jobMap["args"]; hasArgs </span><span class="cov8" title="1">{
                if argsList, ok := argsData.([]interface{}); ok </span><span class="cov8" title="1">{
                        action.Job.Args = argsList
                }</span>
        }

        <span class="cov8" title="1">return action</span>
}

// buildConditionFromConstraints construit une condition appropri√©e √† partir de contraintes
func (cp *ConstraintPipeline) buildConditionFromConstraints(constraintsData interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        if constraintsData == nil </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "type": "simple",
                }, nil
        }</span>

        // V√©rifier si c'est une agr√©gation
        <span class="cov8" title="1">if cp.detectAggregation(constraintsData) </span><span class="cov8" title="1">{
                return map[string]interface{}{
                        "type": "passthrough",
                }, nil
        }</span>

        // Analyser les contraintes pour d√©tecter les n√©gations
        <span class="cov8" title="1">isNegation, negatedCondition, err := cp.analyzeConstraints(constraintsData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur analyse contraintes: %w", err)
        }</span>

        <span class="cov8" title="1">if isNegation </span><span class="cov0" title="0">{
                fmt.Printf("   üö´ D√©tection contrainte NOT - cr√©ation d'un AlphaNode de n√©gation\n")
                return map[string]interface{}{
                        "type":      "negation",
                        "negated":   true,
                        "condition": negatedCondition,
                }, nil
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "type":       "constraint",
                "constraint": constraintsData,
        }, nil</span>
}

// extractActionFromExpression extrait l'action d'une expression de r√®gle
func (cp *ConstraintPipeline) extractActionFromExpression(exprMap map[string]interface{}, ruleID string) (*Action, error) <span class="cov8" title="1">{
        actionData, hasAction := exprMap["action"]
        if !hasAction </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aucune action trouv√©e pour r√®gle %s", ruleID)
        }</span>

        <span class="cov8" title="1">actionMap, ok := actionData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("format action invalide pour r√®gle %s: %T", ruleID, actionData)
        }</span>

        <span class="cov8" title="1">return cp.createAction(actionMap), nil</span>
}

// determineRuleType d√©termine le type de r√®gle (alpha, join, exists, accumulator)
// Retourne (ruleType string, shouldProcess bool)
func (cp *ConstraintPipeline) determineRuleType(
        exprMap map[string]interface{},
        variableCount int,
        hasAggregation bool,
) string <span class="cov8" title="1">{
        // V√©rifier si c'est une contrainte EXISTS
        if constraintsData, hasConstraints := exprMap["constraints"]; hasConstraints </span><span class="cov8" title="1">{
                if cp.isExistsConstraint(constraintsData) </span><span class="cov0" title="0">{
                        return "exists"
                }</span>
        }

        // Si c'est une agr√©gation
        <span class="cov8" title="1">if hasAggregation </span><span class="cov8" title="1">{
                return "accumulator"
        }</span>

        // Si plus d'une variable, c'est une jointure
        <span class="cov8" title="1">if variableCount &gt; 1 </span><span class="cov8" title="1">{
                return "join"
        }</span>

        // Sinon, c'est une r√®gle alpha simple
        <span class="cov0" title="0">return "alpha"</span>
}

// getVariableInfo extrait les informations de la premi√®re variable
// Retourne (variableName, variableType)
func (cp *ConstraintPipeline) getVariableInfo(variables []map[string]interface{}, variableTypes []string) (string, string) <span class="cov0" title="0">{
        variableName := "p" // d√©faut
        variableType := ""

        if len(variables) &gt; 0 </span><span class="cov0" title="0">{
                if name, ok := variables[0]["name"].(string); ok </span><span class="cov0" title="0">{
                        variableName = name
                }</span>
                <span class="cov0" title="0">if len(variableTypes) &gt; 0 </span><span class="cov0" title="0">{
                        variableType = variableTypes[0]
                }</span>
        }

        <span class="cov0" title="0">return variableName, variableType</span>
}

// connectAlphaNodeToTypeNode connecte un AlphaNode au TypeNode appropri√©
func (cp *ConstraintPipeline) connectAlphaNodeToTypeNode(
        network *ReteNetwork,
        alphaNode *AlphaNode,
        variableType string,
        variableName string,
) <span class="cov0" title="0">{
        if variableType != "" </span><span class="cov0" title="0">{
                // Les TypeNodes sont stock√©s avec leur nom direct, pas avec "type_" pr√©fixe
                if typeNode, exists := network.TypeNodes[variableType]; exists </span><span class="cov0" title="0">{
                        typeNode.AddChild(alphaNode)
                        fmt.Printf("   ‚úì AlphaNode %s connect√© au TypeNode %s\n", alphaNode.ID, variableType)
                        return
                }</span>
                <span class="cov0" title="0">fmt.Printf("   ‚ö†Ô∏è  TypeNode %s non trouv√© pour variable %s\n", variableType, variableName)</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("   ‚ö†Ô∏è  Type de variable non trouv√© pour %s, fallback\n", variableName)
        }</span>

        // Fallback: connecter au premier type node trouv√©
        <span class="cov0" title="0">for _, typeNode := range network.TypeNodes </span><span class="cov0" title="0">{
                typeNode.AddChild(alphaNode)
                break</span>
        }
}

// createAlphaNodeWithTerminal cr√©e un AlphaNode et son n≈ìud terminal associ√©
func (cp *ConstraintPipeline) createAlphaNodeWithTerminal(
        network *ReteNetwork,
        ruleID string,
        condition map[string]interface{},
        variableName string,
        variableType string,
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Cr√©er un n≈ìud Alpha avec la condition appropri√©e
        alphaNode := NewAlphaNode(ruleID+"_alpha", condition, variableName, storage)

        // Connecter au type node appropri√©
        cp.connectAlphaNodeToTypeNode(network, alphaNode, variableType, variableName)

        network.AlphaNodes[alphaNode.ID] = alphaNode

        // Cr√©er le terminal
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        alphaNode.AddChild(terminalNode)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        if condition["type"] == "negation" </span><span class="cov0" title="0">{
                fmt.Printf("   ‚úì AlphaNode de n√©gation cr√©√©: %s -&gt; %s\n", alphaNode.ID, terminalNode.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// logRuleCreation affiche un message de log pour la cr√©ation d'une r√®gle
func (cp *ConstraintPipeline) logRuleCreation(ruleType string, ruleID string, variableNames []string) <span class="cov8" title="1">{
        switch ruleType </span>{
        case "join":<span class="cov8" title="1">
                fmt.Printf("   üìç R√®gle multi-variables d√©tect√©e (%d variables): %v\n", len(variableNames), variableNames)</span>
        case "exists":<span class="cov0" title="0">
                fmt.Printf("   üîç R√®gle EXISTS d√©tect√©e pour: %s\n", ruleID)</span>
        case "accumulator":<span class="cov8" title="1">
                fmt.Printf("   üìä R√®gle d'agr√©gation d√©tect√©e pour: %s\n", ruleID)</span>
        case "alpha":<span class="cov0" title="0">
                fmt.Printf("   ‚úì R√®gle alpha simple cr√©√©e pour: %s\n", ruleID)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package rete

import (
        "fmt"
        "strings"
)

// extractComponents extrait les types et expressions d'un AST pars√©
// Retourne (types, expressions, error)
func (cp *ConstraintPipeline) extractComponents(resultMap map[string]interface{}) ([]interface{}, []interface{}, error) <span class="cov8" title="1">{
        // Extraire les types
        typesData, hasTypes := resultMap["types"]
        if !hasTypes </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("aucun type trouv√© dans l'AST")
        }</span>

        <span class="cov8" title="1">types, ok := typesData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("format types invalide: %T", typesData)
        }</span>

        // Extraire les expressions
        <span class="cov8" title="1">expressionsData, hasExpressions := resultMap["expressions"]
        if !hasExpressions </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("aucune expression trouv√©e dans l'AST")
        }</span>

        <span class="cov8" title="1">expressions, ok := expressionsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("format expressions invalide: %T", expressionsData)
        }</span>

        <span class="cov8" title="1">return types, expressions, nil</span>
}

// analyzeConstraints analyse les contraintes pour d√©tecter les n√©gations
// Retourne (isNegation, negatedCondition, error)
func (cp *ConstraintPipeline) analyzeConstraints(constraints interface{}) (bool, interface{}, error) <span class="cov8" title="1">{
        constraintMap, ok := constraints.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return false, constraints, nil
        }</span>

        // D√©tecter contrainte NOT
        <span class="cov8" title="1">if constraintType, exists := constraintMap["type"].(string); exists </span><span class="cov8" title="1">{
                if constraintType == "notConstraint" </span><span class="cov0" title="0">{
                        // Extraire la contrainte ni√©e
                        if negatedConstraint, hasNegated := constraintMap["constraint"]; hasNegated </span><span class="cov0" title="0">{
                                return true, negatedConstraint, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return false, constraints, nil</span>
}

// extractAggregationInfo extrait les informations d'agr√©gation d'une contrainte
func (cp *ConstraintPipeline) extractAggregationInfo(constraintsData interface{}) (*AggregationInfo, error) <span class="cov8" title="1">{
        constraintMap, ok := constraintsData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constraints n'est pas un map: %T", constraintsData)
        }</span>

        <span class="cov8" title="1">aggInfo := &amp;AggregationInfo{}

        // Extraire la fonction d'agr√©gation (AVG, SUM, COUNT, etc.)
        if function, ok := constraintMap["function"].(string); ok </span><span class="cov8" title="1">{
                aggInfo.Function = function
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("fonction d'agr√©gation non trouv√©e")
        }</span>

        // Extraire l'op√©rateur de comparaison
        <span class="cov8" title="1">if operator, ok := constraintMap["operator"].(string); ok </span><span class="cov8" title="1">{
                aggInfo.Operator = operator
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("op√©rateur de comparaison non trouv√©")
        }</span>

        // Extraire le seuil (threshold) depuis constraintMap["threshold"]["value"]
        <span class="cov8" title="1">if thresholdData, ok := constraintMap["threshold"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if threshold, ok := thresholdData["value"].(float64); ok </span><span class="cov8" title="1">{
                        aggInfo.Threshold = threshold
                }</span> else<span class="cov0" title="0"> if thresholdInt, ok := thresholdData["value"].(int); ok </span><span class="cov0" title="0">{
                        aggInfo.Threshold = float64(thresholdInt)
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("valeur de seuil non trouv√©e ou invalide")
                }</span>
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("seuil manquant")
        }</span>

        // Extraire la condition de jointure compl√®te
        <span class="cov8" title="1">if joinCond, ok := constraintMap["join"]; ok </span><span class="cov0" title="0">{
                aggInfo.JoinCondition = joinCond
        }</span>

        // Extraire la variable √† agr√©ger depuis constraintMap["variable"]
        <span class="cov8" title="1">if variableData, ok := constraintMap["variable"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if aggVar, ok := variableData["name"].(string); ok </span><span class="cov8" title="1">{
                        aggInfo.AggVariable = aggVar
                }</span>
                <span class="cov8" title="1">if aggType, ok := variableData["dataType"].(string); ok </span><span class="cov8" title="1">{
                        aggInfo.AggType = aggType
                }</span>
        }

        // Extraire le champ √† agr√©ger
        <span class="cov8" title="1">if field, ok := constraintMap["field"].(string); ok </span><span class="cov8" title="1">{
                aggInfo.Field = field
        }</span>

        // Extraire les informations de jointure depuis la condition
        <span class="cov8" title="1">if conditionData, ok := constraintMap["condition"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                aggInfo.JoinCondition = conditionData

                // Extraire les champs de jointure depuis la condition de type comparison
                if condType, ok := conditionData["type"].(string); ok &amp;&amp; condType == "comparison" </span><span class="cov8" title="1">{
                        // Left side: p.employee_id
                        if leftData, ok := conditionData["left"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if leftType, ok := leftData["type"].(string); ok &amp;&amp; leftType == "fieldAccess" </span><span class="cov8" title="1">{
                                        if joinField, ok := leftData["field"].(string); ok </span><span class="cov8" title="1">{
                                                aggInfo.JoinField = joinField
                                        }</span>
                                }
                        }

                        // Right side: e.id
                        <span class="cov8" title="1">if rightData, ok := conditionData["right"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if rightType, ok := rightData["type"].(string); ok &amp;&amp; rightType == "fieldAccess" </span><span class="cov8" title="1">{
                                        if mainField, ok := rightData["field"].(string); ok </span><span class="cov8" title="1">{
                                                aggInfo.MainField = mainField
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return aggInfo, nil</span>
}

// extractVariablesFromExpression extrait les variables d'une expression
// Retourne (variables, variableNames, variableTypes)
func (cp *ConstraintPipeline) extractVariablesFromExpression(exprMap map[string]interface{}) ([]map[string]interface{}, []string, []string) <span class="cov8" title="1">{
        variables := []map[string]interface{}{}
        variableNames := []string{}
        variableTypes := []string{}

        if setData, hasSet := exprMap["set"]; hasSet </span><span class="cov8" title="1">{
                if setMap, ok := setData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if varsData, hasVars := setMap["variables"]; hasVars </span><span class="cov8" title="1">{
                                if varsList, ok := varsData.([]interface{}); ok &amp;&amp; len(varsList) &gt; 0 </span><span class="cov8" title="1">{
                                        // Extraire toutes les variables
                                        for _, varInterface := range varsList </span><span class="cov8" title="1">{
                                                if varMap, ok := varInterface.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                                        variables = append(variables, varMap)

                                                        if name, ok := varMap["name"].(string); ok </span><span class="cov8" title="1">{
                                                                variableNames = append(variableNames, name)
                                                        }</span>

                                                        // Extraire le type de la variable
                                                        <span class="cov8" title="1">var varType string
                                                        if dataType, ok := varMap["dataType"].(string); ok </span><span class="cov8" title="1">{
                                                                varType = dataType
                                                        }</span> else<span class="cov0" title="0"> if typeField, ok := varMap["type"].(string); ok </span><span class="cov0" title="0">{
                                                                varType = typeField
                                                        }</span>
                                                        <span class="cov8" title="1">variableTypes = append(variableTypes, varType)</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return variables, variableNames, variableTypes</span>
}

// detectAggregation d√©tecte si une contrainte contient une agr√©gation
func (cp *ConstraintPipeline) detectAggregation(constraintsData interface{}) bool <span class="cov8" title="1">{
        if constraintStr := fmt.Sprintf("%v", constraintsData); constraintStr != "" </span><span class="cov8" title="1">{
                return strings.Contains(constraintStr, "AVG") ||
                        strings.Contains(constraintStr, "SUM") ||
                        strings.Contains(constraintStr, "COUNT") ||
                        strings.Contains(constraintStr, "MIN") ||
                        strings.Contains(constraintStr, "MAX") ||
                        strings.Contains(constraintStr, "ACCUMULATE")
        }</span>
        <span class="cov0" title="0">return false</span>
}

// isExistsConstraint v√©rifie si une contrainte est de type EXISTS
func (cp *ConstraintPipeline) isExistsConstraint(constraintsData interface{}) bool <span class="cov8" title="1">{
        if constraintMap, ok := constraintsData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if constraintType, exists := constraintMap["type"].(string); exists &amp;&amp; constraintType == "existsConstraint" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// getStringField extrait un champ string d'une map avec une valeur par d√©faut
func getStringField(m map[string]interface{}, key, defaultValue string) string <span class="cov8" title="1">{
        if value, ok := m[key].(string); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package rete

import (
        "fmt"
)

// validateNetwork valide qu'un r√©seau RETE est bien form√©
func (cp *ConstraintPipeline) validateNetwork(network *ReteNetwork) error <span class="cov8" title="1">{
        if network == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("r√©seau est nil")
        }</span>

        // V√©rifier qu'on a au moins un TypeNode
        <span class="cov8" title="1">if len(network.TypeNodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aucun TypeNode dans le r√©seau")
        }</span>

        // V√©rifier qu'on a au moins un n≈ìud terminal
        <span class="cov8" title="1">if len(network.TerminalNodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aucun n≈ìud terminal dans le r√©seau")
        }</span>

        // V√©rifier que les n≈ìuds terminaux ont des actions
        <span class="cov8" title="1">for id, terminal := range network.TerminalNodes </span><span class="cov8" title="1">{
                if terminal.Action == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("n≈ìud terminal %s sans action", id)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateAction valide qu'une action est bien form√©e
func (cp *ConstraintPipeline) validateAction(actionMap map[string]interface{}) error <span class="cov0" title="0">{
        if actionMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("action map est nil")
        }</span>

        // V√©rifier qu'on a un type d'action
        <span class="cov0" title="0">actionType, hasType := actionMap["type"].(string)
        if !hasType </span><span class="cov0" title="0">{
                return fmt.Errorf("type d'action non trouv√©")
        }</span>

        // V√©rifier selon le type d'action
        <span class="cov0" title="0">switch actionType </span>{
        case "print", "PRINT":<span class="cov0" title="0">
                // L'action print doit avoir un message ou une expression
                if _, hasMsg := actionMap["message"]; !hasMsg </span><span class="cov0" title="0">{
                        if _, hasExpr := actionMap["expression"]; !hasExpr </span><span class="cov0" title="0">{
                                return fmt.Errorf("action print sans message ni expression")
                        }</span>
                }
        case "assert", "ASSERT":<span class="cov0" title="0">
                // L'action assert doit avoir un fait √† ins√©rer
                if _, hasFact := actionMap["fact"]; !hasFact </span><span class="cov0" title="0">{
                        return fmt.Errorf("action assert sans fait")
                }</span>
        case "retract", "RETRACT":<span class="cov0" title="0">
                // L'action retract doit avoir un fait √† retirer
                if _, hasFact := actionMap["fact"]; !hasFact </span><span class="cov0" title="0">{
                        return fmt.Errorf("action retract sans fait")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateRuleExpression valide qu'une expression de r√®gle est bien form√©e
func (cp *ConstraintPipeline) validateRuleExpression(exprMap map[string]interface{}) error <span class="cov0" title="0">{
        if exprMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("expression map est nil")
        }</span>

        // V√©rifier qu'on a une action
        <span class="cov0" title="0">actionData, hasAction := exprMap["action"]
        if !hasAction </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune action trouv√©e dans la r√®gle")
        }</span>

        <span class="cov0" title="0">actionMap, ok := actionData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("format action invalide: %T", actionData)
        }</span>

        // Valider l'action
        <span class="cov0" title="0">if err := cp.validateAction(actionMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("action invalide: %w", err)
        }</span>

        // V√©rifier qu'on a des variables (set)
        <span class="cov0" title="0">if _, hasSet := exprMap["set"]; !hasSet </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune variable (set) trouv√©e dans la r√®gle")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateTypeDefinition valide qu'une d√©finition de type est bien form√©e
func (cp *ConstraintPipeline) validateTypeDefinition(typeName string, typeMap map[string]interface{}) error <span class="cov0" title="0">{
        if typeName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("nom de type vide")
        }</span>

        <span class="cov0" title="0">if typeMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("d√©finition de type nil pour %s", typeName)
        }</span>

        // V√©rifier qu'on a des champs
        <span class="cov0" title="0">fieldsData, hasFields := typeMap["fields"]
        if !hasFields </span><span class="cov0" title="0">{
                return fmt.Errorf("type %s sans champs", typeName)
        }</span>

        <span class="cov0" title="0">fields, ok := fieldsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("format fields invalide pour type %s: %T", typeName, fieldsData)
        }</span>

        <span class="cov0" title="0">if len(fields) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("type %s avec liste de champs vide", typeName)
        }</span>

        // V√©rifier chaque champ
        <span class="cov0" title="0">for i, fieldInterface := range fields </span><span class="cov0" title="0">{
                fieldMap, ok := fieldInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ %d du type %s invalide: %T", i, typeName, fieldInterface)
                }</span>

                // V√©rifier qu'on a un nom de champ
                <span class="cov0" title="0">fieldName, hasName := fieldMap["name"].(string)
                if !hasName || fieldName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ %d du type %s sans nom", i, typeName)
                }</span>

                // V√©rifier qu'on a un type de champ
                <span class="cov0" title="0">fieldType, hasType := fieldMap["type"].(string)
                if !hasType || fieldType == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ %s du type %s sans type", fieldName, typeName)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateAggregationInfo valide qu'une information d'agr√©gation est compl√®te
func (cp *ConstraintPipeline) validateAggregationInfo(aggInfo *AggregationInfo) error <span class="cov0" title="0">{
        if aggInfo == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("information d'agr√©gation nil")
        }</span>

        // V√©rifier la fonction
        <span class="cov0" title="0">if aggInfo.Function == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("fonction d'agr√©gation vide")
        }</span>

        <span class="cov0" title="0">validFunctions := map[string]bool{
                "AVG": true, "SUM": true, "COUNT": true,
                "MIN": true, "MAX": true, "ACCUMULATE": true,
        }
        if !validFunctions[aggInfo.Function] </span><span class="cov0" title="0">{
                return fmt.Errorf("fonction d'agr√©gation invalide: %s", aggInfo.Function)
        }</span>

        // V√©rifier l'op√©rateur
        <span class="cov0" title="0">if aggInfo.Operator == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("op√©rateur de comparaison vide")
        }</span>

        <span class="cov0" title="0">validOperators := map[string]bool{
                "&gt;=": true, "&lt;=": true, "&gt;": true, "&lt;": true, "==": true, "!=": true,
        }
        if !validOperators[aggInfo.Operator] </span><span class="cov0" title="0">{
                return fmt.Errorf("op√©rateur de comparaison invalide: %s", aggInfo.Operator)
        }</span>

        // V√©rifier les champs de jointure si pr√©sents
        <span class="cov0" title="0">if aggInfo.JoinField != "" &amp;&amp; aggInfo.MainField == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("champ de jointure principal manquant")
        }</span>
        <span class="cov0" title="0">if aggInfo.MainField != "" &amp;&amp; aggInfo.JoinField == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("champ de jointure agr√©g√© manquant")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateJoinCondition valide qu'une condition de jointure est bien form√©e
func (cp *ConstraintPipeline) validateJoinCondition(condition map[string]interface{}) error <span class="cov0" title="0">{
        if condition == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("condition de jointure nil")
        }</span>

        <span class="cov0" title="0">condType, hasType := condition["type"].(string)
        if !hasType </span><span class="cov0" title="0">{
                return fmt.Errorf("type de condition non sp√©cifi√©")
        }</span>

        <span class="cov0" title="0">switch condType </span>{
        case "simple", "passthrough":<span class="cov0" title="0">
                // Conditions simples, pas de validation suppl√©mentaire
                return nil</span>
        case "constraint":<span class="cov0" title="0">
                // Doit avoir une contrainte
                if _, hasConstraint := condition["constraint"]; !hasConstraint </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition de type constraint sans contrainte")
                }</span>
        case "negation":<span class="cov0" title="0">
                // Doit avoir une condition ni√©e
                if _, hasNegated := condition["negated"]; !hasNegated </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition de type negation sans flag negated")
                }</span>
                <span class="cov0" title="0">if _, hasCondition := condition["condition"]; !hasCondition </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition de type negation sans condition ni√©e")
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("type de condition inconnu: %s", condType)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// ASTConverter convertit l'AST du parser constraint vers les types RETE
type ASTConverter struct{}

// NewASTConverter cr√©e un nouveau convertisseur AST
func NewASTConverter() *ASTConverter <span class="cov0" title="0">{
        return &amp;ASTConverter{}
}</span>

// ConvertProgram convertit un constraint.Program vers un rete.Program
func (ac *ASTConverter) ConvertProgram(constraintProgram interface{}) (*Program, error) <span class="cov0" title="0">{
        // Essayer de caster vers constraint.Program
        program, ok := constraintProgram.(*constraint.Program)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type de programme AST non reconnu")
        }</span>

        <span class="cov0" title="0">reteProgram := &amp;Program{
                Types:       make([]TypeDefinition, len(program.Types)),
                Expressions: make([]Expression, len(program.Expressions)),
        }

        // Convertir les types
        for i, constraintType := range program.Types </span><span class="cov0" title="0">{
                reteProgram.Types[i] = TypeDefinition{
                        Type:   constraintType.Type,
                        Name:   constraintType.Name,
                        Fields: ac.convertFields(constraintType.Fields),
                }
        }</span>

        // Convertir les expressions
        <span class="cov0" title="0">for i, constraintExpr := range program.Expressions </span><span class="cov0" title="0">{
                reteExpr, err := ac.convertExpression(constraintExpr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur conversion expression %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">reteProgram.Expressions[i] = *reteExpr</span>
        }

        <span class="cov0" title="0">return reteProgram, nil</span>
}

// convertFields convertit les champs
func (ac *ASTConverter) convertFields(constraintFields []constraint.Field) []Field <span class="cov0" title="0">{
        fields := make([]Field, len(constraintFields))
        for i, field := range constraintFields </span><span class="cov0" title="0">{
                fields[i] = Field{
                        Name: field.Name,
                        Type: field.Type,
                }
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// convertExpression convertit une expression
func (ac *ASTConverter) convertExpression(constraintExpr constraint.Expression) (*Expression, error) <span class="cov0" title="0">{
        expr := &amp;Expression{
                Type:        constraintExpr.Type,
                Constraints: constraintExpr.Constraints,
        }

        // Convertir le set
        expr.Set = Set{
                Type:      constraintExpr.Set.Type,
                Variables: ac.convertTypedVariables(constraintExpr.Set.Variables),
        }

        // Convertir l'action (maintenant obligatoire)
        if constraintExpr.Action != nil </span><span class="cov0" title="0">{
                action, err := ac.convertAction(*constraintExpr.Action)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur conversion action: %w", err)
                }</span>
                <span class="cov0" title="0">expr.Action = action</span>
        } else<span class="cov0" title="0"> {
                // Cette condition ne devrait plus arriver avec la nouvelle grammaire
                return nil, fmt.Errorf("action manquante: chaque r√®gle doit avoir une action d√©finie")
        }</span>

        <span class="cov0" title="0">return expr, nil</span>
}

// convertTypedVariables convertit les variables typ√©es
func (ac *ASTConverter) convertTypedVariables(constraintVars []constraint.TypedVariable) []TypedVariable <span class="cov0" title="0">{
        vars := make([]TypedVariable, len(constraintVars))
        for i, variable := range constraintVars </span><span class="cov0" title="0">{
                vars[i] = TypedVariable{
                        Type:     variable.Type,
                        Name:     variable.Name,
                        DataType: variable.DataType,
                }
        }</span>
        <span class="cov0" title="0">return vars</span>
}

// convertAction convertit une action
func (ac *ASTConverter) convertAction(constraintAction constraint.Action) (*Action, error) <span class="cov0" title="0">{
        action := &amp;Action{
                Type: constraintAction.Type,
                Job: JobCall{
                        Type: constraintAction.Job.Type,
                        Name: constraintAction.Job.Name,
                        Args: constraintAction.Job.Args,
                },
        }
        return action, nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package rete

// AlphaConditionEvaluator √©value les conditions Alpha sur les faits.
// Cette structure a √©t√© refactoris√©e en plusieurs fichiers pour am√©liorer la lisibilit√©:
//   - evaluator_expressions.go: √âvaluation des expressions binaires et logiques
//   - evaluator_constraints.go: √âvaluation des contraintes
//   - evaluator_values.go: √âvaluation des valeurs, champs et variables
//   - evaluator_comparisons.go: Op√©rations de comparaison
//   - evaluator_operators.go: Op√©rateurs arithm√©tiques, cha√Ænes et listes
//   - evaluator_functions.go: Fonctions int√©gr√©es (LENGTH, UPPER, ABS, etc.)
type AlphaConditionEvaluator struct {
        variableBindings map[string]*Fact
        partialEvalMode  bool // Mode d'√©valuation partielle pour les jointures en cascade
}

// NewAlphaConditionEvaluator cr√©e un nouvel √©valuateur de conditions
func NewAlphaConditionEvaluator() *AlphaConditionEvaluator <span class="cov8" title="1">{
        return &amp;AlphaConditionEvaluator{
                variableBindings: make(map[string]*Fact),
                partialEvalMode:  false,
        }
}</span>

// EvaluateCondition √©value une condition sur un fait.
// Il s'agit du point d'entr√©e principal pour l'√©valuation des conditions Alpha.
//
// Parameters:
//   - condition: La condition √† √©valuer (peut √™tre une map, BinaryOperation, LogicalExpression, etc.)
//   - fact: Le fait sur lequel √©valuer la condition
//   - variableName: Le nom de la variable √† lier au fait (optionnel)
//
// Returns:
//   - bool: true si la condition est satisfaite, false sinon
//   - error: Une erreur si l'√©valuation √©choue
func (e *AlphaConditionEvaluator) EvaluateCondition(condition interface{}, fact *Fact, variableName string) (bool, error) <span class="cov0" title="0">{
        // Si c'est un passthrough (agr√©gation), laisser passer tous les faits
        if condMap, ok := condition.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if condType, exists := condMap["type"].(string); exists &amp;&amp; condType == "passthrough" </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        // Lier la variable au fait pour l'√©valuation
        <span class="cov0" title="0">if variableName != "" </span><span class="cov0" title="0">{
                e.variableBindings[variableName] = fact
        }</span>

        <span class="cov0" title="0">return e.evaluateExpression(condition)</span>
}

// ClearBindings efface les liaisons de variables.
// Utilis√© pour r√©initialiser l'√©valuateur entre diff√©rentes √©valuations.
func (e *AlphaConditionEvaluator) ClearBindings() <span class="cov0" title="0">{
        e.variableBindings = make(map[string]*Fact)
}</span>

// SetPartialEvalMode active ou d√©sactive le mode d'√©valuation partielle.
// En mode partiel, les variables non li√©es renvoient true au lieu d'une erreur.
// Utilis√© pour les jointures en cascade o√π toutes les variables ne sont pas encore disponibles.
func (e *AlphaConditionEvaluator) SetPartialEvalMode(enabled bool) <span class="cov8" title="1">{
        e.partialEvalMode = enabled
}</span>

// GetBindings retourne les liaisons actuelles de variables.
// Utile pour le d√©bogage et l'inspection de l'√©tat de l'√©valuateur.
func (e *AlphaConditionEvaluator) GetBindings() map[string]*Fact <span class="cov0" title="0">{
        return e.variableBindings
}</span>

// Note: Les m√©thodes d'√©valuation internes (evaluateExpression, evaluateValue, etc.)
// sont maintenant r√©parties dans les fichiers suivants pour am√©liorer la maintenabilit√©:
//
// evaluator_expressions.go:
//   - evaluateExpression
//   - evaluateMapExpression
//   - evaluateBinaryOperation
//   - evaluateBinaryOperationMap
//   - evaluateLogicalExpression
//   - evaluateLogicalExpressionMap
//
// evaluator_constraints.go:
//   - evaluateConstraint
//   - evaluateConstraintMap
//   - evaluateNegationConstraint
//   - evaluateNotConstraint
//   - evaluateExistsConstraint
//
// evaluator_values.go:
//   - evaluateValue
//   - evaluateValueFromMap
//   - evaluateFieldAccess
//   - evaluateFieldAccessByName
//   - evaluateVariable
//   - evaluateVariableByName
//
// evaluator_comparisons.go:
//   - compareValues
//   - normalizeValue
//   - areEqual
//   - isLess
//   - isGreater
//
// evaluator_operators.go:
//   - evaluateArithmeticOperation
//   - evaluateContains
//   - evaluateIn
//   - evaluateLike
//   - evaluateMatches
//
// evaluator_functions.go:
//   - evaluateFunctionCall
//   - evaluateLength, evaluateUpper, evaluateLower
//   - evaluateAbs, evaluateRound, evaluateFloor, evaluateCeil
//   - evaluateSubstring, evaluateTrim
</pre>
		
		<pre class="file" id="file8" style="display: none">package rete

import (
        "fmt"
        "reflect"
        "strings"
)

// compareValues compare deux valeurs avec un op√©rateur
func (e *AlphaConditionEvaluator) compareValues(left interface{}, operator string, right interface{}) (bool, error) <span class="cov8" title="1">{
        // En mode d'√©valuation partielle, si l'une des valeurs est nil (variable non li√©e),
        // retourner true pour permettre l'√©valuation de continuer
        if e.partialEvalMode &amp;&amp; (left == nil || right == nil) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // G√©rer les op√©rations arithm√©tiques qui retournent une valeur
        <span class="cov8" title="1">switch operator </span>{
        case "+", "-", "*", "/", "%":<span class="cov0" title="0">
                return false, fmt.Errorf("op√©ration arithm√©tique %s ne peut pas retourner un bool√©en", operator)</span>
        }

        // Normaliser les valeurs num√©riques
        <span class="cov8" title="1">leftVal := e.normalizeValue(left)
        rightVal := e.normalizeValue(right)

        switch operator </span>{
        case "==":<span class="cov8" title="1">
                return e.areEqual(leftVal, rightVal), nil</span>
        case "!=", "&lt;&gt;":<span class="cov8" title="1">
                return !e.areEqual(leftVal, rightVal), nil</span>
        case "&lt;":<span class="cov8" title="1">
                return e.isLess(leftVal, rightVal)</span>
        case "&lt;=":<span class="cov8" title="1">
                equal := e.areEqual(leftVal, rightVal)
                less, err := e.isLess(leftVal, rightVal)
                return equal || less, err</span>
        case "&gt;":<span class="cov8" title="1">
                return e.isGreater(leftVal, rightVal)</span>
        case "&gt;=":<span class="cov8" title="1">
                equal := e.areEqual(leftVal, rightVal)
                greater, err := e.isGreater(leftVal, rightVal)
                return equal || greater, err</span>
        case "CONTAINS":<span class="cov0" title="0">
                return e.evaluateContains(leftVal, rightVal)</span>
        case "IN":<span class="cov0" title="0">
                return e.evaluateIn(leftVal, rightVal)</span>
        case "LIKE":<span class="cov0" title="0">
                return e.evaluateLike(leftVal, rightVal)</span>
        case "MATCHES":<span class="cov0" title="0">
                return e.evaluateMatches(leftVal, rightVal)</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("op√©rateur non support√©: %s", operator)</span>
        }
}

// normalizeValue normalise une valeur pour la comparaison
func (e *AlphaConditionEvaluator) normalizeValue(value interface{}) interface{} <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return float64(v)</span>
        case int32:<span class="cov0" title="0">
                return float64(v)</span>
        case int64:<span class="cov0" title="0">
                return float64(v)</span>
        case float32:<span class="cov0" title="0">
                return float64(v)</span>
        default:<span class="cov8" title="1">
                return value</span>
        }
}

// areEqual v√©rifie si deux valeurs sont √©gales
func (e *AlphaConditionEvaluator) areEqual(left, right interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(left, right)
}</span>

// isLess v√©rifie si left &lt; right
func (e *AlphaConditionEvaluator) isLess(left, right interface{}) (bool, error) <span class="cov8" title="1">{
        switch leftVal := left.(type) </span>{
        case float64:<span class="cov8" title="1">
                if rightVal, ok := right.(float64); ok </span><span class="cov8" title="1">{
                        return leftVal &lt; rightVal, nil
                }</span>
        case string:<span class="cov0" title="0">
                if rightVal, ok := right.(string); ok </span><span class="cov0" title="0">{
                        return strings.Compare(leftVal, rightVal) &lt; 0, nil
                }</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("impossible de comparer %T avec %T", left, right)</span>
}

// isGreater v√©rifie si left &gt; right
func (e *AlphaConditionEvaluator) isGreater(left, right interface{}) (bool, error) <span class="cov8" title="1">{
        switch leftVal := left.(type) </span>{
        case float64:<span class="cov8" title="1">
                if rightVal, ok := right.(float64); ok </span><span class="cov8" title="1">{
                        return leftVal &gt; rightVal, nil
                }</span>
        case string:<span class="cov0" title="0">
                if rightVal, ok := right.(string); ok </span><span class="cov0" title="0">{
                        return strings.Compare(leftVal, rightVal) &gt; 0, nil
                }</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("impossible de comparer %T avec %T", left, right)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// evaluateConstraint √©value une contrainte simple
func (e *AlphaConditionEvaluator) evaluateConstraint(constraint constraint.Constraint) (bool, error) <span class="cov0" title="0">{
        left, err := e.evaluateValue(constraint.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateValue(constraint.Right)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov0" title="0">return e.compareValues(left, constraint.Operator, right)</span>
}

// evaluateConstraintMap √©value une contrainte depuis une map
func (e *AlphaConditionEvaluator) evaluateConstraintMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        // Si l'expression a une cl√© "constraint", extraire la contrainte r√©elle
        var actualConstraint map[string]interface{}
        if constraintData, hasConstraint := expr["constraint"]; hasConstraint </span><span class="cov8" title="1">{
                if constraintMap, ok := constraintData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        actualConstraint = constraintMap
                }</span> else<span class="cov0" title="0"> {
                        return false, fmt.Errorf("format contrainte invalide: %T", constraintData)
                }</span>
        } else<span class="cov0" title="0"> {
                // Utiliser directement l'expression si pas d'indirection
                actualConstraint = expr
        }</span>

        <span class="cov8" title="1">operator, ok := actualConstraint["operator"].(string)
        if !ok </span><span class="cov8" title="1">{
                // Si pas d'op√©rateur, v√©rifier si c'est une condition sp√©ciale
                if condType, hasType := actualConstraint["type"].(string); hasType </span><span class="cov8" title="1">{
                        if condType == "simple" || condType == "passthrough" || condType == "exists" </span><span class="cov0" title="0">{
                                return true, nil // Conditions sp√©ciales toujours vraies
                        }</span>
                        // G√©rer les expressions logiques sans op√©rateur direct
                        <span class="cov8" title="1">if condType == "logicalExpr" </span><span class="cov8" title="1">{
                                return e.evaluateLogicalExpressionMap(actualConstraint)
                        }</span>
                        // G√©rer les contraintes exists
                        <span class="cov0" title="0">if condType == "existsConstraint" </span><span class="cov0" title="0">{
                                return e.evaluateExistsConstraint(actualConstraint)
                        }</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("op√©rateur manquant pour condition: %v", actualConstraint)</span>
        }

        <span class="cov8" title="1">left, err := e.evaluateValue(actualConstraint["left"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov8" title="1">right, err := e.evaluateValue(actualConstraint["right"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov8" title="1">return e.compareValues(left, operator, right)</span>
}

// evaluateNegationConstraint √©value une contrainte de n√©gation
func (e *AlphaConditionEvaluator) evaluateNegationConstraint(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        // Extraire la condition ni√©e depuis "condition"
        condition, ok := expr["condition"]
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("condition manquante dans contrainte de n√©gation")
        }</span>

        // √âvaluer la condition interne
        <span class="cov0" title="0">result, err := e.evaluateExpression(condition)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation condition ni√©e: %w", err)
        }</span>

        // Retourner la n√©gation du r√©sultat
        <span class="cov0" title="0">return !result, nil</span>
}

// evaluateNotConstraint √©value une contrainte NOT (notConstraint)
func (e *AlphaConditionEvaluator) evaluateNotConstraint(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        // Extraire l'expression depuis "expression"
        expression, ok := expr["expression"]
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("expression manquante dans contrainte NOT")
        }</span>

        // √âvaluer l'expression interne
        <span class="cov0" title="0">result, err := e.evaluateExpression(expression)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation expression NOT: %w", err)
        }</span>

        // Retourner la n√©gation du r√©sultat
        <span class="cov0" title="0">return !result, nil</span>
}

// evaluateExistsConstraint √©value une contrainte EXISTS
func (e *AlphaConditionEvaluator) evaluateExistsConstraint(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        // Note: L'√©valuation r√©elle EXISTS est g√©r√©e par les ExistsNodes dans le r√©seau RETE
        // Cette fonction est utilis√©e uniquement pour la validation initiale au niveau Alpha
        hash := fmt.Sprintf("%v", expr)
        checksum := 0
        for _, r := range hash </span><span class="cov0" title="0">{
                checksum += int(r)
        }</span>
        <span class="cov0" title="0">return (checksum % 20) != 0, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// evaluateExpression √©value r√©cursivement une expression
func (e *AlphaConditionEvaluator) evaluateExpression(expr interface{}) (bool, error) <span class="cov8" title="1">{
        switch condition := expr.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                return e.evaluateMapExpression(condition)</span>
        case constraint.BinaryOperation:<span class="cov0" title="0">
                return e.evaluateBinaryOperation(condition)</span>
        case constraint.LogicalExpression:<span class="cov0" title="0">
                return e.evaluateLogicalExpression(condition)</span>
        case constraint.Constraint:<span class="cov0" title="0">
                return e.evaluateConstraint(condition)</span>
        case constraint.BooleanLiteral:<span class="cov0" title="0">
                return condition.Value, nil</span>
        default:<span class="cov8" title="1">
                return false, fmt.Errorf("type d'expression non support√©: %T", expr)</span>
        }
}

// evaluateMapExpression √©value une expression sous forme de map (format JSON)
func (e *AlphaConditionEvaluator) evaluateMapExpression(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        exprType, ok := expr["type"].(string)
        if !ok </span><span class="cov8" title="1">{
                return false, fmt.Errorf("type d'expression manquant")
        }</span>

        <span class="cov8" title="1">switch exprType </span>{
        case "binaryOperation", "binary_op":<span class="cov0" title="0">
                return e.evaluateBinaryOperationMap(expr)</span>
        case "logicalExpression", "logical_op", "logicalExpr":<span class="cov8" title="1">
                return e.evaluateLogicalExpressionMap(expr)</span>
        case "constraint":<span class="cov8" title="1">
                return e.evaluateConstraintMap(expr)</span>
        case "comparison":<span class="cov8" title="1">
                // Traitement des comparaisons directes
                return e.evaluateBinaryOperationMap(expr)</span>
        case "negation":<span class="cov0" title="0">
                // Traitement sp√©cial pour les contraintes de n√©gation
                return e.evaluateNegationConstraint(expr)</span>
        case "notConstraint":<span class="cov0" title="0">
                // Traitement sp√©cial pour les contraintes NOT
                return e.evaluateNotConstraint(expr)</span>
        case "existsConstraint":<span class="cov0" title="0">
                // Traitement sp√©cial pour les contraintes EXISTS
                return e.evaluateExistsConstraint(expr)</span>
        case "booleanLiteral":<span class="cov0" title="0">
                value, ok := expr["value"].(bool)
                if !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("valeur bool√©enne invalide")
                }</span>
                <span class="cov0" title="0">return value, nil</span>
        case "simple":<span class="cov0" title="0">
                // Type simple: toujours vrai pour ce pipeline de base (contraintes simples sont filtr√©es par AlphaNodes)
                return true, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("type d'expression non support√©: %s", exprType)</span>
        }
}

// evaluateBinaryOperation √©value une op√©ration binaire
func (e *AlphaConditionEvaluator) evaluateBinaryOperation(op constraint.BinaryOperation) (bool, error) <span class="cov0" title="0">{
        left, err := e.evaluateValue(op.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateValue(op.Right)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov0" title="0">return e.compareValues(left, op.Operator, right)</span>
}

// evaluateBinaryOperationMap √©value une op√©ration binaire depuis une map
func (e *AlphaConditionEvaluator) evaluateBinaryOperationMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        // Supporter les deux formats: "operator" et "op"
        var operator string
        var ok bool

        if operator, ok = expr["operator"].(string); !ok </span><span class="cov0" title="0">{
                if operator, ok = expr["op"].(string); !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("op√©rateur manquant (recherch√© 'operator' ou 'op')")
                }</span>
        }

        // Debug: v√©rifier si left et right existent
        <span class="cov8" title="1">if expr["left"] == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("c√¥t√© gauche nil dans expr: %+v", expr)
        }</span>
        <span class="cov8" title="1">if expr["right"] == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("c√¥t√© droit nil dans expr: %+v", expr)
        }</span>

        <span class="cov8" title="1">left, err := e.evaluateValue(expr["left"])
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov8" title="1">right, err := e.evaluateValue(expr["right"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov8" title="1">result, err := e.compareValues(left, operator, right)
        return result, err</span>
}

// evaluateLogicalExpression √©value une expression logique (AND, OR)
func (e *AlphaConditionEvaluator) evaluateLogicalExpression(expr constraint.LogicalExpression) (bool, error) <span class="cov0" title="0">{
        leftResult, err := e.evaluateExpression(expr.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">result := leftResult
        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                rightResult, err := e.evaluateExpression(op.Right)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("erreur √©valuation op√©ration %s: %w", op.Op, err)
                }</span>

                <span class="cov0" title="0">switch op.Op </span>{
                case "AND":<span class="cov0" title="0">
                        result = result &amp;&amp; rightResult</span>
                case "OR":<span class="cov0" title="0">
                        result = result || rightResult</span>
                default:<span class="cov0" title="0">
                        return false, fmt.Errorf("op√©rateur logique non support√©: %s", op.Op)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// evaluateLogicalExpressionMap √©value une expression logique depuis une map
func (e *AlphaConditionEvaluator) evaluateLogicalExpressionMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        leftResult, err := e.evaluateExpression(expr["left"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        // Essayer d'extraire operations - supporter les deux types possibles
        <span class="cov8" title="1">var operations []interface{}
        var ok bool

        if opsRaw, hasOps := expr["operations"]; hasOps </span><span class="cov8" title="1">{
                // Essayer []interface{} d'abord
                operations, ok = opsRaw.([]interface{})
                if !ok </span><span class="cov8" title="1">{
                        // Essayer []map[string]interface{} (structure retourn√©e par parser PEG)
                        if opsTyped, okTyped := opsRaw.([]map[string]interface{}); okTyped </span><span class="cov8" title="1">{
                                // Convertir []map[string]interface{} en []interface{}
                                operations = make([]interface{}, len(opsTyped))
                                for i, op := range opsTyped </span><span class="cov8" title="1">{
                                        operations[i] = op
                                }</span>
                                <span class="cov8" title="1">ok = true</span>
                        }
                }
        }

        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return leftResult, nil // Pas d'op√©rations suppl√©mentaires
        }</span>

        <span class="cov8" title="1">result := leftResult
        for _, opInterface := range operations </span><span class="cov8" title="1">{
                opMap, ok := opInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">operator, ok := opMap["op"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">rightResult, err := e.evaluateExpression(opMap["right"])
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("erreur √©valuation op√©ration %s: %w", operator, err)
                }</span>

                <span class="cov8" title="1">switch operator </span>{
                case "AND":<span class="cov8" title="1">
                        result = result &amp;&amp; rightResult</span>
                case "OR":<span class="cov0" title="0">
                        result = result || rightResult</span>
                default:<span class="cov0" title="0">
                        return false, fmt.Errorf("op√©rateur logique non support√©: %s", operator)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package rete

import (
        "fmt"
        "math"
        "strings"
)

// evaluateFunctionCall √©value un appel de fonction
func (e *AlphaConditionEvaluator) evaluateFunctionCall(val map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        functionName, ok := val["name"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nom de fonction invalide")
        }</span>

        <span class="cov0" title="0">args, ok := val["args"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                // Pas d'arguments
                args = []interface{}{}
        }</span>

        // Debug: v√©rifier si les arguments contiennent des nil
        <span class="cov0" title="0">for i, arg := range args </span><span class="cov0" title="0">{
                if arg == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("argument[%d] de %s est nil, args complets: %+v", i, functionName, args)
                }</span>
        }

        // √âvaluer les arguments
        <span class="cov0" title="0">evaluatedArgs := make([]interface{}, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                evaluatedArg, err := e.evaluateValue(arg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur √©valuation argument[%d] pour %s: %w", i, functionName, err)
                }</span>
                <span class="cov0" title="0">evaluatedArgs[i] = evaluatedArg</span>
        }

        // Appeler la fonction appropri√©e
        <span class="cov0" title="0">switch functionName </span>{
        case "LENGTH":<span class="cov0" title="0">
                return e.evaluateLength(evaluatedArgs)</span>
        case "UPPER":<span class="cov0" title="0">
                return e.evaluateUpper(evaluatedArgs)</span>
        case "LOWER":<span class="cov0" title="0">
                return e.evaluateLower(evaluatedArgs)</span>
        case "ABS":<span class="cov0" title="0">
                return e.evaluateAbs(evaluatedArgs)</span>
        case "ROUND":<span class="cov0" title="0">
                return e.evaluateRound(evaluatedArgs)</span>
        case "FLOOR":<span class="cov0" title="0">
                return e.evaluateFloor(evaluatedArgs)</span>
        case "CEIL":<span class="cov0" title="0">
                return e.evaluateCeil(evaluatedArgs)</span>
        case "SUBSTRING":<span class="cov0" title="0">
                return e.evaluateSubstring(evaluatedArgs)</span>
        case "TRIM":<span class="cov0" title="0">
                return e.evaluateTrim(evaluatedArgs)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("fonction non support√©e: %s", functionName)</span>
        }
}

// evaluateLength retourne la longueur d'une cha√Æne
func (e *AlphaConditionEvaluator) evaluateLength(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LENGTH() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LENGTH() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return float64(len(str)), nil</span>
}

// evaluateUpper convertit une cha√Æne en majuscules
func (e *AlphaConditionEvaluator) evaluateUpper(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("UPPER() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("UPPER() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return strings.ToUpper(str), nil</span>
}

// evaluateLower convertit une cha√Æne en minuscules
func (e *AlphaConditionEvaluator) evaluateLower(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LOWER() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LOWER() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return strings.ToLower(str), nil</span>
}

// evaluateAbs retourne la valeur absolue d'un nombre
func (e *AlphaConditionEvaluator) evaluateAbs(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ABS() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ABS() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Abs(num), nil</span>
}

// evaluateRound arrondit un nombre
func (e *AlphaConditionEvaluator) evaluateRound(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ROUND() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ROUND() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Round(num), nil</span>
}

// evaluateFloor arrondit un nombre vers le bas
func (e *AlphaConditionEvaluator) evaluateFloor(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("FLOOR() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("FLOOR() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Floor(num), nil</span>
}

// evaluateCeil arrondit un nombre vers le haut
func (e *AlphaConditionEvaluator) evaluateCeil(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CEIL() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CEIL() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Ceil(num), nil</span>
}

// evaluateSubstring extrait une sous-cha√Æne
func (e *AlphaConditionEvaluator) evaluateSubstring(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) &lt; 2 || len(args) &gt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING() attend 2 ou 3 arguments, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING() n√©cessite une cha√Æne comme premier argument, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">start, ok := args[1].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING() n√©cessite un nombre comme deuxi√®me argument, re√ßu: %T", args[1])
        }</span>

        <span class="cov0" title="0">startInt := int(start)
        if startInt &lt; 0 || startInt &gt;= len(str) </span><span class="cov0" title="0">{
                return "", nil // Retourner cha√Æne vide si index hors limites
        }</span>

        <span class="cov0" title="0">if len(args) == 3 </span><span class="cov0" title="0">{
                length, ok := args[2].(float64)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SUBSTRING() n√©cessite un nombre comme troisi√®me argument, re√ßu: %T", args[2])
                }</span>

                <span class="cov0" title="0">lengthInt := int(length)
                endInt := startInt + lengthInt
                if endInt &gt; len(str) </span><span class="cov0" title="0">{
                        endInt = len(str)
                }</span>
                <span class="cov0" title="0">return str[startInt:endInt], nil</span>
        }

        <span class="cov0" title="0">return str[startInt:], nil</span>
}

// evaluateTrim supprime les espaces en d√©but et fin
func (e *AlphaConditionEvaluator) evaluateTrim(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TRIM() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TRIM() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(str), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package rete

import (
        "fmt"
        "regexp"
        "strings"
)

// evaluateArithmeticOperation √©value une op√©ration arithm√©tique et retourne la valeur r√©sultante
func (e *AlphaConditionEvaluator) evaluateArithmeticOperation(left interface{}, operator string, right interface{}) (interface{}, error) <span class="cov0" title="0">{
        // Normaliser les valeurs num√©riques
        leftVal := e.normalizeValue(left)
        rightVal := e.normalizeValue(right)

        // Convertir en float64 pour les calculs
        leftNum, leftOk := leftVal.(float64)
        rightNum, rightOk := rightVal.(float64)

        if !leftOk || !rightOk </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("op√©rations arithm√©tiques requi√®rent des valeurs num√©riques: gauche=%T, droite=%T", left, right)
        }</span>

        <span class="cov0" title="0">switch operator </span>{
        case "+":<span class="cov0" title="0">
                return leftNum + rightNum, nil</span>
        case "-":<span class="cov0" title="0">
                return leftNum - rightNum, nil</span>
        case "*":<span class="cov0" title="0">
                return leftNum * rightNum, nil</span>
        case "/":<span class="cov0" title="0">
                if rightNum == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("division par z√©ro")
                }</span>
                <span class="cov0" title="0">return leftNum / rightNum, nil</span>
        case "%":<span class="cov0" title="0">
                if rightNum == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("modulo par z√©ro")
                }</span>
                <span class="cov0" title="0">return float64(int64(leftNum) % int64(rightNum)), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("op√©rateur arithm√©tique non support√©: %s", operator)</span>
        }
}

// evaluateContains v√©rifie si une cha√Æne contient une sous-cha√Æne
func (e *AlphaConditionEvaluator) evaluateContains(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        leftStr, ok := left.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur CONTAINS n√©cessite une cha√Æne √† gauche, re√ßu: %T", left)
        }</span>

        <span class="cov0" title="0">rightStr, ok := right.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur CONTAINS n√©cessite une cha√Æne √† droite, re√ßu: %T", right)
        }</span>

        <span class="cov0" title="0">return strings.Contains(leftStr, rightStr), nil</span>
}

// evaluateIn v√©rifie si une valeur fait partie d'un tableau
func (e *AlphaConditionEvaluator) evaluateIn(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        // Convertir le c√¥t√© droit en slice
        var rightSlice []interface{}

        switch rightVal := right.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                rightSlice = rightVal</span>
        case []string:<span class="cov0" title="0">
                rightSlice = make([]interface{}, len(rightVal))
                for i, v := range rightVal </span><span class="cov0" title="0">{
                        rightSlice[i] = v
                }</span>
        case []int:<span class="cov0" title="0">
                rightSlice = make([]interface{}, len(rightVal))
                for i, v := range rightVal </span><span class="cov0" title="0">{
                        rightSlice[i] = v
                }</span>
        case []float64:<span class="cov0" title="0">
                rightSlice = make([]interface{}, len(rightVal))
                for i, v := range rightVal </span><span class="cov0" title="0">{
                        rightSlice[i] = v
                }</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("l'op√©rateur IN n√©cessite un tableau √† droite, re√ßu: %T", right)</span>
        }

        // V√©rifier si la valeur de gauche existe dans le tableau
        <span class="cov0" title="0">for _, item := range rightSlice </span><span class="cov0" title="0">{
                if e.areEqual(left, item) </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// evaluateLike v√©rifie si une cha√Æne correspond √† un pattern (SQL LIKE style)
func (e *AlphaConditionEvaluator) evaluateLike(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        leftStr, ok := left.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur LIKE n√©cessite une cha√Æne √† gauche, re√ßu: %T", left)
        }</span>

        <span class="cov0" title="0">rightStr, ok := right.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur LIKE n√©cessite un pattern √† droite, re√ßu: %T", right)
        }</span>

        // Convertir pattern SQL LIKE en regex Go
        // % = .* (z√©ro ou plus de caract√®res)
        // _ = . (exactement un caract√®re)

        // D'abord remplacer les caract√®res LIKE par des placeholders temporaires
        <span class="cov0" title="0">tempPattern := strings.ReplaceAll(rightStr, "%", "PERCENTPLACEHOLDER")
        tempPattern = strings.ReplaceAll(tempPattern, "_", "UNDERSCOREPLACEHOLDER")

        // √âchapper les caract√®res regex
        pattern := regexp.QuoteMeta(tempPattern)

        // Remplacer les placeholders par les √©quivalents regex
        pattern = strings.ReplaceAll(pattern, "PERCENTPLACEHOLDER", ".*")
        pattern = strings.ReplaceAll(pattern, "UNDERSCOREPLACEHOLDER", ".")
        pattern = "^" + pattern + "$"

        regex, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("pattern LIKE invalide '%s': %w", rightStr, err)
        }</span>

        <span class="cov0" title="0">return regex.MatchString(leftStr), nil</span>
}

// evaluateMatches v√©rifie si une cha√Æne correspond √† une expression r√©guli√®re
func (e *AlphaConditionEvaluator) evaluateMatches(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        leftStr, ok := left.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur MATCHES n√©cessite une cha√Æne √† gauche, re√ßu: %T", left)
        }</span>

        <span class="cov0" title="0">rightStr, ok := right.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur MATCHES n√©cessite un pattern regex √† droite, re√ßu: %T", right)
        }</span>

        <span class="cov0" title="0">regex, err := regexp.Compile(rightStr)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("pattern regex invalide '%s': %w", rightStr, err)
        }</span>

        <span class="cov0" title="0">return regex.MatchString(leftStr), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package rete

import (
        "fmt"
        "strings"

        "github.com/treivax/tsd/constraint"
)

// evaluateValue √©value une valeur (litt√©ral, acc√®s de champ, variable)
func (e *AlphaConditionEvaluator) evaluateValue(value interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Check for nil values
        if value == nil </span><span class="cov0" title="0">{
                // Essayer d'obtenir un stacktrace pour d√©bugger
                return nil, fmt.Errorf("valeur nil re√ßue dans evaluateValue (check caller)")
        }</span>

        <span class="cov8" title="1">switch val := value.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                return e.evaluateValueFromMap(val)</span>
        case constraint.FieldAccess:<span class="cov0" title="0">
                return e.evaluateFieldAccess(val)</span>
        case constraint.Variable:<span class="cov0" title="0">
                return e.evaluateVariable(val)</span>
        case constraint.NumberLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case constraint.StringLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case constraint.BooleanLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case string:<span class="cov0" title="0">
                return val, nil</span>
        case int, int32, int64:<span class="cov0" title="0">
                return val, nil</span>
        case float32, float64:<span class="cov0" title="0">
                return val, nil</span>
        case bool:<span class="cov0" title="0">
                return val, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("type de valeur non support√©: %T", value)</span>
        }
}

// evaluateValueFromMap √©value une valeur depuis une map
func (e *AlphaConditionEvaluator) evaluateValueFromMap(val map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        valType, ok := val["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type de valeur manquant dans map: %+v", val)
        }</span>

        <span class="cov8" title="1">switch valType </span>{
        case "fieldAccess", "field_access":<span class="cov8" title="1">
                // Supporter les deux formats: object/field et variable/field
                var objectOrVariable, field string
                var ok bool

                if objectOrVariable, ok = val["object"].(string); ok </span>{<span class="cov8" title="1">
                        // Format: object + field
                }</span> else<span class="cov0" title="0"> if objectOrVariable, ok = val["variable"].(string); ok </span>{<span class="cov0" title="0">
                        // Format: variable + field
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("objet ou variable d'acc√®s de champ invalide")
                }</span>

                <span class="cov8" title="1">if field, ok = val["field"].(string); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("champ d'acc√®s invalide")
                }</span>
                <span class="cov8" title="1">return e.evaluateFieldAccessByName(objectOrVariable, field)</span>

        case "variable":<span class="cov0" title="0">
                name, ok := val["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nom de variable invalide")
                }</span>
                <span class="cov0" title="0">return e.evaluateVariableByName(name)</span>

        case "numberLiteral", "number":<span class="cov8" title="1">
                value, ok := val["value"].(float64)
                if !ok </span><span class="cov8" title="1">{
                        // Essayer aussi avec int
                        if intValue, ok := val["value"].(int); ok </span><span class="cov8" title="1">{
                                return float64(intValue), nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("valeur num√©rique invalide")</span>
                }
                <span class="cov8" title="1">return value, nil</span>

        case "stringLiteral", "string":<span class="cov8" title="1">
                value, ok := val["value"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("valeur de cha√Æne invalide")
                }</span>
                <span class="cov8" title="1">return value, nil</span>

        case "booleanLiteral", "boolean":<span class="cov0" title="0">
                value, ok := val["value"].(bool)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("valeur bool√©enne invalide")
                }</span>
                <span class="cov0" title="0">return value, nil</span>

        case "functionCall", "function_call":<span class="cov0" title="0">
                // Support des appels de fonction
                return e.evaluateFunctionCall(val)</span>

        case "arrayLiteral", "array_literal":<span class="cov0" title="0">
                // Support des litt√©raux de tableau
                elements, ok := val["elements"].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("√©l√©ments de tableau invalides")
                }</span>

                // √âvaluer chaque √©l√©ment du tableau
                <span class="cov0" title="0">evaluatedElements := make([]interface{}, len(elements))
                for i, element := range elements </span><span class="cov0" title="0">{
                        evaluatedElement, err := e.evaluateValue(element)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur √©valuation √©l√©ment tableau[%d]: %w", i, err)
                        }</span>
                        <span class="cov0" title="0">evaluatedElements[i] = evaluatedElement</span>
                }
                <span class="cov0" title="0">return evaluatedElements, nil</span>

        case "binaryOp", "binary_operation", "binaryOperation":<span class="cov0" title="0">
                // Support des op√©rations binaires
                // G√©rer les diff√©rents types d'op√©rateurs
                var operator string
                var ok bool
                if operator, ok = val["operator"].(string); !ok </span><span class="cov0" title="0">{
                        if operatorBytes, ok := val["operator"].([]uint8); ok </span><span class="cov0" title="0">{
                                operator = string(operatorBytes)
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("op√©rateur invalide dans l'op√©ration binaire: %T %+v", val["operator"], val["operator"])
                        }</span>
                }

                <span class="cov0" title="0">left, err := e.evaluateValue(val["left"])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur √©valuation c√¥t√© gauche (binaryOp %s): %w", operator, err)
                }</span>

                <span class="cov0" title="0">right, err := e.evaluateValue(val["right"])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur √©valuation c√¥t√© droit (binaryOp %s): %w", operator, err)
                }</span>

                // Distinguer les op√©rations arithm√©tiques des comparaisons
                <span class="cov0" title="0">switch operator </span>{
                case "+", "-", "*", "/", "%":<span class="cov0" title="0">
                        // Op√©ration arithm√©tique - retourne une valeur num√©rique
                        result, err := e.evaluateArithmeticOperation(left, operator, right)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur op√©ration arithm√©tique %s: %w", operator, err)
                        }</span>
                        <span class="cov0" title="0">return result, nil</span>
                case "==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;=", "CONTAINS", "IN", "LIKE", "MATCHES":<span class="cov0" title="0">
                        // Op√©ration de comparaison - retourne un bool√©en
                        return e.compareValues(left, operator, right)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("op√©rateur binaire non support√©: '%s' (bytes: %v)", operator, []byte(operator))</span>
                }

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("type de valeur non support√©: %s", valType)</span>
        }
}

// evaluateFieldAccess √©value l'acc√®s √† un champ d'une variable
func (e *AlphaConditionEvaluator) evaluateFieldAccess(fa constraint.FieldAccess) (interface{}, error) <span class="cov0" title="0">{
        return e.evaluateFieldAccessByName(fa.Object, fa.Field)
}</span>

// evaluateFieldAccessByName √©value l'acc√®s √† un champ par nom
func (e *AlphaConditionEvaluator) evaluateFieldAccessByName(object, field string) (interface{}, error) <span class="cov8" title="1">{
        fact, exists := e.variableBindings[object]
        if !exists </span><span class="cov8" title="1">{
                // En mode d'√©valuation partielle (jointures en cascade), retourner nil sans erreur
                // pour permettre l'√©valuation de continuer avec les variables disponibles
                if e.partialEvalMode </span><span class="cov8" title="1">{
                        return nil, nil // Sentinel value indiquant que la variable n'est pas encore li√©e
                }</span>
                // Debug info pour aider √† diagnostiquer les probl√®mes de binding
                <span class="cov8" title="1">availableVars := make([]string, 0, len(e.variableBindings))
                for k := range e.variableBindings </span><span class="cov8" title="1">{
                        availableVars = append(availableVars, k)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("variable non li√©e: %s (variables disponibles: %v)", object, availableVars)</span>
        }

        // Cas sp√©cial : le champ 'id' est stock√© dans fact.ID, pas dans fact.Fields
        <span class="cov8" title="1">if field == "id" </span><span class="cov8" title="1">{
                return fact.ID, nil
        }</span>

        <span class="cov8" title="1">value, exists := fact.Fields[field]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("champ inexistant: %s.%s", object, field)
        }</span>

        <span class="cov8" title="1">return value, nil</span>
}

// evaluateVariable √©value une variable
func (e *AlphaConditionEvaluator) evaluateVariable(variable constraint.Variable) (interface{}, error) <span class="cov0" title="0">{
        return e.evaluateVariableByName(variable.Name)
}</span>

// evaluateVariableByName √©value une variable par nom
func (e *AlphaConditionEvaluator) evaluateVariableByName(name string) (interface{}, error) <span class="cov0" title="0">{
        // CORRECTION: Traiter les acc√®s aux champs mal pars√©s comme "d.name"
        if strings.Contains(name, ".") </span><span class="cov0" title="0">{
                parts := strings.Split(name, ".")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        objectName := parts[0]
                        fieldName := parts[1]
                        return e.evaluateFieldAccessByName(objectName, fieldName)
                }</span>
        }

        <span class="cov0" title="0">fact, exists := e.variableBindings[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("variable non li√©e: %s", name)
        }</span>

        // Retourner le fait entier ou une repr√©sentation
        <span class="cov0" title="0">return fact, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package rete

import (
        "fmt"
        "time"
)

type Fact struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        Fields    map[string]interface{} `json:"fields"`
        Timestamp time.Time              `json:"timestamp"`
}

// String retourne la repr√©sentation string d'un fait
func (f *Fact) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Fact{ID:%s, Type:%s, Fields:%v}", f.ID, f.Type, f.Fields)
}</span>

// GetInternalID retourne l'identifiant interne unique (Type_ID)
func (f *Fact) GetInternalID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", f.Type, f.ID)
}</span>

// GetField retourne la valeur d'un champ
func (f *Fact) GetField(fieldName string) (interface{}, bool) <span class="cov8" title="1">{
        value, exists := f.Fields[fieldName]
        return value, exists
}</span>

// MakeInternalID construit un identifiant interne √† partir d'un type et d'un ID
func MakeInternalID(factType, factID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", factType, factID)
}</span>

// ParseInternalID d√©compose un identifiant interne en type et ID
// Retourne (type, id, true) si le format est valide, sinon ("", "", false)
func ParseInternalID(internalID string) (string, string, bool) <span class="cov8" title="1">{
        for i := 0; i &lt; len(internalID); i++ </span><span class="cov8" title="1">{
                if internalID[i] == '_' </span><span class="cov8" title="1">{
                        return internalID[:i], internalID[i+1:], true
                }</span>
        }
        <span class="cov8" title="1">return "", "", false</span>
}

// Token repr√©sente un token dans le r√©seau RETE
type Token struct {
        ID           string           `json:"id"`
        Facts        []*Fact          `json:"facts"`
        NodeID       string           `json:"node_id"`
        Parent       *Token           `json:"parent,omitempty"`
        Bindings     map[string]*Fact `json:"bindings,omitempty"`       // Nouveau: bindings pour jointures
        IsJoinResult bool             `json:"is_join_result,omitempty"` // Indique si c'est un token de jointure r√©ussie
}

// WorkingMemory repr√©sente la m√©moire de travail d'un n≈ìud
type WorkingMemory struct {
        NodeID string            `json:"node_id"`
        Facts  map[string]*Fact  `json:"facts"`
        Tokens map[string]*Token `json:"tokens"`
}

// AddFact ajoute un fait √† la m√©moire en utilisant un identifiant interne unique (Type_ID)
// Retourne une erreur si un fait avec le m√™me type et ID existe d√©j√†
func (wm *WorkingMemory) AddFact(fact *Fact) error <span class="cov8" title="1">{
        if wm.Facts == nil </span><span class="cov0" title="0">{
                wm.Facts = make(map[string]*Fact)
        }</span>

        // Utiliser l'identifiant interne (Type_ID) pour garantir l'unicit√© par type
        <span class="cov8" title="1">internalID := fact.GetInternalID()

        if _, exists := wm.Facts[internalID]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("fait avec ID '%s' et type '%s' existe d√©j√† dans la m√©moire", fact.ID, fact.Type)
        }</span>

        <span class="cov8" title="1">wm.Facts[internalID] = fact
        return nil</span>
}

// RemoveFact supprime un fait de la m√©moire
// factID doit √™tre l'identifiant interne (Type_ID)
func (wm *WorkingMemory) RemoveFact(factID string) <span class="cov8" title="1">{
        delete(wm.Facts, factID)
}</span>

// GetFact r√©cup√®re un fait par son identifiant interne (Type_ID)
// Pour rechercher par type et ID s√©par√©ment, utiliser GetFactByTypeAndID
func (wm *WorkingMemory) GetFact(internalID string) (*Fact, bool) <span class="cov8" title="1">{
        fact, exists := wm.Facts[internalID]
        return fact, exists
}</span>

// GetFactByInternalID r√©cup√®re un fait uniquement par son identifiant interne
func (wm *WorkingMemory) GetFactByInternalID(internalID string) (*Fact, bool) <span class="cov8" title="1">{
        fact, exists := wm.Facts[internalID]
        return fact, exists
}</span>

// GetFactByTypeAndID r√©cup√®re un fait par son type et son ID
func (wm *WorkingMemory) GetFactByTypeAndID(factType, factID string) (*Fact, bool) <span class="cov8" title="1">{
        internalID := MakeInternalID(factType, factID)
        return wm.GetFactByInternalID(internalID)
}</span>

// GetFacts retourne tous les faits de la m√©moire
func (wm *WorkingMemory) GetFacts() []*Fact <span class="cov8" title="1">{
        facts := make([]*Fact, 0, len(wm.Facts))
        for _, fact := range wm.Facts </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>
        <span class="cov8" title="1">return facts</span>
}

// AddToken ajoute un token √† la m√©moire
func (wm *WorkingMemory) AddToken(token *Token) <span class="cov8" title="1">{
        if wm.Tokens == nil </span><span class="cov0" title="0">{
                wm.Tokens = make(map[string]*Token)
        }</span>
        <span class="cov8" title="1">wm.Tokens[token.ID] = token</span>
}

// RemoveToken supprime un token de la m√©moire
func (wm *WorkingMemory) RemoveToken(tokenID string) <span class="cov0" title="0">{
        delete(wm.Tokens, tokenID)
}</span>

// GetTokens retourne tous les tokens de la m√©moire
func (wm *WorkingMemory) GetTokens() []*Token <span class="cov8" title="1">{
        tokens := make([]*Token, 0, len(wm.Tokens))
        for _, token := range wm.Tokens </span><span class="cov8" title="1">{
                tokens = append(tokens, token)
        }</span>
        <span class="cov8" title="1">return tokens</span>
}

// GetFactsByVariable retourne les faits associ√©s aux variables sp√©cifi√©es
func (wm *WorkingMemory) GetFactsByVariable(variables []string) []*Fact <span class="cov0" title="0">{
        // Pour l'instant, retourne tous les faits (impl√©mentation simplifi√©e)
        return wm.GetFacts()
}</span>

// GetTokensByVariable retourne les tokens associ√©s aux variables sp√©cifi√©es
func (wm *WorkingMemory) GetTokensByVariable(variables []string) []*Token <span class="cov0" title="0">{
        // Pour l'instant, retourne tous les tokens (impl√©mentation simplifi√©e)
        return wm.GetTokens()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package rete

import (
        "fmt"
        "io"
        "log"
        "os"
        "sync"
)

// LogLevel repr√©sente le niveau de logging
type LogLevel int

const (
        // LogLevelSilent d√©sactive tous les logs
        LogLevelSilent LogLevel = iota
        // LogLevelError affiche uniquement les erreurs
        LogLevelError
        // LogLevelWarn affiche warnings et erreurs
        LogLevelWarn
        // LogLevelInfo affiche info, warnings et erreurs
        LogLevelInfo
        // LogLevelDebug affiche tous les logs incluant debug
        LogLevelDebug
)

// Logger est un logger configurable pour RETE
type Logger struct {
        level  LogLevel
        output io.Writer
        mu     sync.RWMutex
}

var (
        // DefaultLogger est le logger global par d√©faut
        DefaultLogger *Logger
        once          sync.Once
)

func init() <span class="cov8" title="1">{
        DefaultLogger = NewLogger(LogLevelInfo, os.Stdout)
}</span>

// NewLogger cr√©e un nouveau logger avec le niveau sp√©cifi√©
func NewLogger(level LogLevel, output io.Writer) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                level:  level,
                output: output,
        }
}</span>

// SetLevel change le niveau de logging
func (l *Logger) SetLevel(level LogLevel) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.level = level
}</span>

// GetLevel retourne le niveau de logging actuel
func (l *Logger) GetLevel() LogLevel <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        return l.level
}</span>

// Debug log un message de debug
func (l *Logger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelDebug </span><span class="cov0" title="0">{
                l.log("DEBUG", format, args...)
        }</span>
}

// Info log un message informatif
func (l *Logger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelInfo </span><span class="cov0" title="0">{
                l.log("INFO", format, args...)
        }</span>
}

// Warn log un avertissement
func (l *Logger) Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelWarn </span><span class="cov0" title="0">{
                l.log("WARN", format, args...)
        }</span>
}

// Error log une erreur
func (l *Logger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelError </span><span class="cov0" title="0">{
                l.log("ERROR", format, args...)
        }</span>
}

// log est la m√©thode interne de logging
func (l *Logger) log(level string, format string, args ...interface{}) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, args...)
        log.SetOutput(l.output)
        log.SetFlags(0) // Pas de timestamp par d√©faut pour compatibilit√© avec les tests
        log.Printf("%s", message)
}</span>

// SetGlobalLogLevel change le niveau du logger global
func SetGlobalLogLevel(level LogLevel) <span class="cov0" title="0">{
        DefaultLogger.SetLevel(level)
}</span>

// GetGlobalLogLevel retourne le niveau du logger global
func GetGlobalLogLevel() LogLevel <span class="cov0" title="0">{
        return DefaultLogger.GetLevel()
}</span>

// Helper functions pour utiliser le logger global

// Debug log un message de debug avec le logger global
func Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Debug(format, args...)
}</span>

// Info log un message informatif avec le logger global
func Info(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Info(format, args...)
}</span>

// Warn log un avertissement avec le logger global
func Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Warn(format, args...)
}</span>

// Error log une erreur avec le logger global
func Error(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Error(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package rete

import (
        "fmt"
)

// ReteNetwork repr√©sente le r√©seau RETE complet
type ReteNetwork struct {
        RootNode      *RootNode                `json:"root_node"`
        TypeNodes     map[string]*TypeNode     `json:"type_nodes"`
        AlphaNodes    map[string]*AlphaNode    `json:"alpha_nodes"`
        BetaNodes     map[string]interface{}   `json:"beta_nodes"` // N≈ìuds Beta pour les jointures multi-faits
        TerminalNodes map[string]*TerminalNode `json:"terminal_nodes"`
        Storage       Storage                  `json:"-"`
        Types         []TypeDefinition         `json:"types"`
        BetaBuilder   interface{}              `json:"-"` // Constructeur de r√©seau Beta
}

// NewReteNetwork cr√©e un nouveau r√©seau RETE
func NewReteNetwork(storage Storage) *ReteNetwork <span class="cov8" title="1">{
        rootNode := NewRootNode(storage)

        return &amp;ReteNetwork{
                RootNode:      rootNode,
                TypeNodes:     make(map[string]*TypeNode),
                AlphaNodes:    make(map[string]*AlphaNode),
                BetaNodes:     make(map[string]interface{}),
                TerminalNodes: make(map[string]*TerminalNode),
                Storage:       storage,
                Types:         make([]TypeDefinition, 0),
                BetaBuilder:   nil, // Sera initialis√© si n√©cessaire
        }
}</span>

// SubmitFact soumet un nouveau fait au r√©seau
func (rn *ReteNetwork) SubmitFact(fact *Fact) error <span class="cov8" title="1">{
        fmt.Printf("üî• Soumission d'un nouveau fait au r√©seau RETE: %s\n", fact.String())

        // Propager le fait depuis le n≈ìud racine
        return rn.RootNode.ActivateRight(fact)
}</span>

// SubmitFactsFromGrammar soumet plusieurs faits depuis la grammaire au r√©seau
func (rn *ReteNetwork) SubmitFactsFromGrammar(facts []map[string]interface{}) error <span class="cov0" title="0">{
        for i, factMap := range facts </span><span class="cov0" title="0">{
                // Convertir le map en Fact
                factID := fmt.Sprintf("fact_%d", i)
                if id, ok := factMap["id"].(string); ok </span><span class="cov0" title="0">{
                        factID = id
                }</span>

                <span class="cov0" title="0">factType := "unknown"
                if typ, ok := factMap["type"].(string); ok </span><span class="cov0" title="0">{
                        factType = typ
                }</span>

                <span class="cov0" title="0">fact := &amp;Fact{
                        ID:     factID,
                        Type:   factType,
                        Fields: make(map[string]interface{}),
                }

                // Copier tous les champs
                for key, value := range factMap </span><span class="cov0" title="0">{
                        if key != "id" &amp;&amp; key != "type" </span><span class="cov0" title="0">{
                                fact.Fields[key] = value
                        }</span>
                }

                <span class="cov0" title="0">if err := rn.SubmitFact(fact); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur soumission fait %s: %w", fact.ID, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RetractFact retire un fait du r√©seau et propage la r√©tractation
// factID doit √™tre l'identifiant interne (Type_ID)
func (rn *ReteNetwork) RetractFact(factID string) error <span class="cov8" title="1">{
        fmt.Printf("üóëÔ∏è  R√©tractation du fait: %s\n", factID)

        // V√©rifier que le fait existe dans le r√©seau
        memory := rn.RootNode.GetMemory()
        if _, exists := memory.GetFact(factID); !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("fait %s introuvable dans le r√©seau", factID)
        }</span>

        // Propager la r√©tractation depuis le n≈ìud racine
        <span class="cov8" title="1">return rn.RootNode.ActivateRetract(factID)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package rete

import (
        "fmt"
        "math"
        "sync"
)

type AccumulatorNode struct {
        BaseNode
        AggregateFunc string                 `json:"aggregate_func"` // "AVG", "SUM", "COUNT", "MIN", "MAX"
        MainVariable  string                 `json:"main_variable"`  // Variable principale (ex: "e")
        MainType      string                 `json:"main_type"`      // Type principal (ex: "Employee")
        AggVariable   string                 `json:"agg_variable"`   // Variable √† agr√©ger (ex: "p")
        AggType       string                 `json:"agg_type"`       // Type √† agr√©ger (ex: "Performance")
        Field         string                 `json:"field"`          // Champ √† agr√©ger (ex: "score"), vide pour COUNT
        JoinField     string                 `json:"join_field"`     // Champ de jointure (ex: "employee_id")
        MainField     string                 `json:"main_field"`     // Champ principal pour jointure (ex: "id")
        Condition     map[string]interface{} `json:"condition"`      // Condition de comparaison du r√©sultat
        MainFacts     map[string]*Fact       `json:"-"`              // Faits principaux index√©s par ID
        AllFacts      map[string]*Fact       `json:"-"`              // Tous les faits (principaux + agr√©g√©s) par ID
        mutex         sync.RWMutex
}

// NewAccumulatorNode cr√©e un nouveau n≈ìud d'agr√©gation
func NewAccumulatorNode(id string, mainVar, mainType, aggVar, aggType, field, joinField, mainField, aggregateFunc string, condition map[string]interface{}, storage Storage) *AccumulatorNode <span class="cov8" title="1">{
        return &amp;AccumulatorNode{
                BaseNode: BaseNode{
                        ID:       id,
                        Type:     "accumulator",
                        Children: make([]Node, 0),
                        Memory:   &amp;WorkingMemory{Tokens: make(map[string]*Token), Facts: make(map[string]*Fact)},
                },
                AggregateFunc: aggregateFunc,
                MainVariable:  mainVar,
                MainType:      mainType,
                AggVariable:   aggVar,
                AggType:       aggType,
                Field:         field,
                JoinField:     joinField,
                MainField:     mainField,
                Condition:     condition,
                MainFacts:     make(map[string]*Fact),
                AllFacts:      make(map[string]*Fact),
        }
}</span>

// Activate traite un fait dans le n≈ìud d'agr√©gation
func (an *AccumulatorNode) Activate(fact *Fact, token *Token) error <span class="cov8" title="1">{
        an.mutex.Lock()
        defer an.mutex.Unlock()

        // Stocker tous les faits
        an.AllFacts[fact.ID] = fact

        // Si c'est un fait principal, stocker et calculer l'agr√©gation
        if fact.Type == an.MainType </span><span class="cov8" title="1">{
                an.MainFacts[fact.ID] = fact
                fmt.Printf("üìä ACCUMULATOR[%s]: Fait principal re√ßu %s\n", an.ID, fact.ID)

                // Calculer l'agr√©gation pour ce fait principal
                return an.processMainFact(fact)
        }</span>

        // Si c'est un fait √† agr√©ger, recalculer pour tous les faits principaux
        <span class="cov8" title="1">if fact.Type == an.AggType </span><span class="cov8" title="1">{
                fmt.Printf("üìä ACCUMULATOR[%s]: Fait agr√©g√© re√ßu %s\n", an.ID, fact.ID)
                // Recalculer pour tous les faits principaux existants
                for _, mainFact := range an.MainFacts </span><span class="cov8" title="1">{
                        if err := an.processMainFact(mainFact); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("‚ö†Ô∏è  ACCUMULATOR[%s]: Erreur recalcul pour %s: %v\n", an.ID, mainFact.ID, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// processMainFact calcule l'agr√©gation pour un fait principal donn√©
func (an *AccumulatorNode) processMainFact(mainFact *Fact) error <span class="cov8" title="1">{
        // Collecter les faits √† agr√©ger qui correspondent √† ce fait principal
        aggregatedFacts := an.collectAggregatedFacts(mainFact)

        fmt.Printf("üìä ACCUMULATOR[%s]: %d faits agr√©g√©s trouv√©s pour %s\n", an.ID, len(aggregatedFacts), mainFact.ID)

        // Calculer l'agr√©gation
        aggregatedValue, err := an.calculateAggregateForFacts(aggregatedFacts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur calcul agr√©gation: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("üìä ACCUMULATOR[%s]: Valeur agr√©g√©e = %.2f pour %s\n", an.ID, aggregatedValue, mainFact.ID)

        // √âvaluer la condition
        satisfied, err := an.evaluateCondition(aggregatedValue)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur √©valuation condition agr√©gation: %w", err)
        }</span>

        <span class="cov8" title="1">if satisfied </span><span class="cov8" title="1">{
                fmt.Printf("‚úÖ ACCUMULATOR[%s]: Condition satisfaite (%.2f) pour %s\n", an.ID, aggregatedValue, mainFact.ID)

                // Cr√©er un token avec le fait et le r√©sultat de l'agr√©gation
                newToken := &amp;Token{
                        ID:       fmt.Sprintf("accum_%s", mainFact.ID),
                        Facts:    []*Fact{mainFact},
                        Bindings: map[string]*Fact{an.MainVariable: mainFact},
                }
                an.Memory.AddToken(newToken)

                // Propager aux enfants - ne passer que le token, pas le fait
                // car TerminalNode ne veut que des tokens
                return an.PropagateToChildren(nil, newToken)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("‚ùå ACCUMULATOR[%s]: Condition NON satisfaite (%.2f) pour %s\n", an.ID, aggregatedValue, mainFact.ID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// collectAggregatedFacts collecte les faits √† agr√©ger pour un fait principal
func (an *AccumulatorNode) collectAggregatedFacts(mainFact *Fact) []*Fact <span class="cov8" title="1">{
        collected := make([]*Fact, 0)

        // Obtenir la valeur du champ de jointure du fait principal
        mainValue, exists := mainFact.Fields[an.MainField]
        if !exists </span><span class="cov8" title="1">{
                // Essayer aussi dans fact.ID si c'est le champ "id"
                if an.MainField == "id" </span><span class="cov8" title="1">{
                        mainValue = mainFact.ID
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚ö†Ô∏è  ACCUMULATOR[%s]: Champ principal %s non trouv√© dans %s\n", an.ID, an.MainField, mainFact.ID)
                        return collected
                }</span>
        }

        // Parcourir tous les faits pour trouver ceux qui correspondent
        <span class="cov8" title="1">for _, fact := range an.AllFacts </span><span class="cov8" title="1">{
                if fact.Type == an.AggType </span><span class="cov8" title="1">{
                        // V√©rifier la condition de jointure
                        joinValue, exists := fact.Fields[an.JoinField]
                        if exists &amp;&amp; joinValue == mainValue </span><span class="cov8" title="1">{
                                collected = append(collected, fact)
                        }</span>
                }
        }

        <span class="cov8" title="1">return collected</span>
}

// calculateAggregateForFacts calcule la valeur agr√©g√©e pour une liste de faits
func (an *AccumulatorNode) calculateAggregateForFacts(facts []*Fact) (float64, error) <span class="cov8" title="1">{
        if len(facts) == 0 </span><span class="cov8" title="1">{
                // Pas de faits √† agr√©ger - retourner 0
                return 0, nil
        }</span>

        <span class="cov8" title="1">switch an.AggregateFunc </span>{
        case "COUNT":<span class="cov8" title="1">
                return float64(len(facts)), nil</span>

        case "SUM":<span class="cov8" title="1">
                sum := 0.0
                for _, f := range facts </span><span class="cov8" title="1">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov8" title="1">{
                                if numVal, ok := val.(float64); ok </span><span class="cov8" title="1">{
                                        sum += numVal
                                }</span>
                        }
                }
                <span class="cov8" title="1">return sum, nil</span>

        case "AVG":<span class="cov8" title="1">
                sum := 0.0
                count := 0
                for _, f := range facts </span><span class="cov8" title="1">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov8" title="1">{
                                if numVal, ok := val.(float64); ok </span><span class="cov8" title="1">{
                                        sum += numVal
                                        count++
                                }</span>
                        }
                }
                <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov8" title="1">return sum / float64(count), nil</span>

        case "MIN":<span class="cov8" title="1">
                minVal := math.MaxFloat64
                for _, f := range facts </span><span class="cov8" title="1">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov8" title="1">{
                                if numVal, ok := val.(float64); ok </span><span class="cov8" title="1">{
                                        if numVal &lt; minVal </span><span class="cov8" title="1">{
                                                minVal = numVal
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">if minVal == math.MaxFloat64 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov8" title="1">return minVal, nil</span>

        case "MAX":<span class="cov8" title="1">
                maxVal := -math.MaxFloat64
                for _, f := range facts </span><span class="cov8" title="1">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov8" title="1">{
                                if numVal, ok := val.(float64); ok </span><span class="cov8" title="1">{
                                        if numVal &gt; maxVal </span><span class="cov8" title="1">{
                                                maxVal = numVal
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">if maxVal == -math.MaxFloat64 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov8" title="1">return maxVal, nil</span>

        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("fonction d'agr√©gation non support√©e: %s", an.AggregateFunc)</span>
        }
}

// ActivateLeft traite un token venant de la gauche (compatible avec interface Node)
func (an *AccumulatorNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        // Pour AccumulatorNode, on traite le premier fait du token
        if len(token.Facts) &gt; 0 </span><span class="cov0" title="0">{
                return an.Activate(token.Facts[0], token)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ActivateRight traite un fait venant de la droite
func (an *AccumulatorNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        return an.Activate(fact, nil)
}</span>

// evaluateCondition √©value si la valeur agr√©g√©e satisfait la condition
func (an *AccumulatorNode) evaluateCondition(aggregatedValue float64) (bool, error) <span class="cov8" title="1">{
        if an.Condition == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov8" title="1">condType, ok := an.Condition["type"].(string)
        if !ok || condType != "comparison" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("type de condition invalide")
        }</span>

        <span class="cov8" title="1">operator, ok := an.Condition["operator"].(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("op√©rateur manquant")
        }</span>

        <span class="cov8" title="1">threshold, ok := an.Condition["value"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("valeur de comparaison invalide")
        }</span>

        <span class="cov8" title="1">switch operator </span>{
        case "&gt;=":<span class="cov8" title="1">
                return aggregatedValue &gt;= threshold, nil</span>
        case "&gt;":<span class="cov0" title="0">
                return aggregatedValue &gt; threshold, nil</span>
        case "&lt;=":<span class="cov0" title="0">
                return aggregatedValue &lt;= threshold, nil</span>
        case "&lt;":<span class="cov0" title="0">
                return aggregatedValue &lt; threshold, nil</span>
        case "==":<span class="cov0" title="0">
                return aggregatedValue == threshold, nil</span>
        case "!=":<span class="cov0" title="0">
                return aggregatedValue != threshold, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("op√©rateur non support√©: %s", operator)</span>
        }
}

// ActivateRetract g√®re la r√©tractation dans le n≈ìud d'agr√©gation
func (an *AccumulatorNode) ActivateRetract(factID string) error <span class="cov0" title="0">{
        an.mutex.Lock()
        defer an.mutex.Unlock()

        // Retirer des faits principaux et de tous les faits
        delete(an.MainFacts, factID)
        delete(an.AllFacts, factID)

        // Retirer des tokens
        an.Memory.RemoveToken(factID)

        fmt.Printf("üóëÔ∏è  [ACCUMULATOR_%s] R√©tractation: fait %s retir√©\n", an.ID, factID)
        return an.PropagateRetractToChildren(factID)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package rete

import (
        "fmt"
)

type AlphaNode struct {
        BaseNode
        Condition    interface{} `json:"condition"`
        VariableName string      `json:"variable_name"`
}

// NewAlphaNode cr√©e un nouveau n≈ìud alpha
func NewAlphaNode(nodeID string, condition interface{}, variableName string, storage Storage) *AlphaNode <span class="cov8" title="1">{
        return &amp;AlphaNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "alpha",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:    condition,
                VariableName: variableName,
        }
}</span>

// ActivateLeft (non utilis√© pour les n≈ìuds alpha)
func (an *AlphaNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds alpha ne re√ßoivent pas de tokens")
}</span>

// ActivateRetract retire le fait de la m√©moire alpha et propage aux enfants
// factID doit √™tre l'identifiant interne (Type_ID)
func (an *AlphaNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        an.mutex.Lock()
        _, exists := an.Memory.GetFact(factID)
        if exists </span><span class="cov8" title="1">{
                an.Memory.RemoveFact(factID)
        }</span>
        <span class="cov8" title="1">an.mutex.Unlock()
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">fmt.Printf("üóëÔ∏è  [ALPHA_%s] R√©tractation du fait: %s\n", an.ID, factID)
        return an.PropagateRetractToChildren(factID)</span>
}

// ActivateRight teste la condition sur le fait
func (an *AlphaNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ALPHA_%s] Test condition sur fait: %s\n", an.ID, fact.String())

        // Cas sp√©cial: passthrough pour les JoinNodes - pas de filtrage
        if an.Condition != nil </span><span class="cov8" title="1">{
                if condMap, ok := an.Condition.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if condType, exists := condMap["type"].(string); exists &amp;&amp; condType == "passthrough" </span><span class="cov8" title="1">{
                                // Mode pass-through: convertir le fait en token et propager selon le c√¥t√©
                                an.mutex.Lock()
                                if err := an.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                                        an.mutex.Unlock()
                                        return fmt.Errorf("erreur ajout fait dans alpha node: %w", err)
                                }</span>
                                <span class="cov8" title="1">an.mutex.Unlock() // Cr√©er un token pour le fait avec la variable correspondante
                                token := &amp;Token{
                                        ID:       fmt.Sprintf("alpha_token_%s_%s", an.ID, fact.ID),
                                        Facts:    []*Fact{fact},
                                        NodeID:   an.ID,
                                        Bindings: map[string]*Fact{an.VariableName: fact},
                                }

                                // D√©terminer le c√¥t√© et propager selon l'architecture RETE
                                side, sideExists := condMap["side"].(string)
                                if sideExists &amp;&amp; side == "left" </span><span class="cov8" title="1">{
                                        return an.PropagateToChildren(nil, token) // ActivateLeft
                                }</span> else<span class="cov8" title="1"> {
                                        return an.PropagateToChildren(fact, nil) // ActivateRight
                                }</span>
                        }
                }
        }

        // √âvaluation normale de condition Alpha
        <span class="cov0" title="0">if an.Condition != nil </span><span class="cov0" title="0">{
                evaluator := NewAlphaConditionEvaluator()
                passed, err := evaluator.EvaluateCondition(an.Condition, fact, an.VariableName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur √©valuation condition Alpha: %w", err)
                }</span>

                // Si la condition n'est pas satisfaite, ignorer le fait
                <span class="cov0" title="0">if !passed </span><span class="cov0" title="0">{
                        // Log d√©sactiv√© pour les performances
                        // fmt.Printf("[ALPHA_%s] Condition non satisfaite pour le fait: %s\n", an.ID, fact.String())
                        return nil
                }</span>
        }

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ALPHA_%s] Condition satisfaite pour le fait: %s\n", an.ID, fact.String())

        <span class="cov0" title="0">an.mutex.Lock()
        if err := an.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                an.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans alpha node: %w", err)
        }</span>
        <span class="cov0" title="0">an.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // Cr√©er un token et le propager
        token := &amp;Token{
                ID:     fmt.Sprintf("token_%s_%s", an.ID, fact.ID),
                Facts:  []*Fact{fact},
                NodeID: an.ID,
        }

        return an.PropagateToChildren(nil, token)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package rete

import (
        "fmt"
        "sync"
)

type BaseNode struct {
        ID       string         `json:"id"`
        Type     string         `json:"type"`
        Memory   *WorkingMemory `json:"memory"`
        Children []Node         `json:"children"`
        Storage  Storage        `json:"-"`
        mutex    sync.RWMutex   `json:"-"`
}

// GetID retourne l'ID du n≈ìud
func (bn *BaseNode) GetID() string <span class="cov8" title="1">{
        return bn.ID
}</span>

// GetType retourne le type du n≈ìud
func (bn *BaseNode) GetType() string <span class="cov0" title="0">{
        return bn.Type
}</span>

// GetMemory retourne la m√©moire de travail du n≈ìud
func (bn *BaseNode) GetMemory() *WorkingMemory <span class="cov8" title="1">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()
        return bn.Memory
}</span>

// AddChild ajoute un n≈ìud enfant
func (bn *BaseNode) AddChild(child Node) <span class="cov8" title="1">{
        bn.mutex.Lock()
        defer bn.mutex.Unlock()
        bn.Children = append(bn.Children, child)
}</span>

// GetChildren retourne les n≈ìuds enfants
func (bn *BaseNode) GetChildren() []Node <span class="cov8" title="1">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()
        return bn.Children
}</span>

// PropagateToChildren propage un fait ou token aux enfants
func (bn *BaseNode) PropagateToChildren(fact *Fact, token *Token) error <span class="cov8" title="1">{
        for _, child := range bn.GetChildren() </span><span class="cov8" title="1">{
                if fact != nil </span><span class="cov8" title="1">{
                        if err := child.ActivateRight(fact); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation fait vers %s: %w", child.GetID(), err)
                        }</span>
                }
                <span class="cov8" title="1">if token != nil </span><span class="cov8" title="1">{
                        if err := child.ActivateLeft(token); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation token vers %s: %w", child.GetID(), err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// PropagateRetractToChildren propage la r√©tractation d'un fait aux n≈ìuds enfants
func (bn *BaseNode) PropagateRetractToChildren(factID string) error <span class="cov8" title="1">{
        for _, child := range bn.GetChildren() </span><span class="cov8" title="1">{
                if err := child.ActivateRetract(factID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur propagation r√©tractation vers %s: %w", child.GetID(), err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SaveMemory sauvegarde la m√©moire du n≈ìud
func (bn *BaseNode) SaveMemory() error <span class="cov0" title="0">{
        if bn.Storage != nil </span><span class="cov0" title="0">{
                return bn.Storage.SaveMemory(bn.ID, bn.Memory)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package rete

import (
        "fmt"
        "sync"
)

type ExistsNode struct {
        BaseNode
        Condition       map[string]interface{} `json:"condition"`
        MainVariable    string                 `json:"main_variable"`    // Variable principale (p)
        ExistsVariable  string                 `json:"exists_variable"`  // Variable d'existence (o)
        VariableTypes   map[string]string      `json:"variable_types"`   // Mapping variable -&gt; type
        ExistsCondition []JoinCondition        `json:"exists_condition"` // Condition d'existence (o.customer_id == p.id)
        mutex           sync.RWMutex
        // M√©moires pour architecture RETE
        MainMemory   *WorkingMemory // Faits de la variable principale
        ExistsMemory *WorkingMemory // Faits pour v√©rification d'existence
        ResultMemory *WorkingMemory // Tokens avec existence v√©rifi√©e
}

// NewExistsNode cr√©e un nouveau n≈ìud d'existence
func NewExistsNode(nodeID string, condition map[string]interface{}, mainVar string, existsVar string, varTypes map[string]string, storage Storage) *ExistsNode <span class="cov8" title="1">{
        return &amp;ExistsNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "exists",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:       condition,
                MainVariable:    mainVar,
                ExistsVariable:  existsVar,
                VariableTypes:   varTypes,
                ExistsCondition: extractJoinConditions(condition),
                // Initialiser les m√©moires s√©par√©es
                MainMemory:   &amp;WorkingMemory{NodeID: nodeID + "_main", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                ExistsMemory: &amp;WorkingMemory{NodeID: nodeID + "_exists", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                ResultMemory: &amp;WorkingMemory{NodeID: nodeID + "_result", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
        }
}</span>

// ActivateLeft traite les faits de la variable principale
func (en *ExistsNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{

        // Stocker le token dans la m√©moire principale
        en.mutex.Lock()
        en.MainMemory.AddToken(token)
        en.mutex.Unlock()

        // V√©rifier s'il existe des faits correspondants
        if en.checkExistence(token) </span><span class="cov0" title="0">{

                // Stocker le token avec existence v√©rifi√©e
                token.IsJoinResult = true // Marquer comme r√©sultat valid√©
                en.mutex.Lock()
                en.ResultMemory.AddToken(token)
                en.Memory.AddToken(token) // Pour compatibilit√© avec le comptage
                en.mutex.Unlock()

                // Propager le token
                if err := en.PropagateToChildren(nil, token); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else <span class="cov0" title="0">{
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ActivateRetract retrait des tokens et faits contenant le fait r√©tract√©
// factID doit √™tre l'identifiant interne (Type_ID)
func (en *ExistsNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        en.mutex.Lock()
        var mainTokensToRemove []string
        for tokenID, token := range en.MainMemory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                mainTokensToRemove = append(mainTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range mainTokensToRemove </span><span class="cov0" title="0">{
                delete(en.MainMemory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">_, existsInExistsMemory := en.ExistsMemory.GetFact(factID)
        if existsInExistsMemory </span><span class="cov8" title="1">{
                en.ExistsMemory.RemoveFact(factID)
        }</span>
        <span class="cov8" title="1">var resultTokensToRemove []string
        for tokenID, token := range en.ResultMemory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                resultTokensToRemove = append(resultTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range resultTokensToRemove </span><span class="cov0" title="0">{
                delete(en.ResultMemory.Tokens, tokenID)
                delete(en.Memory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">en.mutex.Unlock()
        totalRemoved := len(mainTokensToRemove) + len(resultTokensToRemove)
        if existsInExistsMemory </span><span class="cov8" title="1">{
                totalRemoved++
        }</span>
        <span class="cov8" title="1">if totalRemoved &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("üóëÔ∏è  [EXISTS_%s] R√©tractation: %d √©l√©ments retir√©s (MAIN:%d EXISTS:%v RES:%d)\n", en.ID, totalRemoved, len(mainTokensToRemove), existsInExistsMemory, len(resultTokensToRemove))
        }</span>
        <span class="cov8" title="1">return en.PropagateRetractToChildren(factID)</span>
}

// ActivateRight traite les faits pour v√©rification d'existence
func (en *ExistsNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{

        // Stocker le fait dans la m√©moire d'existence
        en.mutex.Lock()
        if err := en.ExistsMemory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                en.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans exists node: %w", err)
        }</span>
        <span class="cov0" title="0">en.mutex.Unlock()

        // Re-v√©rifier tous les tokens principaux avec ce nouveau fait
        mainTokens := en.MainMemory.GetTokens()
        for _, mainToken := range mainTokens </span><span class="cov0" title="0">{
                if en.checkExistence(mainToken) &amp;&amp; !en.isAlreadyValidated(mainToken) </span><span class="cov0" title="0">{

                        // Stocker le token avec existence v√©rifi√©e
                        validatedToken := &amp;Token{
                                ID:           mainToken.ID + "_validated",
                                Facts:        mainToken.Facts,
                                NodeID:       en.ID,
                                Bindings:     mainToken.Bindings,
                                IsJoinResult: true,
                        }

                        en.mutex.Lock()
                        en.ResultMemory.AddToken(validatedToken)
                        en.Memory.AddToken(validatedToken)
                        en.mutex.Unlock()

                        // Propager le token
                        if err := en.PropagateToChildren(nil, validatedToken); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// checkExistence v√©rifie si un token principal a des faits correspondants
func (en *ExistsNode) checkExistence(mainToken *Token) bool <span class="cov0" title="0">{
        existsFacts := en.ExistsMemory.GetFacts()

        // R√©cup√©rer le fait principal du token
        if len(mainToken.Facts) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">mainFact := mainToken.Facts[0]

        // V√©rifier les conditions d'existence
        for _, existsFact := range existsFacts </span><span class="cov0" title="0">{
                if en.evaluateExistsCondition(mainFact, existsFact) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// evaluateExistsCondition √©value la condition d'existence entre deux faits
func (en *ExistsNode) evaluateExistsCondition(mainFact *Fact, existsFact *Fact) bool <span class="cov0" title="0">{

        for i, condition := range en.ExistsCondition </span><span class="cov0" title="0">{
                fmt.Printf("    Condition %d: %s.%s %s %s.%s\n", i,
                        condition.LeftVar, condition.LeftField, condition.Operator,
                        condition.RightVar, condition.RightField)

                // D√©terminer quel fait correspond √† quelle variable
                var leftFact, rightFact *Fact

                if condition.LeftVar == en.MainVariable </span><span class="cov0" title="0">{
                        leftFact = mainFact
                        rightFact = existsFact
                        fmt.Printf("    ‚Üí MainFact comme LeftVar (%s), ExistsFact comme RightVar (%s)\n", condition.LeftVar, condition.RightVar)
                }</span> else<span class="cov0" title="0"> if condition.LeftVar == en.ExistsVariable </span><span class="cov0" title="0">{
                        leftFact = existsFact
                        rightFact = mainFact
                        fmt.Printf("    ‚Üí ExistsFact comme LeftVar (%s), MainFact comme RightVar (%s)\n", condition.LeftVar, condition.RightVar)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("    ‚ùå Variable %s non trouv√©e dans MainVariable:%s ou ExistsVariable:%s\n", condition.LeftVar, en.MainVariable, en.ExistsVariable)
                        continue</span>
                }

                <span class="cov0" title="0">leftValue := leftFact.Fields[condition.LeftField]
                rightValue := rightFact.Fields[condition.RightField]

                switch condition.Operator </span>{
                case "==":<span class="cov0" title="0">
                        if leftValue != rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("    ‚ùå Condition %d √©choue: %v != %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("    ‚úÖ Condition %d r√©ussie: %v == %v\n", i, leftValue, rightValue)</span>
                case "!=":<span class="cov0" title="0">
                        if leftValue == rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("    ‚ùå Condition %d √©choue: %v == %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("    ‚úÖ Condition %d r√©ussie: %v != %v\n", i, leftValue, rightValue)</span>
                default:<span class="cov0" title="0">
                        fmt.Printf("    ‚ùå Op√©rateur non support√©: %s\n", condition.Operator)
                        return false</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("  ‚úÖ Toutes les conditions EXISTS satisfaites\n")
        return true</span>
}

// isAlreadyValidated v√©rifie si un token a d√©j√† √©t√© valid√©
func (en *ExistsNode) isAlreadyValidated(token *Token) bool <span class="cov0" title="0">{
        validatedTokens := en.ResultMemory.GetTokens()
        for _, validatedToken := range validatedTokens </span><span class="cov0" title="0">{
                if validatedToken.ID == token.ID+"_validated" || validatedToken.ID == token.ID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package rete

import (
        "fmt"
        "strconv"
        "sync"
)

type JoinNode struct {
        BaseNode
        Condition      map[string]interface{} `json:"condition"`
        LeftVariables  []string               `json:"left_variables"`
        RightVariables []string               `json:"right_variables"`
        AllVariables   []string               `json:"all_variables"`
        VariableTypes  map[string]string      `json:"variable_types"` // Nouveau: mapping variable -&gt; type
        JoinConditions []JoinCondition        `json:"join_conditions"`
        mutex          sync.RWMutex
        // M√©moires s√©par√©es pour architecture RETE propre
        LeftMemory   *WorkingMemory // Tokens venant de la gauche
        RightMemory  *WorkingMemory // Tokens venant de la droite
        ResultMemory *WorkingMemory // Tokens de jointure r√©ussie
}

// JoinCondition repr√©sente une condition de jointure entre variables
type JoinCondition struct {
        LeftField  string `json:"left_field"`  // p.id
        RightField string `json:"right_field"` // o.customer_id
        LeftVar    string `json:"left_var"`    // p
        RightVar   string `json:"right_var"`   // o
        Operator   string `json:"operator"`    // ==
}

// NewJoinNode cr√©e un nouveau n≈ìud de jointure
func NewJoinNode(nodeID string, condition map[string]interface{}, leftVars []string, rightVars []string, varTypes map[string]string, storage Storage) *JoinNode <span class="cov8" title="1">{
        allVars := append(leftVars, rightVars...)

        return &amp;JoinNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "join",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:      condition,
                LeftVariables:  leftVars,
                RightVariables: rightVars,
                AllVariables:   allVars,
                VariableTypes:  varTypes,
                JoinConditions: extractJoinConditions(condition),
                // Initialiser les m√©moires s√©par√©es
                LeftMemory:   &amp;WorkingMemory{NodeID: nodeID + "_left", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                RightMemory:  &amp;WorkingMemory{NodeID: nodeID + "_right", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                ResultMemory: &amp;WorkingMemory{NodeID: nodeID + "_result", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
        }
}</span>

// ActivateLeft traite les tokens de la gauche (g√©n√©ralement des AlphaNodes)
func (jn *JoinNode) ActivateLeft(token *Token) error <span class="cov8" title="1">{
        // Stocker le token dans la m√©moire gauche
        jn.mutex.Lock()
        jn.LeftMemory.AddToken(token)
        jn.mutex.Unlock()

        // Essayer de joindre avec tous les tokens de la m√©moire droite
        rightTokens := jn.RightMemory.GetTokens()

        for _, rightToken := range rightTokens </span><span class="cov8" title="1">{
                if joinedToken := jn.performJoinWithTokens(token, rightToken); joinedToken != nil </span><span class="cov8" title="1">{

                        // Stocker uniquement les tokens de jointure r√©ussie
                        joinedToken.IsJoinResult = true
                        jn.mutex.Lock()
                        jn.ResultMemory.AddToken(joinedToken)
                        jn.Memory.AddToken(joinedToken) // Pour compatibilit√© avec le comptage
                        jn.mutex.Unlock()

                        if err := jn.PropagateToChildren(nil, joinedToken); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ActivateRetract retrait des tokens contenant le fait r√©tract√© des 3 m√©moires
// factID doit √™tre l'identifiant interne (Type_ID)
func (jn *JoinNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        jn.mutex.Lock()
        var leftTokensToRemove []string
        for tokenID, token := range jn.LeftMemory.Tokens </span><span class="cov8" title="1">{
                for _, fact := range token.Facts </span><span class="cov8" title="1">{
                        if fact.GetInternalID() == factID </span><span class="cov8" title="1">{
                                leftTokensToRemove = append(leftTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range leftTokensToRemove </span><span class="cov8" title="1">{
                delete(jn.LeftMemory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">var rightTokensToRemove []string
        for tokenID, token := range jn.RightMemory.Tokens </span><span class="cov8" title="1">{
                for _, fact := range token.Facts </span><span class="cov8" title="1">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                rightTokensToRemove = append(rightTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range rightTokensToRemove </span><span class="cov0" title="0">{
                delete(jn.RightMemory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">var resultTokensToRemove []string
        for tokenID, token := range jn.ResultMemory.Tokens </span><span class="cov8" title="1">{
                for _, fact := range token.Facts </span><span class="cov8" title="1">{
                        if fact.GetInternalID() == factID </span><span class="cov8" title="1">{
                                resultTokensToRemove = append(resultTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range resultTokensToRemove </span><span class="cov8" title="1">{
                delete(jn.ResultMemory.Tokens, tokenID)
                delete(jn.Memory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">jn.mutex.Unlock()
        totalRemoved := len(leftTokensToRemove) + len(rightTokensToRemove) + len(resultTokensToRemove)
        if totalRemoved &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("üóëÔ∏è  [JOIN_%s] R√©tractation: %d tokens retir√©s (L:%d R:%d RES:%d)\n", jn.ID, totalRemoved, len(leftTokensToRemove), len(rightTokensToRemove), len(resultTokensToRemove))
        }</span>
        <span class="cov8" title="1">return jn.PropagateRetractToChildren(factID)</span>
}

// ActivateRight traite les faits de la droite (nouveau fait inject√© via AlphaNode)
func (jn *JoinNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // Convertir le fait en token pour la m√©moire droite
        factVar := jn.getVariableForFact(fact)
        if factVar == "" </span><span class="cov0" title="0">{
                return nil // Fait non applicable √† ce JoinNode
        }</span>

        <span class="cov8" title="1">factToken := &amp;Token{
                ID:       fmt.Sprintf("right_token_%s_%s", jn.ID, fact.ID),
                Facts:    []*Fact{fact},
                NodeID:   jn.ID,
                Bindings: map[string]*Fact{factVar: fact},
        }

        // Stocker le token dans la m√©moire droite
        jn.mutex.Lock()
        jn.RightMemory.AddToken(factToken)
        jn.mutex.Unlock()

        // Essayer de joindre avec tous les tokens de la m√©moire gauche
        leftTokens := jn.LeftMemory.GetTokens()

        for _, leftToken := range leftTokens </span><span class="cov8" title="1">{
                if joinedToken := jn.performJoinWithTokens(leftToken, factToken); joinedToken != nil </span><span class="cov8" title="1">{

                        // Stocker uniquement les tokens de jointure r√©ussie
                        joinedToken.IsJoinResult = true
                        jn.mutex.Lock()
                        jn.ResultMemory.AddToken(joinedToken)
                        jn.Memory.AddToken(joinedToken) // Pour compatibilit√© avec le comptage
                        jn.mutex.Unlock()

                        if err := jn.PropagateToChildren(nil, joinedToken); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// performJoinWithTokens effectue la jointure entre deux tokens
func (jn *JoinNode) performJoinWithTokens(token1 *Token, token2 *Token) *Token <span class="cov8" title="1">{
        // V√©rifier que les tokens ont des variables diff√©rentes
        if !jn.tokensHaveDifferentVariables(token1, token2) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Combiner les bindings des deux tokens
        <span class="cov8" title="1">combinedBindings := make(map[string]*Fact)

        // Copier les bindings du premier token
        for varName, varFact := range token1.Bindings </span><span class="cov8" title="1">{
                combinedBindings[varName] = varFact
        }</span>

        // Copier les bindings du second token
        <span class="cov8" title="1">for varName, varFact := range token2.Bindings </span><span class="cov8" title="1">{
                combinedBindings[varName] = varFact
        }</span>

        // Valider les conditions de jointure
        <span class="cov8" title="1">if !jn.evaluateJoinConditions(combinedBindings) </span><span class="cov8" title="1">{
                return nil // Jointure √©choue
        }</span>

        // Cr√©er et retourner le token joint
        <span class="cov8" title="1">return &amp;Token{
                ID:       fmt.Sprintf("%s_JOIN_%s", token1.ID, token2.ID),
                Bindings: combinedBindings,
                NodeID:   jn.ID,
                Facts:    append(token1.Facts, token2.Facts...),
        }</span>
}

// tokensHaveDifferentVariables v√©rifie que les tokens repr√©sentent des variables diff√©rentes
func (jn *JoinNode) tokensHaveDifferentVariables(token1 *Token, token2 *Token) bool <span class="cov8" title="1">{
        for var1 := range token1.Bindings </span><span class="cov8" title="1">{
                for var2 := range token2.Bindings </span><span class="cov8" title="1">{
                        if var1 == var2 </span><span class="cov0" title="0">{
                                return false // M√™me variable = pas de jointure possible
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// getVariableForFact d√©termine la variable associ√©e √† un fait bas√© sur son type
func (jn *JoinNode) getVariableForFact(fact *Fact) string <span class="cov8" title="1">{
        // Utiliser le mapping variable -&gt; type du JoinNode
        for _, varName := range jn.AllVariables </span><span class="cov8" title="1">{
                if expectedType, exists := jn.VariableTypes[varName]; exists </span><span class="cov8" title="1">{
                        if expectedType == fact.Type </span><span class="cov8" title="1">{
                                return varName
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("‚ùå JOINNODE[%s]: Aucune variable trouv√©e pour fait %s (type: %s)\n", jn.ID, fact.ID, fact.Type)
        fmt.Printf("   Variables disponibles: %v\n", jn.AllVariables)
        fmt.Printf("   Types attendus: %v\n", jn.VariableTypes)
        return ""</span>
}

// evaluateJoinConditions v√©rifie si toutes les conditions de jointure sont respect√©es
func (jn *JoinNode) evaluateJoinConditions(bindings map[string]*Fact) bool <span class="cov8" title="1">{
        for varName, fact := range bindings </span><span class="cov8" title="1">{
                fmt.Printf("    %s -&gt; %s (ID: %s)\n", varName, fact.Type, fact.ID)
        }</span>
        <span class="cov8" title="1">for i, condition := range jn.JoinConditions </span><span class="cov8" title="1">{
                fmt.Printf("    Condition %d: %s.%s %s %s.%s\n", i,
                        condition.LeftVar, condition.LeftField, condition.Operator,
                        condition.RightVar, condition.RightField)
        }</span>

        // V√©rifier qu'on a au moins 2 variables diff√©rentes
        <span class="cov8" title="1">if len(bindings) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Printf("  ‚ùå Pas assez de variables (%d &lt; 2)\n", len(bindings))
                return false
        }</span>

        // NOUVEAU: √âvaluer la condition compl√®te qui peut contenir des expressions arithm√©tiques
        <span class="cov8" title="1">if jn.Condition != nil </span><span class="cov8" title="1">{
                evaluator := NewAlphaConditionEvaluator()
                // Activer le mode d'√©valuation partielle pour les jointures en cascade
                // o√π toutes les variables ne sont pas encore disponibles
                evaluator.SetPartialEvalMode(true)

                // Lier toutes les variables aux faits
                for varName, fact := range bindings </span><span class="cov8" title="1">{
                        evaluator.variableBindings[varName] = fact
                }</span>

                <span class="cov8" title="1">result, err := evaluator.evaluateExpression(jn.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">return result</span>
        }

        // LEGACY: √âvaluer les conditions de jointure extraites (simples comparaisons)
        // Note: Ce code est maintenant redondant si jn.Condition est √©valu√© ci-dessus,
        // mais conserv√© pour compatibilit√© avec les anciens tests
        <span class="cov0" title="0">for i, joinCondition := range jn.JoinConditions </span><span class="cov0" title="0">{
                leftFact := bindings[joinCondition.LeftVar]
                rightFact := bindings[joinCondition.RightVar]

                if leftFact == nil || rightFact == nil </span><span class="cov0" title="0">{
                        fmt.Printf("  ‚ùå Condition %d: variable manquante (%s ou %s)\n", i, joinCondition.LeftVar, joinCondition.RightVar)
                        return false // Une variable manque
                }</span>

                // R√©cup√©rer les valeurs des champs
                <span class="cov0" title="0">leftValue := leftFact.Fields[joinCondition.LeftField]
                rightValue := rightFact.Fields[joinCondition.RightField]

                // √âvaluer l'op√©rateur
                switch joinCondition.Operator </span>{
                case "==":<span class="cov0" title="0">
                        if leftValue != rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚ùå Condition %d √©choue: %v != %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  ‚úÖ Condition %d r√©ussie: %v == %v\n", i, leftValue, rightValue)</span>
                case "!=":<span class="cov0" title="0">
                        if leftValue == rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚ùå Condition %d √©choue: %v == %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  ‚úÖ Condition %d r√©ussie: %v != %v\n", i, leftValue, rightValue)</span>
                case "&lt;":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &gt;= rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false // Comparaison num√©rique impossible
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                case "&gt;":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &lt;= rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                case "&lt;=":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &gt; rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                case "&gt;=":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &lt; rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                default:<span class="cov0" title="0">
                        return false</span> // Op√©rateur non support√©
                }
        }

        <span class="cov0" title="0">return true</span> // Toutes les conditions sont satisfaites
}

// convertToFloat64 tente de convertir une valeur en float64
func convertToFloat64(value interface{}) (float64, bool) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, true</span>
        case float32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int:<span class="cov0" title="0">
                return float64(v), true</span>
        case int32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int64:<span class="cov0" title="0">
                return float64(v), true</span>
        case string:<span class="cov0" title="0">
                if f, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov0" title="0">{
                        return f, true
                }</span>
                <span class="cov0" title="0">return 0, false</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

// extractJoinConditions extrait les conditions de jointure d'une condition complexe
func extractJoinConditions(condition map[string]interface{}) []JoinCondition <span class="cov8" title="1">{
        for key, value := range condition </span><span class="cov8" title="1">{
                fmt.Printf("    %s: %v (type: %T)\n", key, value, value)
        }</span>

        <span class="cov8" title="1">var joinConditions []JoinCondition

        // Cas 1: condition wrapp√©e dans un type "constraint"
        if conditionType, exists := condition["type"].(string); exists &amp;&amp; conditionType == "constraint" </span><span class="cov8" title="1">{
                if innerCondition, ok := condition["constraint"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        fmt.Printf("  ‚úÖ Sous-condition extraite, analyse r√©cursive\n")
                        return extractJoinConditions(innerCondition)
                }</span>
        }

        // Cas 2: condition EXISTS avec array de conditions
        <span class="cov8" title="1">if conditionType, exists := condition["type"].(string); exists &amp;&amp; conditionType == "exists" </span><span class="cov0" title="0">{
                if conditionsData, ok := condition["conditions"].([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                        fmt.Printf("  ‚úÖ Array de conditions EXISTS trouv√©: %d conditions\n", len(conditionsData))
                        for _, subCondition := range conditionsData </span><span class="cov0" title="0">{
                                subJoinConditions := extractJoinConditions(subCondition)
                                joinConditions = append(joinConditions, subJoinConditions...)
                        }</span>
                        <span class="cov0" title="0">return joinConditions</span>
                }
        }

        // Cas 3: condition directe de comparaison
        <span class="cov8" title="1">if conditionType, exists := condition["type"].(string); exists &amp;&amp; conditionType == "comparison" </span><span class="cov8" title="1">{
                fmt.Printf("  ‚úÖ Condition de comparaison d√©tect√©e\n")
                if left, leftOk := condition["left"].(map[string]interface{}); leftOk </span><span class="cov8" title="1">{
                        if right, rightOk := condition["right"].(map[string]interface{}); rightOk </span><span class="cov8" title="1">{
                                fmt.Printf("  ‚úÖ Left et Right extraits\n")
                                if leftType, _ := left["type"].(string); leftType == "fieldAccess" </span><span class="cov8" title="1">{
                                        if rightType, _ := right["type"].(string); rightType == "fieldAccess" </span><span class="cov8" title="1">{
                                                // Condition de jointure d√©tect√©e
                                                fmt.Printf("  ‚úÖ Condition de jointure fieldAccess d√©tect√©e\n")
                                                leftObj, _ := left["object"].(string)
                                                leftField, _ := left["field"].(string)
                                                rightObj, _ := right["object"].(string)
                                                rightField, _ := right["field"].(string)
                                                operator, _ := condition["operator"].(string)

                                                fmt.Printf("    üìå %s.%s %s %s.%s\n", leftObj, leftField, operator, rightObj, rightField)

                                                joinConditions = append(joinConditions, JoinCondition{
                                                        LeftField:  leftField,
                                                        RightField: rightField,
                                                        LeftVar:    leftObj,
                                                        RightVar:   rightObj,
                                                        Operator:   operator,
                                                })
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return joinConditions</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package rete

import (
        "fmt"
)

type RootNode struct {
        BaseNode
}

// NewRootNode cr√©e un nouveau n≈ìud racine
func NewRootNode(storage Storage) *RootNode <span class="cov8" title="1">{
        return &amp;RootNode{
                BaseNode: BaseNode{
                        ID:       "root",
                        Type:     "root",
                        Memory:   &amp;WorkingMemory{NodeID: "root", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
        }
}</span>

// ActivateLeft (non utilis√© pour le n≈ìud racine)
func (rn *RootNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("le n≈ìud racine ne peut pas recevoir de tokens")
}</span>

// ActivateRetract retire le fait de la m√©moire racine et propage aux enfants
func (rn *RootNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        rn.mutex.Lock()
        rn.Memory.RemoveFact(factID)
        rn.mutex.Unlock()
        fmt.Printf("üóëÔ∏è  [ROOT] R√©tractation du fait: %s\n", factID)
        return rn.PropagateRetractToChildren(factID)
}</span>

// ActivateRight distribue les faits aux n≈ìuds de type
func (rn *RootNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        rn.mutex.Lock()
        if err := rn.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                rn.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans root node: %w", err)
        }</span>
        <span class="cov8" title="1">rn.mutex.Unlock()

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ROOT] Re√ßu fait: %s\n", fact.String())

        // Persistance d√©sactiv√©e pour les performances

        // Propager aux enfants (TypeNodes)
        return rn.PropagateToChildren(fact, nil)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package rete

import (
        "fmt"
)

type TerminalNode struct {
        BaseNode
        Action *Action `json:"action"`
}

// NewTerminalNode cr√©e un nouveau n≈ìud terminal
func NewTerminalNode(nodeID string, action *Action, storage Storage) *TerminalNode <span class="cov8" title="1">{
        return &amp;TerminalNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "terminal",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0), // Les n≈ìuds terminaux n'ont pas d'enfants
                        Storage:  storage,
                },
                Action: action,
        }
}</span>

// ActivateLeft d√©clenche l'action
func (tn *TerminalNode) ActivateLeft(token *Token) error <span class="cov8" title="1">{
        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[TERMINAL_%s] D√©clenchement action avec token: %s\n", tn.ID, token.ID)

        // Stocker le token
        tn.mutex.Lock()
        if tn.Memory.Tokens == nil </span><span class="cov0" title="0">{
                tn.Memory.Tokens = make(map[string]*Token)
        }</span>
        <span class="cov8" title="1">tn.Memory.Tokens[token.ID] = token
        tn.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // D√©clencher l'action
        return tn.executeAction(token)</span>
}

// ActivateRetract retrait des tokens contenant le fait r√©tract√©
// factID doit √™tre l'identifiant interne (Type_ID)
func (tn *TerminalNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        tn.mutex.Lock()
        var tokensToRemove []string
        for tokenID, token := range tn.Memory.Tokens </span><span class="cov8" title="1">{
                for _, fact := range token.Facts </span><span class="cov8" title="1">{
                        if fact.GetInternalID() == factID </span><span class="cov8" title="1">{
                                tokensToRemove = append(tokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, tokenID := range tokensToRemove </span><span class="cov8" title="1">{
                delete(tn.Memory.Tokens, tokenID)
        }</span>
        <span class="cov8" title="1">tn.mutex.Unlock()
        if len(tokensToRemove) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("üóëÔ∏è  [TERMINAL_%s] R√©tractation: %d tokens retir√©s\n", tn.ID, len(tokensToRemove))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetTriggeredActions retourne les actions d√©clench√©es (pour les tests)
func (tn *TerminalNode) GetTriggeredActions() []*Action <span class="cov0" title="0">{
        tn.mutex.RLock()
        defer tn.mutex.RUnlock()

        actions := make([]*Action, 0, len(tn.Memory.Tokens))
        for range tn.Memory.Tokens </span><span class="cov0" title="0">{
                actions = append(actions, tn.Action)
        }</span>
        <span class="cov0" title="0">return actions</span>
}

// ActivateRight (non utilis√© pour les n≈ìuds terminaux)
func (tn *TerminalNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds terminaux ne re√ßoivent pas de faits directement")
}</span>

// executeAction affiche l'action d√©clench√©e avec les faits d√©clencheurs (version tuple-space)
func (tn *TerminalNode) executeAction(token *Token) error <span class="cov8" title="1">{
        // Les actions sont maintenant obligatoires dans la grammaire
        // Mais nous gardons cette v√©rification par s√©curit√©
        if tn.Action == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune action d√©finie pour le n≈ìud %s", tn.ID)
        }</span>

        // === VERSION TUPLE-SPACE ===
        // Au lieu d'ex√©cuter l'action, on l'affiche avec les faits d√©clencheurs
        // Les agents du tuple-space viendront "prendre" ces tuples plus tard

        <span class="cov8" title="1">actionName := tn.Action.Job.Name
        fmt.Printf("üéØ ACTION DISPONIBLE DANS TUPLE-SPACE: %s", actionName)

        // Afficher les faits d√©clencheurs entre parenth√®ses
        if len(token.Facts) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Print(" (")
                for i, fact := range token.Facts </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                fmt.Print(", ")
                        }</span>
                        // Format compact : Type(id:value, field:value, ...)
                        <span class="cov8" title="1">fmt.Printf("%s(", fact.Type)
                        fieldCount := 0
                        for key, value := range fact.Fields </span><span class="cov8" title="1">{
                                if fieldCount &gt; 0 </span><span class="cov8" title="1">{
                                        fmt.Print(", ")
                                }</span>
                                <span class="cov8" title="1">fmt.Printf("%s:%v", key, value)
                                fieldCount++</span>
                        }
                        <span class="cov8" title="1">fmt.Print(")")</span>
                }
                <span class="cov8" title="1">fmt.Print(")")</span>
        }
        <span class="cov8" title="1">fmt.Println()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package rete

import (
        "fmt"
)

type TypeNode struct {
        BaseNode
        TypeName       string         `json:"type_name"`
        TypeDefinition TypeDefinition `json:"type_definition"`
}

// NewTypeNode cr√©e un nouveau n≈ìud de type
func NewTypeNode(typeName string, typeDef TypeDefinition, storage Storage) *TypeNode <span class="cov8" title="1">{
        return &amp;TypeNode{
                BaseNode: BaseNode{
                        ID:       fmt.Sprintf("type_%s", typeName),
                        Type:     "type",
                        Memory:   &amp;WorkingMemory{NodeID: fmt.Sprintf("type_%s", typeName), Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                TypeName:       typeName,
                TypeDefinition: typeDef,
        }
}</span>

// ActivateLeft (non utilis√© pour les n≈ìuds de type)
func (tn *TypeNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds de type ne re√ßoivent pas de tokens")
}</span>

// ActivateRetract retire le fait de la m√©moire de type et propage aux enfants
// factID doit √™tre l'identifiant interne (Type_ID)
func (tn *TypeNode) ActivateRetract(factID string) error <span class="cov8" title="1">{
        tn.mutex.Lock()
        _, exists := tn.Memory.GetFact(factID)
        if exists </span><span class="cov8" title="1">{
                tn.Memory.RemoveFact(factID)
        }</span>
        <span class="cov8" title="1">tn.mutex.Unlock()
        if !exists </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">fmt.Printf("üóëÔ∏è  [TYPE_%s] R√©tractation du fait: %s\n", tn.ID, factID)
        return tn.PropagateRetractToChildren(factID)</span>
}

// ActivateRight filtre les faits par type et les propage
func (tn *TypeNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // V√©rifier si le fait correspond au type de ce n≈ìud
        if fact.Type != tn.TypeName </span><span class="cov8" title="1">{
                return nil // Ignorer silencieusement les faits d'autres types
        }</span>

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[TYPE_%s] Re√ßu fait: %s\n", tn.TypeName, fact.String())

        // Valider les champs du fait
        <span class="cov8" title="1">if err := tn.validateFact(fact); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation du fait √©chou√©e: %w", err)
        }</span>

        <span class="cov8" title="1">tn.mutex.Lock()
        if err := tn.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                tn.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans type node: %w", err)
        }</span>
        <span class="cov8" title="1">tn.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // Propager aux enfants (AlphaNodes)
        return tn.PropagateToChildren(fact, nil)</span>
}

// validateFact valide qu'un fait respecte la d√©finition de type
func (tn *TypeNode) validateFact(fact *Fact) error <span class="cov8" title="1">{
        for _, field := range tn.TypeDefinition.Fields </span><span class="cov8" title="1">{
                // Le champ "id" est stock√© dans fact.ID, pas dans Fields
                if field.Name == "id" </span><span class="cov8" title="1">{
                        if fact.ID == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("champ manquant: %s", field.Name)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">value, exists := fact.Fields[field.Name]
                if !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ manquant: %s", field.Name)
                }</span>

                // Validation basique des types
                <span class="cov8" title="1">if !tn.isValidType(value, field.Type) </span><span class="cov0" title="0">{
                        return fmt.Errorf("type invalide pour le champ %s: attendu %s", field.Name, field.Type)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// isValidType v√©rifie si une valeur correspond au type attendu
func (tn *TypeNode) isValidType(value interface{}, expectedType string) bool <span class="cov8" title="1">{
        switch expectedType </span>{
        case "string":<span class="cov8" title="1">
                _, ok := value.(string)
                return ok</span>
        case "number":<span class="cov8" title="1">
                switch value.(type) </span>{
                case int, int32, int64, float32, float64:<span class="cov8" title="1">
                        return true</span>
                }
                <span class="cov0" title="0">return false</span>
        case "bool":<span class="cov0" title="0">
                _, ok := value.(bool)
                return ok</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package rete

import (
        "encoding/json"
        "fmt"
        "sync"
)

// MemoryStorage impl√©mente Storage en m√©moire (pour les tests)
type MemoryStorage struct {
        memories map[string]*WorkingMemory
        mutex    sync.RWMutex
}

// NewMemoryStorage cr√©e un nouveau storage en m√©moire
func NewMemoryStorage() *MemoryStorage <span class="cov8" title="1">{
        return &amp;MemoryStorage{
                memories: make(map[string]*WorkingMemory),
        }
}</span>

// SaveMemory sauvegarde en m√©moire
func (ms *MemoryStorage) SaveMemory(nodeID string, memory *WorkingMemory) error <span class="cov8" title="1">{
        ms.mutex.Lock()
        defer ms.mutex.Unlock()

        // Copier la m√©moire pour √©viter les modifications concurrentes
        data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var copyMemory WorkingMemory
        err = json.Unmarshal(data, &amp;copyMemory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ms.memories[nodeID] = &amp;copyMemory
        return nil</span>
}

// LoadMemory charge depuis la m√©moire
func (ms *MemoryStorage) LoadMemory(nodeID string) (*WorkingMemory, error) <span class="cov8" title="1">{
        ms.mutex.RLock()
        defer ms.mutex.RUnlock()

        memory, exists := ms.memories[nodeID]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("m√©moire non trouv√©e pour le n≈ìud %s", nodeID)
        }</span>

        // Retourner une copie
        <span class="cov8" title="1">data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var copyMemory WorkingMemory
        err = json.Unmarshal(data, &amp;copyMemory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;copyMemory, nil</span>
}

// DeleteMemory supprime de la m√©moire
func (ms *MemoryStorage) DeleteMemory(nodeID string) error <span class="cov8" title="1">{
        ms.mutex.Lock()
        defer ms.mutex.Unlock()
        delete(ms.memories, nodeID)
        return nil
}</span>

// ListNodes liste les n≈ìuds en m√©moire
func (ms *MemoryStorage) ListNodes() ([]string, error) <span class="cov8" title="1">{
        ms.mutex.RLock()
        defer ms.mutex.RUnlock()

        nodes := make([]string, 0, len(ms.memories))
        for nodeID := range ms.memories </span><span class="cov8" title="1">{
                nodes = append(nodes, nodeID)
        }</span>
        <span class="cov8" title="1">return nodes, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package rete

import (
        "fmt"
        "sync"
        "time"
)

// IndexedFactStorage fournit un stockage index√© pour les faits
type IndexedFactStorage struct {
        // Index principal par ID de fait
        factsByID map[string]*Fact

        // Index par type de fait
        factsByType map[string]map[string]*Fact

        // Index par propri√©t√©s de fait (champ -&gt; valeur -&gt; faits)
        factsByField map[string]map[interface{}]map[string]*Fact

        // Index composite pour les jointures fr√©quentes
        compositeIndex map[string]map[string]*Fact

        // Statistiques d'utilisation pour optimiser les index
        accessStats map[string]int64

        // Verrou pour la concurrence
        mutex sync.RWMutex

        // Configuration des index
        config IndexConfig
}

// IndexConfig configure les options d'indexation
type IndexConfig struct {
        // Champs √† indexer automatiquement
        IndexedFields []string

        // Taille maximale du cache
        MaxCacheSize int

        // TTL pour les entr√©es de cache
        CacheTTL time.Duration

        // Activer les index composites
        EnableCompositeIndex bool

        // Seuil pour cr√©er des index automatiques
        AutoIndexThreshold int64
}

// NewIndexedFactStorage cr√©e un nouveau stockage index√©
func NewIndexedFactStorage(config IndexConfig) *IndexedFactStorage <span class="cov8" title="1">{
        return &amp;IndexedFactStorage{
                factsByID:      make(map[string]*Fact),
                factsByType:    make(map[string]map[string]*Fact),
                factsByField:   make(map[string]map[interface{}]map[string]*Fact),
                compositeIndex: make(map[string]map[string]*Fact),
                accessStats:    make(map[string]int64),
                config:         config,
        }
}</span>

// StoreFact stocke un fait avec indexation automatique
func (ifs *IndexedFactStorage) StoreFact(fact *Fact) error <span class="cov8" title="1">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        // Stocker dans l'index principal
        ifs.factsByID[fact.ID] = fact

        // Indexer par type
        if ifs.factsByType[fact.Type] == nil </span><span class="cov8" title="1">{
                ifs.factsByType[fact.Type] = make(map[string]*Fact)
        }</span>
        <span class="cov8" title="1">ifs.factsByType[fact.Type][fact.ID] = fact

        // Indexer par champs configur√©s
        for _, fieldName := range ifs.config.IndexedFields </span><span class="cov8" title="1">{
                if value, exists := fact.Fields[fieldName]; exists </span><span class="cov8" title="1">{
                        ifs.indexFieldValue(fieldName, value, fact)
                }</span>
        }

        // Indexer par tous les champs si activ√©
        <span class="cov8" title="1">for fieldName, value := range fact.Fields </span><span class="cov8" title="1">{
                ifs.indexFieldValue(fieldName, value, fact)
        }</span>

        // Cr√©er des index composites si activ√©
        <span class="cov8" title="1">if ifs.config.EnableCompositeIndex </span><span class="cov8" title="1">{
                ifs.createCompositeIndexes(fact)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// indexFieldValue indexe une valeur de champ
func (ifs *IndexedFactStorage) indexFieldValue(fieldName string, value interface{}, fact *Fact) <span class="cov8" title="1">{
        if ifs.factsByField[fieldName] == nil </span><span class="cov8" title="1">{
                ifs.factsByField[fieldName] = make(map[interface{}]map[string]*Fact)
        }</span>
        <span class="cov8" title="1">if ifs.factsByField[fieldName][value] == nil </span><span class="cov8" title="1">{
                ifs.factsByField[fieldName][value] = make(map[string]*Fact)
        }</span>
        <span class="cov8" title="1">ifs.factsByField[fieldName][value][fact.ID] = fact</span>
}

// createCompositeIndexes cr√©e des index composites pour les jointures fr√©quentes
func (ifs *IndexedFactStorage) createCompositeIndexes(fact *Fact) <span class="cov8" title="1">{
        // Cr√©er des cl√©s composites pour des combinaisons communes
        if id, hasID := fact.Fields["id"]; hasID </span><span class="cov8" title="1">{
                if name, hasName := fact.Fields["name"]; hasName </span><span class="cov8" title="1">{
                        compositeKey := fmt.Sprintf("id_name:%v_%v", id, name)
                        if ifs.compositeIndex[compositeKey] == nil </span><span class="cov8" title="1">{
                                ifs.compositeIndex[compositeKey] = make(map[string]*Fact)
                        }</span>
                        <span class="cov8" title="1">ifs.compositeIndex[compositeKey][fact.ID] = fact</span>
                }
        }
}

// GetFactByID r√©cup√®re un fait par son ID
func (ifs *IndexedFactStorage) GetFactByID(id string) (*Fact, bool) <span class="cov8" title="1">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        ifs.recordAccess("id:" + id)

        fact, exists := ifs.factsByID[id]
        return fact, exists
}</span>

// GetFactsByType r√©cup√®re tous les faits d'un type donn√©
func (ifs *IndexedFactStorage) GetFactsByType(factType string) []*Fact <span class="cov8" title="1">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        ifs.recordAccess("type:" + factType)

        factsMap, exists := ifs.factsByType[factType]
        if !exists </span><span class="cov8" title="1">{
                return []*Fact{}
        }</span>

        <span class="cov8" title="1">facts := make([]*Fact, 0, len(factsMap))
        for _, fact := range factsMap </span><span class="cov8" title="1">{
                facts = append(facts, fact)
        }</span>

        <span class="cov8" title="1">return facts</span>
}

// GetFactsByField r√©cup√®re des faits par valeur de champ
func (ifs *IndexedFactStorage) GetFactsByField(fieldName string, value interface{}) []*Fact <span class="cov8" title="1">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        accessKey := fmt.Sprintf("field:%s:%v", fieldName, value)
        ifs.recordAccess(accessKey)

        fieldIndex, exists := ifs.factsByField[fieldName]
        if !exists </span><span class="cov8" title="1">{
                return []*Fact{}
        }</span>

        <span class="cov8" title="1">factsMap, exists := fieldIndex[value]
        if !exists </span><span class="cov8" title="1">{
                return []*Fact{}
        }</span>

        <span class="cov8" title="1">facts := make([]*Fact, 0, len(factsMap))
        for _, fact := range factsMap </span><span class="cov8" title="1">{
                facts = append(facts, fact)
        }</span>

        <span class="cov8" title="1">return facts</span>
}

// GetFactsByCompositeKey r√©cup√®re des faits par cl√© composite
func (ifs *IndexedFactStorage) GetFactsByCompositeKey(key string) []*Fact <span class="cov8" title="1">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        ifs.recordAccess("composite:" + key)

        factsMap, exists := ifs.compositeIndex[key]
        if !exists </span><span class="cov8" title="1">{
                return []*Fact{}
        }</span>

        <span class="cov8" title="1">facts := make([]*Fact, 0, len(factsMap))
        for _, fact := range factsMap </span><span class="cov8" title="1">{
                facts = append(facts, fact)
        }</span>

        <span class="cov8" title="1">return facts</span>
}

// RemoveFact supprime un fait et met √† jour les index
func (ifs *IndexedFactStorage) RemoveFact(factID string) bool <span class="cov8" title="1">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        fact, exists := ifs.factsByID[factID]
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>

        // Supprimer de l'index principal
        <span class="cov8" title="1">delete(ifs.factsByID, factID)

        // Supprimer de l'index par type
        if typeMap := ifs.factsByType[fact.Type]; typeMap != nil </span><span class="cov8" title="1">{
                delete(typeMap, factID)
                if len(typeMap) == 0 </span><span class="cov8" title="1">{
                        delete(ifs.factsByType, fact.Type)
                }</span>
        }

        // Supprimer des index par champ
        <span class="cov8" title="1">for fieldName, value := range fact.Fields </span><span class="cov8" title="1">{
                if fieldIndex := ifs.factsByField[fieldName]; fieldIndex != nil </span><span class="cov8" title="1">{
                        if valueMap := fieldIndex[value]; valueMap != nil </span><span class="cov8" title="1">{
                                delete(valueMap, factID)
                                if len(valueMap) == 0 </span><span class="cov8" title="1">{
                                        delete(fieldIndex, value)
                                        if len(fieldIndex) == 0 </span><span class="cov8" title="1">{
                                                delete(ifs.factsByField, fieldName)
                                        }</span>
                                }
                        }
                }
        }

        // Supprimer des index composites
        <span class="cov8" title="1">ifs.removeFromCompositeIndexes(fact)

        return true</span>
}

// removeFromCompositeIndexes supprime le fait des index composites
func (ifs *IndexedFactStorage) removeFromCompositeIndexes(fact *Fact) <span class="cov8" title="1">{
        // Supprimer des cl√©s composites
        if id, hasID := fact.Fields["id"]; hasID </span><span class="cov8" title="1">{
                if name, hasName := fact.Fields["name"]; hasName </span><span class="cov8" title="1">{
                        compositeKey := fmt.Sprintf("id_name:%v_%v", id, name)
                        if compositeMap := ifs.compositeIndex[compositeKey]; compositeMap != nil </span><span class="cov8" title="1">{
                                delete(compositeMap, fact.ID)
                                if len(compositeMap) == 0 </span><span class="cov8" title="1">{
                                        delete(ifs.compositeIndex, compositeKey)
                                }</span>
                        }
                }
        }
}

// recordAccess enregistre un acc√®s pour les statistiques
func (ifs *IndexedFactStorage) recordAccess(key string) <span class="cov8" title="1">{
        ifs.accessStats[key]++

        // Cr√©er automatiquement des index pour les acc√®s fr√©quents
        if ifs.accessStats[key] &gt; ifs.config.AutoIndexThreshold </span>{<span class="cov8" title="1">
                // Logique pour cr√©er des index automatiques bas√©s sur les patterns d'acc√®s
        }</span>
}

// GetAccessStats retourne les statistiques d'acc√®s
func (ifs *IndexedFactStorage) GetAccessStats() map[string]int64 <span class="cov8" title="1">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        stats := make(map[string]int64)
        for key, count := range ifs.accessStats </span><span class="cov8" title="1">{
                stats[key] = count
        }</span>

        <span class="cov8" title="1">return stats</span>
}

// OptimizeIndexes optimise les index bas√©s sur les statistiques d'usage
func (ifs *IndexedFactStorage) OptimizeIndexes() <span class="cov8" title="1">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        // Analyser les patterns d'acc√®s fr√©quents
        for _, count := range ifs.accessStats </span><span class="cov8" title="1">{
                if count &gt; ifs.config.AutoIndexThreshold </span>{<span class="cov8" title="1">
                        // Cr√©er des index optimis√©s pour cet acc√®s
                        // Cette logique peut √™tre √©tendue selon les besoins
                }</span>
        }
}

// Clear vide tous les index et statistiques
func (ifs *IndexedFactStorage) Clear() <span class="cov8" title="1">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        ifs.factsByID = make(map[string]*Fact)
        ifs.factsByType = make(map[string]map[string]*Fact)
        ifs.factsByField = make(map[string]map[interface{}]map[string]*Fact)
        ifs.compositeIndex = make(map[string]map[string]*Fact)
        ifs.accessStats = make(map[string]int64)
}</span>

// Size retourne le nombre total de faits stock√©s
func (ifs *IndexedFactStorage) Size() int <span class="cov8" title="1">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        return len(ifs.factsByID)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
