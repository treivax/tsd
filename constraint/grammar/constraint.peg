// Grammaire PEG Complète et Cohérente avec le Réseau RETE
// Cette grammaire supporte tous les constructs nécessaires pour une intégration complète
// avec les noeuds du réseau RETE : AlphaNode, BetaNode, NotNode, ExistsNode, AccumulateNode, TerminalNode
//
// Commande pour générer le parser: pigeon -o parser.go constraint.peg
{
package constraint

import (
    "fmt"
    "strconv"
    "strings"
)
}

Start <- _ statements:StatementList _ EOF {
    // Séparer types, actions, expressions, faits, retractions, ruleRemovals et reset
    types := []interface{}{}
    actions := []interface{}{}
    expressions := []interface{}{}
    facts := []interface{}{}
    retractions := []interface{}{}
    ruleRemovals := []interface{}{}
    resets := []interface{}{}

    if statements != nil {
        for _, stmt := range statements.([]interface{}) {
            if stmtMap, ok := stmt.(map[string]interface{}); ok {
                if stmtMap["type"] == "typeDefinition" {
                    types = append(types, stmt)
                } else if stmtMap["type"] == "actionDefinition" {
                    actions = append(actions, stmt)
                } else if stmtMap["type"] == "expression" {
                    expressions = append(expressions, stmt)
                } else if stmtMap["type"] == "fact" {
                    facts = append(facts, stmt)
                } else if stmtMap["type"] == "retraction" {
                    retractions = append(retractions, stmt)
                } else if stmtMap["type"] == "ruleRemoval" {
                    ruleRemovals = append(ruleRemovals, stmt)
                } else if stmtMap["type"] == "reset" {
                    resets = append(resets, stmt)
                }
            }
        }
    }

    return map[string]interface{}{
        "types": types,
        "actions": actions,
        "expressions": expressions,
        "facts": facts,
        "retractions": retractions,
        "ruleRemovals": ruleRemovals,
        "resets": resets,
    }, nil
}

StatementList <- statements:(Statement _)* {
    result := []interface{}{}
    if statements != nil {
        for _, stmt := range statements.([]interface{}) {
            result = append(result, stmt.([]interface{})[0])
        }
    }
    return result, nil
}

Statement <- TypeDefinition / ActionDefinition / Expression / RemoveRule / RemoveFact / Fact / Reset

Reset <- "reset" {
    return map[string]interface{}{
        "type": "reset",
    }, nil
}

TypeDefinition <- "type" _ name:IdentName _ "(" _ fields:FieldList _ ")" {
    return map[string]interface{}{
        "type": "typeDefinition",
        "name": name,
        "fields": fields,
    }, nil
}

FieldList <- first:Field rest:(_ "," _ Field)* {
    fields := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            fields = append(fields, item.([]interface{})[3])
        }
    }
    return fields, nil
}

Field <- name:IdentName _ ":" _ fieldType:FieldType {
    return map[string]interface{}{
        "name": name,
        "type": fieldType,
    }, nil
}

FieldType <- "string" { return "string", nil } /
             "number" { return "number", nil } /
             "bool"   { return "bool", nil }

ActionDefinition <- "action" _ name:IdentName _ "(" _ params:ParameterList? _ ")" {
    if params == nil {
        params = []interface{}{}
    }
    return map[string]interface{}{
        "type": "actionDefinition",
        "name": name,
        "parameters": params,
    }, nil
}

ParameterList <- first:Parameter rest:(_ "," _ Parameter)* {
    parameters := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            parameters = append(parameters, item.([]interface{})[3])
        }
    }
    return parameters, nil
}

Parameter <- name:IdentName _ ":" _ paramType:ParameterType optional:"?"? _ defaultValue:(_ "=" _ ParameterDefaultValue)? {
    result := map[string]interface{}{
        "name": name,
        "type": paramType,
        "optional": optional != nil,
    }
    if defaultValue != nil {
        result["defaultValue"] = defaultValue.([]interface{})[3]
    }
    return result, nil
}

ParameterType <- IdentName { return string(c.text), nil }

ParameterDefaultValue <- Number / StringLiteral / BooleanLiteral

Expression <- "rule" _ ruleId:IdentName _ ":" _ patterns:PatternBlocks _ "/" _ constraints:Constraints _ "==>" _ action:Action {
    // If only one pattern block, use old structure for backward compatibility
    patternList := patterns.([]interface{})
    if len(patternList) == 1 {
        return map[string]interface{}{
            "type": "expression",
            "ruleId": ruleId,
            "set": patternList[0],
            "constraints": constraints,
            "action": action,
        }, nil
    }

    // Multiple pattern blocks (aggregation with joins)
    return map[string]interface{}{
        "type": "expression",
        "ruleId": ruleId,
        "patterns": patterns,
        "constraints": constraints,
        "action": action,
    }, nil
}

PatternBlocks <- first:Set rest:(_ "/" _ Set)* {
    blocks := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            blocks = append(blocks, item.([]interface{})[3])
        }
    }
    return blocks, nil
}

Set <- "{" _ variables:TypedVariableList _ "}" {
    return map[string]interface{}{
        "type": "set",
        "variables": variables,
    }, nil
}

TypedVariableList <- first:TypedVariable rest:(_ "," _ TypedVariable)* {
    variables := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            variables = append(variables, item.([]interface{})[3])
        }
    }
    return variables, nil
}

TypedVariable <- AggregationVariable / SimpleTypedVariable

SimpleTypedVariable <- name:IdentName _ ":" _ dataType:IdentName {
    return map[string]interface{}{
        "type": "typedVariable",
        "name": name,
        "dataType": dataType,
    }, nil
}

AggregationVariable <- name:IdentName _ ":" _ aggFunc:AccumulateFunction _ "(" _ fieldAccess:FieldAccess _ ")" {
    return map[string]interface{}{
        "type": "aggregationVariable",
        "name": name,
        "function": aggFunc,
        "field": fieldAccess,
    }, nil
}

Constraints <- first:Constraint rest:(_ LogicalOp _ Constraint)* {
    if rest == nil || len(rest.([]interface{})) == 0 {
        return first, nil
    }

    operations := []map[string]interface{}{}
    for _, item := range rest.([]interface{}) {
        op := item.([]interface{})[1]
        right := item.([]interface{})[3]
        operations = append(operations, map[string]interface{}{
            "op": op,
            "right": right,
        })
    }

    return map[string]interface{}{
        "type": "logicalExpr",
        "left": first,
        "operations": operations,
    }, nil
}

Constraint <- "(" _ expr:Constraints _ ")" { return expr, nil } /
              NotConstraint /
              ExistsConstraint /
              AccumulateConstraint /
              left:ArithmeticExpr _ op:ComparisonOp _ right:ArithmeticExpr {
    return map[string]interface{}{
        "type": "comparison",
        "left": left,
        "operator": op,
        "right": right,
    }, nil
}

NotConstraint <- ("NOT" / "not" / "Not") _ "(" _ expr:Constraints _ ")" {
    return map[string]interface{}{
        "type": "notConstraint",
        "expression": expr,
    }, nil
}

ExistsConstraint <- ("EXISTS" / "exists" / "Exists") _ "(" _ variable:TypedVariable _ "/" _ condition:Constraints _ ")" {
    return map[string]interface{}{
        "type": "existsConstraint",
        "variable": variable,
        "condition": condition,
    }, nil
}

AccumulateConstraint <- accumFunc:AccumulateFunction _ "(" _ accumVar:TypedVariable _ "/" _ accumCond:Constraints _ accumField:(_ ";" _ FieldAccess)? _ ")" _ accumOp:ComparisonOp _ accumThreshold:ArithmeticExpr {
    fieldValue := ""
    if accumField != nil {
        fieldAccess := accumField.([]interface{})[3].(map[string]interface{})
        fieldValue = fieldAccess["field"].(string)
    }

    return map[string]interface{}{
        "type": "accumulateConstraint",
        "function": accumFunc,
        "variable": accumVar,
        "condition": accumCond,
        "field": fieldValue,
        "operator": accumOp,
        "threshold": accumThreshold,
    }, nil
}

AccumulateFunction <- ("AVG" / "avg" / "Avg") { return "AVG", nil } /
                     ("COUNT" / "count" / "Count") { return "COUNT", nil } /
                     ("SUM" / "sum" / "Sum") { return "SUM", nil } /
                     ("MIN" / "min" / "Min") { return "MIN", nil } /
                     ("MAX" / "max" / "Max") { return "MAX", nil }


ArithmeticExpr <- first:Term rest:(_ ("+" / "-") _ Term)* {
    if rest == nil || len(rest.([]interface{})) == 0 {
        return first, nil
    }

    result := first
    for _, item := range rest.([]interface{}) {
        op := item.([]interface{})[1]
        right := item.([]interface{})[3]
        result = map[string]interface{}{
            "type": "binaryOp",
            "left": result,
            "operator": op,
            "right": right,
        }
    }
    return result, nil
}

Term <- first:Factor rest:(_ ("*" / "/") _ Factor)* {
    if rest == nil || len(rest.([]interface{})) == 0 {
        return first, nil
    }

    result := first
    for _, item := range rest.([]interface{}) {
        op := item.([]interface{})[1]
        right := item.([]interface{})[3]
        result = map[string]interface{}{
            "type": "binaryOp",
            "left": result,
            "operator": op,
            "right": right,
        }
    }
    return result, nil
}

Factor <- "(" _ expr:ArithmeticExpr _ ")" { return expr, nil } /
          CastExpression /
          FunctionCall /
          FieldAccess /
          Number /
          StringLiteral /
          BooleanLiteral /
          ArrayLiteral /
          Variable

CastExpression <- "(" _ castType:CastType _ ")" _ expr:Factor {
    return map[string]interface{}{
        "type": "cast",
        "castType": castType,
        "expression": expr,
    }, nil
}

CastType <- "number" { return "number", nil } /
            "string" { return "string", nil } /
            "bool"   { return "bool", nil }

FieldAccess <- object:IdentName "." field:IdentName {
    return map[string]interface{}{
        "type": "fieldAccess",
        "object": object,
        "field": field,
    }, nil
}

Variable <- name:IdentName {
    return map[string]interface{}{
        "type": "variable",
        "name": name,
    }, nil
}

ArrayLiteral <- "[" _ elements:ArrayElementList? _ "]" {
    if elements == nil {
        elements = []interface{}{}
    }
    return map[string]interface{}{
        "type": "arrayLiteral",
        "elements": elements,
    }, nil
}

ArrayElementList <- first:ArithmeticExpr rest:(_ "," _ ArithmeticExpr)* {
    elements := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            elements = append(elements, item.([]interface{})[3])
        }
    }
    return elements, nil
}

FunctionCall <- name:FunctionName _ "(" _ args:FunctionArgList? _ ")" {
    if args == nil {
        args = []interface{}{}
    }
    return map[string]interface{}{
        "type": "functionCall",
        "name": name,
        "args": args,
    }, nil
}

FunctionName <- ("LENGTH" / "length" / "Length") { return "LENGTH", nil } /
                ("SUBSTRING" / "substring" / "Substring") { return "SUBSTRING", nil } /
                ("UPPER" / "upper" / "Upper") { return "UPPER", nil } /
                ("LOWER" / "lower" / "Lower") { return "LOWER", nil } /
                ("TRIM" / "trim" / "Trim") { return "TRIM", nil } /
                ("ABS" / "abs" / "Abs") { return "ABS", nil } /
                ("ROUND" / "round" / "Round") { return "ROUND", nil } /
                ("FLOOR" / "floor" / "Floor") { return "FLOOR", nil } /
                ("CEIL" / "ceil" / "Ceil") { return "CEIL", nil }

FunctionArgList <- first:ArithmeticExpr rest:(_ "," _ ArithmeticExpr)* {
    args := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            args = append(args, item.([]interface{})[3])
        }
    }
    return args, nil
}

Action <- first:JobCall rest:(_ "," _ JobCall)* {
    jobs := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            jobs = append(jobs, item.([]interface{})[3])
        }
    }
    return map[string]interface{}{
        "type": "action",
        "jobs": jobs,
    }, nil
}

JobCall <- name:IdentName _ "(" _ args:ArgumentList? _ ")" {
    if args == nil {
        args = []interface{}{}
    }
    return map[string]interface{}{
        "type": "jobCall",
        "name": name,
        "args": args,
    }, nil
}

ArgumentList <- first:ArithmeticExpr rest:(_ "," _ ArithmeticExpr)* {
    arguments := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            arguments = append(arguments, item.([]interface{})[3])
        }
    }
    return arguments, nil
}

ComparisonOp <- "==" { return "==", nil } /
                "!=" { return "!=", nil } /
                "<=" { return "<=", nil } /
                ">=" { return ">=", nil } /
                "<"  { return "<", nil } /
                ">"  { return ">", nil } /
                ("IN" / "in" / "In") { return "IN", nil } /
                ("LIKE" / "like" / "Like") { return "LIKE", nil } /
                ("MATCHES" / "matches" / "Matches") { return "MATCHES", nil } /
                ("CONTAINS" / "contains" / "Contains") { return "CONTAINS", nil }

LogicalOp <- ("AND" / "and" / "And") { return "AND", nil } /
             ("OR" / "or" / "Or")  { return "OR", nil }

BooleanLiteral <- "true" {
        return map[string]interface{}{
            "type": "boolean",
            "value": true,
        }, nil
    } /
    "false" {
        return map[string]interface{}{
            "type": "boolean",
            "value": false,
        }, nil
    }

Number <- sign:"-"? digits:[0-9]+ decimal:("." [0-9]+)? {
    val, err := strconv.ParseFloat(string(c.text), 64)
    if err != nil {
        return nil, err
    }
    return map[string]interface{}{
        "type": "number",
        "value": val,
    }, nil
}

StringLiteral <- "\"" chars:DoubleStringChar* "\"" {
        var builder strings.Builder
        if chars != nil {
            for _, char := range chars.([]interface{}) {
                builder.WriteString(char.(string))
            }
        }
        return map[string]interface{}{
            "type": "string",
            "value": builder.String(),
        }, nil
    } /
    "'" chars:SingleStringChar* "'" {
        var builder strings.Builder
        if chars != nil {
            for _, char := range chars.([]interface{}) {
                builder.WriteString(char.(string))
            }
        }
        return map[string]interface{}{
            "type": "string",
            "value": builder.String(),
        }, nil
    }

DoubleStringChar <- EscapeSequence / (!'"' UnicodeChar) {
    return string(c.text), nil
}

SingleStringChar <- EscapeSequence / (!'\'' UnicodeChar) {
    return string(c.text), nil
}

EscapeSequence <- "\\" char:EscapeChar {
    var charStr string
    switch v := char.(type) {
    case string:
        charStr = v
    case []uint8:
        charStr = string(v)
    default:
        charStr = fmt.Sprintf("%v", char)
    }

    switch charStr {
    case "n":
        return "\n", nil
    case "t":
        return "\t", nil
    case "r":
        return "\r", nil
    case "\\":
        return "\\", nil
    case "\"":
        return "\"", nil
    case "'":
        return "'", nil
    default:
        return "\\" + charStr, nil
    }
}

EscapeChar <- "n" { return "n", nil } /
              "t" { return "t", nil } /
              "r" { return "r", nil } /
              "\\" { return "\\", nil } /
              "\"" { return "\"", nil } /
              "'" { return "'", nil } /
              . { return string(c.text), nil }

UnicodeChar <- .

// RemoveRule définit le parsing d'une suppression de règle avec le format: remove rule <ruleID>
RemoveRule <- "remove" _ "rule" _ ruleID:IdentName {
    return map[string]interface{}{
        "type": "ruleRemoval",
        "ruleID": ruleID,
    }, nil
}

// RemoveFact définit le parsing d'une rétractation de fait avec le format: remove fact TypeName ID
RemoveFact <- "remove" _ "fact" _ typeName:IdentName _ factID:FactID {
    return map[string]interface{}{
        "type": "retraction",
        "typeName": typeName,
        "factID": factID,
    }, nil
}

// FactID est un identifiant pour un fait (peut contenir des caractères spéciaux)
FactID <- chars:([a-zA-Z0-9_-] / SpecialFactChar)+ {
    return string(c.text), nil
}

// Fact définit le parsing d'un fait avec le nouveau format TypeName(field:value, ...)
Fact <- typeName:IdentName "(" _ fields:FactFieldList _ ")" {
    return map[string]interface{}{
        "type": "fact",
        "typeName": typeName,
        "fields": fields,
    }, nil
}

FactFieldList <- first:FactField rest:(_ "," _ FactField)* {
    fields := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            fields = append(fields, item.([]interface{})[3])
        }
    }
    return fields, nil
}

FactField <- name:IdentName ":" _ value:FactValue {
    return map[string]interface{}{
        "name": name,
        "value": value,
    }, nil
}

FactValue <- StringLiteral / Number / BooleanLiteral / ComplexIdentifier {
    // ComplexIdentifier pour les valeurs non-quotées complexes comme des IDs
    return map[string]interface{}{
        "type": "identifier",
        "value": string(c.text),
    }, nil
}

ComplexIdentifier <- ComplexIdentStart ComplexIdentContinue* {
    return string(c.text), nil
}

ComplexIdentStart <- [a-zA-Z0-9_] / UnicodeLetterStart

ComplexIdentContinue <- [a-zA-Z0-9_-] / UnicodeLetterContinue / SpecialFactChar

// Caractères spéciaux autorisés dans les valeurs de faits
SpecialFactChar <- [-_:.]

IdentName <- IdentStart IdentContinue* {
    return string(c.text), nil
}

IdentStart <- [a-zA-Z_] / UnicodeLetterStart

IdentContinue <- [a-zA-Z0-9_-] / UnicodeLetterContinue / PunctuationChar

// Support pour les caractères Unicode étendus (tous les scripts majeurs)
// Latin étendu, Grec, Cyrillique, Hébreu, Arabe, CJK (Chinois, Japonais, Coréen), etc.
UnicodeLetterStart <- [\u00C0-\u00D6] / [\u00D8-\u00F6] / [\u00F8-\u017F] /
                      [\u0100-\u024F] / [\u1E00-\u1EFF] / [\u0370-\u03FF] /
                      [\u0400-\u04FF] / [\u0590-\u05FF] / [\u0600-\u06FF] /
                      [\u3040-\u309F] / [\u30A0-\u30FF] / [\u3400-\u4DBF] /
                      [\u4E00-\u9FFF] / [\uAC00-\uD7AF] / [\uF900-\uFAFF]

UnicodeLetterContinue <- [\u00C0-\u00D6] / [\u00D8-\u00F6] / [\u00F8-\u017F] /
                         [\u0100-\u024F] / [\u1E00-\u1EFF] / [\u0370-\u03FF] /
                         [\u0400-\u04FF] / [\u0590-\u05FF] / [\u0600-\u06FF] /
                         [\u0300-\u036F] / [\u1AB0-\u1AFF] / [\u1DC0-\u1DFF] /
                         [\u3040-\u309F] / [\u30A0-\u30FF] / [\u3400-\u4DBF] /
                         [\u4E00-\u9FFF] / [\uAC00-\uD7AF] / [\uF900-\uFAFF]

PunctuationChar <- [-_] / ['] / [\u2010-\u2015] / [\u2032-\u2037]

_ <- (Whitespace / Comment)*

Whitespace <- [ \t\r\n]

Comment <- LineComment / BlockComment / EndOfLineComment

LineComment <- "//" CommentText:(![\r\n] .)* {
    return nil, nil  // Les commentaires ne retournent rien
}

BlockComment <- "/*" CommentText:(!"*/" .)* "*/" {
    return nil, nil  // Les commentaires ne retournent rien
}

EndOfLineComment <- "#" CommentText:(![\r\n] .)* {
    return nil, nil  // Support pour commentaires style shell/Python
}

EOF <- !.
