
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rete: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/treivax/tsd/rete/alpha_builder.go (57.4%)</option>
				
				<option value="file1">github.com/treivax/tsd/rete/converter.go (0.0%)</option>
				
				<option value="file2">github.com/treivax/tsd/rete/evaluator.go (52.8%)</option>
				
				<option value="file3">github.com/treivax/tsd/rete/network.go (0.0%)</option>
				
				<option value="file4">github.com/treivax/tsd/rete/rete.go (27.8%)</option>
				
				<option value="file5">github.com/treivax/tsd/rete/storage.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package rete

import (
        "fmt"
)

// AlphaConditionBuilder aide √† construire des conditions Alpha
type AlphaConditionBuilder struct{}

// NewAlphaConditionBuilder cr√©e un nouveau constructeur de conditions
func NewAlphaConditionBuilder() *AlphaConditionBuilder <span class="cov8" title="1">{
        return &amp;AlphaConditionBuilder{}
}</span>

// FieldEquals cr√©e une condition d'√©galit√© sur un champ
func (acb *AlphaConditionBuilder) FieldEquals(variable, field string, value interface{}) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "==",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldNotEquals cr√©e une condition d'in√©galit√© sur un champ
func (acb *AlphaConditionBuilder) FieldNotEquals(variable, field string, value interface{}) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "!=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldLessThan cr√©e une condition de comparaison inf√©rieure sur un champ
func (acb *AlphaConditionBuilder) FieldLessThan(variable, field string, value interface{}) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&lt;",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldLessOrEqual cr√©e une condition de comparaison inf√©rieure ou √©gale sur un champ
func (acb *AlphaConditionBuilder) FieldLessOrEqual(variable, field string, value interface{}) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&lt;=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldGreaterThan cr√©e une condition de comparaison sup√©rieure sur un champ
func (acb *AlphaConditionBuilder) FieldGreaterThan(variable, field string, value interface{}) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&gt;",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldGreaterOrEqual cr√©e une condition de comparaison sup√©rieure ou √©gale sur un champ
func (acb *AlphaConditionBuilder) FieldGreaterOrEqual(variable, field string, value interface{}) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&gt;=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// And cr√©e une condition logique AND
func (acb *AlphaConditionBuilder) And(left, right interface{}) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type": "logicalExpression",
                "left": left,
                "operations": []interface{}{
                        map[string]interface{}{
                                "op":    "AND",
                                "right": right,
                        },
                },
        }
}</span>

// Or cr√©e une condition logique OR
func (acb *AlphaConditionBuilder) Or(left, right interface{}) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type": "logicalExpression",
                "left": left,
                "operations": []interface{}{
                        map[string]interface{}{
                                "op":    "OR",
                                "right": right,
                        },
                },
        }
}</span>

// AndMultiple cr√©e une condition logique AND avec plusieurs conditions
func (acb *AlphaConditionBuilder) AndMultiple(conditions ...interface{}) interface{} <span class="cov8" title="1">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return acb.True()
        }</span>
        <span class="cov8" title="1">if len(conditions) == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>

        <span class="cov8" title="1">operations := make([]interface{}, 0, len(conditions)-1)
        for _, condition := range conditions[1:] </span><span class="cov8" title="1">{
                operations = append(operations, map[string]interface{}{
                        "op":    "AND",
                        "right": condition,
                })
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "type":       "logicalExpression",
                "left":       conditions[0],
                "operations": operations,
        }</span>
}

// OrMultiple cr√©e une condition logique OR avec plusieurs conditions
func (acb *AlphaConditionBuilder) OrMultiple(conditions ...interface{}) interface{} <span class="cov8" title="1">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return acb.False()
        }</span>
        <span class="cov8" title="1">if len(conditions) == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>

        <span class="cov8" title="1">operations := make([]interface{}, 0, len(conditions)-1)
        for _, condition := range conditions[1:] </span><span class="cov8" title="1">{
                operations = append(operations, map[string]interface{}{
                        "op":    "OR",
                        "right": condition,
                })
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "type":       "logicalExpression",
                "left":       conditions[0],
                "operations": operations,
        }</span>
}

// True cr√©e une condition toujours vraie
func (acb *AlphaConditionBuilder) True() interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":  "booleanLiteral",
                "value": true,
        }
}</span>

// False cr√©e une condition toujours fausse
func (acb *AlphaConditionBuilder) False() interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":  "booleanLiteral",
                "value": false,
        }
}</span>

// FieldRange cr√©e une condition de plage pour un champ (min &lt;= field &lt;= max)
func (acb *AlphaConditionBuilder) FieldRange(variable, field string, min, max interface{}) interface{} <span class="cov8" title="1">{
        minCondition := acb.FieldGreaterOrEqual(variable, field, min)
        maxCondition := acb.FieldLessOrEqual(variable, field, max)
        return acb.And(minCondition, maxCondition)
}</span>

// FieldIn cr√©e une condition de pr√©sence dans une liste de valeurs
func (acb *AlphaConditionBuilder) FieldIn(variable, field string, values ...interface{}) interface{} <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return acb.False()
        }</span>

        <span class="cov0" title="0">conditions := make([]interface{}, len(values))
        for i, value := range values </span><span class="cov0" title="0">{
                conditions[i] = acb.FieldEquals(variable, field, value)
        }</span>

        <span class="cov0" title="0">return acb.OrMultiple(conditions...)</span>
}

// FieldNotIn cr√©e une condition d'absence dans une liste de valeurs
func (acb *AlphaConditionBuilder) FieldNotIn(variable, field string, values ...interface{}) interface{} <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return acb.True()
        }</span>

        <span class="cov0" title="0">conditions := make([]interface{}, len(values))
        for i, value := range values </span><span class="cov0" title="0">{
                conditions[i] = acb.FieldNotEquals(variable, field, value)
        }</span>

        <span class="cov0" title="0">return acb.AndMultiple(conditions...)</span>
}

// createLiteral cr√©e un litt√©ral typ√©
func (acb *AlphaConditionBuilder) createLiteral(value interface{}) map[string]interface{} <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return map[string]interface{}{
                        "type":  "stringLiteral",
                        "value": v,
                }</span>
        case int:<span class="cov8" title="1">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case int32:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case int64:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case float32:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case float64:<span class="cov8" title="1">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": v,
                }</span>
        case bool:<span class="cov8" title="1">
                return map[string]interface{}{
                        "type":  "booleanLiteral",
                        "value": v,
                }</span>
        default:<span class="cov0" title="0">
                // Fallback vers string
                return map[string]interface{}{
                        "type":  "stringLiteral",
                        "value": fmt.Sprintf("%v", v),
                }</span>
        }
}

// CreateConstraintFromAST cr√©e une condition √† partir d'un AST de contrainte
func (acb *AlphaConditionBuilder) CreateConstraintFromAST(constraint interface{}) interface{} <span class="cov0" title="0">{
        // Si c'est d√©j√† une map, la retourner telle quelle
        if constraintMap, ok := constraint.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                return constraintMap
        }</span>

        // Sinon, retourner tel quel (sera trait√© par l'√©valuateur)
        <span class="cov0" title="0">return constraint</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// ASTConverter convertit l'AST du parser constraint vers les types RETE
type ASTConverter struct{}

// NewASTConverter cr√©e un nouveau convertisseur AST
func NewASTConverter() *ASTConverter <span class="cov0" title="0">{
        return &amp;ASTConverter{}
}</span>

// ConvertProgram convertit un constraint.Program vers un rete.Program
func (ac *ASTConverter) ConvertProgram(constraintProgram interface{}) (*Program, error) <span class="cov0" title="0">{
        // Essayer de caster vers constraint.Program
        program, ok := constraintProgram.(*constraint.Program)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type de programme AST non reconnu")
        }</span>

        <span class="cov0" title="0">reteProgram := &amp;Program{
                Types:       make([]TypeDefinition, len(program.Types)),
                Expressions: make([]Expression, len(program.Expressions)),
        }

        // Convertir les types
        for i, constraintType := range program.Types </span><span class="cov0" title="0">{
                reteProgram.Types[i] = TypeDefinition{
                        Type:   constraintType.Type,
                        Name:   constraintType.Name,
                        Fields: ac.convertFields(constraintType.Fields),
                }
        }</span>

        // Convertir les expressions
        <span class="cov0" title="0">for i, constraintExpr := range program.Expressions </span><span class="cov0" title="0">{
                reteExpr, err := ac.convertExpression(constraintExpr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur conversion expression %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">reteProgram.Expressions[i] = *reteExpr</span>
        }

        <span class="cov0" title="0">return reteProgram, nil</span>
}

// convertFields convertit les champs
func (ac *ASTConverter) convertFields(constraintFields []constraint.Field) []Field <span class="cov0" title="0">{
        fields := make([]Field, len(constraintFields))
        for i, field := range constraintFields </span><span class="cov0" title="0">{
                fields[i] = Field{
                        Name: field.Name,
                        Type: field.Type,
                }
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// convertExpression convertit une expression
func (ac *ASTConverter) convertExpression(constraintExpr constraint.Expression) (*Expression, error) <span class="cov0" title="0">{
        expr := &amp;Expression{
                Type:        constraintExpr.Type,
                Constraints: constraintExpr.Constraints,
        }

        // Convertir le set
        expr.Set = Set{
                Type:      constraintExpr.Set.Type,
                Variables: ac.convertTypedVariables(constraintExpr.Set.Variables),
        }

        // Convertir l'action si pr√©sente
        if constraintExpr.Action != nil </span><span class="cov0" title="0">{
                action, err := ac.convertAction(*constraintExpr.Action)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur conversion action: %w", err)
                }</span>
                <span class="cov0" title="0">expr.Action = action</span>
        }

        <span class="cov0" title="0">return expr, nil</span>
}

// convertTypedVariables convertit les variables typ√©es
func (ac *ASTConverter) convertTypedVariables(constraintVars []constraint.TypedVariable) []TypedVariable <span class="cov0" title="0">{
        vars := make([]TypedVariable, len(constraintVars))
        for i, variable := range constraintVars </span><span class="cov0" title="0">{
                vars[i] = TypedVariable{
                        Type:     variable.Type,
                        Name:     variable.Name,
                        DataType: variable.DataType,
                }
        }</span>
        <span class="cov0" title="0">return vars</span>
}

// convertAction convertit une action
func (ac *ASTConverter) convertAction(constraintAction constraint.Action) (*Action, error) <span class="cov0" title="0">{
        action := &amp;Action{
                Type: constraintAction.Type,
                Job: JobCall{
                        Type: constraintAction.Job.Type,
                        Name: constraintAction.Job.Name,
                        Args: constraintAction.Job.Args,
                },
        }
        return action, nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package rete

import (
        "fmt"
        "reflect"
        "strings"

        "github.com/treivax/tsd/constraint"
)

// AlphaConditionEvaluator √©value les conditions Alpha sur les faits
type AlphaConditionEvaluator struct {
        variableBindings map[string]*Fact
}

// NewAlphaConditionEvaluator cr√©e un nouvel √©valuateur de conditions
func NewAlphaConditionEvaluator() *AlphaConditionEvaluator <span class="cov8" title="1">{
        return &amp;AlphaConditionEvaluator{
                variableBindings: make(map[string]*Fact),
        }
}</span>

// EvaluateCondition √©value une condition sur un fait
func (e *AlphaConditionEvaluator) EvaluateCondition(condition interface{}, fact *Fact, variableName string) (bool, error) <span class="cov8" title="1">{
        // Lier la variable au fait pour l'√©valuation
        if variableName != "" </span><span class="cov8" title="1">{
                e.variableBindings[variableName] = fact
        }</span>

        <span class="cov8" title="1">return e.evaluateExpression(condition)</span>
}

// evaluateExpression √©value r√©cursivement une expression
func (e *AlphaConditionEvaluator) evaluateExpression(expr interface{}) (bool, error) <span class="cov8" title="1">{
        switch condition := expr.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                return e.evaluateMapExpression(condition)</span>
        case constraint.BinaryOperation:<span class="cov0" title="0">
                return e.evaluateBinaryOperation(condition)</span>
        case constraint.LogicalExpression:<span class="cov0" title="0">
                return e.evaluateLogicalExpression(condition)</span>
        case constraint.Constraint:<span class="cov0" title="0">
                return e.evaluateConstraint(condition)</span>
        case constraint.BooleanLiteral:<span class="cov0" title="0">
                return condition.Value, nil</span>
        default:<span class="cov8" title="1">
                return false, fmt.Errorf("type d'expression non support√©: %T", expr)</span>
        }
}

// evaluateMapExpression √©value une expression sous forme de map (format JSON)
func (e *AlphaConditionEvaluator) evaluateMapExpression(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        exprType, ok := expr["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("type d'expression manquant")
        }</span>

        <span class="cov8" title="1">switch exprType </span>{
        case "binaryOperation":<span class="cov8" title="1">
                return e.evaluateBinaryOperationMap(expr)</span>
        case "logicalExpression":<span class="cov8" title="1">
                return e.evaluateLogicalExpressionMap(expr)</span>
        case "constraint":<span class="cov0" title="0">
                return e.evaluateConstraintMap(expr)</span>
        case "booleanLiteral":<span class="cov8" title="1">
                value, ok := expr["value"].(bool)
                if !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("valeur bool√©enne invalide")
                }</span>
                <span class="cov8" title="1">return value, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("type d'expression non support√©: %s", exprType)</span>
        }
}

// evaluateBinaryOperation √©value une op√©ration binaire
func (e *AlphaConditionEvaluator) evaluateBinaryOperation(op constraint.BinaryOperation) (bool, error) <span class="cov0" title="0">{
        left, err := e.evaluateValue(op.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateValue(op.Right)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov0" title="0">return e.compareValues(left, op.Operator, right)</span>
}

// evaluateBinaryOperationMap √©value une op√©ration binaire depuis une map
func (e *AlphaConditionEvaluator) evaluateBinaryOperationMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        operator, ok := expr["operator"].(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("op√©rateur manquant")
        }</span>

        <span class="cov8" title="1">left, err := e.evaluateValue(expr["left"])
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov8" title="1">right, err := e.evaluateValue(expr["right"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov8" title="1">return e.compareValues(left, operator, right)</span>
}

// evaluateLogicalExpression √©value une expression logique (AND, OR)
func (e *AlphaConditionEvaluator) evaluateLogicalExpression(expr constraint.LogicalExpression) (bool, error) <span class="cov0" title="0">{
        leftResult, err := e.evaluateExpression(expr.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">result := leftResult
        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                rightResult, err := e.evaluateExpression(op.Right)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("erreur √©valuation op√©ration %s: %w", op.Op, err)
                }</span>

                <span class="cov0" title="0">switch op.Op </span>{
                case "AND":<span class="cov0" title="0">
                        result = result &amp;&amp; rightResult</span>
                case "OR":<span class="cov0" title="0">
                        result = result || rightResult</span>
                default:<span class="cov0" title="0">
                        return false, fmt.Errorf("op√©rateur logique non support√©: %s", op.Op)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// evaluateLogicalExpressionMap √©value une expression logique depuis une map
func (e *AlphaConditionEvaluator) evaluateLogicalExpressionMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        leftResult, err := e.evaluateExpression(expr["left"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov8" title="1">operations, ok := expr["operations"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return leftResult, nil // Pas d'op√©rations suppl√©mentaires
        }</span>

        <span class="cov8" title="1">result := leftResult
        for _, opInterface := range operations </span><span class="cov8" title="1">{
                opMap, ok := opInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">operator, ok := opMap["op"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">rightResult, err := e.evaluateExpression(opMap["right"])
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("erreur √©valuation op√©ration %s: %w", operator, err)
                }</span>

                <span class="cov8" title="1">switch operator </span>{
                case "AND":<span class="cov8" title="1">
                        result = result &amp;&amp; rightResult</span>
                case "OR":<span class="cov8" title="1">
                        result = result || rightResult</span>
                default:<span class="cov0" title="0">
                        return false, fmt.Errorf("op√©rateur logique non support√©: %s", operator)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// evaluateConstraint √©value une contrainte simple
func (e *AlphaConditionEvaluator) evaluateConstraint(constraint constraint.Constraint) (bool, error) <span class="cov0" title="0">{
        left, err := e.evaluateValue(constraint.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateValue(constraint.Right)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov0" title="0">return e.compareValues(left, constraint.Operator, right)</span>
}

// evaluateConstraintMap √©value une contrainte depuis une map
func (e *AlphaConditionEvaluator) evaluateConstraintMap(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        operator, ok := expr["operator"].(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("op√©rateur manquant")
        }</span>

        <span class="cov0" title="0">left, err := e.evaluateValue(expr["left"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateValue(expr["right"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov0" title="0">return e.compareValues(left, operator, right)</span>
}

// evaluateValue √©value une valeur (litt√©ral, acc√®s de champ, variable)
func (e *AlphaConditionEvaluator) evaluateValue(value interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch val := value.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                return e.evaluateValueFromMap(val)</span>
        case constraint.FieldAccess:<span class="cov0" title="0">
                return e.evaluateFieldAccess(val)</span>
        case constraint.Variable:<span class="cov0" title="0">
                return e.evaluateVariable(val)</span>
        case constraint.NumberLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case constraint.StringLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case constraint.BooleanLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case string:<span class="cov0" title="0">
                return val, nil</span>
        case int, int32, int64:<span class="cov0" title="0">
                return val, nil</span>
        case float32, float64:<span class="cov0" title="0">
                return val, nil</span>
        case bool:<span class="cov0" title="0">
                return val, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("type de valeur non support√©: %T", value)</span>
        }
}

// evaluateValueFromMap √©value une valeur depuis une map
func (e *AlphaConditionEvaluator) evaluateValueFromMap(val map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        valType, ok := val["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type de valeur manquant")
        }</span>

        <span class="cov8" title="1">switch valType </span>{
        case "fieldAccess":<span class="cov8" title="1">
                object, ok := val["object"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("objet d'acc√®s de champ invalide")
                }</span>
                <span class="cov8" title="1">field, ok := val["field"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("champ d'acc√®s invalide")
                }</span>
                <span class="cov8" title="1">return e.evaluateFieldAccessByName(object, field)</span>

        case "variable":<span class="cov0" title="0">
                name, ok := val["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nom de variable invalide")
                }</span>
                <span class="cov0" title="0">return e.evaluateVariableByName(name)</span>

        case "numberLiteral":<span class="cov8" title="1">
                value, ok := val["value"].(float64)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("valeur num√©rique invalide")
                }</span>
                <span class="cov8" title="1">return value, nil</span>

        case "stringLiteral":<span class="cov8" title="1">
                value, ok := val["value"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("valeur de cha√Æne invalide")
                }</span>
                <span class="cov8" title="1">return value, nil</span>

        case "booleanLiteral":<span class="cov8" title="1">
                value, ok := val["value"].(bool)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("valeur bool√©enne invalide")
                }</span>
                <span class="cov8" title="1">return value, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("type de valeur non support√©: %s", valType)</span>
        }
}

// evaluateFieldAccess √©value l'acc√®s √† un champ d'une variable
func (e *AlphaConditionEvaluator) evaluateFieldAccess(fa constraint.FieldAccess) (interface{}, error) <span class="cov0" title="0">{
        return e.evaluateFieldAccessByName(fa.Object, fa.Field)
}</span>

// evaluateFieldAccessByName √©value l'acc√®s √† un champ par nom
func (e *AlphaConditionEvaluator) evaluateFieldAccessByName(object, field string) (interface{}, error) <span class="cov8" title="1">{
        fact, exists := e.variableBindings[object]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("variable non li√©e: %s", object)
        }</span>

        <span class="cov8" title="1">value, exists := fact.Fields[field]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("champ inexistant: %s.%s", object, field)
        }</span>

        <span class="cov8" title="1">return value, nil</span>
}

// evaluateVariable √©value une variable
func (e *AlphaConditionEvaluator) evaluateVariable(variable constraint.Variable) (interface{}, error) <span class="cov0" title="0">{
        return e.evaluateVariableByName(variable.Name)
}</span>

// evaluateVariableByName √©value une variable par nom
func (e *AlphaConditionEvaluator) evaluateVariableByName(name string) (interface{}, error) <span class="cov0" title="0">{
        fact, exists := e.variableBindings[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("variable non li√©e: %s", name)
        }</span>

        // Retourner le fait entier ou une repr√©sentation
        <span class="cov0" title="0">return fact, nil</span>
}

// compareValues compare deux valeurs avec un op√©rateur
func (e *AlphaConditionEvaluator) compareValues(left interface{}, operator string, right interface{}) (bool, error) <span class="cov8" title="1">{
        // Normaliser les valeurs num√©riques
        leftVal := e.normalizeValue(left)
        rightVal := e.normalizeValue(right)

        switch operator </span>{
        case "==", "=":<span class="cov8" title="1">
                return e.areEqual(leftVal, rightVal), nil</span>
        case "!=", "&lt;&gt;":<span class="cov8" title="1">
                return !e.areEqual(leftVal, rightVal), nil</span>
        case "&lt;":<span class="cov8" title="1">
                return e.isLess(leftVal, rightVal)</span>
        case "&lt;=":<span class="cov8" title="1">
                equal := e.areEqual(leftVal, rightVal)
                less, err := e.isLess(leftVal, rightVal)
                return equal || less, err</span>
        case "&gt;":<span class="cov8" title="1">
                return e.isGreater(leftVal, rightVal)</span>
        case "&gt;=":<span class="cov8" title="1">
                equal := e.areEqual(leftVal, rightVal)
                greater, err := e.isGreater(leftVal, rightVal)
                return equal || greater, err</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("op√©rateur non support√©: %s", operator)</span>
        }
}

// normalizeValue normalise une valeur pour la comparaison
func (e *AlphaConditionEvaluator) normalizeValue(value interface{}) interface{} <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return float64(v)</span>
        case int32:<span class="cov0" title="0">
                return float64(v)</span>
        case int64:<span class="cov0" title="0">
                return float64(v)</span>
        case float32:<span class="cov0" title="0">
                return float64(v)</span>
        default:<span class="cov8" title="1">
                return value</span>
        }
}

// areEqual v√©rifie si deux valeurs sont √©gales
func (e *AlphaConditionEvaluator) areEqual(left, right interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(left, right)
}</span>

// isLess v√©rifie si left &lt; right
func (e *AlphaConditionEvaluator) isLess(left, right interface{}) (bool, error) <span class="cov8" title="1">{
        switch leftVal := left.(type) </span>{
        case float64:<span class="cov8" title="1">
                if rightVal, ok := right.(float64); ok </span><span class="cov8" title="1">{
                        return leftVal &lt; rightVal, nil
                }</span>
        case string:<span class="cov8" title="1">
                if rightVal, ok := right.(string); ok </span><span class="cov8" title="1">{
                        return strings.Compare(leftVal, rightVal) &lt; 0, nil
                }</span>
        }
        <span class="cov8" title="1">return false, fmt.Errorf("impossible de comparer %T avec %T", left, right)</span>
}

// isGreater v√©rifie si left &gt; right
func (e *AlphaConditionEvaluator) isGreater(left, right interface{}) (bool, error) <span class="cov8" title="1">{
        switch leftVal := left.(type) </span>{
        case float64:<span class="cov8" title="1">
                if rightVal, ok := right.(float64); ok </span><span class="cov8" title="1">{
                        return leftVal &gt; rightVal, nil
                }</span>
        case string:<span class="cov8" title="1">
                if rightVal, ok := right.(string); ok </span><span class="cov8" title="1">{
                        return strings.Compare(leftVal, rightVal) &gt; 0, nil
                }</span>
        }
        <span class="cov8" title="1">return false, fmt.Errorf("impossible de comparer %T avec %T", left, right)</span>
}

// ClearBindings efface les liaisons de variables
func (e *AlphaConditionEvaluator) ClearBindings() <span class="cov8" title="1">{
        e.variableBindings = make(map[string]*Fact)
}</span>

// GetBindings retourne les liaisons actuelles
func (e *AlphaConditionEvaluator) GetBindings() map[string]*Fact <span class="cov8" title="1">{
        return e.variableBindings
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package rete

import (
        "fmt"
)

// ReteNetwork repr√©sente le r√©seau RETE complet
type ReteNetwork struct {
        RootNode      *RootNode                `json:"root_node"`
        TypeNodes     map[string]*TypeNode     `json:"type_nodes"`
        AlphaNodes    map[string]*AlphaNode    `json:"alpha_nodes"`
        TerminalNodes map[string]*TerminalNode `json:"terminal_nodes"`
        Storage       Storage                  `json:"-"`
        Types         []TypeDefinition         `json:"types"`
}

// NewReteNetwork cr√©e un nouveau r√©seau RETE
func NewReteNetwork(storage Storage) *ReteNetwork <span class="cov0" title="0">{
        rootNode := NewRootNode(storage)

        return &amp;ReteNetwork{
                RootNode:      rootNode,
                TypeNodes:     make(map[string]*TypeNode),
                AlphaNodes:    make(map[string]*AlphaNode),
                TerminalNodes: make(map[string]*TerminalNode),
                Storage:       storage,
                Types:         make([]TypeDefinition, 0),
        }
}</span>

// SubmitFact soumet un nouveau fait au r√©seau
func (rn *ReteNetwork) SubmitFact(fact *Fact) error <span class="cov0" title="0">{
        fmt.Printf("üî• Soumission d'un nouveau fait au r√©seau RETE: %s\n", fact.String())

        // Propager le fait depuis le n≈ìud racine
        return rn.RootNode.ActivateRight(fact)
}</span>

// LoadFromAST construit le r√©seau RETE √† partir d'un AST
func (rn *ReteNetwork) LoadFromAST(program *Program) error <span class="cov0" title="0">{
        fmt.Printf("üèóÔ∏è  Construction du r√©seau RETE √† partir de l'AST\n")

        // Charger les types
        rn.Types = program.Types
        fmt.Printf("   Types d√©finis: %d\n", len(program.Types))

        // Cr√©er les n≈ìuds de type
        for _, typeDef := range program.Types </span><span class="cov0" title="0">{
                typeNode := NewTypeNode(typeDef.Name, typeDef, rn.Storage)
                rn.TypeNodes[typeDef.Name] = typeNode
                rn.RootNode.AddChild(typeNode)
                fmt.Printf("   ‚úì Cr√©√© TypeNode: %s\n", typeDef.Name)
        }</span>

        // Cr√©er les n≈ìuds pour chaque expression (r√®gle)
        <span class="cov0" title="0">for i, expr := range program.Expressions </span><span class="cov0" title="0">{
                ruleID := fmt.Sprintf("rule_%d", i)
                fmt.Printf("   üìã Traitement de la r√®gle: %s\n", ruleID)

                // Cr√©er les n≈ìuds alpha pour les conditions
                alphaNodes, err := rn.createAlphaNodes(expr, ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur cr√©ation n≈ìuds alpha: %w", err)
                }</span>

                // Cr√©er le n≈ìud terminal pour l'action
                <span class="cov0" title="0">terminalNode := NewTerminalNode(ruleID+"_terminal", expr.Action, rn.Storage)
                rn.TerminalNodes[terminalNode.ID] = terminalNode

                // Connecter les n≈ìuds alpha au n≈ìud terminal
                for _, alphaNode := range alphaNodes </span><span class="cov0" title="0">{
                        alphaNode.AddChild(terminalNode)
                        fmt.Printf("     ‚úì Connect√© AlphaNode %s -&gt; TerminalNode %s\n", alphaNode.ID, terminalNode.ID)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üéØ R√©seau RETE construit avec succ√®s!\n")
        fmt.Printf("   - %d TypeNodes\n", len(rn.TypeNodes))
        fmt.Printf("   - %d AlphaNodes\n", len(rn.AlphaNodes))
        fmt.Printf("   - %d TerminalNodes\n", len(rn.TerminalNodes))

        return nil</span>
}

// createAlphaNodes cr√©e les n≈ìuds alpha pour une expression
func (rn *ReteNetwork) createAlphaNodes(expr Expression, ruleID string) ([]*AlphaNode, error) <span class="cov0" title="0">{
        var alphaNodes []*AlphaNode

        // Identifier le type de la variable dans le set
        for _, variable := range expr.Set.Variables </span><span class="cov0" title="0">{
                typeNode, exists := rn.TypeNodes[variable.DataType]
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("type non trouv√©: %s", variable.DataType)
                }</span>

                // Cr√©er un n≈ìud alpha pour cette condition
                <span class="cov0" title="0">alphaNodeID := fmt.Sprintf("%s_alpha_%s", ruleID, variable.Name)
                alphaNode := NewAlphaNode(alphaNodeID, expr.Constraints, variable.Name, rn.Storage)
                rn.AlphaNodes[alphaNodeID] = alphaNode

                // Connecter le n≈ìud de type au n≈ìud alpha
                typeNode.AddChild(alphaNode)

                alphaNodes = append(alphaNodes, alphaNode)
                fmt.Printf("     ‚úì Cr√©√© AlphaNode: %s pour variable: %s\n", alphaNodeID, variable.Name)</span>
        }

        <span class="cov0" title="0">return alphaNodes, nil</span>
}

// GetNetworkState retourne l'√©tat complet du r√©seau
func (rn *ReteNetwork) GetNetworkState() (map[string]*WorkingMemory, error) <span class="cov0" title="0">{
        state := make(map[string]*WorkingMemory)

        // R√©cup√©rer l'√©tat de tous les n≈ìuds
        nodes := []Node{rn.RootNode}

        for _, typeNode := range rn.TypeNodes </span><span class="cov0" title="0">{
                nodes = append(nodes, typeNode)
        }</span>
        <span class="cov0" title="0">for _, alphaNode := range rn.AlphaNodes </span><span class="cov0" title="0">{
                nodes = append(nodes, alphaNode)
        }</span>
        <span class="cov0" title="0">for _, terminalNode := range rn.TerminalNodes </span><span class="cov0" title="0">{
                nodes = append(nodes, terminalNode)
        }</span>

        <span class="cov0" title="0">for _, node := range nodes </span><span class="cov0" title="0">{
                memory, err := rn.Storage.LoadMemory(node.GetID())
                if err != nil </span><span class="cov0" title="0">{
                        // Si pas de m√©moire sauv√©e, utiliser la m√©moire courante
                        memory = node.GetMemory()
                }</span>
                <span class="cov0" title="0">state[node.GetID()] = memory</span>
        }

        <span class="cov0" title="0">return state, nil</span>
}

// PrintNetworkStructure affiche la structure du r√©seau
func (rn *ReteNetwork) PrintNetworkStructure() <span class="cov0" title="0">{
        fmt.Printf("\nüìä STRUCTURE DU R√âSEAU RETE:\n")
        fmt.Printf("Root: %s\n", rn.RootNode.GetID())

        for typeName, typeNode := range rn.TypeNodes </span><span class="cov0" title="0">{
                fmt.Printf("‚îú‚îÄ‚îÄ TypeNode[%s]: %s\n", typeName, typeNode.GetID())

                for _, child := range typeNode.GetChildren() </span><span class="cov0" title="0">{
                        if alphaNode, ok := child.(*AlphaNode); ok </span><span class="cov0" title="0">{
                                fmt.Printf("‚îÇ   ‚îú‚îÄ‚îÄ AlphaNode: %s\n", alphaNode.GetID())

                                for _, grandChild := range alphaNode.GetChildren() </span><span class="cov0" title="0">{
                                        if terminalNode, ok := grandChild.(*TerminalNode); ok </span><span class="cov0" title="0">{
                                                fmt.Printf("‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TerminalNode: %s\n", terminalNode.GetID())
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">fmt.Printf("\n")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package rete

import (
        "fmt"
        "sync"
        "time"
)

// ========== TYPES DE BASE ==========

// Fact repr√©sente un fait dans le syst√®me RETE
type Fact struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        Fields    map[string]interface{} `json:"fields"`
        Timestamp time.Time              `json:"timestamp"`
}

// String retourne la repr√©sentation string d'un fait
func (f *Fact) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Fact{ID:%s, Type:%s, Fields:%v}", f.ID, f.Type, f.Fields)
}</span>

// GetField retourne la valeur d'un champ
func (f *Fact) GetField(fieldName string) (interface{}, bool) <span class="cov0" title="0">{
        value, exists := f.Fields[fieldName]
        return value, exists
}</span>

// Token repr√©sente un token dans le r√©seau RETE
type Token struct {
        ID     string  `json:"id"`
        Facts  []*Fact `json:"facts"`
        NodeID string  `json:"node_id"`
        Parent *Token  `json:"parent,omitempty"`
}

// WorkingMemory repr√©sente la m√©moire de travail d'un n≈ìud
type WorkingMemory struct {
        NodeID string            `json:"node_id"`
        Facts  map[string]*Fact  `json:"facts"`
        Tokens map[string]*Token `json:"tokens"`
}

// AddFact ajoute un fait √† la m√©moire
func (wm *WorkingMemory) AddFact(fact *Fact) <span class="cov8" title="1">{
        if wm.Facts == nil </span><span class="cov0" title="0">{
                wm.Facts = make(map[string]*Fact)
        }</span>
        <span class="cov8" title="1">wm.Facts[fact.ID] = fact</span>
}

// RemoveFact supprime un fait de la m√©moire
func (wm *WorkingMemory) RemoveFact(factID string) <span class="cov0" title="0">{
        delete(wm.Facts, factID)
}</span>

// GetFacts retourne tous les faits de la m√©moire
func (wm *WorkingMemory) GetFacts() []*Fact <span class="cov0" title="0">{
        facts := make([]*Fact, 0, len(wm.Facts))
        for _, fact := range wm.Facts </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>
        <span class="cov0" title="0">return facts</span>
}

// ========== INTERFACES ==========

// Node interface pour tous les n≈ìuds du r√©seau RETE
type Node interface {
        GetID() string
        GetType() string
        GetMemory() *WorkingMemory
        ActivateLeft(token *Token) error
        ActivateRight(fact *Fact) error
        AddChild(child Node)
        GetChildren() []Node
}

// Storage interface pour la persistance
type Storage interface {
        SaveMemory(nodeID string, memory *WorkingMemory) error
        LoadMemory(nodeID string) (*WorkingMemory, error)
        DeleteMemory(nodeID string) error
        ListNodes() ([]string, error)
}

// ========== TYPES POUR COMPATIBILIT√â AST ==========

type Field struct {
        Name string `json:"name"`
        Type string `json:"type"`
}

type TypeDefinition struct {
        Type   string  `json:"type"`
        Name   string  `json:"name"`
        Fields []Field `json:"fields"`
}

type JobCall struct {
        Type string   `json:"type"`
        Name string   `json:"name"`
        Args []string `json:"args"`
}

type Action struct {
        Type string  `json:"type"`
        Job  JobCall `json:"job"`
}

type TypedVariable struct {
        Type     string `json:"type"`
        Name     string `json:"name"`
        DataType string `json:"dataType"`
}

type Set struct {
        Type      string          `json:"type"`
        Variables []TypedVariable `json:"variables"`
}

type Expression struct {
        Type        string      `json:"type"`
        Set         Set         `json:"set"`
        Constraints interface{} `json:"constraints"`
        Action      *Action     `json:"action,omitempty"`
}

type Program struct {
        Types       []TypeDefinition `json:"types"`
        Expressions []Expression     `json:"expressions"`
}

// ========== IMPL√âMENTATION DES N≈íUDS ==========

// BaseNode impl√©mente les fonctionnalit√©s communes √† tous les n≈ìuds
type BaseNode struct {
        ID       string         `json:"id"`
        Type     string         `json:"type"`
        Memory   *WorkingMemory `json:"memory"`
        Children []Node         `json:"children"`
        Storage  Storage        `json:"-"`
        mutex    sync.RWMutex   `json:"-"`
}

// GetID retourne l'ID du n≈ìud
func (bn *BaseNode) GetID() string <span class="cov0" title="0">{
        return bn.ID
}</span>

// GetType retourne le type du n≈ìud
func (bn *BaseNode) GetType() string <span class="cov0" title="0">{
        return bn.Type
}</span>

// GetMemory retourne la m√©moire de travail du n≈ìud
func (bn *BaseNode) GetMemory() *WorkingMemory <span class="cov0" title="0">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()
        return bn.Memory
}</span>

// AddChild ajoute un n≈ìud enfant
func (bn *BaseNode) AddChild(child Node) <span class="cov8" title="1">{
        bn.mutex.Lock()
        defer bn.mutex.Unlock()
        bn.Children = append(bn.Children, child)
}</span>

// GetChildren retourne les n≈ìuds enfants
func (bn *BaseNode) GetChildren() []Node <span class="cov8" title="1">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()
        return bn.Children
}</span>

// PropagateToChildren propage un fait ou token aux enfants
func (bn *BaseNode) PropagateToChildren(fact *Fact, token *Token) error <span class="cov8" title="1">{
        for _, child := range bn.GetChildren() </span><span class="cov8" title="1">{
                if fact != nil </span><span class="cov0" title="0">{
                        if err := child.ActivateRight(fact); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation fait vers %s: %w", child.GetID(), err)
                        }</span>
                }
                <span class="cov8" title="1">if token != nil </span><span class="cov8" title="1">{
                        if err := child.ActivateLeft(token); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation token vers %s: %w", child.GetID(), err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// SaveMemory sauvegarde la m√©moire du n≈ìud
func (bn *BaseNode) SaveMemory() error <span class="cov0" title="0">{
        if bn.Storage != nil </span><span class="cov0" title="0">{
                return bn.Storage.SaveMemory(bn.ID, bn.Memory)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ========== N≈íUD RACINE ==========

// RootNode est le n≈ìud racine qui re√ßoit tous les faits
type RootNode struct {
        BaseNode
}

// NewRootNode cr√©e un nouveau n≈ìud racine
func NewRootNode(storage Storage) *RootNode <span class="cov0" title="0">{
        return &amp;RootNode{
                BaseNode: BaseNode{
                        ID:       "root",
                        Type:     "root",
                        Memory:   &amp;WorkingMemory{NodeID: "root", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
        }
}</span>

// ActivateLeft (non utilis√© pour le n≈ìud racine)
func (rn *RootNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("le n≈ìud racine ne peut pas recevoir de tokens")
}</span>

// ActivateRight distribue les faits aux n≈ìuds de type
func (rn *RootNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{
        rn.mutex.Lock()
        rn.Memory.AddFact(fact)
        rn.mutex.Unlock()

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ROOT] Re√ßu fait: %s\n", fact.String())

        // Persistance d√©sactiv√©e pour les performances

        // Propager aux enfants (TypeNodes)
        return rn.PropagateToChildren(fact, nil)
}</span>

// ========== N≈íUD DE TYPE ==========

// TypeNode filtre les faits selon leur type
type TypeNode struct {
        BaseNode
        TypeName       string         `json:"type_name"`
        TypeDefinition TypeDefinition `json:"type_definition"`
}

// NewTypeNode cr√©e un nouveau n≈ìud de type
func NewTypeNode(typeName string, typeDef TypeDefinition, storage Storage) *TypeNode <span class="cov0" title="0">{
        return &amp;TypeNode{
                BaseNode: BaseNode{
                        ID:       fmt.Sprintf("type_%s", typeName),
                        Type:     "type",
                        Memory:   &amp;WorkingMemory{NodeID: fmt.Sprintf("type_%s", typeName), Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                TypeName:       typeName,
                TypeDefinition: typeDef,
        }
}</span>

// ActivateLeft (non utilis√© pour les n≈ìuds de type)
func (tn *TypeNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds de type ne re√ßoivent pas de tokens")
}</span>

// ActivateRight filtre les faits par type et les propage
func (tn *TypeNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{
        // V√©rifier si le fait correspond au type de ce n≈ìud
        if fact.Type != tn.TypeName </span><span class="cov0" title="0">{
                return nil // Ignorer silencieusement les faits d'autres types
        }</span>

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[TYPE_%s] Re√ßu fait: %s\n", tn.TypeName, fact.String())

        // Valider les champs du fait
        <span class="cov0" title="0">if err := tn.validateFact(fact); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation du fait √©chou√©e: %w", err)
        }</span>

        <span class="cov0" title="0">tn.mutex.Lock()
        tn.Memory.AddFact(fact)
        tn.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // Propager aux enfants (AlphaNodes)
        return tn.PropagateToChildren(fact, nil)</span>
}

// validateFact valide qu'un fait respecte la d√©finition de type
func (tn *TypeNode) validateFact(fact *Fact) error <span class="cov0" title="0">{
        for _, field := range tn.TypeDefinition.Fields </span><span class="cov0" title="0">{
                value, exists := fact.Fields[field.Name]
                if !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ manquant: %s", field.Name)
                }</span>

                // Validation basique des types
                <span class="cov0" title="0">if !tn.isValidType(value, field.Type) </span><span class="cov0" title="0">{
                        return fmt.Errorf("type invalide pour le champ %s: attendu %s", field.Name, field.Type)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// isValidType v√©rifie si une valeur correspond au type attendu
func (tn *TypeNode) isValidType(value interface{}, expectedType string) bool <span class="cov0" title="0">{
        switch expectedType </span>{
        case "string":<span class="cov0" title="0">
                _, ok := value.(string)
                return ok</span>
        case "number":<span class="cov0" title="0">
                switch value.(type) </span>{
                case int, int32, int64, float32, float64:<span class="cov0" title="0">
                        return true</span>
                }
                <span class="cov0" title="0">return false</span>
        case "bool":<span class="cov0" title="0">
                _, ok := value.(bool)
                return ok</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// ========== N≈íUD ALPHA (CONDITIONS SIMPLES) ==========

// AlphaNode teste une condition sur un fait
type AlphaNode struct {
        BaseNode
        Condition    interface{} `json:"condition"`
        VariableName string      `json:"variable_name"`
}

// NewAlphaNode cr√©e un nouveau n≈ìud alpha
func NewAlphaNode(nodeID string, condition interface{}, variableName string, storage Storage) *AlphaNode <span class="cov8" title="1">{
        return &amp;AlphaNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "alpha",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:    condition,
                VariableName: variableName,
        }
}</span>

// ActivateLeft (non utilis√© pour les n≈ìuds alpha)
func (an *AlphaNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds alpha ne re√ßoivent pas de tokens")
}</span>

// ActivateRight teste la condition sur le fait
func (an *AlphaNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ALPHA_%s] Test condition sur fait: %s\n", an.ID, fact.String())

        // √âvaluer la condition Alpha sur le fait
        if an.Condition != nil </span><span class="cov8" title="1">{
                evaluator := NewAlphaConditionEvaluator()
                passed, err := evaluator.EvaluateCondition(an.Condition, fact, an.VariableName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur √©valuation condition Alpha: %w", err)
                }</span>

                // Si la condition n'est pas satisfaite, ignorer le fait
                <span class="cov8" title="1">if !passed </span><span class="cov8" title="1">{
                        // Log d√©sactiv√© pour les performances
                        // fmt.Printf("[ALPHA_%s] Condition non satisfaite pour le fait: %s\n", an.ID, fact.String())
                        return nil
                }</span>
        }

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ALPHA_%s] Condition satisfaite pour le fait: %s\n", an.ID, fact.String())

        <span class="cov8" title="1">an.mutex.Lock()
        an.Memory.AddFact(fact)
        an.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // Cr√©er un token et le propager
        token := &amp;Token{
                ID:     fmt.Sprintf("token_%s_%s", an.ID, fact.ID),
                Facts:  []*Fact{fact},
                NodeID: an.ID,
        }

        return an.PropagateToChildren(nil, token)</span>
}

// ========== N≈íUD TERMINAL (ACTIONS) ==========

// TerminalNode d√©clenche une action
type TerminalNode struct {
        BaseNode
        Action *Action `json:"action"`
}

// NewTerminalNode cr√©e un nouveau n≈ìud terminal
func NewTerminalNode(nodeID string, action *Action, storage Storage) *TerminalNode <span class="cov0" title="0">{
        return &amp;TerminalNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "terminal",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0), // Les n≈ìuds terminaux n'ont pas d'enfants
                        Storage:  storage,
                },
                Action: action,
        }
}</span>

// ActivateLeft d√©clenche l'action
func (tn *TerminalNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[TERMINAL_%s] D√©clenchement action avec token: %s\n", tn.ID, token.ID)

        // Stocker le token
        tn.mutex.Lock()
        if tn.Memory.Tokens == nil </span><span class="cov0" title="0">{
                tn.Memory.Tokens = make(map[string]*Token)
        }</span>
        <span class="cov0" title="0">tn.Memory.Tokens[token.ID] = token
        tn.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // D√©clencher l'action
        return tn.executeAction(token)</span>
}

// ActivateRight (non utilis√© pour les n≈ìuds terminaux)
func (tn *TerminalNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds terminaux ne re√ßoivent pas de faits directement")
}</span>

// executeAction ex√©cute l'action avec les faits du token
func (tn *TerminalNode) executeAction(token *Token) error <span class="cov0" title="0">{
        if tn.Action == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune action d√©finie pour le n≈ìud %s", tn.ID)
        }</span>

        // Action ex√©cut√©e silencieusement (logs d√©sactiv√©s pour les performances)
        // Format de sortie de base : nom de l'action + faits
        // fmt.Printf("üéØ ACTION D√âCLENCH√âE: %s\n", tn.Action.Job.Name)
        // fmt.Printf("   Arguments: %v\n", tn.Action.Job.Args)
        // fmt.Printf("   Faits correspondants:\n")

        // for _, fact := range token.Facts {
        //        factJSON, _ := json.MarshalIndent(fact, "     ", "  ")
        //        fmt.Printf("     - %s\n", factJSON)
        // }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package rete

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        clientv3 "go.etcd.io/etcd/client/v3"
)

// EtcdStorage impl√©mente l'interface Storage avec etcd
type EtcdStorage struct {
        client    *clientv3.Client
        keyPrefix string
        timeout   time.Duration
}

// NewEtcdStorage cr√©e un nouveau storage etcd
func NewEtcdStorage(endpoints []string, keyPrefix string) (*EtcdStorage, error) <span class="cov0" title="0">{
        client, err := clientv3.New(clientv3.Config{
                Endpoints:   endpoints,
                DialTimeout: 5 * time.Second,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur connexion etcd: %w", err)
        }</span>

        <span class="cov0" title="0">storage := &amp;EtcdStorage{
                client:    client,
                keyPrefix: keyPrefix,
                timeout:   5 * time.Second,
        }

        // Tester la connexion
        ctx, cancel := context.WithTimeout(context.Background(), storage.timeout)
        defer cancel()

        _, err = client.Status(ctx, endpoints[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("test connexion etcd √©chou√©: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Connexion etcd √©tablie (prefix: %s)\n", keyPrefix)
        return storage, nil</span>
}

// Close ferme la connexion etcd
func (es *EtcdStorage) Close() error <span class="cov0" title="0">{
        return es.client.Close()
}</span>

// SaveMemory sauvegarde la m√©moire d'un n≈ìud dans etcd
func (es *EtcdStorage) SaveMemory(nodeID string, memory *WorkingMemory) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), es.timeout)
        defer cancel()

        // S√©rialiser la m√©moire en JSON
        data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur s√©rialisation m√©moire: %w", err)
        }</span>

        // Cl√© etcd pour ce n≈ìud
        <span class="cov0" title="0">key := fmt.Sprintf("%s/nodes/%s/memory", es.keyPrefix, nodeID)

        // Sauvegarder dans etcd avec un timestamp
        _, err = es.client.Put(ctx, key, string(data))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur sauvegarde etcd: %w", err)
        }</span>

        // √âgalement sauvegarder un timestamp de derni√®re modification
        <span class="cov0" title="0">timestampKey := fmt.Sprintf("%s/nodes/%s/timestamp", es.keyPrefix, nodeID)
        _, err = es.client.Put(ctx, timestampKey, time.Now().Format(time.RFC3339))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Erreur sauvegarde timestamp: %v\n", err) // Non bloquant
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoadMemory charge la m√©moire d'un n≈ìud depuis etcd
func (es *EtcdStorage) LoadMemory(nodeID string) (*WorkingMemory, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), es.timeout)
        defer cancel()

        // Cl√© etcd pour ce n≈ìud
        key := fmt.Sprintf("%s/nodes/%s/memory", es.keyPrefix, nodeID)

        // R√©cup√©rer depuis etcd
        resp, err := es.client.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur lecture etcd: %w", err)
        }</span>

        <span class="cov0" title="0">if len(resp.Kvs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("m√©moire non trouv√©e pour le n≈ìud %s", nodeID)
        }</span>

        // D√©s√©rialiser la m√©moire
        <span class="cov0" title="0">var memory WorkingMemory
        err = json.Unmarshal(resp.Kvs[0].Value, &amp;memory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur d√©s√©rialisation m√©moire: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;memory, nil</span>
}

// DeleteMemory supprime la m√©moire d'un n≈ìud d'etcd
func (es *EtcdStorage) DeleteMemory(nodeID string) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), es.timeout)
        defer cancel()

        // Supprimer la m√©moire et le timestamp
        memoryKey := fmt.Sprintf("%s/nodes/%s/memory", es.keyPrefix, nodeID)
        timestampKey := fmt.Sprintf("%s/nodes/%s/timestamp", es.keyPrefix, nodeID)

        _, err := es.client.Delete(ctx, memoryKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur suppression m√©moire etcd: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = es.client.Delete(ctx, timestampKey)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Erreur suppression timestamp: %v\n", err) // Non bloquant
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListNodes retourne la liste des n≈ìuds stock√©s
func (es *EtcdStorage) ListNodes() ([]string, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), es.timeout)
        defer cancel()

        // Prefix pour tous les n≈ìuds
        prefix := fmt.Sprintf("%s/nodes/", es.keyPrefix)

        // R√©cup√©rer toutes les cl√©s avec ce pr√©fixe
        resp, err := es.client.Get(ctx, prefix, clientv3.WithPrefix(), clientv3.WithKeysOnly())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur liste n≈ìuds etcd: %w", err)
        }</span>

        // Extraire les IDs des n≈ìuds
        <span class="cov0" title="0">nodeIDs := make(map[string]bool)
        for _, kv := range resp.Kvs </span><span class="cov0" title="0">{
                key := string(kv.Key)
                // Extraire l'ID du n≈ìud depuis la cl√©
                // Format: prefix/nodes/{nodeID}/memory ou prefix/nodes/{nodeID}/timestamp
                parts := strings.Split(strings.TrimPrefix(key, prefix), "/")
                if len(parts) &gt;= 1 </span><span class="cov0" title="0">{
                        nodeIDs[parts[0]] = true
                }</span>
        }

        // Convertir en slice
        <span class="cov0" title="0">nodes := make([]string, 0, len(nodeIDs))
        for nodeID := range nodeIDs </span><span class="cov0" title="0">{
                nodes = append(nodes, nodeID)
        }</span>

        <span class="cov0" title="0">return nodes, nil</span>
}

// MemoryStorage impl√©mente Storage en m√©moire (pour les tests)
type MemoryStorage struct {
        memories map[string]*WorkingMemory
        mutex    sync.RWMutex
}

// NewMemoryStorage cr√©e un nouveau storage en m√©moire
func NewMemoryStorage() *MemoryStorage <span class="cov0" title="0">{
        return &amp;MemoryStorage{
                memories: make(map[string]*WorkingMemory),
        }
}</span>

// SaveMemory sauvegarde en m√©moire
func (ms *MemoryStorage) SaveMemory(nodeID string, memory *WorkingMemory) error <span class="cov0" title="0">{
        ms.mutex.Lock()
        defer ms.mutex.Unlock()

        // Copier la m√©moire pour √©viter les modifications concurrentes
        data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var copyMemory WorkingMemory
        err = json.Unmarshal(data, &amp;copyMemory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ms.memories[nodeID] = &amp;copyMemory
        return nil</span>
}

// LoadMemory charge depuis la m√©moire
func (ms *MemoryStorage) LoadMemory(nodeID string) (*WorkingMemory, error) <span class="cov0" title="0">{
        ms.mutex.RLock()
        defer ms.mutex.RUnlock()

        memory, exists := ms.memories[nodeID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("m√©moire non trouv√©e pour le n≈ìud %s", nodeID)
        }</span>

        // Retourner une copie
        <span class="cov0" title="0">data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var copyMemory WorkingMemory
        err = json.Unmarshal(data, &amp;copyMemory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;copyMemory, nil</span>
}

// DeleteMemory supprime de la m√©moire
func (ms *MemoryStorage) DeleteMemory(nodeID string) error <span class="cov0" title="0">{
        ms.mutex.Lock()
        defer ms.mutex.Unlock()
        delete(ms.memories, nodeID)
        return nil
}</span>

// ListNodes liste les n≈ìuds en m√©moire
func (ms *MemoryStorage) ListNodes() ([]string, error) <span class="cov0" title="0">{
        ms.mutex.RLock()
        defer ms.mutex.RUnlock()

        nodes := make([]string, 0, len(ms.memories))
        for nodeID := range ms.memories </span><span class="cov0" title="0">{
                nodes = append(nodes, nodeID)
        }</span>
        <span class="cov0" title="0">return nodes, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
