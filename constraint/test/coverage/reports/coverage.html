
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/treivax/tsd/constraint/internal/config/config.go (0.0%)</option>

				<option value="file1">github.com/treivax/tsd/constraint/pkg/domain/errors.go (86.7%)</option>

				<option value="file2">github.com/treivax/tsd/constraint/pkg/domain/types.go (96.0%)</option>

				<option value="file3">github.com/treivax/tsd/constraint/pkg/validator/types.go (92.2%)</option>

				<option value="file4">github.com/treivax/tsd/constraint/pkg/validator/validator.go (78.1%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/treivax/tsd/constraint/pkg/domain"
)

// Config représente la configuration complète du module constraint
type Config struct {
        Parser    domain.ParserConfig    `json:"parser"`
        Validator domain.ValidatorConfig `json:"validator"`
        Logger    domain.LoggerConfig    `json:"logger"`
        Debug     bool                   `json:"debug"`
        Version   string                 `json:"version"`
}

// DefaultConfig retourne une configuration par défaut
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Parser: domain.ParserConfig{
                        MaxExpressions: 1000,
                        Debug:          false,
                        Recover:        true,
                },
                Validator: domain.ValidatorConfig{
                        StrictMode: true,
                        AllowedOperators: []string{
                                "==", "!=", "&lt;", "&gt;", "&lt;=", "&gt;=",
                                "AND", "OR", "NOT",
                                "+", "-", "*", "/", "%",
                        },
                        MaxDepth: 20,
                },
                Logger: domain.LoggerConfig{
                        Level:  "info",
                        Format: "json",
                        Output: "stdout",
                },
                Debug:   false,
                Version: "1.0.0",
        }
}</span>

// ConfigManager gère la configuration du module
type ConfigManager struct {
        config   *Config
        filePath string
}

// NewConfigManager crée un nouveau gestionnaire de configuration
func NewConfigManager(configPath string) *ConfigManager <span class="cov0" title="0">{
        return &amp;ConfigManager{
                config:   DefaultConfig(),
                filePath: configPath,
        }
}</span>

// LoadFromFile charge la configuration depuis un fichier
func (cm *ConfigManager) LoadFromFile() error <span class="cov0" title="0">{
        if cm.filePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("config file path not set")
        }</span>

        // Vérifier si le fichier existe
        <span class="cov0" title="0">if _, err := os.Stat(cm.filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Si le fichier n'existe pas, créer la configuration par défaut
                return cm.SaveToFile()
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(cm.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config file %s: %w", cm.filePath, err)
        }</span>

        <span class="cov0" title="0">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse config file %s: %w", cm.filePath, err)
        }</span>

        <span class="cov0" title="0">cm.config = &amp;config
        return nil</span>
}

// SaveToFile sauvegarde la configuration dans un fichier
func (cm *ConfigManager) SaveToFile() error <span class="cov0" title="0">{
        if cm.filePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("config file path not set")
        }</span>

        // Créer le répertoire si nécessaire
        <span class="cov0" title="0">dir := filepath.Dir(cm.filePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory %s: %w", dir, err)
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(cm.config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(cm.filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file %s: %w", cm.filePath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfig retourne la configuration actuelle
func (cm *ConfigManager) GetConfig() *Config <span class="cov0" title="0">{
        return cm.config
}</span>

// SetConfig définit une nouvelle configuration
func (cm *ConfigManager) SetConfig(config *Config) <span class="cov0" title="0">{
        cm.config = config
}</span>

// GetParserConfig retourne la configuration du parser
func (cm *ConfigManager) GetParserConfig() domain.ParserConfig <span class="cov0" title="0">{
        return cm.config.Parser
}</span>

// GetValidatorConfig retourne la configuration du validateur
func (cm *ConfigManager) GetValidatorConfig() domain.ValidatorConfig <span class="cov0" title="0">{
        return cm.config.Validator
}</span>

// GetLoggerConfig retourne la configuration du logger
func (cm *ConfigManager) GetLoggerConfig() domain.LoggerConfig <span class="cov0" title="0">{
        return cm.config.Logger
}</span>

// IsDebugEnabled vérifie si le mode debug est activé
func (cm *ConfigManager) IsDebugEnabled() bool <span class="cov0" title="0">{
        return cm.config.Debug || cm.config.Parser.Debug
}</span>

// UpdateParserConfig met à jour la configuration du parser
func (cm *ConfigManager) UpdateParserConfig(config domain.ParserConfig) <span class="cov0" title="0">{
        cm.config.Parser = config
}</span>

// UpdateValidatorConfig met à jour la configuration du validateur
func (cm *ConfigManager) UpdateValidatorConfig(config domain.ValidatorConfig) <span class="cov0" title="0">{
        cm.config.Validator = config
}</span>

// UpdateLoggerConfig met à jour la configuration du logger
func (cm *ConfigManager) UpdateLoggerConfig(config domain.LoggerConfig) <span class="cov0" title="0">{
        cm.config.Logger = config
}</span>

// SetDebug active/désactive le mode debug
func (cm *ConfigManager) SetDebug(enabled bool) <span class="cov0" title="0">{
        cm.config.Debug = enabled
}</span>

// Validate valide la configuration
func (cm *ConfigManager) Validate() error <span class="cov0" title="0">{
        config := cm.config

        // Validation du parser
        if config.Parser.MaxExpressions &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("parser.max_expressions must be positive, got %d", config.Parser.MaxExpressions)
        }</span>

        // Validation du validateur
        <span class="cov0" title="0">if config.Validator.MaxDepth &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("validator.max_depth must be positive, got %d", config.Validator.MaxDepth)
        }</span>

        <span class="cov0" title="0">if len(config.Validator.AllowedOperators) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("validator.allowed_operators cannot be empty")
        }</span>

        // Validation du logger
        <span class="cov0" title="0">validLevels := map[string]bool{
                "debug": true, "info": true, "warn": true, "error": true,
        }
        if !validLevels[config.Logger.Level] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid logger level: %s", config.Logger.Level)
        }</span>

        <span class="cov0" title="0">validFormats := map[string]bool{
                "json": true, "text": true, "plain": true,
        }
        if !validFormats[config.Logger.Format] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid logger format: %s", config.Logger.Format)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// String retourne une représentation JSON de la configuration
func (cm *ConfigManager) String() string <span class="cov0" title="0">{
        data, err := json.MarshalIndent(cm.config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("ConfigManager{error: %v}", err)
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}

// Clone crée une copie de la configuration
func (cm *ConfigManager) Clone() *ConfigManager <span class="cov0" title="0">{
        configCopy := *cm.config
        return &amp;ConfigManager{
                config:   &amp;configCopy,
                filePath: cm.filePath,
        }
}</span>

// Reset remet la configuration aux valeurs par défaut
func (cm *ConfigManager) Reset() <span class="cov0" title="0">{
        cm.config = DefaultConfig()
}</pre>

		<pre class="file" id="file1" style="display: none">package domain

import (
        "fmt"
)

// ErrorType définit les types d'erreurs du module constraint
type ErrorType string

const (
        // Erreurs de parsing
        ParseError ErrorType = "PARSE_ERROR"

        // Erreurs de validation
        ValidationError ErrorType = "VALIDATION_ERROR"
        TypeMismatchError ErrorType = "TYPE_MISMATCH_ERROR"
        FieldNotFoundError ErrorType = "FIELD_NOT_FOUND_ERROR"
        UnknownTypeError ErrorType = "UNKNOWN_TYPE_ERROR"

        // Erreurs de contraintes
        ConstraintValidationError ErrorType = "CONSTRAINT_ERROR"
        ActionError ErrorType = "ACTION_ERROR"
)

// Error représente une erreur structurée du module constraint
type Error struct {
        Type    ErrorType `json:"type"`
        Message string    `json:"message"`
        Context Context   `json:"context"`
        Cause   error     `json:"cause,omitempty"`
}

// Context fournit des informations contextuelles sur l'erreur
type Context struct {
        File     string      `json:"file,omitempty"`
        Line     int         `json:"line,omitempty"`
        Column   int         `json:"column,omitempty"`
        Field    string      `json:"field,omitempty"`
        Type     string      `json:"type,omitempty"`
        Variable string      `json:"variable,omitempty"`
        Value    interface{} `json:"value,omitempty"`
        Expected string      `json:"expected,omitempty"`
        Actual   string      `json:"actual,omitempty"`
}

// Error implémente l'interface error
func (ce *Error) Error() string <span class="cov8" title="1">{
        if ce.Context.File != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s at %s:%d:%d: %s",
                        ce.Type, ce.Context.File, ce.Context.Line, ce.Context.Column, ce.Message)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s: %s", ce.Type, ce.Message)</span>
}

// Unwrap permet le unwrapping des erreurs
func (ce *Error) Unwrap() error <span class="cov8" title="1">{
        return ce.Cause
}</span>

// Is permet la comparaison des types d'erreurs
func (ce *Error) Is(target error) bool <span class="cov8" title="1">{
        if t, ok := target.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == t.Type
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Constructeurs d'erreurs

// NewParseError crée une erreur de parsing
func NewParseError(message, file string, line, column int) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Type:    ParseError,
                Message: message,
                Context: Context{
                        File:   file,
                        Line:   line,
                        Column: column,
                },
        }
}</span>

// NewValidationError crée une erreur de validation
func NewValidationError(message string, ctx Context) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Type:    ValidationError,
                Message: message,
                Context: ctx,
        }
}</span>

// NewTypeMismatchError crée une erreur de type incompatible
func NewTypeMismatchError(expected, actual string, ctx Context) *Error <span class="cov8" title="1">{
        ctx.Expected = expected
        ctx.Actual = actual
        return &amp;Error{
                Type:    TypeMismatchError,
                Message: fmt.Sprintf("type mismatch: expected %s, got %s", expected, actual),
                Context: ctx,
        }
}</span>

// NewFieldNotFoundError crée une erreur de champ introuvable
func NewFieldNotFoundError(field, typeName string, ctx Context) *Error <span class="cov8" title="1">{
        ctx.Field = field
        ctx.Type = typeName
        return &amp;Error{
                Type:    FieldNotFoundError,
                Message: fmt.Sprintf("field '%s' not found in type '%s'", field, typeName),
                Context: ctx,
        }
}</span>

// NewUnknownTypeError crée une erreur de type inconnu
func NewUnknownTypeError(typeName string, ctx Context) *Error <span class="cov8" title="1">{
        ctx.Type = typeName
        return &amp;Error{
                Type:    UnknownTypeError,
                Message: fmt.Sprintf("unknown type '%s'", typeName),
                Context: ctx,
        }
}</span>

// NewConstraintError crée une erreur de contrainte
func NewConstraintError(message string, ctx Context) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Type:    ConstraintValidationError,
                Message: message,
                Context: ctx,
        }
}</span>

// NewActionError crée une erreur d'action
func NewActionError(message string, ctx Context) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Type:    ActionError,
                Message: message,
                Context: ctx,
        }
}</span>

// Helpers pour vérifier les types d'erreurs

// IsParseError vérifie si l'erreur est une erreur de parsing
func IsParseError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == ParseError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsValidationError vérifie si l'erreur est une erreur de validation
func IsValidationError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == ValidationError ||
                           ce.Type == TypeMismatchError ||
                           ce.Type == FieldNotFoundError ||
                           ce.Type == UnknownTypeError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsTypeMismatchError vérifie si l'erreur est une erreur de type incompatible
func IsTypeMismatchError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == TypeMismatchError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsFieldNotFoundError vérifie si l'erreur est une erreur de champ introuvable
func IsFieldNotFoundError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == FieldNotFoundError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsUnknownTypeError vérifie si l'erreur est une erreur de type inconnu
func IsUnknownTypeError(err error) bool <span class="cov8" title="1">{
        if ce, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                return ce.Type == UnknownTypeError
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ErrorCollection permet de collecter plusieurs erreurs
type ErrorCollection struct {
        Errors []*Error `json:"errors"`
}

// NewErrorCollection crée une nouvelle collection d'erreurs
func NewErrorCollection() *ErrorCollection <span class="cov8" title="1">{
        return &amp;ErrorCollection{
                Errors: make([]*Error, 0),
        }
}</span>

// Add ajoute une erreur à la collection
func (ec *ErrorCollection) Add(err *Error) <span class="cov8" title="1">{
        ec.Errors = append(ec.Errors, err)
}</span>

// HasErrors vérifie s'il y a des erreurs
func (ec *ErrorCollection) HasErrors() bool <span class="cov8" title="1">{
        return len(ec.Errors) &gt; 0
}</span>

// Error implémente l'interface error pour la collection
func (ec *ErrorCollection) Error() string <span class="cov8" title="1">{
        if len(ec.Errors) == 0 </span><span class="cov8" title="1">{
                return "no errors"
        }</span>
        <span class="cov8" title="1">if len(ec.Errors) == 1 </span><span class="cov8" title="1">{
                return ec.Errors[0].Error()
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%d errors: %s (and %d more)",
                len(ec.Errors), ec.Errors[0].Error(), len(ec.Errors)-1)</span>
}

// First retourne la première erreur ou nil
func (ec *ErrorCollection) First() *Error <span class="cov8" title="1">{
        if len(ec.Errors) &gt; 0 </span><span class="cov8" title="1">{
                return ec.Errors[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>

		<pre class="file" id="file2" style="display: none">package domain

import (
        "encoding/json"
        "fmt"
        "time"
)

// Program représente un programme complet de contraintes
type Program struct {
        Types       []TypeDefinition `json:"types"`
        Expressions []Expression     `json:"expressions"`
        Metadata    *Metadata        `json:"metadata,omitempty"`
}

// Metadata contient les informations sur le programme
type Metadata struct {
        Version     string    `json:"version"`
        CreatedAt   time.Time `json:"created_at"`
        Author      string    `json:"author,omitempty"`
        Description string    `json:"description,omitempty"`
}

// TypeDefinition définit un type personnalisé avec ses champs
type TypeDefinition struct {
        Type   string  `json:"type"`
        Name   string  `json:"name"`
        Fields []Field `json:"fields"`
}

// Field représente un champ dans une définition de type
type Field struct {
        Name string `json:"name"`
        Type string `json:"type"`
}

// Expression représente une règle métier complète
type Expression struct {
        Type        string      `json:"type"`
        Set         Set         `json:"set"`
        Constraints interface{} `json:"constraints"`
        Action      *Action     `json:"action,omitempty"`
}

// Set représente l'ensemble de variables typées dans une règle
type Set struct {
        Type      string          `json:"type"`
        Variables []TypedVariable `json:"variables"`
}

// TypedVariable représente une variable avec son type
type TypedVariable struct {
        Type     string `json:"type"`
        Name     string `json:"name"`
        DataType string `json:"dataType"`
}

// Constraint représente une contrainte (condition)
type Constraint struct {
        Type     string      `json:"type"`
        Left     interface{} `json:"left,omitempty"`
        Operator string      `json:"operator,omitempty"`
        Right    interface{} `json:"right,omitempty"`
}

// Action représente une action à exécuter quand les conditions sont remplies
type Action struct {
        Type string  `json:"type"`
        Job  JobCall `json:"job"`
}

// JobCall représente l'appel d'une fonction/job
type JobCall struct {
        Type string   `json:"type"`
        Name string   `json:"name"`
        Args []string `json:"args"`
}

// FieldAccess représente l'accès à un champ d'une variable
type FieldAccess struct {
        Type   string `json:"type"`
        Object string `json:"object"`
        Field  string `json:"field"`
}

// Variable représente une référence à une variable
type Variable struct {
        Type string `json:"type"`
        Name string `json:"name"`
}

// Literal types pour les valeurs constantes
type BooleanLiteral struct {
        Type  string `json:"type"`
        Value bool   `json:"value"`
}

type StringLiteral struct {
        Type  string `json:"type"`
        Value string `json:"value"`
}

type NumberLiteral struct {
        Type  string `json:"type"`
        Value float64 `json:"value"`
}

type IntegerLiteral struct {
        Type  string `json:"type"`
        Value int64  `json:"value"`
}

// Constructeurs pour faciliter la création des structures

// NewProgram crée un nouveau programme
func NewProgram() *Program <span class="cov8" title="1">{
        return &amp;Program{
                Types:       make([]TypeDefinition, 0),
                Expressions: make([]Expression, 0),
                Metadata: &amp;Metadata{
                        Version:   "1.0",
                        CreatedAt: time.Now(),
                },
        }
}</span>

// NewTypeDefinition crée une nouvelle définition de type
func NewTypeDefinition(name string) *TypeDefinition <span class="cov8" title="1">{
        return &amp;TypeDefinition{
                Type:   "typeDefinition",
                Name:   name,
                Fields: make([]Field, 0),
        }
}</span>

// AddField ajoute un champ à la définition de type
func (td *TypeDefinition) AddField(name, fieldType string) <span class="cov8" title="1">{
        td.Fields = append(td.Fields, Field{
                Name: name,
                Type: fieldType,
        })
}</span>

// NewExpression crée une nouvelle expression/règle
func NewExpression() *Expression <span class="cov8" title="1">{
        return &amp;Expression{
                Type: "expression",
                Set: Set{
                        Type:      "set",
                        Variables: make([]TypedVariable, 0),
                },
        }
}</span>

// AddVariable ajoute une variable au set de l'expression
func (e *Expression) AddVariable(name, dataType string) <span class="cov8" title="1">{
        e.Set.Variables = append(e.Set.Variables, TypedVariable{
                Type:     "typedVariable",
                Name:     name,
                DataType: dataType,
        })
}</span>

// NewConstraint crée une nouvelle contrainte binaire
func NewConstraint(left interface{}, operator string, right interface{}) *Constraint <span class="cov8" title="1">{
        return &amp;Constraint{
                Type:     "constraint",
                Left:     left,
                Operator: operator,
                Right:    right,
        }
}</span>

// NewFieldAccess crée un nouvel accès de champ
func NewFieldAccess(object, field string) *FieldAccess <span class="cov8" title="1">{
        return &amp;FieldAccess{
                Type:   "fieldAccess",
                Object: object,
                Field:  field,
        }
}</span>

// NewAction crée une nouvelle action
func NewAction(jobName string, args ...string) *Action <span class="cov8" title="1">{
        return &amp;Action{
                Type: "action",
                Job: JobCall{
                        Type: "jobCall",
                        Name: jobName,
                        Args: args,
                },
        }
}</span>

// Méthodes utilitaires

// String retourne une représentation JSON formatée du programme
func (p *Program) String() string <span class="cov8" title="1">{
        data, err := json.MarshalIndent(p, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Program{Types: %d, Expressions: %d}", len(p.Types), len(p.Expressions))
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

// GetTypeByName trouve une définition de type par son nom
func (p *Program) GetTypeByName(name string) *TypeDefinition <span class="cov8" title="1">{
        for i := range p.Types </span><span class="cov8" title="1">{
                if p.Types[i].Name == name </span><span class="cov8" title="1">{
                        return &amp;p.Types[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetFieldByName trouve un champ dans la définition de type par son nom
func (td *TypeDefinition) GetFieldByName(name string) *Field <span class="cov8" title="1">{
        for i := range td.Fields </span><span class="cov8" title="1">{
                if td.Fields[i].Name == name </span><span class="cov8" title="1">{
                        return &amp;td.Fields[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// HasField vérifie si un type a un champ donné
func (td *TypeDefinition) HasField(name string) bool <span class="cov8" title="1">{
        return td.GetFieldByName(name) != nil
}</span>

// Validation helpers

// IsValidOperator vérifie si un opérateur est valide
func IsValidOperator(op string) bool <span class="cov8" title="1">{
        validOps := map[string]bool{
                "==": true, "!=": true, "&lt;": true, "&gt;": true, "&lt;=": true, "&gt;=": true,
                "AND": true, "OR": true, "NOT": true,
                "+": true, "-": true, "*": true, "/": true, "%": true,
        }
        return validOps[op]
}</span>

// IsValidType vérifie si un type est valide
func IsValidType(t string) bool <span class="cov8" title="1">{
        validTypes := map[string]bool{
                "string": true, "number": true, "bool": true, "integer": true,
        }
        return validTypes[t]
}</pre>

		<pre class="file" id="file3" style="display: none">package validator

import (
        "fmt"
        "sync"

        "github.com/treivax/tsd/constraint/pkg/domain"
)

// TypeRegistry implémente l'interface domain.TypeRegistry
type TypeRegistry struct {
        types map[string]domain.TypeDefinition
        mutex sync.RWMutex
}

// NewTypeRegistry crée un nouveau registre de types
func NewTypeRegistry() *TypeRegistry <span class="cov8" title="1">{
        return &amp;TypeRegistry{
                types: make(map[string]domain.TypeDefinition),
                mutex: sync.RWMutex{},
        }
}</span>

// RegisterType enregistre un nouveau type
func (tr *TypeRegistry) RegisterType(typeDef domain.TypeDefinition) error <span class="cov8" title="1">{
        tr.mutex.Lock()
        defer tr.mutex.Unlock()

        if _, exists := tr.types[typeDef.Name]; exists </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        fmt.Sprintf("type '%s' already exists", typeDef.Name),
                        domain.Context{Type: typeDef.Name},
                )
        }</span>

        <span class="cov8" title="1">tr.types[typeDef.Name] = typeDef
        return nil</span>
}

// GetType récupère un type par son nom
func (tr *TypeRegistry) GetType(name string) (*domain.TypeDefinition, error) <span class="cov8" title="1">{
        tr.mutex.RLock()
        defer tr.mutex.RUnlock()

        if typeDef, exists := tr.types[name]; exists </span><span class="cov8" title="1">{
                return &amp;typeDef, nil
        }</span>

        <span class="cov8" title="1">return nil, domain.NewUnknownTypeError(
                name,
                domain.Context{Type: name},
        )</span>
}

// HasType vérifie si un type existe
func (tr *TypeRegistry) HasType(name string) bool <span class="cov8" title="1">{
        tr.mutex.RLock()
        defer tr.mutex.RUnlock()

        _, exists := tr.types[name]
        return exists
}</span>

// ListTypes retourne tous les types enregistrés
func (tr *TypeRegistry) ListTypes() []domain.TypeDefinition <span class="cov8" title="1">{
        tr.mutex.RLock()
        defer tr.mutex.RUnlock()

        types := make([]domain.TypeDefinition, 0, len(tr.types))
        for _, typeDef := range tr.types </span><span class="cov8" title="1">{
                types = append(types, typeDef)
        }</span>
        <span class="cov8" title="1">return types</span>
}

// GetTypeFields retourne les champs d'un type
func (tr *TypeRegistry) GetTypeFields(typeName string) (map[string]string, error) <span class="cov8" title="1">{
        typeDef, err := tr.GetType(typeName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fields := make(map[string]string)
        for _, field := range typeDef.Fields </span><span class="cov8" title="1">{
                fields[field.Name] = field.Type
        }</span>

        <span class="cov8" title="1">return fields, nil</span>
}

// Clear supprime tous les types (utile pour les tests)
func (tr *TypeRegistry) Clear() <span class="cov8" title="1">{
        tr.mutex.Lock()
        defer tr.mutex.Unlock()

        tr.types = make(map[string]domain.TypeDefinition)
}</span>

// TypeChecker implémente l'interface domain.TypeChecker
type TypeChecker struct {
        registry domain.TypeRegistry
}

// NewTypeChecker crée un nouveau vérificateur de types
func NewTypeChecker(registry domain.TypeRegistry) *TypeChecker <span class="cov8" title="1">{
        return &amp;TypeChecker{
                registry: registry,
        }
}</span>

// GetFieldType retourne le type d'un champ
func (tc *TypeChecker) GetFieldType(fieldAccess interface{}, variables []domain.TypedVariable, types []domain.TypeDefinition) (string, error) <span class="cov8" title="1">{
        // Cast vers FieldAccess
        fa, ok := fieldAccess.(*domain.FieldAccess)
        if !ok </span><span class="cov8" title="1">{
                // Essayer avec une map (format JSON)
                if faMap, ok := fieldAccess.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        objectName, _ := faMap["object"].(string)
                        fieldName, _ := faMap["field"].(string)

                        fa = &amp;domain.FieldAccess{
                                Object: objectName,
                                Field:  fieldName,
                        }
                }</span> else<span class="cov0" title="0"> {
                        return "", domain.NewValidationError(
                                "invalid field access format",
                                domain.Context{Value: fieldAccess},
                        )
                }</span>
        }

        // Trouver la variable
        <span class="cov8" title="1">var variableType string
        for _, variable := range variables </span><span class="cov8" title="1">{
                if variable.Name == fa.Object </span><span class="cov8" title="1">{
                        variableType = variable.DataType
                        break</span>
                }
        }

        <span class="cov8" title="1">if variableType == "" </span><span class="cov8" title="1">{
                return "", domain.NewValidationError(
                        fmt.Sprintf("variable '%s' not found", fa.Object),
                        domain.Context{Variable: fa.Object},
                )
        }</span>

        // Trouver le type de la variable
        <span class="cov8" title="1">typeDef, err := tc.registry.GetType(variableType)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Trouver le champ dans le type
        <span class="cov8" title="1">field := typeDef.GetFieldByName(fa.Field)
        if field == nil </span><span class="cov8" title="1">{
                return "", domain.NewFieldNotFoundError(
                        fa.Field,
                        variableType,
                        domain.Context{
                                Field:    fa.Field,
                                Type:     variableType,
                                Variable: fa.Object,
                        },
                )
        }</span>

        <span class="cov8" title="1">return field.Type, nil</span>
}

// GetValueType retourne le type d'une valeur
func (tc *TypeChecker) GetValueType(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case bool:<span class="cov8" title="1">
                return "bool"</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return "integer"</span>
        case float32, float64:<span class="cov8" title="1">
                return "number"</span>
        case string:<span class="cov8" title="1">
                return "string"</span>
        case map[string]interface{}:<span class="cov8" title="1">
                // Format JSON, essayer de déterminer le type
                if valueType, ok := v["type"].(string); ok </span><span class="cov8" title="1">{
                        switch valueType </span>{
                        case "booleanLiteral":<span class="cov8" title="1">
                                return "bool"</span>
                        case "integerLiteral":<span class="cov8" title="1">
                                return "integer"</span>
                        case "numberLiteral":<span class="cov8" title="1">
                                return "number"</span>
                        case "stringLiteral":<span class="cov8" title="1">
                                return "string"</span>
                        }
                }
                // Si on a une valeur directe
                <span class="cov8" title="1">if val, ok := v["value"]; ok </span><span class="cov8" title="1">{
                        return tc.GetValueType(val)
                }</span>
                <span class="cov0" title="0">return "unknown"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// ValidateTypeCompatibility vérifie la compatibilité entre types
func (tc *TypeChecker) ValidateTypeCompatibility(leftType, rightType, operator string) error <span class="cov8" title="1">{
        // Opérateurs de comparaison
        comparisonOps := map[string]bool{
                "==": true, "!=": true, "&lt;": true, "&gt;": true, "&lt;=": true, "&gt;=": true,
        }

        // Opérateurs logiques
        logicalOps := map[string]bool{
                "AND": true, "OR": true, "NOT": true,
        }

        // Opérateurs arithmétiques
        arithmeticOps := map[string]bool{
                "+": true, "-": true, "*": true, "/": true, "%": true,
        }

        // Vérification basique des opérateurs
        if !domain.IsValidOperator(operator) </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        fmt.Sprintf("invalid operator: %s", operator),
                        domain.Context{
                                Expected: "valid operator (==, !=, &lt;, &gt;, &lt;=, &gt;=, AND, OR, NOT, +, -, *, /, %)",
                                Actual:   operator,
                        },
                )
        }</span>

        // Règles spécifiques par opérateur
        <span class="cov8" title="1">if comparisonOps[operator] </span><span class="cov8" title="1">{
                // Pour les comparaisons, les types doivent être compatibles
                return tc.validateComparisonTypes(leftType, rightType, operator)
        }</span>

        <span class="cov8" title="1">if logicalOps[operator] </span><span class="cov8" title="1">{
                // Pour les opérations logiques, les opérandes doivent être booléens
                return tc.validateLogicalTypes(leftType, rightType, operator)
        }</span>

        <span class="cov8" title="1">if arithmeticOps[operator] </span><span class="cov8" title="1">{
                // Pour l'arithmétique, les types doivent être numériques
                return tc.validateArithmeticTypes(leftType, rightType, operator)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateComparisonTypes valide les types pour les opérateurs de comparaison
func (tc *TypeChecker) validateComparisonTypes(leftType, rightType, operator string) error <span class="cov8" title="1">{
        // Égalité/inégalité : tous types compatibles si identiques
        if operator == "==" || operator == "!=" </span><span class="cov8" title="1">{
                if leftType != rightType </span><span class="cov0" title="0">{
                        return domain.NewTypeMismatchError(
                                leftType,
                                rightType,
                                domain.Context{},
                        )
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Comparaisons ordinales : seulement pour les types numériques et strings
        <span class="cov8" title="1">orderableTypes := map[string]bool{
                "number": true, "integer": true, "string": true,
        }

        if !orderableTypes[leftType] || !orderableTypes[rightType] </span><span class="cov0" title="0">{
                return domain.NewValidationError(
                        fmt.Sprintf("operator '%s' not supported for types '%s' and '%s'",
                                operator, leftType, rightType),
                        domain.Context{
                                Expected: "number, integer, or string",
                                Actual:   fmt.Sprintf("%s, %s", leftType, rightType),
                        },
                )
        }</span>

        <span class="cov8" title="1">if leftType != rightType </span><span class="cov8" title="1">{
                return domain.NewTypeMismatchError(
                        leftType,
                        rightType,
                        domain.Context{},
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateLogicalTypes valide les types pour les opérateurs logiques
func (tc *TypeChecker) validateLogicalTypes(leftType, rightType, operator string) error <span class="cov8" title="1">{
        if operator == "NOT" </span><span class="cov8" title="1">{
                // NOT est unaire, vérifier seulement le type de gauche
                if leftType != "bool" </span><span class="cov8" title="1">{
                        return domain.NewTypeMismatchError(
                                "bool",
                                leftType,
                                domain.Context{},
                        )
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // AND/OR : les deux opérandes doivent être booléens
        <span class="cov8" title="1">if leftType != "bool" || rightType != "bool" </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        fmt.Sprintf("logical operator '%s' requires boolean operands", operator),
                        domain.Context{
                                Expected: "bool, bool",
                                Actual:   fmt.Sprintf("%s, %s", leftType, rightType),
                        },
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateArithmeticTypes valide les types pour les opérateurs arithmétiques
func (tc *TypeChecker) validateArithmeticTypes(leftType, rightType, operator string) error <span class="cov8" title="1">{
        numericTypes := map[string]bool{
                "number": true, "integer": true,
        }

        if !numericTypes[leftType] || !numericTypes[rightType] </span><span class="cov8" title="1">{
                return domain.NewValidationError(
                        fmt.Sprintf("arithmetic operator '%s' requires numeric operands", operator),
                        domain.Context{
                                Expected: "number or integer",
                                Actual:   fmt.Sprintf("%s, %s", leftType, rightType),
                        },
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>

		<pre class="file" id="file4" style="display: none">package validator

import (
        "fmt"
        "strings"

        "github.com/treivax/tsd/constraint/pkg/domain"
)

// ConstraintValidator implémente l'interface domain.Validator
type ConstraintValidator struct {
        typeRegistry domain.TypeRegistry
        typeChecker  domain.TypeChecker
        config       domain.ValidatorConfig
}

// NewConstraintValidator crée un nouveau validateur
func NewConstraintValidator(registry domain.TypeRegistry, checker domain.TypeChecker) *ConstraintValidator <span class="cov8" title="1">{
        return &amp;ConstraintValidator{
                typeRegistry: registry,
                typeChecker:  checker,
                config: domain.ValidatorConfig{
                        StrictMode:       true,
                        AllowedOperators: []string{"==", "!=", "&lt;", "&gt;", "&lt;=", "&gt;=", "AND", "OR", "NOT"},
                        MaxDepth:         10,
                },
        }
}</span>

// ValidateProgram valide un programme complet
func (v *ConstraintValidator) ValidateProgram(program interface{}) error <span class="cov8" title="1">{
        // Conversion vers Program
        prog, ok := program.(*domain.Program)
        if !ok </span><span class="cov8" title="1">{
                return domain.NewValidationError("invalid program type", domain.Context{})
        }</span>

        // Validation des types d'abord
        <span class="cov8" title="1">if err := v.ValidateTypes(prog.Types); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Enregistrer les types dans le registry
        <span class="cov8" title="1">for _, typeDef := range prog.Types </span><span class="cov8" title="1">{
                if err := v.typeRegistry.RegisterType(typeDef); err != nil </span><span class="cov8" title="1">{
                        return domain.NewValidationError(
                                fmt.Sprintf("failed to register type %s: %v", typeDef.Name, err),
                                domain.Context{Type: typeDef.Name},
                        )
                }</span>
        }

        // Validation des expressions
        <span class="cov8" title="1">for i, expr := range prog.Expressions </span><span class="cov8" title="1">{
                if err := v.ValidateExpression(expr, prog.Types); err != nil </span><span class="cov0" title="0">{
                        ctx := domain.Context{
                                Field: fmt.Sprintf("expression[%d]", i),
                        }
                        return domain.NewValidationError(
                                fmt.Sprintf("invalid expression %d: %v", i, err),
                                ctx,
                        )
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateTypes valide les définitions de types
func (v *ConstraintValidator) ValidateTypes(types []domain.TypeDefinition) error <span class="cov8" title="1">{
        typeNames := make(map[string]bool)

        for i, typeDef := range types </span><span class="cov8" title="1">{
                // Vérifier les noms dupliqués
                if typeNames[typeDef.Name] </span><span class="cov8" title="1">{
                        return domain.NewValidationError(
                                fmt.Sprintf("duplicate type name: %s", typeDef.Name),
                                domain.Context{
                                        Type:  typeDef.Name,
                                        Field: fmt.Sprintf("types[%d]", i),
                                },
                        )
                }</span>
                <span class="cov8" title="1">typeNames[typeDef.Name] = true

                // Vérifier que le type a un nom valide
                if typeDef.Name == "" </span><span class="cov8" title="1">{
                        return domain.NewValidationError(
                                "type name cannot be empty",
                                domain.Context{Field: fmt.Sprintf("types[%d].name", i)},
                        )
                }</span>

                // Vérifier que le type a des champs
                <span class="cov8" title="1">if len(typeDef.Fields) == 0 </span><span class="cov8" title="1">{
                        return domain.NewValidationError(
                                fmt.Sprintf("type %s must have at least one field", typeDef.Name),
                                domain.Context{
                                        Type:  typeDef.Name,
                                        Field: fmt.Sprintf("types[%d].fields", i),
                                },
                        )
                }</span>

                // Valider chaque champ
                <span class="cov8" title="1">fieldNames := make(map[string]bool)
                for j, field := range typeDef.Fields </span><span class="cov8" title="1">{
                        if fieldNames[field.Name] </span><span class="cov8" title="1">{
                                return domain.NewValidationError(
                                        fmt.Sprintf("duplicate field name '%s' in type '%s'", field.Name, typeDef.Name),
                                        domain.Context{
                                                Type:  typeDef.Name,
                                                Field: field.Name,
                                        },
                                )
                        }</span>
                        <span class="cov8" title="1">fieldNames[field.Name] = true

                        if field.Name == "" </span><span class="cov0" title="0">{
                                return domain.NewValidationError(
                                        fmt.Sprintf("field name cannot be empty in type %s", typeDef.Name),
                                        domain.Context{
                                                Type:  typeDef.Name,
                                                Field: fmt.Sprintf("types[%d].fields[%d].name", i, j),
                                        },
                                )
                        }</span>

                        <span class="cov8" title="1">if !domain.IsValidType(field.Type) </span><span class="cov8" title="1">{
                                return domain.NewValidationError(
                                        fmt.Sprintf("invalid field type '%s' for field '%s' in type '%s'",
                                                field.Type, field.Name, typeDef.Name),
                                        domain.Context{
                                                Type:     typeDef.Name,
                                                Field:    field.Name,
                                                Expected: "string, number, bool, or integer",
                                                Actual:   field.Type,
                                        },
                                )
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateExpression valide une expression/règle
func (v *ConstraintValidator) ValidateExpression(expr domain.Expression, types []domain.TypeDefinition) error <span class="cov8" title="1">{
        // Valider le set de variables
        if len(expr.Set.Variables) == 0 </span><span class="cov0" title="0">{
                return domain.NewValidationError(
                        "expression must have at least one variable",
                        domain.Context{},
                )
        }</span>

        // Vérifier que tous les types des variables existent
        <span class="cov8" title="1">for i, variable := range expr.Set.Variables </span><span class="cov8" title="1">{
                found := false
                for _, typeDef := range types </span><span class="cov8" title="1">{
                        if typeDef.Name == variable.DataType </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return domain.NewUnknownTypeError(
                                variable.DataType,
                                domain.Context{
                                        Variable: variable.Name,
                                        Field:    fmt.Sprintf("set.variables[%d].dataType", i),
                                },
                        )
                }</span>
        }

        // Valider les contraintes si elles existent
        <span class="cov8" title="1">if expr.Constraints != nil </span><span class="cov0" title="0">{
                if err := v.ValidateConstraint(expr.Constraints, expr.Set.Variables, types); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Valider l'action si elle existe
        <span class="cov8" title="1">if expr.Action != nil </span><span class="cov0" title="0">{
                validator := NewActionValidator()
                if err := validator.ValidateAction(expr.Action); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateConstraint valide une contrainte
func (v *ConstraintValidator) ValidateConstraint(constraint interface{}, variables []domain.TypedVariable, types []domain.TypeDefinition) error <span class="cov0" title="0">{
        // Cette méthode délègue au type checker pour les détails de validation des types
        return v.typeChecker.ValidateTypeCompatibility("", "", "")
}</span>

// SetConfig configure le validateur
func (v *ConstraintValidator) SetConfig(config domain.ValidatorConfig) <span class="cov0" title="0">{
        v.config = config
}</span>

// GetConfig retourne la configuration actuelle
func (v *ConstraintValidator) GetConfig() domain.ValidatorConfig <span class="cov0" title="0">{
        return v.config
}</span>

// ActionValidator valide les actions
type ActionValidator struct{}

// NewActionValidator crée un nouveau validateur d'actions
func NewActionValidator() *ActionValidator <span class="cov8" title="1">{
        return &amp;ActionValidator{}
}</span>

// ValidateAction valide une action
func (av *ActionValidator) ValidateAction(action *domain.Action) error <span class="cov8" title="1">{
        if action == nil </span><span class="cov8" title="1">{
                return domain.NewActionError(
                        "action cannot be nil",
                        domain.Context{},
                )
        }</span>

        <span class="cov8" title="1">return av.ValidateJobCall(action.Job)</span>
}

// ValidateJobCall valide un appel de fonction/job
func (av *ActionValidator) ValidateJobCall(jobCall domain.JobCall) error <span class="cov8" title="1">{
        if strings.TrimSpace(jobCall.Name) == "" </span><span class="cov8" title="1">{
                return domain.NewActionError(
                        "job name cannot be empty",
                        domain.Context{Field: "job.name"},
                )
        }</span>

        // Valider les arguments (optionnel)
        <span class="cov8" title="1">for i, arg := range jobCall.Args </span><span class="cov8" title="1">{
                if strings.TrimSpace(arg) == "" </span><span class="cov8" title="1">{
                        return domain.NewActionError(
                                fmt.Sprintf("job argument %d cannot be empty", i),
                                domain.Context{
                                        Field: fmt.Sprintf("job.args[%d]", i),
                                        Value: arg,
                                },
                        )
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
