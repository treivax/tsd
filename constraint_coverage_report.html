
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>constraint: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/treivax/tsd/constraint/api.go (17.4%)</option>
				
				<option value="file1">github.com/treivax/tsd/constraint/constraint_utils.go (87.7%)</option>
				
				<option value="file2">github.com/treivax/tsd/constraint/errors.go (0.0%)</option>
				
				<option value="file3">github.com/treivax/tsd/constraint/parser.go (48.8%)</option>
				
				<option value="file4">github.com/treivax/tsd/constraint/program_state.go (90.7%)</option>
				
				<option value="file5">github.com/treivax/tsd/constraint/program_state_methods.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package constraint

import (
        "encoding/json"
        "fmt"
)

// ParseConstraint parses constraint input and returns the AST.
// It takes a filename (for error reporting) and the input bytes to parse.
// Returns the parsed AST as an interface{} or an error if parsing fails.
//
// Example:
//
//        content, _ := os.ReadFile("rules.constraint")
//        ast, err := ParseConstraint("rules.constraint", content)
func ParseConstraint(filename string, input []byte) (interface{}, error) <span class="cov8" title="1">{
        return Parse(filename, input)
}</span>

// ValidateConstraintProgram validates a parsed constraint program AST.
// It performs semantic validation including type checking, variable resolution,
// and constraint consistency checks.
//
// Example:
//
//        ast, _ := ParseConstraint("rules.constraint", content)
//        err := ValidateConstraintProgram(ast)
func ValidateConstraintProgram(result interface{}) error <span class="cov0" title="0">{
        return ValidateProgram(result)
}</span>

// ParseConstraintFile parses a constraint file from the filesystem.
// It reads the file and parses it, returning the AST or an error.
// This is a convenience function that combines file reading and parsing.
//
// Example:
//
//        ast, err := ParseConstraintFile("rules.constraint")
func ParseConstraintFile(filename string) (interface{}, error) <span class="cov8" title="1">{
        return ParseFile(filename)
}</span>

// ParseFactsFile parses a .facts file using the constraint grammar.
// This allows facts to be parsed using the same grammar as constraint files,
// enabling unified processing of constraint and fact definitions.
//
// Example:
//
//        facts, err := ParseFactsFile("data.facts")
func ParseFactsFile(filename string) (interface{}, error) <span class="cov0" title="0">{
        return ParseFile(filename)
}</span>

// ExtractFactsFromProgram extrait les faits d'un programme parsé et les convertit au format RETE
func ExtractFactsFromProgram(result interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Convertir le résultat en structure Program
        jsonData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur conversion JSON: %v", err)
        }</span>

        <span class="cov0" title="0">var program Program
        err = json.Unmarshal(jsonData, &amp;program)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur parsing JSON: %v", err)
        }</span>

        // Convertir les faits au format RETE
        <span class="cov0" title="0">reteFacts := ConvertFactsToReteFormat(program)
        return reteFacts, nil</span>
}

// ConvertResultToProgram convertit le résultat du parser en structure Program
func ConvertResultToProgram(result interface{}) (*Program, error) <span class="cov8" title="1">{
        // Convertir le résultat en structure Program
        jsonData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur conversion JSON: %v", err)
        }</span>

        <span class="cov8" title="1">var program Program
        err = json.Unmarshal(jsonData, &amp;program)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur parsing JSON: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;program, nil</span>
}

// ConvertToReteProgram convertit une structure Program des contraintes vers le format attendu par RETE
func ConvertToReteProgram(program *Program) interface{} <span class="cov0" title="0">{
        // Convertir les types en map[string]interface{} via JSON pour être compatible avec RETE
        typesInterface := make([]interface{}, len(program.Types))
        for i, typeDef := range program.Types </span><span class="cov0" title="0">{
                // Sérialiser vers JSON puis désérialiser en map
                jsonData, err := json.Marshal(typeDef)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var typeMap map[string]interface{}
                json.Unmarshal(jsonData, &amp;typeMap)
                typesInterface[i] = typeMap</span>
        }

        // Convertir les expressions en map[string]interface{} via JSON
        <span class="cov0" title="0">expressionsInterface := make([]interface{}, len(program.Expressions))
        for i, expr := range program.Expressions </span><span class="cov0" title="0">{
                // Sérialiser vers JSON puis désérialiser en map
                jsonData, err := json.Marshal(expr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var exprMap map[string]interface{}
                json.Unmarshal(jsonData, &amp;exprMap)
                expressionsInterface[i] = exprMap</span>
        }

        // Créer une structure compatible avec le format attendu par RETE
        <span class="cov0" title="0">reteProgram := map[string]interface{}{
                "types":       typesInterface,
                "expressions": expressionsInterface,
        }
        return reteProgram</span>
}

// NewIterativeParser creates a new iterative parser that can parse multiple files
// and maintain state across parsing operations. This enables parsing type definitions,
// rules, and facts from separate files while ensuring consistency.
//
// Example:
//
//        parser := NewIterativeParser()
//        err := parser.ParseFile("types.constraint")
//        err = parser.ParseFile("rules.constraint")
//        err = parser.ParseFile("facts.constraint")
//        program := parser.GetProgram()
func NewIterativeParser() *IterativeParser <span class="cov0" title="0">{
        return &amp;IterativeParser{
                state: NewProgramState(),
        }
}</span>

// IterativeParser provides iterative parsing capabilities with state management
type IterativeParser struct {
        state *ProgramState
}

// ParseFile parses a file and merges it with the current state.
// The file can contain types, rules, facts, or any combination.
// Validation is performed to ensure consistency with previously parsed content.
func (ip *IterativeParser) ParseFile(filename string) error <span class="cov0" title="0">{
        return ip.state.ParseAndMerge(filename)
}</span>

// ParseContent parses content from a string and merges it with current state.
func (ip *IterativeParser) ParseContent(content, filename string) error <span class="cov0" title="0">{
        return ip.state.ParseAndMergeContent(content, filename)
}</span>

// GetProgram returns the current combined program state
func (ip *IterativeParser) GetProgram() *Program <span class="cov0" title="0">{
        return ip.state.ToProgram()
}</span>

// GetState returns the internal state for advanced usage
func (ip *IterativeParser) GetState() *ProgramState <span class="cov0" title="0">{
        return ip.state
}</span>

// Reset clears all parsed content and resets to empty state
func (ip *IterativeParser) Reset() <span class="cov0" title="0">{
        ip.state = NewProgramState()
}</span>

// GetParsingStatistics returns statistics about the parsing process
func (ip *IterativeParser) GetParsingStatistics() ParsingStatistics <span class="cov0" title="0">{
        return ParsingStatistics{
                TypesCount:       len(ip.state.Types),
                RulesCount:       len(ip.state.Rules),
                FactsCount:       len(ip.state.Facts),
                FilesParsedCount: len(ip.state.FilesParsed),
                FilesParsed:      ip.state.FilesParsed,
        }
}</span>

// ParsingStatistics contains statistics about the parsing process
type ParsingStatistics struct {
        TypesCount       int      `json:"types_count"`
        RulesCount       int      `json:"rules_count"`
        FactsCount       int      `json:"facts_count"`
        FilesParsedCount int      `json:"files_parsed_count"`
        FilesParsed      []string `json:"files_parsed"`
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package constraint

import (
        "encoding/json"
        "fmt"
)

// Constraint type constants
const (
        ConstraintTypeFieldAccess = "fieldAccess"
        ConstraintTypeComparison  = "comparison"
        ConstraintTypeLogicalExpr = "logicalExpr"
        ConstraintTypeBinaryOp    = "binaryOp"
)

// Value type constants
const (
        ValueTypeString     = "string"
        ValueTypeNumber     = "number"
        ValueTypeBoolean    = "boolean"
        ValueTypeBool       = "bool"
        ValueTypeIdentifier = "identifier"
        ValueTypeVariable   = "variable"
        ValueTypeUnknown    = "unknown"
)

// Special field name constants
const (
        FieldNameID       = "id"
        FieldNameReteType = "reteType"
)

// Fonctions utilitaires pour traiter l'AST du parser de contraintes

// ValidateTypes vérifie que tous les types référencés dans les expressions sont définis
func ValidateTypes(program Program) error <span class="cov8" title="1">{
        definedTypes := make(map[string]bool)
        for _, typeDef := range program.Types </span><span class="cov8" title="1">{
                definedTypes[typeDef.Name] = true
        }</span>

        // Vérifier les variables typées dans toutes les expressions
        <span class="cov8" title="1">for i, expression := range program.Expressions </span><span class="cov8" title="1">{
                for _, variable := range expression.Set.Variables </span><span class="cov8" title="1">{
                        if !definedTypes[variable.DataType] </span><span class="cov8" title="1">{
                                return fmt.Errorf("expression %d: type non défini: %s pour la variable %s", i+1, variable.DataType, variable.Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetTypeFields retourne les champs d'un type donné
func GetTypeFields(program Program, typeName string) ([]Field, error) <span class="cov8" title="1">{
        for _, typeDef := range program.Types </span><span class="cov8" title="1">{
                if typeDef.Name == typeName </span><span class="cov8" title="1">{
                        return typeDef.Fields, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("type non trouvé: %s", typeName)</span>
}

// ValidateFieldAccess vérifie qu'un accès aux champs est valide dans une expression donnée
func ValidateFieldAccess(program Program, fieldAccess FieldAccess, expressionIndex int) error <span class="cov8" title="1">{
        if expressionIndex &gt;= len(program.Expressions) </span><span class="cov8" title="1">{
                return fmt.Errorf("index d'expression invalide: %d", expressionIndex)
        }</span>

        // Trouver le type de l'objet dans l'expression spécifiée
        <span class="cov8" title="1">var objectType string
        for _, variable := range program.Expressions[expressionIndex].Set.Variables </span><span class="cov8" title="1">{
                if variable.Name == fieldAccess.Object </span><span class="cov8" title="1">{
                        objectType = variable.DataType
                        break</span>
                }
        }

        <span class="cov8" title="1">if objectType == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("variable non trouvée: %s dans l'expression %d", fieldAccess.Object, expressionIndex+1)
        }</span>

        // Vérifier que le champ existe dans le type
        <span class="cov8" title="1">fields, err := GetTypeFields(program, objectType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, field := range fields </span><span class="cov8" title="1">{
                if field.Name == fieldAccess.Field </span><span class="cov8" title="1">{
                        return nil // Champ trouvé
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("champ %s non trouvé dans le type %s", fieldAccess.Field, objectType)</span>
}

// ValidateAction vérifie qu'une action est valide dans le contexte d'une expression
func ValidateAction(program Program, action Action, expressionIndex int) error <span class="cov8" title="1">{
        if expressionIndex &gt;= len(program.Expressions) </span><span class="cov8" title="1">{
                return fmt.Errorf("index d'expression invalide: %d", expressionIndex)
        }</span>

        <span class="cov8" title="1">expression := program.Expressions[expressionIndex]

        // Créer une map des variables disponibles dans l'expression
        availableVars := make(map[string]bool)
        for _, variable := range expression.Set.Variables </span><span class="cov8" title="1">{
                availableVars[variable.Name] = true
        }</span>

        // Vérifier que tous les arguments de l'action référencent des variables valides
        <span class="cov8" title="1">for _, arg := range action.Job.Args </span><span class="cov8" title="1">{
                // Extraire les variables utilisées dans l'argument
                vars := extractVariablesFromArg(arg)
                for _, varName := range vars </span><span class="cov8" title="1">{
                        if !availableVars[varName] </span><span class="cov8" title="1">{
                                return fmt.Errorf("action %s: argument contient la variable '%s' qui ne correspond à aucune variable de l'expression", action.Job.Name, varName)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// extractVariablesFromArg extrait les noms de variables utilisées dans un argument d'action
func extractVariablesFromArg(arg interface{}) []string <span class="cov8" title="1">{
        var vars []string

        // Si c'est une string simple, c'est probablement un nom de variable
        if str, ok := arg.(string); ok </span><span class="cov8" title="1">{
                vars = append(vars, str)
                return vars
        }</span>

        // Si c'est un objet (map), extraire les variables selon le type
        <span class="cov8" title="1">if argMap, ok := arg.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                argType, _ := argMap["type"].(string)
                switch argType </span>{
                case "fieldAccess":<span class="cov8" title="1">
                        if object, ok := argMap["object"].(string); ok </span><span class="cov8" title="1">{
                                vars = append(vars, object)
                        }</span>
                case "string":<span class="cov8" title="1"></span>
                        // Les string literals ne contiennent pas de variables
                case "number":<span class="cov8" title="1"></span>
                        // Les number literals ne contiennent pas de variables
                default:<span class="cov0" title="0"></span>
                        // Pour d'autres types, on peut chercher récursivement
                        // mais pour l'instant on ignore
                }
        }

        <span class="cov8" title="1">return vars</span>
}

// GetFieldType retourne le type d'un champ spécifique d'un objet dans une expression
func GetFieldType(program Program, object string, field string, expressionIndex int) (string, error) <span class="cov8" title="1">{
        if expressionIndex &gt;= len(program.Expressions) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("index d'expression invalide: %d", expressionIndex)
        }</span>

        // Trouver le type de l'objet
        <span class="cov8" title="1">var objectType string
        for _, variable := range program.Expressions[expressionIndex].Set.Variables </span><span class="cov8" title="1">{
                if variable.Name == object </span><span class="cov8" title="1">{
                        objectType = variable.DataType
                        break</span>
                }
        }

        <span class="cov8" title="1">if objectType == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("variable non trouvée: %s", object)
        }</span>

        // Trouver le type du champ dans la définition du type
        <span class="cov8" title="1">fields, err := GetTypeFields(program, objectType)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">for _, f := range fields </span><span class="cov8" title="1">{
                if f.Name == field </span><span class="cov8" title="1">{
                        return f.Type, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("champ %s non trouvé dans le type %s", field, objectType)</span>
}

// GetValueType retourne le type d'une valeur dans l'AST
func GetValueType(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                valueType, ok := v["type"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return ValueTypeUnknown
                }</span>
                <span class="cov8" title="1">switch valueType </span>{
                case ValueTypeNumber:<span class="cov8" title="1">
                        return ValueTypeNumber</span>
                case ValueTypeString:<span class="cov8" title="1">
                        return ValueTypeString</span>
                case ValueTypeBoolean:<span class="cov8" title="1">
                        return ValueTypeBool</span>
                case ValueTypeVariable:<span class="cov8" title="1">
                        // Pour les variables comme "true", "false" qui sont parsées comme variables
                        name, ok := v["name"].(string)
                        if ok </span><span class="cov8" title="1">{
                                switch name </span>{
                                case "true", "false":<span class="cov8" title="1">
                                        return ValueTypeBool</span>
                                }
                        }
                        <span class="cov8" title="1">return ValueTypeVariable</span> // Type non déterminable sans contexte
                }
        }
        <span class="cov8" title="1">return ValueTypeUnknown</span>
}

// ValidateTypeCompatibility vérifie la compatibilité des types dans les comparaisons
// ValidateTypeCompatibility validates type compatibility within constraints
func ValidateTypeCompatibility(program Program, constraint interface{}, expressionIndex int) error <span class="cov8" title="1">{
        constraintMap, ok := constraint.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">constraintType, ok := constraintMap["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch constraintType </span>{
        case ConstraintTypeComparison:<span class="cov8" title="1">
                return validateConstraintWithOperands(program, constraintMap, expressionIndex, true)</span>
        case ConstraintTypeLogicalExpr:<span class="cov0" title="0">
                return validateLogicalExpressionConstraint(program, constraintMap, expressionIndex)</span>
        case ConstraintTypeBinaryOp:<span class="cov0" title="0">
                return validateConstraintWithOperands(program, constraintMap, expressionIndex, false)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// validateConstraintWithOperands handles validation for constraints with left/right operands
func validateConstraintWithOperands(program Program, c map[string]interface{}, expressionIndex int, checkCompatibility bool) error <span class="cov8" title="1">{
        left := c["left"]
        right := c["right"]

        if left == nil || right == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Validate type compatibility between operands (only for comparisons)
        <span class="cov8" title="1">if checkCompatibility </span><span class="cov8" title="1">{
                if err := validateOperandTypeCompatibility(program, left, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Recursive validation for operands
        <span class="cov8" title="1">if err := ValidateTypeCompatibility(program, left, expressionIndex); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateTypeCompatibility(program, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateOperandTypeCompatibility checks if two operands have compatible types
func validateOperandTypeCompatibility(program Program, left, right interface{}, expressionIndex int) error <span class="cov8" title="1">{
        leftType, err := getOperandType(program, left, expressionIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rightType, err := getOperandType(program, right, expressionIndex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check compatibility
        <span class="cov8" title="1">if leftType != ValueTypeUnknown &amp;&amp; rightType != ValueTypeUnknown &amp;&amp; rightType != ValueTypeVariable </span><span class="cov8" title="1">{
                if leftType != rightType </span><span class="cov0" title="0">{
                        return fmt.Errorf("incompatibilité de types dans la comparaison: %s vs %s", leftType, rightType)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getOperandType determines the type of an operand in a constraint
func getOperandType(program Program, operand interface{}, expressionIndex int) (string, error) <span class="cov8" title="1">{
        operandMap, ok := operand.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return GetValueType(operand), nil
        }</span>

        <span class="cov8" title="1">if operandMap["type"] == ConstraintTypeFieldAccess </span><span class="cov8" title="1">{
                object := operandMap["object"].(string)
                field := operandMap["field"].(string)
                return GetFieldType(program, object, field, expressionIndex)
        }</span>

        <span class="cov8" title="1">return GetValueType(operand), nil</span>
}

// validateLogicalExpressionConstraint handles logical expression validation
func validateLogicalExpressionConstraint(program Program, c map[string]interface{}, expressionIndex int) error <span class="cov8" title="1">{
        if left := c["left"]; left != nil </span><span class="cov8" title="1">{
                if err := ValidateTypeCompatibility(program, left, expressionIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">operations, ok := c["operations"].([]interface{})
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, op := range operations </span><span class="cov8" title="1">{
                opMap, ok := op.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if right := opMap["right"]; right != nil </span><span class="cov8" title="1">{
                        if err := ValidateTypeCompatibility(program, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// validateBinaryOpConstraint handles binary operation validation (wrapper for backward compatibility)
func validateBinaryOpConstraint(program Program, c map[string]interface{}, expressionIndex int) error <span class="cov8" title="1">{
        return validateConstraintWithOperands(program, c, expressionIndex, false)
}</span>

// ValidateConstraintFieldAccess parcourt récursivement les contraintes pour valider les accès aux champs
func ValidateConstraintFieldAccess(program Program, constraint interface{}, expressionIndex int) error <span class="cov8" title="1">{
        switch c := constraint.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                constraintType, ok := c["type"].(string)
                if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">switch constraintType </span>{
                case ConstraintTypeFieldAccess:<span class="cov8" title="1">
                        object, objOk := c["object"].(string)
                        field, fieldOk := c["field"].(string)
                        if objOk &amp;&amp; fieldOk </span><span class="cov8" title="1">{
                                fieldAccess := FieldAccess{
                                        Type:   ConstraintTypeFieldAccess,
                                        Object: object,
                                        Field:  field,
                                }
                                return ValidateFieldAccess(program, fieldAccess, expressionIndex)
                        }</span>
                case ConstraintTypeComparison, ConstraintTypeBinaryOp:<span class="cov8" title="1">
                        return validateFieldAccessInOperands(program, c, expressionIndex)</span>
                case ConstraintTypeLogicalExpr:<span class="cov8" title="1">
                        return validateFieldAccessInLogicalExpr(program, c, expressionIndex)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// validateFieldAccessInOperands validates field access in left/right operands
func validateFieldAccessInOperands(program Program, c map[string]interface{}, expressionIndex int) error <span class="cov8" title="1">{
        if left := c["left"]; left != nil </span><span class="cov8" title="1">{
                if err := ValidateConstraintFieldAccess(program, left, expressionIndex); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if right := c["right"]; right != nil </span><span class="cov8" title="1">{
                if err := ValidateConstraintFieldAccess(program, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// validateFieldAccessInLogicalExpr validates field access in logical expressions
func validateFieldAccessInLogicalExpr(program Program, c map[string]interface{}, expressionIndex int) error <span class="cov8" title="1">{
        if left := c["left"]; left != nil </span><span class="cov8" title="1">{
                if err := ValidateConstraintFieldAccess(program, left, expressionIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if operations, ok := c["operations"].([]interface{}); ok </span><span class="cov8" title="1">{
                for _, op := range operations </span><span class="cov8" title="1">{
                        if opMap, ok := op.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if right := opMap["right"]; right != nil </span><span class="cov8" title="1">{
                                        if err := ValidateConstraintFieldAccess(program, right, expressionIndex); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateProgram effectue une validation complète du programme parsé
func ValidateProgram(result interface{}) error <span class="cov8" title="1">{
        // Convertir le résultat en structure Program
        program, err := convertResultToProgram(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validation des types
        <span class="cov8" title="1">if err := ValidateTypes(program); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("erreur validation types: %v", err)
        }</span>

        // Validation des faits
        <span class="cov8" title="1">if err := ValidateFacts(program); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur validation faits: %v", err)
        }</span>

        // Validation des contraintes dans les expressions
        <span class="cov8" title="1">if err := validateExpressionConstraints(program); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validation des actions dans les expressions
        <span class="cov8" title="1">if err := validateExpressionActions(program); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Printf("✓ Programme valide avec %d type(s), %d expression(s) et %d fait(s)\n", len(program.Types), len(program.Expressions), len(program.Facts))
        return nil</span>
}

// convertResultToProgram converts the parser result to a Program structure
func convertResultToProgram(result interface{}) (Program, error) <span class="cov8" title="1">{
        var program Program

        jsonData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return program, fmt.Errorf("erreur conversion JSON: %v", err)
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(jsonData, &amp;program)
        if err != nil </span><span class="cov0" title="0">{
                return program, fmt.Errorf("erreur parsing JSON: %v", err)
        }</span>

        <span class="cov8" title="1">return program, nil</span>
}

// validateExpressionConstraints validates field access and type compatibility in all constraints
func validateExpressionConstraints(program Program) error <span class="cov8" title="1">{
        for i, expression := range program.Expressions </span><span class="cov8" title="1">{
                if expression.Constraints != nil </span><span class="cov8" title="1">{
                        // Validation des accès aux champs
                        if err := ValidateConstraintFieldAccess(program, expression.Constraints, i); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur validation champs dans l'expression %d: %v", i+1, err)
                        }</span>

                        // Validation des types dans les comparaisons
                        <span class="cov8" title="1">if err := ValidateTypeCompatibility(program, expression.Constraints, i); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur validation types dans l'expression %d: %v", i+1, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// validateExpressionActions validates that all expressions have valid actions
func validateExpressionActions(program Program) error <span class="cov8" title="1">{
        for i, expression := range program.Expressions </span><span class="cov8" title="1">{
                if expression.Action != nil </span><span class="cov8" title="1">{
                        if err := ValidateAction(program, *expression.Action, i); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur validation action dans l'expression %d: %v", i+1, err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Avec la nouvelle grammaire, cette condition ne devrait plus arriver
                        return fmt.Errorf("action manquante dans l'expression %d: chaque règle doit avoir une action définie", i+1)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateFacts vérifie que tous les faits parsés sont cohérents avec les définitions de types
func ValidateFacts(program Program) error <span class="cov8" title="1">{
        definedTypes := make(map[string]TypeDefinition)
        for _, typeDef := range program.Types </span><span class="cov8" title="1">{
                definedTypes[typeDef.Name] = typeDef
        }</span>

        <span class="cov8" title="1">for i, fact := range program.Facts </span><span class="cov8" title="1">{
                // Vérifier que le type du fait existe
                typeDef, exists := definedTypes[fact.TypeName]
                if !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("fait %d: type non défini: %s", i+1, fact.TypeName)
                }</span>

                // Créer une map des champs définis pour ce type
                <span class="cov8" title="1">definedFields := make(map[string]string)
                for _, field := range typeDef.Fields </span><span class="cov8" title="1">{
                        definedFields[field.Name] = field.Type
                }</span>

                // Vérifier chaque champ du fait
                <span class="cov8" title="1">for j, factField := range fact.Fields </span><span class="cov8" title="1">{
                        // Vérifier que le champ existe dans le type
                        expectedType, exists := definedFields[factField.Name]
                        if !exists </span><span class="cov8" title="1">{
                                return fmt.Errorf("fait %d, champ %d: champ '%s' non défini dans le type %s", i+1, j+1, factField.Name, fact.TypeName)
                        }</span>

                        // Vérifier la compatibilité du type de la valeur
                        <span class="cov8" title="1">err := ValidateFactFieldType(factField.Value, expectedType, fact.TypeName, factField.Name)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("fait %d, champ %d: %v", i+1, j+1, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateFactFieldType vérifie que la valeur d'un champ de fait correspond au type attendu
func ValidateFactFieldType(value FactValue, expectedType, typeName, fieldName string) error <span class="cov8" title="1">{
        switch expectedType </span>{
        case ValueTypeString:<span class="cov8" title="1">
                if value.Type != ValueTypeString &amp;&amp; value.Type != ValueTypeIdentifier </span><span class="cov8" title="1">{
                        return fmt.Errorf("champ '%s' du type %s attend une valeur string, reçu %s", fieldName, typeName, value.Type)
                }</span>
        case ValueTypeNumber:<span class="cov8" title="1">
                if value.Type != ValueTypeNumber </span><span class="cov8" title="1">{
                        return fmt.Errorf("champ '%s' du type %s attend une valeur number, reçu %s", fieldName, typeName, value.Type)
                }</span>
        case ValueTypeBool, ValueTypeBoolean:<span class="cov8" title="1">
                if value.Type != ValueTypeBoolean </span><span class="cov8" title="1">{
                        return fmt.Errorf("champ '%s' du type %s attend une valeur boolean, reçu %s", fieldName, typeName, value.Type)
                }</span>
        default:<span class="cov8" title="1">
                // Type non reconnu, on accepte pour l'instant
                return nil</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ConvertFactsToReteFormat convertit les faits parsés par la grammaire vers le format attendu par le réseau RETE
func ConvertFactsToReteFormat(program Program) []map[string]interface{} <span class="cov8" title="1">{
        var reteFacts []map[string]interface{}

        for i, fact := range program.Facts </span><span class="cov8" title="1">{
                reteFact := map[string]interface{}{
                        FieldNameReteType: fact.TypeName, // Type RETE (ex: "Balance")
                }

                // Convertir les champs et gérer l'ID
                factID := convertFactFields(fact.Fields, reteFact, i)

                // Définir l'ID du fait (nécessaire pour le réseau RETE)
                reteFact[FieldNameID] = factID

                // CORRECTION CRITIQUE: Assurer que le type RETE est toujours préservé
                reteFact[FieldNameReteType] = fact.TypeName

                reteFacts = append(reteFacts, reteFact)
        }</span>

        <span class="cov8" title="1">return reteFacts</span>
}

// convertFactFields converts fact fields and returns the fact ID
func convertFactFields(fields []FactField, reteFact map[string]interface{}, factIndex int) string <span class="cov8" title="1">{
        var factID string
        hasExplicitID := false

        for _, field := range fields </span><span class="cov8" title="1">{
                convertedValue := convertFactFieldValue(field.Value)

                // Ajouter le champ au fact
                reteFact[field.Name] = convertedValue

                // Vérifier si c'est un champ ID
                if field.Name == FieldNameID </span><span class="cov8" title="1">{
                        factID = convertedValue.(string)
                        hasExplicitID = true
                }</span>
        }

        // Générer un ID si pas fourni explicitement
        <span class="cov8" title="1">if !hasExplicitID </span><span class="cov0" title="0">{
                factID = fmt.Sprintf("parsed_fact_%d", factIndex+1)
        }</span>

        <span class="cov8" title="1">return factID</span>
}

// convertFactFieldValue converts a fact field value to its appropriate Go type
func convertFactFieldValue(value FactValue) interface{} <span class="cov8" title="1">{
        switch value.Type </span>{
        case ValueTypeString, ValueTypeNumber, ValueTypeBoolean:<span class="cov8" title="1">
                if valMap, ok := value.Value.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        return valMap["value"]
                }</span>
                <span class="cov0" title="0">return value.Value</span>
        case ValueTypeIdentifier:<span class="cov8" title="1">
                // Les identifiants non-quotés sont traités comme des strings
                return value.Value</span>
        default:<span class="cov0" title="0">
                return value.Value</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package constraint

import (
        "fmt"
        "strings"
)

// ValidationError represents a non-blocking validation error that occurs during parsing.
// It captures the context of the error including the file, type of element (fact/rule),
// the error message, and optionally the line number where the error occurred.
type ValidationError struct {
        File    string // Source file where the error occurred
        Type    string // Type of element: "fact", "rule", or "type"
        Message string // Descriptive error message
        Line    int    // Line number in the source file (0 if unknown)
}

// Error implements the error interface for ValidationError.
func (ve ValidationError) Error() string <span class="cov0" title="0">{
        if ve.Line &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%d: %s in %s", ve.File, ve.Line, ve.Message, ve.Type)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s: %s in %s", ve.File, ve.Message, ve.Type)</span>
}

// ValidationErrors is a collection of validation errors.
type ValidationErrors []ValidationError

// Error implements the error interface for ValidationErrors.
func (ve ValidationErrors) Error() string <span class="cov0" title="0">{
        if len(ve) == 0 </span><span class="cov0" title="0">{
                return "no validation errors"
        }</span>
        <span class="cov0" title="0">if len(ve) == 1 </span><span class="cov0" title="0">{
                return ve[0].Error()
        }</span>
        <span class="cov0" title="0">var sb strings.Builder
        fmt.Fprintf(&amp;sb, "%d validation errors:\n", len(ve))
        for i, err := range ve </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;sb, "  %d. %s\n", i+1, err.Error())
        }</span>
        <span class="cov0" title="0">return sb.String()</span>
}

// HasErrors returns true if there are any validation errors.
func (ve ValidationErrors) HasErrors() bool <span class="cov0" title="0">{
        return len(ve) &gt; 0
}</span>

// Count returns the number of validation errors.
func (ve ValidationErrors) Count() int <span class="cov0" title="0">{
        return len(ve)
}</span>

// Error type constants for validation errors
const (
        ErrorTypeFact = "fact"
        ErrorTypeRule = "rule"
        ErrorTypeType = "type"
)
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by pigeon; DO NOT EDIT.

package constraint

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "math"
        "os"
        "sort"
        "strconv"
        "strings"
        "sync"
        "unicode"
        "unicode/utf8"
)

var g = &amp;grammar{
        rules: []*rule{
                {
                        name: "Start",
                        pos:  position{line: 16, col: 1, offset: 413},
                        expr: &amp;actionExpr{
                                pos: position{line: 16, col: 10, offset: 422},
                                run: (*parser).callonStart1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 16, col: 10, offset: 422},
                                        exprs: []any{
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 16, col: 10, offset: 422},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 16, col: 12, offset: 424},
                                                        label: "statements",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 16, col: 23, offset: 435},
                                                                name: "StatementList",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 16, col: 37, offset: 449},
                                                        name: "_",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 16, col: 39, offset: 451},
                                                        name: "EOF",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "StatementList",
                        pos:  position{line: 47, col: 1, offset: 1459},
                        expr: &amp;actionExpr{
                                pos: position{line: 47, col: 18, offset: 1476},
                                run: (*parser).callonStatementList1,
                                expr: &amp;labeledExpr{
                                        pos:   position{line: 47, col: 18, offset: 1476},
                                        label: "statements",
                                        expr: &amp;zeroOrMoreExpr{
                                                pos: position{line: 47, col: 29, offset: 1487},
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 47, col: 30, offset: 1488},
                                                        exprs: []any{
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 47, col: 30, offset: 1488},
                                                                        name: "Statement",
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 47, col: 40, offset: 1498},
                                                                        name: "_",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Statement",
                        pos:  position{line: 57, col: 1, offset: 1722},
                        expr: &amp;choiceExpr{
                                pos: position{line: 57, col: 14, offset: 1735},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 57, col: 14, offset: 1735},
                                                name: "TypeDefinition",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 57, col: 31, offset: 1752},
                                                name: "Expression",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 57, col: 44, offset: 1765},
                                                name: "RemoveFact",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 57, col: 57, offset: 1778},
                                                name: "Fact",
                                        },
                                },
                        },
                },
                {
                        name: "TypeDefinition",
                        pos:  position{line: 59, col: 1, offset: 1784},
                        expr: &amp;actionExpr{
                                pos: position{line: 59, col: 19, offset: 1802},
                                run: (*parser).callonTypeDefinition1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 59, col: 19, offset: 1802},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 59, col: 19, offset: 1802},
                                                        val:        "type",
                                                        ignoreCase: false,
                                                        want:       "\"type\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 26, offset: 1809},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 59, col: 28, offset: 1811},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 59, col: 33, offset: 1816},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 43, offset: 1826},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 59, col: 45, offset: 1828},
                                                        val:        ":",
                                                        ignoreCase: false,
                                                        want:       "\":\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 49, offset: 1832},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 59, col: 51, offset: 1834},
                                                        val:        "&lt;",
                                                        ignoreCase: false,
                                                        want:       "\"&lt;\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 55, offset: 1838},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 59, col: 57, offset: 1840},
                                                        label: "fields",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 59, col: 64, offset: 1847},
                                                                name: "FieldList",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 59, col: 74, offset: 1857},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 59, col: 76, offset: 1859},
                                                        val:        "&gt;",
                                                        ignoreCase: false,
                                                        want:       "\"&gt;\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FieldList",
                        pos:  position{line: 67, col: 1, offset: 1996},
                        expr: &amp;actionExpr{
                                pos: position{line: 67, col: 14, offset: 2009},
                                run: (*parser).callonFieldList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 67, col: 14, offset: 2009},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 67, col: 14, offset: 2009},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 67, col: 20, offset: 2015},
                                                                name: "Field",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 67, col: 26, offset: 2021},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 67, col: 31, offset: 2026},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 67, col: 32, offset: 2027},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 67, col: 32, offset: 2027},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 67, col: 34, offset: 2029},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 67, col: 38, offset: 2033},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 67, col: 40, offset: 2035},
                                                                                        name: "Field",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Field",
                        pos:  position{line: 77, col: 1, offset: 2256},
                        expr: &amp;actionExpr{
                                pos: position{line: 77, col: 10, offset: 2265},
                                run: (*parser).callonField1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 77, col: 10, offset: 2265},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 77, col: 10, offset: 2265},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 77, col: 15, offset: 2270},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 77, col: 25, offset: 2280},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 77, col: 27, offset: 2282},
                                                        val:        ":",
                                                        ignoreCase: false,
                                                        want:       "\":\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 77, col: 31, offset: 2286},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 77, col: 33, offset: 2288},
                                                        label: "fieldType",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 77, col: 43, offset: 2298},
                                                                name: "AtomicType",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "AtomicType",
                        pos:  position{line: 84, col: 1, offset: 2409},
                        expr: &amp;choiceExpr{
                                pos: position{line: 84, col: 15, offset: 2423},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 84, col: 15, offset: 2423},
                                                run: (*parser).callonAtomicType2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 84, col: 15, offset: 2423},
                                                        val:        "string",
                                                        ignoreCase: false,
                                                        want:       "\"string\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 85, col: 15, offset: 2473},
                                                run: (*parser).callonAtomicType4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 85, col: 15, offset: 2473},
                                                        val:        "number",
                                                        ignoreCase: false,
                                                        want:       "\"number\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 86, col: 15, offset: 2523},
                                                run: (*parser).callonAtomicType6,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 86, col: 15, offset: 2523},
                                                        val:        "bool",
                                                        ignoreCase: false,
                                                        want:       "\"bool\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Expression",
                        pos:  position{line: 88, col: 1, offset: 2556},
                        expr: &amp;actionExpr{
                                pos: position{line: 88, col: 15, offset: 2570},
                                run: (*parser).callonExpression1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 88, col: 15, offset: 2570},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 88, col: 15, offset: 2570},
                                                        label: "set",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 88, col: 19, offset: 2574},
                                                                name: "Set",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 88, col: 23, offset: 2578},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 88, col: 25, offset: 2580},
                                                        val:        "/",
                                                        ignoreCase: false,
                                                        want:       "\"/\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 88, col: 29, offset: 2584},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 88, col: 31, offset: 2586},
                                                        label: "constraints",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 88, col: 43, offset: 2598},
                                                                name: "Constraints",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 88, col: 55, offset: 2610},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 88, col: 57, offset: 2612},
                                                        label: "action",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 88, col: 64, offset: 2619},
                                                                name: "Action",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Set",
                        pos:  position{line: 97, col: 1, offset: 2789},
                        expr: &amp;actionExpr{
                                pos: position{line: 97, col: 8, offset: 2796},
                                run: (*parser).callonSet1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 97, col: 8, offset: 2796},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 97, col: 8, offset: 2796},
                                                        val:        "{",
                                                        ignoreCase: false,
                                                        want:       "\"{\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 97, col: 12, offset: 2800},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 97, col: 14, offset: 2802},
                                                        label: "variables",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 97, col: 24, offset: 2812},
                                                                name: "TypedVariableList",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 97, col: 42, offset: 2830},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 97, col: 44, offset: 2832},
                                                        val:        "}",
                                                        ignoreCase: false,
                                                        want:       "\"}\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "TypedVariableList",
                        pos:  position{line: 104, col: 1, offset: 2942},
                        expr: &amp;actionExpr{
                                pos: position{line: 104, col: 22, offset: 2963},
                                run: (*parser).callonTypedVariableList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 104, col: 22, offset: 2963},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 104, col: 22, offset: 2963},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 104, col: 28, offset: 2969},
                                                                name: "TypedVariable",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 104, col: 42, offset: 2983},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 104, col: 47, offset: 2988},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 104, col: 48, offset: 2989},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 104, col: 48, offset: 2989},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 104, col: 50, offset: 2991},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 104, col: 54, offset: 2995},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 104, col: 56, offset: 2997},
                                                                                        name: "TypedVariable",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "TypedVariable",
                        pos:  position{line: 114, col: 1, offset: 3238},
                        expr: &amp;actionExpr{
                                pos: position{line: 114, col: 18, offset: 3255},
                                run: (*parser).callonTypedVariable1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 114, col: 18, offset: 3255},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 114, col: 18, offset: 3255},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 114, col: 23, offset: 3260},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 114, col: 33, offset: 3270},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 114, col: 35, offset: 3272},
                                                        val:        ":",
                                                        ignoreCase: false,
                                                        want:       "\":\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 114, col: 39, offset: 3276},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 114, col: 41, offset: 3278},
                                                        label: "dataType",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 114, col: 50, offset: 3287},
                                                                name: "IdentName",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Constraints",
                        pos:  position{line: 122, col: 1, offset: 3433},
                        expr: &amp;actionExpr{
                                pos: position{line: 122, col: 16, offset: 3448},
                                run: (*parser).callonConstraints1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 122, col: 16, offset: 3448},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 122, col: 16, offset: 3448},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 122, col: 22, offset: 3454},
                                                                name: "Constraint",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 122, col: 33, offset: 3465},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 122, col: 38, offset: 3470},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 122, col: 39, offset: 3471},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 122, col: 39, offset: 3471},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 122, col: 41, offset: 3473},
                                                                                        name: "LogicalOp",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 122, col: 51, offset: 3483},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 122, col: 53, offset: 3485},
                                                                                        name: "Constraint",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Constraint",
                        pos:  position{line: 144, col: 1, offset: 4029},
                        expr: &amp;choiceExpr{
                                pos: position{line: 144, col: 15, offset: 4043},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 144, col: 15, offset: 4043},
                                                run: (*parser).callonConstraint2,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 144, col: 15, offset: 4043},
                                                        exprs: []any{
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 144, col: 15, offset: 4043},
                                                                        val:        "(",
                                                                        ignoreCase: false,
                                                                        want:       "\"(\"",
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 144, col: 19, offset: 4047},
                                                                        name: "_",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 144, col: 21, offset: 4049},
                                                                        label: "expr",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 144, col: 26, offset: 4054},
                                                                                name: "Constraints",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 144, col: 38, offset: 4066},
                                                                        name: "_",
                                                                },
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 144, col: 40, offset: 4068},
                                                                        val:        ")",
                                                                        ignoreCase: false,
                                                                        want:       "\")\"",
                                                                },
                                                        },
                                                },
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 145, col: 15, offset: 4109},
                                                name: "NotConstraint",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 146, col: 15, offset: 4139},
                                                name: "ExistsConstraint",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 147, col: 15, offset: 4172},
                                                name: "AccumulateConstraint",
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 148, col: 15, offset: 4209},
                                                run: (*parser).callonConstraint13,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 148, col: 15, offset: 4209},
                                                        exprs: []any{
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 148, col: 15, offset: 4209},
                                                                        label: "left",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 148, col: 20, offset: 4214},
                                                                                name: "ArithmeticExpr",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 148, col: 35, offset: 4229},
                                                                        name: "_",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 148, col: 37, offset: 4231},
                                                                        label: "op",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 148, col: 40, offset: 4234},
                                                                                name: "ComparisonOp",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 148, col: 53, offset: 4247},
                                                                        name: "_",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 148, col: 55, offset: 4249},
                                                                        label: "right",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 148, col: 61, offset: 4255},
                                                                                name: "ArithmeticExpr",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "NotConstraint",
                        pos:  position{line: 157, col: 1, offset: 4421},
                        expr: &amp;actionExpr{
                                pos: position{line: 157, col: 18, offset: 4438},
                                run: (*parser).callonNotConstraint1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 157, col: 18, offset: 4438},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 157, col: 18, offset: 4438},
                                                        val:        "NOT",
                                                        ignoreCase: false,
                                                        want:       "\"NOT\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 157, col: 24, offset: 4444},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 157, col: 26, offset: 4446},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 157, col: 30, offset: 4450},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 157, col: 32, offset: 4452},
                                                        label: "expr",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 157, col: 37, offset: 4457},
                                                                name: "Constraints",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 157, col: 49, offset: 4469},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 157, col: 51, offset: 4471},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ExistsConstraint",
                        pos:  position{line: 164, col: 1, offset: 4587},
                        expr: &amp;actionExpr{
                                pos: position{line: 164, col: 21, offset: 4607},
                                run: (*parser).callonExistsConstraint1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 164, col: 21, offset: 4607},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 164, col: 21, offset: 4607},
                                                        val:        "EXISTS",
                                                        ignoreCase: false,
                                                        want:       "\"EXISTS\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 30, offset: 4616},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 164, col: 32, offset: 4618},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 36, offset: 4622},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 164, col: 38, offset: 4624},
                                                        label: "variable",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 164, col: 47, offset: 4633},
                                                                name: "TypedVariable",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 61, offset: 4647},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 164, col: 63, offset: 4649},
                                                        val:        "/",
                                                        ignoreCase: false,
                                                        want:       "\"/\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 67, offset: 4653},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 164, col: 69, offset: 4655},
                                                        label: "condition",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 164, col: 79, offset: 4665},
                                                                name: "Constraints",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 164, col: 91, offset: 4677},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 164, col: 93, offset: 4679},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "AccumulateConstraint",
                        pos:  position{line: 172, col: 1, offset: 4832},
                        expr: &amp;actionExpr{
                                pos: position{line: 172, col: 25, offset: 4856},
                                run: (*parser).callonAccumulateConstraint1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 172, col: 25, offset: 4856},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 25, offset: 4856},
                                                        label: "accumFunc",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 35, offset: 4866},
                                                                name: "AccumulateFunction",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 54, offset: 4885},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 172, col: 56, offset: 4887},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 60, offset: 4891},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 62, offset: 4893},
                                                        label: "accumVar",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 71, offset: 4902},
                                                                name: "TypedVariable",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 85, offset: 4916},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 172, col: 87, offset: 4918},
                                                        val:        "/",
                                                        ignoreCase: false,
                                                        want:       "\"/\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 91, offset: 4922},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 93, offset: 4924},
                                                        label: "accumCond",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 103, offset: 4934},
                                                                name: "Constraints",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 115, offset: 4946},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 117, offset: 4948},
                                                        label: "accumField",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 172, col: 128, offset: 4959},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 172, col: 129, offset: 4960},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 172, col: 129, offset: 4960},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 172, col: 131, offset: 4962},
                                                                                        val:        ";",
                                                                                        ignoreCase: false,
                                                                                        want:       "\";\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 172, col: 135, offset: 4966},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 172, col: 137, offset: 4968},
                                                                                        name: "FieldAccess",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 151, offset: 4982},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 172, col: 153, offset: 4984},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 157, offset: 4988},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 159, offset: 4990},
                                                        label: "accumOp",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 167, offset: 4998},
                                                                name: "ComparisonOp",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 172, col: 180, offset: 5011},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 172, col: 182, offset: 5013},
                                                        label: "accumThreshold",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 172, col: 197, offset: 5028},
                                                                name: "ArithmeticExpr",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "AccumulateFunction",
                        pos:  position{line: 190, col: 1, offset: 5510},
                        expr: &amp;choiceExpr{
                                pos: position{line: 190, col: 23, offset: 5532},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 190, col: 23, offset: 5532},
                                                run: (*parser).callonAccumulateFunction2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 190, col: 23, offset: 5532},
                                                        val:        "AVG",
                                                        ignoreCase: false,
                                                        want:       "\"AVG\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 191, col: 22, offset: 5583},
                                                run: (*parser).callonAccumulateFunction4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 191, col: 22, offset: 5583},
                                                        val:        "COUNT",
                                                        ignoreCase: false,
                                                        want:       "\"COUNT\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 192, col: 22, offset: 5638},
                                                run: (*parser).callonAccumulateFunction6,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 192, col: 22, offset: 5638},
                                                        val:        "SUM",
                                                        ignoreCase: false,
                                                        want:       "\"SUM\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 193, col: 22, offset: 5689},
                                                run: (*parser).callonAccumulateFunction8,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 193, col: 22, offset: 5689},
                                                        val:        "MIN",
                                                        ignoreCase: false,
                                                        want:       "\"MIN\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 194, col: 22, offset: 5740},
                                                run: (*parser).callonAccumulateFunction10,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 194, col: 22, offset: 5740},
                                                        val:        "MAX",
                                                        ignoreCase: false,
                                                        want:       "\"MAX\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ArithmeticExpr",
                        pos:  position{line: 197, col: 1, offset: 5770},
                        expr: &amp;actionExpr{
                                pos: position{line: 197, col: 19, offset: 5788},
                                run: (*parser).callonArithmeticExpr1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 197, col: 19, offset: 5788},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 197, col: 19, offset: 5788},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 197, col: 25, offset: 5794},
                                                                name: "Term",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 197, col: 30, offset: 5799},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 197, col: 35, offset: 5804},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 197, col: 36, offset: 5805},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 197, col: 36, offset: 5805},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;choiceExpr{
                                                                                        pos: position{line: 197, col: 39, offset: 5808},
                                                                                        alternatives: []any{
                                                                                                &amp;litMatcher{
                                                                                                        pos:        position{line: 197, col: 39, offset: 5808},
                                                                                                        val:        "+",
                                                                                                        ignoreCase: false,
                                                                                                        want:       "\"+\"",
                                                                                                },
                                                                                                &amp;litMatcher{
                                                                                                        pos:        position{line: 197, col: 45, offset: 5814},
                                                                                                        val:        "-",
                                                                                                        ignoreCase: false,
                                                                                                        want:       "\"-\"",
                                                                                                },
                                                                                        },
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 197, col: 50, offset: 5819},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 197, col: 52, offset: 5821},
                                                                                        name: "Term",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Term",
                        pos:  position{line: 216, col: 1, offset: 6264},
                        expr: &amp;actionExpr{
                                pos: position{line: 216, col: 9, offset: 6272},
                                run: (*parser).callonTerm1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 216, col: 9, offset: 6272},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 216, col: 9, offset: 6272},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 216, col: 15, offset: 6278},
                                                                name: "Factor",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 216, col: 22, offset: 6285},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 216, col: 27, offset: 6290},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 216, col: 28, offset: 6291},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 216, col: 28, offset: 6291},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;choiceExpr{
                                                                                        pos: position{line: 216, col: 31, offset: 6294},
                                                                                        alternatives: []any{
                                                                                                &amp;litMatcher{
                                                                                                        pos:        position{line: 216, col: 31, offset: 6294},
                                                                                                        val:        "*",
                                                                                                        ignoreCase: false,
                                                                                                        want:       "\"*\"",
                                                                                                },
                                                                                                &amp;litMatcher{
                                                                                                        pos:        position{line: 216, col: 37, offset: 6300},
                                                                                                        val:        "/",
                                                                                                        ignoreCase: false,
                                                                                                        want:       "\"/\"",
                                                                                                },
                                                                                        },
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 216, col: 42, offset: 6305},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 216, col: 44, offset: 6307},
                                                                                        name: "Factor",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Factor",
                        pos:  position{line: 235, col: 1, offset: 6752},
                        expr: &amp;choiceExpr{
                                pos: position{line: 235, col: 11, offset: 6762},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 235, col: 11, offset: 6762},
                                                run: (*parser).callonFactor2,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 235, col: 11, offset: 6762},
                                                        exprs: []any{
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 235, col: 11, offset: 6762},
                                                                        val:        "(",
                                                                        ignoreCase: false,
                                                                        want:       "\"(\"",
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 235, col: 15, offset: 6766},
                                                                        name: "_",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 235, col: 17, offset: 6768},
                                                                        label: "expr",
                                                                        expr: &amp;ruleRefExpr{
                                                                                pos:  position{line: 235, col: 22, offset: 6773},
                                                                                name: "ArithmeticExpr",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 235, col: 37, offset: 6788},
                                                                        name: "_",
                                                                },
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 235, col: 39, offset: 6790},
                                                                        val:        ")",
                                                                        ignoreCase: false,
                                                                        want:       "\")\"",
                                                                },
                                                        },
                                                },
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 236, col: 11, offset: 6827},
                                                name: "FunctionCall",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 237, col: 11, offset: 6852},
                                                name: "FieldAccess",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 238, col: 11, offset: 6876},
                                                name: "Number",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 239, col: 11, offset: 6895},
                                                name: "StringLiteral",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 240, col: 11, offset: 6921},
                                                name: "BooleanLiteral",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 241, col: 11, offset: 6948},
                                                name: "ArrayLiteral",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 242, col: 11, offset: 6973},
                                                name: "Variable",
                                        },
                                },
                        },
                },
                {
                        name: "FieldAccess",
                        pos:  position{line: 244, col: 1, offset: 6983},
                        expr: &amp;actionExpr{
                                pos: position{line: 244, col: 16, offset: 6998},
                                run: (*parser).callonFieldAccess1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 244, col: 16, offset: 6998},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 244, col: 16, offset: 6998},
                                                        label: "object",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 244, col: 23, offset: 7005},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 244, col: 33, offset: 7015},
                                                        val:        ".",
                                                        ignoreCase: false,
                                                        want:       "\".\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 244, col: 37, offset: 7019},
                                                        label: "field",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 244, col: 43, offset: 7025},
                                                                name: "IdentName",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Variable",
                        pos:  position{line: 252, col: 1, offset: 7167},
                        expr: &amp;actionExpr{
                                pos: position{line: 252, col: 13, offset: 7179},
                                run: (*parser).callonVariable1,
                                expr: &amp;labeledExpr{
                                        pos:   position{line: 252, col: 13, offset: 7179},
                                        label: "name",
                                        expr: &amp;ruleRefExpr{
                                                pos:  position{line: 252, col: 18, offset: 7184},
                                                name: "IdentName",
                                        },
                                },
                        },
                },
                {
                        name: "ArrayLiteral",
                        pos:  position{line: 259, col: 1, offset: 7295},
                        expr: &amp;actionExpr{
                                pos: position{line: 259, col: 17, offset: 7311},
                                run: (*parser).callonArrayLiteral1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 259, col: 17, offset: 7311},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 259, col: 17, offset: 7311},
                                                        val:        "[",
                                                        ignoreCase: false,
                                                        want:       "\"[\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 259, col: 21, offset: 7315},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 259, col: 23, offset: 7317},
                                                        label: "elements",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 259, col: 32, offset: 7326},
                                                                expr: &amp;ruleRefExpr{
                                                                        pos:  position{line: 259, col: 32, offset: 7326},
                                                                        name: "ArrayElementList",
                                                                },
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 259, col: 50, offset: 7344},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 259, col: 52, offset: 7346},
                                                        val:        "]",
                                                        ignoreCase: false,
                                                        want:       "\"]\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ArrayElementList",
                        pos:  position{line: 269, col: 1, offset: 7529},
                        expr: &amp;actionExpr{
                                pos: position{line: 269, col: 21, offset: 7549},
                                run: (*parser).callonArrayElementList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 269, col: 21, offset: 7549},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 269, col: 21, offset: 7549},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 269, col: 27, offset: 7555},
                                                                name: "ArithmeticExpr",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 269, col: 42, offset: 7570},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 269, col: 47, offset: 7575},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 269, col: 48, offset: 7576},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 269, col: 48, offset: 7576},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 269, col: 50, offset: 7578},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 269, col: 54, offset: 7582},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 269, col: 56, offset: 7584},
                                                                                        name: "ArithmeticExpr",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FunctionCall",
                        pos:  position{line: 279, col: 1, offset: 7822},
                        expr: &amp;actionExpr{
                                pos: position{line: 279, col: 17, offset: 7838},
                                run: (*parser).callonFunctionCall1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 279, col: 17, offset: 7838},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 279, col: 17, offset: 7838},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 279, col: 22, offset: 7843},
                                                                name: "FunctionName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 279, col: 35, offset: 7856},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 279, col: 37, offset: 7858},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 279, col: 41, offset: 7862},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 279, col: 43, offset: 7864},
                                                        label: "args",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 279, col: 48, offset: 7869},
                                                                expr: &amp;ruleRefExpr{
                                                                        pos:  position{line: 279, col: 48, offset: 7869},
                                                                        name: "FunctionArgList",
                                                                },
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 279, col: 65, offset: 7886},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 279, col: 67, offset: 7888},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FunctionName",
                        pos:  position{line: 290, col: 1, offset: 8077},
                        expr: &amp;choiceExpr{
                                pos: position{line: 290, col: 17, offset: 8093},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 290, col: 17, offset: 8093},
                                                run: (*parser).callonFunctionName2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 290, col: 17, offset: 8093},
                                                        val:        "LENGTH",
                                                        ignoreCase: false,
                                                        want:       "\"LENGTH\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 291, col: 17, offset: 8145},
                                                run: (*parser).callonFunctionName4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 291, col: 17, offset: 8145},
                                                        val:        "SUBSTRING",
                                                        ignoreCase: false,
                                                        want:       "\"SUBSTRING\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 292, col: 17, offset: 8203},
                                                run: (*parser).callonFunctionName6,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 292, col: 17, offset: 8203},
                                                        val:        "UPPER",
                                                        ignoreCase: false,
                                                        want:       "\"UPPER\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 293, col: 17, offset: 8253},
                                                run: (*parser).callonFunctionName8,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 293, col: 17, offset: 8253},
                                                        val:        "LOWER",
                                                        ignoreCase: false,
                                                        want:       "\"LOWER\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 294, col: 17, offset: 8303},
                                                run: (*parser).callonFunctionName10,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 294, col: 17, offset: 8303},
                                                        val:        "TRIM",
                                                        ignoreCase: false,
                                                        want:       "\"TRIM\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 295, col: 17, offset: 8351},
                                                run: (*parser).callonFunctionName12,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 295, col: 17, offset: 8351},
                                                        val:        "ABS",
                                                        ignoreCase: false,
                                                        want:       "\"ABS\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 296, col: 17, offset: 8397},
                                                run: (*parser).callonFunctionName14,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 296, col: 17, offset: 8397},
                                                        val:        "ROUND",
                                                        ignoreCase: false,
                                                        want:       "\"ROUND\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 297, col: 17, offset: 8447},
                                                run: (*parser).callonFunctionName16,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 297, col: 17, offset: 8447},
                                                        val:        "FLOOR",
                                                        ignoreCase: false,
                                                        want:       "\"FLOOR\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 298, col: 17, offset: 8497},
                                                run: (*parser).callonFunctionName18,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 298, col: 17, offset: 8497},
                                                        val:        "CEIL",
                                                        ignoreCase: false,
                                                        want:       "\"CEIL\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FunctionArgList",
                        pos:  position{line: 300, col: 1, offset: 8528},
                        expr: &amp;actionExpr{
                                pos: position{line: 300, col: 20, offset: 8547},
                                run: (*parser).callonFunctionArgList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 300, col: 20, offset: 8547},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 300, col: 20, offset: 8547},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 300, col: 26, offset: 8553},
                                                                name: "ArithmeticExpr",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 300, col: 41, offset: 8568},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 300, col: 46, offset: 8573},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 300, col: 47, offset: 8574},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 300, col: 47, offset: 8574},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 300, col: 49, offset: 8576},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 300, col: 53, offset: 8580},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 300, col: 55, offset: 8582},
                                                                                        name: "ArithmeticExpr",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Action",
                        pos:  position{line: 310, col: 1, offset: 8804},
                        expr: &amp;actionExpr{
                                pos: position{line: 310, col: 11, offset: 8814},
                                run: (*parser).callonAction1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 310, col: 11, offset: 8814},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 310, col: 11, offset: 8814},
                                                        val:        "==&gt;",
                                                        ignoreCase: false,
                                                        want:       "\"==&gt;\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 310, col: 17, offset: 8820},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 310, col: 19, offset: 8822},
                                                        label: "job",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 310, col: 23, offset: 8826},
                                                                name: "JobCall",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "JobCall",
                        pos:  position{line: 317, col: 1, offset: 8931},
                        expr: &amp;actionExpr{
                                pos: position{line: 317, col: 12, offset: 8942},
                                run: (*parser).callonJobCall1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 317, col: 12, offset: 8942},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 317, col: 12, offset: 8942},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 317, col: 17, offset: 8947},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 317, col: 27, offset: 8957},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 317, col: 29, offset: 8959},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 317, col: 33, offset: 8963},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 317, col: 35, offset: 8965},
                                                        label: "args",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 317, col: 40, offset: 8970},
                                                                expr: &amp;ruleRefExpr{
                                                                        pos:  position{line: 317, col: 40, offset: 8970},
                                                                        name: "ArgumentList",
                                                                },
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 317, col: 54, offset: 8984},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 317, col: 56, offset: 8986},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ArgumentList",
                        pos:  position{line: 328, col: 1, offset: 9170},
                        expr: &amp;actionExpr{
                                pos: position{line: 328, col: 17, offset: 9186},
                                run: (*parser).callonArgumentList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 328, col: 17, offset: 9186},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 328, col: 17, offset: 9186},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 328, col: 23, offset: 9192},
                                                                name: "ArithmeticExpr",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 328, col: 38, offset: 9207},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 328, col: 43, offset: 9212},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 328, col: 44, offset: 9213},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 328, col: 44, offset: 9213},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 328, col: 46, offset: 9215},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 328, col: 50, offset: 9219},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 328, col: 52, offset: 9221},
                                                                                        name: "ArithmeticExpr",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ComparisonOp",
                        pos:  position{line: 338, col: 1, offset: 9463},
                        expr: &amp;choiceExpr{
                                pos: position{line: 338, col: 17, offset: 9479},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 338, col: 17, offset: 9479},
                                                run: (*parser).callonComparisonOp2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 338, col: 17, offset: 9479},
                                                        val:        "==",
                                                        ignoreCase: false,
                                                        want:       "\"==\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 339, col: 17, offset: 9523},
                                                run: (*parser).callonComparisonOp4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 339, col: 17, offset: 9523},
                                                        val:        "!=",
                                                        ignoreCase: false,
                                                        want:       "\"!=\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 340, col: 17, offset: 9567},
                                                run: (*parser).callonComparisonOp6,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 340, col: 17, offset: 9567},
                                                        val:        "&lt;=",
                                                        ignoreCase: false,
                                                        want:       "\"&lt;=\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 341, col: 17, offset: 9611},
                                                run: (*parser).callonComparisonOp8,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 341, col: 17, offset: 9611},
                                                        val:        "&gt;=",
                                                        ignoreCase: false,
                                                        want:       "\"&gt;=\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 342, col: 17, offset: 9655},
                                                run: (*parser).callonComparisonOp10,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 342, col: 17, offset: 9655},
                                                        val:        "&lt;",
                                                        ignoreCase: false,
                                                        want:       "\"&lt;\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 343, col: 17, offset: 9698},
                                                run: (*parser).callonComparisonOp12,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 343, col: 17, offset: 9698},
                                                        val:        "&gt;",
                                                        ignoreCase: false,
                                                        want:       "\"&gt;\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 344, col: 17, offset: 9741},
                                                run: (*parser).callonComparisonOp14,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 344, col: 17, offset: 9741},
                                                        val:        "IN",
                                                        ignoreCase: false,
                                                        want:       "\"IN\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 345, col: 17, offset: 9785},
                                                run: (*parser).callonComparisonOp16,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 345, col: 17, offset: 9785},
                                                        val:        "LIKE",
                                                        ignoreCase: false,
                                                        want:       "\"LIKE\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 346, col: 17, offset: 9833},
                                                run: (*parser).callonComparisonOp18,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 346, col: 17, offset: 9833},
                                                        val:        "MATCHES",
                                                        ignoreCase: false,
                                                        want:       "\"MATCHES\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 347, col: 17, offset: 9887},
                                                run: (*parser).callonComparisonOp20,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 347, col: 17, offset: 9887},
                                                        val:        "CONTAINS",
                                                        ignoreCase: false,
                                                        want:       "\"CONTAINS\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "LogicalOp",
                        pos:  position{line: 349, col: 1, offset: 9926},
                        expr: &amp;choiceExpr{
                                pos: position{line: 349, col: 14, offset: 9939},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 349, col: 14, offset: 9939},
                                                run: (*parser).callonLogicalOp2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 349, col: 14, offset: 9939},
                                                        val:        "AND",
                                                        ignoreCase: false,
                                                        want:       "\"AND\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 350, col: 14, offset: 9982},
                                                run: (*parser).callonLogicalOp4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 350, col: 14, offset: 9982},
                                                        val:        "OR",
                                                        ignoreCase: false,
                                                        want:       "\"OR\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "BooleanLiteral",
                        pos:  position{line: 352, col: 1, offset: 10010},
                        expr: &amp;choiceExpr{
                                pos: position{line: 352, col: 19, offset: 10028},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 352, col: 19, offset: 10028},
                                                run: (*parser).callonBooleanLiteral2,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 352, col: 19, offset: 10028},
                                                        val:        "true",
                                                        ignoreCase: false,
                                                        want:       "\"true\"",
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 358, col: 5, offset: 10161},
                                                run: (*parser).callonBooleanLiteral4,
                                                expr: &amp;litMatcher{
                                                        pos:        position{line: 358, col: 5, offset: 10161},
                                                        val:        "false",
                                                        ignoreCase: false,
                                                        want:       "\"false\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Number",
                        pos:  position{line: 365, col: 1, offset: 10291},
                        expr: &amp;actionExpr{
                                pos: position{line: 365, col: 11, offset: 10301},
                                run: (*parser).callonNumber1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 365, col: 11, offset: 10301},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 365, col: 11, offset: 10301},
                                                        label: "sign",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 365, col: 16, offset: 10306},
                                                                expr: &amp;litMatcher{
                                                                        pos:        position{line: 365, col: 16, offset: 10306},
                                                                        val:        "-",
                                                                        ignoreCase: false,
                                                                        want:       "\"-\"",
                                                                },
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 365, col: 21, offset: 10311},
                                                        label: "digits",
                                                        expr: &amp;oneOrMoreExpr{
                                                                pos: position{line: 365, col: 28, offset: 10318},
                                                                expr: &amp;charClassMatcher{
                                                                        pos:        position{line: 365, col: 28, offset: 10318},
                                                                        val:        "[0-9]",
                                                                        ranges:     []rune{'0', '9'},
                                                                        ignoreCase: false,
                                                                        inverted:   false,
                                                                },
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 365, col: 35, offset: 10325},
                                                        label: "decimal",
                                                        expr: &amp;zeroOrOneExpr{
                                                                pos: position{line: 365, col: 43, offset: 10333},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 365, col: 44, offset: 10334},
                                                                        exprs: []any{
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 365, col: 44, offset: 10334},
                                                                                        val:        ".",
                                                                                        ignoreCase: false,
                                                                                        want:       "\".\"",
                                                                                },
                                                                                &amp;oneOrMoreExpr{
                                                                                        pos: position{line: 365, col: 48, offset: 10338},
                                                                                        expr: &amp;charClassMatcher{
                                                                                                pos:        position{line: 365, col: 48, offset: 10338},
                                                                                                val:        "[0-9]",
                                                                                                ranges:     []rune{'0', '9'},
                                                                                                ignoreCase: false,
                                                                                                inverted:   false,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "StringLiteral",
                        pos:  position{line: 376, col: 1, offset: 10551},
                        expr: &amp;choiceExpr{
                                pos: position{line: 376, col: 18, offset: 10568},
                                alternatives: []any{
                                        &amp;actionExpr{
                                                pos: position{line: 376, col: 18, offset: 10568},
                                                run: (*parser).callonStringLiteral2,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 376, col: 18, offset: 10568},
                                                        exprs: []any{
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 376, col: 18, offset: 10568},
                                                                        val:        "\"",
                                                                        ignoreCase: false,
                                                                        want:       "\"\\\"\"",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 376, col: 23, offset: 10573},
                                                                        label: "chars",
                                                                        expr: &amp;zeroOrMoreExpr{
                                                                                pos: position{line: 376, col: 29, offset: 10579},
                                                                                expr: &amp;ruleRefExpr{
                                                                                        pos:  position{line: 376, col: 29, offset: 10579},
                                                                                        name: "DoubleStringChar",
                                                                                },
                                                                        },
                                                                },
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 376, col: 47, offset: 10597},
                                                                        val:        "\"",
                                                                        ignoreCase: false,
                                                                        want:       "\"\\\"\"",
                                                                },
                                                        },
                                                },
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 388, col: 5, offset: 10933},
                                                run: (*parser).callonStringLiteral9,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 388, col: 5, offset: 10933},
                                                        exprs: []any{
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 388, col: 5, offset: 10933},
                                                                        val:        "'",
                                                                        ignoreCase: false,
                                                                        want:       "\"'\"",
                                                                },
                                                                &amp;labeledExpr{
                                                                        pos:   position{line: 388, col: 9, offset: 10937},
                                                                        label: "chars",
                                                                        expr: &amp;zeroOrMoreExpr{
                                                                                pos: position{line: 388, col: 15, offset: 10943},
                                                                                expr: &amp;ruleRefExpr{
                                                                                        pos:  position{line: 388, col: 15, offset: 10943},
                                                                                        name: "SingleStringChar",
                                                                                },
                                                                        },
                                                                },
                                                                &amp;litMatcher{
                                                                        pos:        position{line: 388, col: 33, offset: 10961},
                                                                        val:        "'",
                                                                        ignoreCase: false,
                                                                        want:       "\"'\"",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "DoubleStringChar",
                        pos:  position{line: 401, col: 1, offset: 11291},
                        expr: &amp;choiceExpr{
                                pos: position{line: 401, col: 21, offset: 11311},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 401, col: 21, offset: 11311},
                                                name: "EscapeSequence",
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 401, col: 38, offset: 11328},
                                                run: (*parser).callonDoubleStringChar3,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 401, col: 39, offset: 11329},
                                                        exprs: []any{
                                                                &amp;notExpr{
                                                                        pos: position{line: 401, col: 39, offset: 11329},
                                                                        expr: &amp;litMatcher{
                                                                                pos:        position{line: 401, col: 40, offset: 11330},
                                                                                val:        "\"",
                                                                                ignoreCase: false,
                                                                                want:       "\"\\\"\"",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 401, col: 44, offset: 11334},
                                                                        name: "UnicodeChar",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "SingleStringChar",
                        pos:  position{line: 405, col: 1, offset: 11383},
                        expr: &amp;choiceExpr{
                                pos: position{line: 405, col: 21, offset: 11403},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 405, col: 21, offset: 11403},
                                                name: "EscapeSequence",
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 405, col: 38, offset: 11420},
                                                run: (*parser).callonSingleStringChar3,
                                                expr: &amp;seqExpr{
                                                        pos: position{line: 405, col: 39, offset: 11421},
                                                        exprs: []any{
                                                                &amp;notExpr{
                                                                        pos: position{line: 405, col: 39, offset: 11421},
                                                                        expr: &amp;litMatcher{
                                                                                pos:        position{line: 405, col: 40, offset: 11422},
                                                                                val:        "'",
                                                                                ignoreCase: false,
                                                                                want:       "\"'\"",
                                                                        },
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 405, col: 45, offset: 11427},
                                                                        name: "UnicodeChar",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "EscapeSequence",
                        pos:  position{line: 409, col: 1, offset: 11476},
                        expr: &amp;actionExpr{
                                pos: position{line: 409, col: 19, offset: 11494},
                                run: (*parser).callonEscapeSequence1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 409, col: 19, offset: 11494},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 409, col: 19, offset: 11494},
                                                        val:        "\\",
                                                        ignoreCase: false,
                                                        want:       "\"\\\\\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 409, col: 24, offset: 11499},
                                                        label: "char",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 409, col: 29, offset: 11504},
                                                                name: "EscapeChar",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "EscapeChar",
                        pos:  position{line: 428, col: 1, offset: 11833},
                        expr: &amp;choiceExpr{
                                pos: position{line: 428, col: 15, offset: 11847},
                                alternatives: []any{
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 15, offset: 11847},
                                                val:        "n",
                                                ignoreCase: false,
                                                want:       "\"n\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 21, offset: 11853},
                                                val:        "t",
                                                ignoreCase: false,
                                                want:       "\"t\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 27, offset: 11859},
                                                val:        "r",
                                                ignoreCase: false,
                                                want:       "\"r\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 33, offset: 11865},
                                                val:        "\\",
                                                ignoreCase: false,
                                                want:       "\"\\\\\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 40, offset: 11872},
                                                val:        "\"",
                                                ignoreCase: false,
                                                want:       "\"\\\"\"",
                                        },
                                        &amp;litMatcher{
                                                pos:        position{line: 428, col: 47, offset: 11879},
                                                val:        "'",
                                                ignoreCase: false,
                                                want:       "\"'\"",
                                        },
                                        &amp;anyMatcher{
                                                line: 428, col: 53, offset: 11885,
                                        },
                                },
                        },
                },
                {
                        name: "UnicodeChar",
                        pos:  position{line: 430, col: 1, offset: 11888},
                        expr: &amp;anyMatcher{
                                line: 430, col: 16, offset: 11903,
                        },
                },
                {
                        name: "RemoveFact",
                        pos:  position{line: 433, col: 1, offset: 12003},
                        expr: &amp;actionExpr{
                                pos: position{line: 433, col: 15, offset: 12017},
                                run: (*parser).callonRemoveFact1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 433, col: 15, offset: 12017},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 433, col: 15, offset: 12017},
                                                        val:        "remove",
                                                        ignoreCase: false,
                                                        want:       "\"remove\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 433, col: 24, offset: 12026},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 433, col: 26, offset: 12028},
                                                        label: "typeName",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 433, col: 35, offset: 12037},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 433, col: 45, offset: 12047},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 433, col: 47, offset: 12049},
                                                        label: "factID",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 433, col: 54, offset: 12056},
                                                                name: "FactID",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FactID",
                        pos:  position{line: 442, col: 1, offset: 12284},
                        expr: &amp;actionExpr{
                                pos: position{line: 442, col: 11, offset: 12294},
                                run: (*parser).callonFactID1,
                                expr: &amp;labeledExpr{
                                        pos:   position{line: 442, col: 11, offset: 12294},
                                        label: "chars",
                                        expr: &amp;oneOrMoreExpr{
                                                pos: position{line: 442, col: 17, offset: 12300},
                                                expr: &amp;choiceExpr{
                                                        pos: position{line: 442, col: 18, offset: 12301},
                                                        alternatives: []any{
                                                                &amp;charClassMatcher{
                                                                        pos:        position{line: 442, col: 18, offset: 12301},
                                                                        val:        "[a-zA-Z0-9_-]",
                                                                        chars:      []rune{'_', '-'},
                                                                        ranges:     []rune{'a', 'z', 'A', 'Z', '0', '9'},
                                                                        ignoreCase: false,
                                                                        inverted:   false,
                                                                },
                                                                &amp;ruleRefExpr{
                                                                        pos:  position{line: 442, col: 34, offset: 12317},
                                                                        name: "SpecialFactChar",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Fact",
                        pos:  position{line: 447, col: 1, offset: 12459},
                        expr: &amp;actionExpr{
                                pos: position{line: 447, col: 9, offset: 12467},
                                run: (*parser).callonFact1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 447, col: 9, offset: 12467},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 447, col: 9, offset: 12467},
                                                        label: "typeName",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 447, col: 18, offset: 12476},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 447, col: 28, offset: 12486},
                                                        val:        "(",
                                                        ignoreCase: false,
                                                        want:       "\"(\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 447, col: 32, offset: 12490},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 447, col: 34, offset: 12492},
                                                        label: "fields",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 447, col: 41, offset: 12499},
                                                                name: "FactFieldList",
                                                        },
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 447, col: 55, offset: 12513},
                                                        name: "_",
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 447, col: 57, offset: 12515},
                                                        val:        ")",
                                                        ignoreCase: false,
                                                        want:       "\")\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FactFieldList",
                        pos:  position{line: 455, col: 1, offset: 12650},
                        expr: &amp;actionExpr{
                                pos: position{line: 455, col: 18, offset: 12667},
                                run: (*parser).callonFactFieldList1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 455, col: 18, offset: 12667},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 455, col: 18, offset: 12667},
                                                        label: "first",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 455, col: 24, offset: 12673},
                                                                name: "FactField",
                                                        },
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 455, col: 34, offset: 12683},
                                                        label: "rest",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 455, col: 39, offset: 12688},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 455, col: 40, offset: 12689},
                                                                        exprs: []any{
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 455, col: 40, offset: 12689},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;litMatcher{
                                                                                        pos:        position{line: 455, col: 42, offset: 12691},
                                                                                        val:        ",",
                                                                                        ignoreCase: false,
                                                                                        want:       "\",\"",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 455, col: 46, offset: 12695},
                                                                                        name: "_",
                                                                                },
                                                                                &amp;ruleRefExpr{
                                                                                        pos:  position{line: 455, col: 48, offset: 12697},
                                                                                        name: "FactField",
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FactField",
                        pos:  position{line: 465, col: 1, offset: 12922},
                        expr: &amp;actionExpr{
                                pos: position{line: 465, col: 14, offset: 12935},
                                run: (*parser).callonFactField1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 465, col: 14, offset: 12935},
                                        exprs: []any{
                                                &amp;labeledExpr{
                                                        pos:   position{line: 465, col: 14, offset: 12935},
                                                        label: "name",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 465, col: 19, offset: 12940},
                                                                name: "IdentName",
                                                        },
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 465, col: 29, offset: 12950},
                                                        val:        ":",
                                                        ignoreCase: false,
                                                        want:       "\":\"",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 465, col: 33, offset: 12954},
                                                        name: "_",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 465, col: 35, offset: 12956},
                                                        label: "value",
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 465, col: 41, offset: 12962},
                                                                name: "FactValue",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "FactValue",
                        pos:  position{line: 472, col: 1, offset: 13069},
                        expr: &amp;choiceExpr{
                                pos: position{line: 472, col: 14, offset: 13082},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 472, col: 14, offset: 13082},
                                                name: "StringLiteral",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 472, col: 30, offset: 13098},
                                                name: "Number",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 472, col: 39, offset: 13107},
                                                name: "BooleanLiteral",
                                        },
                                        &amp;actionExpr{
                                                pos: position{line: 472, col: 56, offset: 13124},
                                                run: (*parser).callonFactValue5,
                                                expr: &amp;ruleRefExpr{
                                                        pos:  position{line: 472, col: 56, offset: 13124},
                                                        name: "ComplexIdentifier",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ComplexIdentifier",
                        pos:  position{line: 480, col: 1, offset: 13335},
                        expr: &amp;actionExpr{
                                pos: position{line: 480, col: 22, offset: 13356},
                                run: (*parser).callonComplexIdentifier1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 480, col: 22, offset: 13356},
                                        exprs: []any{
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 480, col: 22, offset: 13356},
                                                        name: "ComplexIdentStart",
                                                },
                                                &amp;zeroOrMoreExpr{
                                                        pos: position{line: 480, col: 40, offset: 13374},
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 480, col: 40, offset: 13374},
                                                                name: "ComplexIdentContinue",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "ComplexIdentStart",
                        pos:  position{line: 484, col: 1, offset: 13432},
                        expr: &amp;choiceExpr{
                                pos: position{line: 484, col: 22, offset: 13453},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 484, col: 22, offset: 13453},
                                                val:        "[a-zA-Z0-9_]",
                                                chars:      []rune{'_'},
                                                ranges:     []rune{'a', 'z', 'A', 'Z', '0', '9'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 484, col: 37, offset: 13468},
                                                name: "UnicodeLetterStart",
                                        },
                                },
                        },
                },
                {
                        name: "ComplexIdentContinue",
                        pos:  position{line: 486, col: 1, offset: 13488},
                        expr: &amp;choiceExpr{
                                pos: position{line: 486, col: 25, offset: 13512},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 486, col: 25, offset: 13512},
                                                val:        "[a-zA-Z0-9_-]",
                                                chars:      []rune{'_', '-'},
                                                ranges:     []rune{'a', 'z', 'A', 'Z', '0', '9'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 486, col: 41, offset: 13528},
                                                name: "UnicodeLetterContinue",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 486, col: 65, offset: 13552},
                                                name: "SpecialFactChar",
                                        },
                                },
                        },
                },
                {
                        name: "SpecialFactChar",
                        pos:  position{line: 489, col: 1, offset: 13631},
                        expr: &amp;charClassMatcher{
                                pos:        position{line: 489, col: 20, offset: 13650},
                                val:        "[-_:.]",
                                chars:      []rune{'-', '_', ':', '.'},
                                ignoreCase: false,
                                inverted:   false,
                        },
                },
                {
                        name: "IdentName",
                        pos:  position{line: 491, col: 1, offset: 13658},
                        expr: &amp;actionExpr{
                                pos: position{line: 491, col: 14, offset: 13671},
                                run: (*parser).callonIdentName1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 491, col: 14, offset: 13671},
                                        exprs: []any{
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 491, col: 14, offset: 13671},
                                                        name: "IdentStart",
                                                },
                                                &amp;zeroOrMoreExpr{
                                                        pos: position{line: 491, col: 25, offset: 13682},
                                                        expr: &amp;ruleRefExpr{
                                                                pos:  position{line: 491, col: 25, offset: 13682},
                                                                name: "IdentContinue",
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "IdentStart",
                        pos:  position{line: 495, col: 1, offset: 13733},
                        expr: &amp;choiceExpr{
                                pos: position{line: 495, col: 15, offset: 13747},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 495, col: 15, offset: 13747},
                                                val:        "[a-zA-Z_]",
                                                chars:      []rune{'_'},
                                                ranges:     []rune{'a', 'z', 'A', 'Z'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 495, col: 27, offset: 13759},
                                                name: "UnicodeLetterStart",
                                        },
                                },
                        },
                },
                {
                        name: "IdentContinue",
                        pos:  position{line: 497, col: 1, offset: 13779},
                        expr: &amp;choiceExpr{
                                pos: position{line: 497, col: 18, offset: 13796},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 497, col: 18, offset: 13796},
                                                val:        "[a-zA-Z0-9_-]",
                                                chars:      []rune{'_', '-'},
                                                ranges:     []rune{'a', 'z', 'A', 'Z', '0', '9'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 497, col: 34, offset: 13812},
                                                name: "UnicodeLetterContinue",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 497, col: 58, offset: 13836},
                                                name: "PunctuationChar",
                                        },
                                },
                        },
                },
                {
                        name: "UnicodeLetterStart",
                        pos:  position{line: 500, col: 1, offset: 13947},
                        expr: &amp;choiceExpr{
                                pos: position{line: 500, col: 23, offset: 13969},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 500, col: 23, offset: 13969},
                                                val:        "[\\u00C0-\\u00D6]",
                                                ranges:     []rune{'À', 'Ö'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 500, col: 41, offset: 13987},
                                                val:        "[\\u00D8-\\u00F6]",
                                                ranges:     []rune{'Ø', 'ö'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 500, col: 59, offset: 14005},
                                                val:        "[\\u00F8-\\u017F]",
                                                ranges:     []rune{'ø', 'ſ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 501, col: 23, offset: 14045},
                                                val:        "[\\u0100-\\u024F]",
                                                ranges:     []rune{'Ā', 'ɏ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 501, col: 41, offset: 14063},
                                                val:        "[\\u1E00-\\u1EFF]",
                                                ranges:     []rune{'Ḁ', 'ỿ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 501, col: 59, offset: 14081},
                                                val:        "[\\u0370-\\u03FF]",
                                                ranges:     []rune{'Ͱ', 'Ͽ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 502, col: 23, offset: 14121},
                                                val:        "[\\u0400-\\u04FF]",
                                                ranges:     []rune{'Ѐ', 'ӿ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 502, col: 41, offset: 14139},
                                                val:        "[\\u0590-\\u05FF]",
                                                ranges:     []rune{'\u0590', '\u05ff'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 502, col: 59, offset: 14157},
                                                val:        "[\\u0600-\\u06FF]",
                                                ranges:     []rune{'\u0600', 'ۿ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                },
                        },
                },
                {
                        name: "UnicodeLetterContinue",
                        pos:  position{line: 504, col: 1, offset: 14174},
                        expr: &amp;choiceExpr{
                                pos: position{line: 504, col: 26, offset: 14199},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 504, col: 26, offset: 14199},
                                                val:        "[\\u00C0-\\u00D6]",
                                                ranges:     []rune{'À', 'Ö'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 504, col: 44, offset: 14217},
                                                val:        "[\\u00D8-\\u00F6]",
                                                ranges:     []rune{'Ø', 'ö'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 504, col: 62, offset: 14235},
                                                val:        "[\\u00F8-\\u017F]",
                                                ranges:     []rune{'ø', 'ſ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 505, col: 26, offset: 14278},
                                                val:        "[\\u0100-\\u024F]",
                                                ranges:     []rune{'Ā', 'ɏ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 505, col: 44, offset: 14296},
                                                val:        "[\\u1E00-\\u1EFF]",
                                                ranges:     []rune{'Ḁ', 'ỿ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 505, col: 62, offset: 14314},
                                                val:        "[\\u0370-\\u03FF]",
                                                ranges:     []rune{'Ͱ', 'Ͽ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 506, col: 26, offset: 14357},
                                                val:        "[\\u0400-\\u04FF]",
                                                ranges:     []rune{'Ѐ', 'ӿ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 506, col: 44, offset: 14375},
                                                val:        "[\\u0590-\\u05FF]",
                                                ranges:     []rune{'\u0590', '\u05ff'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 506, col: 62, offset: 14393},
                                                val:        "[\\u0600-\\u06FF]",
                                                ranges:     []rune{'\u0600', 'ۿ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 507, col: 26, offset: 14436},
                                                val:        "[\\u0300-\\u036F]",
                                                ranges:     []rune{'̀', 'ͯ'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 507, col: 44, offset: 14454},
                                                val:        "[\\u1AB0-\\u1AFF]",
                                                ranges:     []rune{'᪰', '\u1aff'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 507, col: 62, offset: 14472},
                                                val:        "[\\u1DC0-\\u1DFF]",
                                                ranges:     []rune{'᷀', '᷿'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                },
                        },
                },
                {
                        name: "PunctuationChar",
                        pos:  position{line: 509, col: 1, offset: 14489},
                        expr: &amp;choiceExpr{
                                pos: position{line: 509, col: 20, offset: 14508},
                                alternatives: []any{
                                        &amp;charClassMatcher{
                                                pos:        position{line: 509, col: 20, offset: 14508},
                                                val:        "[-_]",
                                                chars:      []rune{'-', '_'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 509, col: 27, offset: 14515},
                                                val:        "[']",
                                                chars:      []rune{'\''},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 509, col: 33, offset: 14521},
                                                val:        "[\\u2010-\\u2015]",
                                                ranges:     []rune{'‐', '―'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                        &amp;charClassMatcher{
                                                pos:        position{line: 509, col: 51, offset: 14539},
                                                val:        "[\\u2032-\\u2037]",
                                                ranges:     []rune{'′', '‷'},
                                                ignoreCase: false,
                                                inverted:   false,
                                        },
                                },
                        },
                },
                {
                        name: "_",
                        pos:  position{line: 511, col: 1, offset: 14556},
                        expr: &amp;zeroOrMoreExpr{
                                pos: position{line: 511, col: 6, offset: 14561},
                                expr: &amp;choiceExpr{
                                        pos: position{line: 511, col: 7, offset: 14562},
                                        alternatives: []any{
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 511, col: 7, offset: 14562},
                                                        name: "Whitespace",
                                                },
                                                &amp;ruleRefExpr{
                                                        pos:  position{line: 511, col: 20, offset: 14575},
                                                        name: "Comment",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "Whitespace",
                        pos:  position{line: 513, col: 1, offset: 14586},
                        expr: &amp;charClassMatcher{
                                pos:        position{line: 513, col: 15, offset: 14600},
                                val:        "[ \\t\\r\\n]",
                                chars:      []rune{' ', '\t', '\r', '\n'},
                                ignoreCase: false,
                                inverted:   false,
                        },
                },
                {
                        name: "Comment",
                        pos:  position{line: 515, col: 1, offset: 14611},
                        expr: &amp;choiceExpr{
                                pos: position{line: 515, col: 12, offset: 14622},
                                alternatives: []any{
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 515, col: 12, offset: 14622},
                                                name: "LineComment",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 515, col: 26, offset: 14636},
                                                name: "BlockComment",
                                        },
                                        &amp;ruleRefExpr{
                                                pos:  position{line: 515, col: 41, offset: 14651},
                                                name: "EndOfLineComment",
                                        },
                                },
                        },
                },
                {
                        name: "LineComment",
                        pos:  position{line: 517, col: 1, offset: 14669},
                        expr: &amp;actionExpr{
                                pos: position{line: 517, col: 16, offset: 14684},
                                run: (*parser).callonLineComment1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 517, col: 16, offset: 14684},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 517, col: 16, offset: 14684},
                                                        val:        "//",
                                                        ignoreCase: false,
                                                        want:       "\"//\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 517, col: 21, offset: 14689},
                                                        label: "CommentText",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 517, col: 33, offset: 14701},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 517, col: 34, offset: 14702},
                                                                        exprs: []any{
                                                                                &amp;notExpr{
                                                                                        pos: position{line: 517, col: 34, offset: 14702},
                                                                                        expr: &amp;charClassMatcher{
                                                                                                pos:        position{line: 517, col: 35, offset: 14703},
                                                                                                val:        "[\\r\\n]",
                                                                                                chars:      []rune{'\r', '\n'},
                                                                                                ignoreCase: false,
                                                                                                inverted:   false,
                                                                                        },
                                                                                },
                                                                                &amp;anyMatcher{
                                                                                        line: 517, col: 42, offset: 14710,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "BlockComment",
                        pos:  position{line: 521, col: 1, offset: 14779},
                        expr: &amp;actionExpr{
                                pos: position{line: 521, col: 17, offset: 14795},
                                run: (*parser).callonBlockComment1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 521, col: 17, offset: 14795},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 521, col: 17, offset: 14795},
                                                        val:        "/*",
                                                        ignoreCase: false,
                                                        want:       "\"/*\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 521, col: 22, offset: 14800},
                                                        label: "CommentText",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 521, col: 34, offset: 14812},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 521, col: 35, offset: 14813},
                                                                        exprs: []any{
                                                                                &amp;notExpr{
                                                                                        pos: position{line: 521, col: 35, offset: 14813},
                                                                                        expr: &amp;litMatcher{
                                                                                                pos:        position{line: 521, col: 36, offset: 14814},
                                                                                                val:        "*/",
                                                                                                ignoreCase: false,
                                                                                                want:       "\"*/\"",
                                                                                        },
                                                                                },
                                                                                &amp;anyMatcher{
                                                                                        line: 521, col: 41, offset: 14819,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                                &amp;litMatcher{
                                                        pos:        position{line: 521, col: 45, offset: 14823},
                                                        val:        "*/",
                                                        ignoreCase: false,
                                                        want:       "\"*/\"",
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "EndOfLineComment",
                        pos:  position{line: 525, col: 1, offset: 14893},
                        expr: &amp;actionExpr{
                                pos: position{line: 525, col: 21, offset: 14913},
                                run: (*parser).callonEndOfLineComment1,
                                expr: &amp;seqExpr{
                                        pos: position{line: 525, col: 21, offset: 14913},
                                        exprs: []any{
                                                &amp;litMatcher{
                                                        pos:        position{line: 525, col: 21, offset: 14913},
                                                        val:        "#",
                                                        ignoreCase: false,
                                                        want:       "\"#\"",
                                                },
                                                &amp;labeledExpr{
                                                        pos:   position{line: 525, col: 25, offset: 14917},
                                                        label: "CommentText",
                                                        expr: &amp;zeroOrMoreExpr{
                                                                pos: position{line: 525, col: 37, offset: 14929},
                                                                expr: &amp;seqExpr{
                                                                        pos: position{line: 525, col: 38, offset: 14930},
                                                                        exprs: []any{
                                                                                &amp;notExpr{
                                                                                        pos: position{line: 525, col: 38, offset: 14930},
                                                                                        expr: &amp;charClassMatcher{
                                                                                                pos:        position{line: 525, col: 39, offset: 14931},
                                                                                                val:        "[\\r\\n]",
                                                                                                chars:      []rune{'\r', '\n'},
                                                                                                ignoreCase: false,
                                                                                                inverted:   false,
                                                                                        },
                                                                                },
                                                                                &amp;anyMatcher{
                                                                                        line: 525, col: 46, offset: 14938,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                {
                        name: "EOF",
                        pos:  position{line: 529, col: 1, offset: 15016},
                        expr: &amp;notExpr{
                                pos: position{line: 529, col: 8, offset: 15023},
                                expr: &amp;anyMatcher{
                                        line: 529, col: 9, offset: 15024,
                                },
                        },
                },
        },
}

func (c *current) onStart1(statements any) (any, error) <span class="cov8" title="1">{
        // Séparer types, expressions, faits et retractions
        types := []interface{}{}
        expressions := []interface{}{}
        facts := []interface{}{}
        retractions := []interface{}{}

        if statements != nil </span><span class="cov8" title="1">{
                for _, stmt := range statements.([]interface{}) </span><span class="cov8" title="1">{
                        if stmtMap, ok := stmt.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if stmtMap["type"] == "typeDefinition" </span><span class="cov8" title="1">{
                                        types = append(types, stmt)
                                }</span> else<span class="cov8" title="1"> if stmtMap["type"] == "expression" </span><span class="cov8" title="1">{
                                        expressions = append(expressions, stmt)
                                }</span> else<span class="cov8" title="1"> if stmtMap["type"] == "fact" </span><span class="cov8" title="1">{
                                        facts = append(facts, stmt)
                                }</span> else<span class="cov8" title="1"> if stmtMap["type"] == "retraction" </span><span class="cov8" title="1">{
                                        retractions = append(retractions, stmt)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return map[string]interface{}{
                "types":       types,
                "expressions": expressions,
                "facts":       facts,
                "retractions": retractions,
        }, nil</span>
}

func (p *parser) callonStart1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onStart1(stack["statements"])
}</span>

func (c *current) onStatementList1(statements any) (any, error) <span class="cov8" title="1">{
        result := []interface{}{}
        if statements != nil </span><span class="cov8" title="1">{
                for _, stmt := range statements.([]interface{}) </span><span class="cov8" title="1">{
                        result = append(result, stmt.([]interface{})[0])
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func (p *parser) callonStatementList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onStatementList1(stack["statements"])
}</span>

func (c *current) onTypeDefinition1(name, fields any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":   "typeDefinition",
                "name":   name,
                "fields": fields,
        }, nil
}</span>

func (p *parser) callonTypeDefinition1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onTypeDefinition1(stack["name"], stack["fields"])
}</span>

func (c *current) onFieldList1(first, rest any) (any, error) <span class="cov8" title="1">{
        fields := []interface{}{first}
        if rest != nil </span><span class="cov8" title="1">{
                for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                        fields = append(fields, item.([]interface{})[3])
                }</span>
        }
        <span class="cov8" title="1">return fields, nil</span>
}

func (p *parser) callonFieldList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFieldList1(stack["first"], stack["rest"])
}</span>

func (c *current) onField1(name, fieldType any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "name": name,
                "type": fieldType,
        }, nil
}</span>

func (p *parser) callonField1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onField1(stack["name"], stack["fieldType"])
}</span>

func (c *current) onAtomicType2() (any, error) <span class="cov8" title="1">{
        return "string", nil
}</span>

func (p *parser) callonAtomicType2() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAtomicType2()
}</span>

func (c *current) onAtomicType4() (any, error) <span class="cov8" title="1">{
        return "number", nil
}</span>

func (p *parser) callonAtomicType4() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAtomicType4()
}</span>

func (c *current) onAtomicType6() (any, error) <span class="cov0" title="0">{
        return "bool", nil
}</span>

func (p *parser) callonAtomicType6() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAtomicType6()
}</span>

func (c *current) onExpression1(set, constraints, action any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":        "expression",
                "set":         set,
                "constraints": constraints,
                "action":      action,
        }, nil
}</span>

func (p *parser) callonExpression1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onExpression1(stack["set"], stack["constraints"], stack["action"])
}</span>

func (c *current) onSet1(variables any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":      "set",
                "variables": variables,
        }, nil
}</span>

func (p *parser) callonSet1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onSet1(stack["variables"])
}</span>

func (c *current) onTypedVariableList1(first, rest any) (any, error) <span class="cov8" title="1">{
        variables := []interface{}{first}
        if rest != nil </span><span class="cov8" title="1">{
                for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                        variables = append(variables, item.([]interface{})[3])
                }</span>
        }
        <span class="cov8" title="1">return variables, nil</span>
}

func (p *parser) callonTypedVariableList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onTypedVariableList1(stack["first"], stack["rest"])
}</span>

func (c *current) onTypedVariable1(name, dataType any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "typedVariable",
                "name":     name,
                "dataType": dataType,
        }, nil
}</span>

func (p *parser) callonTypedVariable1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onTypedVariable1(stack["name"], stack["dataType"])
}</span>

func (c *current) onConstraints1(first, rest any) (any, error) <span class="cov8" title="1">{
        if rest == nil || len(rest.([]interface{})) == 0 </span><span class="cov0" title="0">{
                return first, nil
        }</span>

        <span class="cov8" title="1">operations := []map[string]interface{}{}
        for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                op := item.([]interface{})[1]
                right := item.([]interface{})[3]
                operations = append(operations, map[string]interface{}{
                        "op":    op,
                        "right": right,
                })
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "type":       "logicalExpr",
                "left":       first,
                "operations": operations,
        }, nil</span>
}

func (p *parser) callonConstraints1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onConstraints1(stack["first"], stack["rest"])
}</span>

func (c *current) onConstraint2(expr any) (any, error) <span class="cov0" title="0">{
        return expr, nil
}</span>

func (p *parser) callonConstraint2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onConstraint2(stack["expr"])
}</span>

func (c *current) onConstraint13(left, op, right any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "comparison",
                "left":     left,
                "operator": op,
                "right":    right,
        }, nil
}</span>

func (p *parser) callonConstraint13() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onConstraint13(stack["left"], stack["op"], stack["right"])
}</span>

func (c *current) onNotConstraint1(expr any) (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":       "notConstraint",
                "expression": expr,
        }, nil
}</span>

func (p *parser) callonNotConstraint1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onNotConstraint1(stack["expr"])
}</span>

func (c *current) onExistsConstraint1(variable, condition any) (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":      "existsConstraint",
                "variable":  variable,
                "condition": condition,
        }, nil
}</span>

func (p *parser) callonExistsConstraint1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onExistsConstraint1(stack["variable"], stack["condition"])
}</span>

func (c *current) onAccumulateConstraint1(accumFunc, accumVar, accumCond, accumField, accumOp, accumThreshold any) (any, error) <span class="cov0" title="0">{
        fieldValue := ""
        if accumField != nil </span><span class="cov0" title="0">{
                fieldAccess := accumField.([]interface{})[3].(map[string]interface{})
                fieldValue = fieldAccess["field"].(string)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type":      "accumulateConstraint",
                "function":  accumFunc,
                "variable":  accumVar,
                "condition": accumCond,
                "field":     fieldValue,
                "operator":  accumOp,
                "threshold": accumThreshold,
        }, nil</span>
}

func (p *parser) callonAccumulateConstraint1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateConstraint1(stack["accumFunc"], stack["accumVar"], stack["accumCond"], stack["accumField"], stack["accumOp"], stack["accumThreshold"])
}</span>

func (c *current) onAccumulateFunction2() (any, error) <span class="cov0" title="0">{
        return "AVG", nil
}</span>

func (p *parser) callonAccumulateFunction2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction2()
}</span>

func (c *current) onAccumulateFunction4() (any, error) <span class="cov0" title="0">{
        return "COUNT", nil
}</span>

func (p *parser) callonAccumulateFunction4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction4()
}</span>

func (c *current) onAccumulateFunction6() (any, error) <span class="cov0" title="0">{
        return "SUM", nil
}</span>

func (p *parser) callonAccumulateFunction6() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction6()
}</span>

func (c *current) onAccumulateFunction8() (any, error) <span class="cov0" title="0">{
        return "MIN", nil
}</span>

func (p *parser) callonAccumulateFunction8() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction8()
}</span>

func (c *current) onAccumulateFunction10() (any, error) <span class="cov0" title="0">{
        return "MAX", nil
}</span>

func (p *parser) callonAccumulateFunction10() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAccumulateFunction10()
}</span>

func (c *current) onArithmeticExpr1(first, rest any) (any, error) <span class="cov8" title="1">{
        if rest == nil || len(rest.([]interface{})) == 0 </span><span class="cov8" title="1">{
                return first, nil
        }</span>

        <span class="cov0" title="0">result := first
        for _, item := range rest.([]interface{}) </span><span class="cov0" title="0">{
                op := item.([]interface{})[1]
                right := item.([]interface{})[3]
                result = map[string]interface{}{
                        "type":     "binaryOp",
                        "left":     result,
                        "operator": op,
                        "right":    right,
                }
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (p *parser) callonArithmeticExpr1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onArithmeticExpr1(stack["first"], stack["rest"])
}</span>

func (c *current) onTerm1(first, rest any) (any, error) <span class="cov8" title="1">{
        if rest == nil || len(rest.([]interface{})) == 0 </span><span class="cov8" title="1">{
                return first, nil
        }</span>

        <span class="cov0" title="0">result := first
        for _, item := range rest.([]interface{}) </span><span class="cov0" title="0">{
                op := item.([]interface{})[1]
                right := item.([]interface{})[3]
                result = map[string]interface{}{
                        "type":     "binaryOp",
                        "left":     result,
                        "operator": op,
                        "right":    right,
                }
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (p *parser) callonTerm1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onTerm1(stack["first"], stack["rest"])
}</span>

func (c *current) onFactor2(expr any) (any, error) <span class="cov0" title="0">{
        return expr, nil
}</span>

func (p *parser) callonFactor2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactor2(stack["expr"])
}</span>

func (c *current) onFieldAccess1(object, field any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":   "fieldAccess",
                "object": object,
                "field":  field,
        }, nil
}</span>

func (p *parser) callonFieldAccess1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFieldAccess1(stack["object"], stack["field"])
}</span>

func (c *current) onVariable1(name any) (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "variable",
                "name": name,
        }, nil
}</span>

func (p *parser) callonVariable1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onVariable1(stack["name"])
}</span>

func (c *current) onArrayLiteral1(elements any) (any, error) <span class="cov0" title="0">{
        if elements == nil </span><span class="cov0" title="0">{
                elements = []interface{}{}
        }</span>
        <span class="cov0" title="0">return map[string]interface{}{
                "type":     "arrayLiteral",
                "elements": elements,
        }, nil</span>
}

func (p *parser) callonArrayLiteral1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onArrayLiteral1(stack["elements"])
}</span>

func (c *current) onArrayElementList1(first, rest any) (any, error) <span class="cov0" title="0">{
        elements := []interface{}{first}
        if rest != nil </span><span class="cov0" title="0">{
                for _, item := range rest.([]interface{}) </span><span class="cov0" title="0">{
                        elements = append(elements, item.([]interface{})[3])
                }</span>
        }
        <span class="cov0" title="0">return elements, nil</span>
}

func (p *parser) callonArrayElementList1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onArrayElementList1(stack["first"], stack["rest"])
}</span>

func (c *current) onFunctionCall1(name, args any) (any, error) <span class="cov0" title="0">{
        if args == nil </span><span class="cov0" title="0">{
                args = []interface{}{}
        }</span>
        <span class="cov0" title="0">return map[string]interface{}{
                "type": "functionCall",
                "name": name,
                "args": args,
        }, nil</span>
}

func (p *parser) callonFunctionCall1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionCall1(stack["name"], stack["args"])
}</span>

func (c *current) onFunctionName2() (any, error) <span class="cov0" title="0">{
        return "LENGTH", nil
}</span>

func (p *parser) callonFunctionName2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName2()
}</span>

func (c *current) onFunctionName4() (any, error) <span class="cov0" title="0">{
        return "SUBSTRING", nil
}</span>

func (p *parser) callonFunctionName4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName4()
}</span>

func (c *current) onFunctionName6() (any, error) <span class="cov0" title="0">{
        return "UPPER", nil
}</span>

func (p *parser) callonFunctionName6() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName6()
}</span>

func (c *current) onFunctionName8() (any, error) <span class="cov0" title="0">{
        return "LOWER", nil
}</span>

func (p *parser) callonFunctionName8() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName8()
}</span>

func (c *current) onFunctionName10() (any, error) <span class="cov0" title="0">{
        return "TRIM", nil
}</span>

func (p *parser) callonFunctionName10() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName10()
}</span>

func (c *current) onFunctionName12() (any, error) <span class="cov0" title="0">{
        return "ABS", nil
}</span>

func (p *parser) callonFunctionName12() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName12()
}</span>

func (c *current) onFunctionName14() (any, error) <span class="cov0" title="0">{
        return "ROUND", nil
}</span>

func (p *parser) callonFunctionName14() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName14()
}</span>

func (c *current) onFunctionName16() (any, error) <span class="cov0" title="0">{
        return "FLOOR", nil
}</span>

func (p *parser) callonFunctionName16() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName16()
}</span>

func (c *current) onFunctionName18() (any, error) <span class="cov0" title="0">{
        return "CEIL", nil
}</span>

func (p *parser) callonFunctionName18() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionName18()
}</span>

func (c *current) onFunctionArgList1(first, rest any) (any, error) <span class="cov0" title="0">{
        args := []interface{}{first}
        if rest != nil </span><span class="cov0" title="0">{
                for _, item := range rest.([]interface{}) </span><span class="cov0" title="0">{
                        args = append(args, item.([]interface{})[3])
                }</span>
        }
        <span class="cov0" title="0">return args, nil</span>
}

func (p *parser) callonFunctionArgList1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFunctionArgList1(stack["first"], stack["rest"])
}</span>

func (c *current) onAction1(job any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type": "action",
                "job":  job,
        }, nil
}</span>

func (p *parser) callonAction1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onAction1(stack["job"])
}</span>

func (c *current) onJobCall1(name, args any) (any, error) <span class="cov8" title="1">{
        if args == nil </span><span class="cov0" title="0">{
                args = []interface{}{}
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{
                "type": "jobCall",
                "name": name,
                "args": args,
        }, nil</span>
}

func (p *parser) callonJobCall1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onJobCall1(stack["name"], stack["args"])
}</span>

func (c *current) onArgumentList1(first, rest any) (any, error) <span class="cov8" title="1">{
        arguments := []interface{}{first}
        if rest != nil </span><span class="cov8" title="1">{
                for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                        arguments = append(arguments, item.([]interface{})[3])
                }</span>
        }
        <span class="cov8" title="1">return arguments, nil</span>
}

func (p *parser) callonArgumentList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onArgumentList1(stack["first"], stack["rest"])
}</span>

func (c *current) onComparisonOp2() (any, error) <span class="cov0" title="0">{
        return "==", nil
}</span>

func (p *parser) callonComparisonOp2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp2()
}</span>

func (c *current) onComparisonOp4() (any, error) <span class="cov0" title="0">{
        return "!=", nil
}</span>

func (p *parser) callonComparisonOp4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp4()
}</span>

func (c *current) onComparisonOp6() (any, error) <span class="cov0" title="0">{
        return "&lt;=", nil
}</span>

func (p *parser) callonComparisonOp6() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp6()
}</span>

func (c *current) onComparisonOp8() (any, error) <span class="cov0" title="0">{
        return "&gt;=", nil
}</span>

func (p *parser) callonComparisonOp8() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp8()
}</span>

func (c *current) onComparisonOp10() (any, error) <span class="cov0" title="0">{
        return "&lt;", nil
}</span>

func (p *parser) callonComparisonOp10() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp10()
}</span>

func (c *current) onComparisonOp12() (any, error) <span class="cov8" title="1">{
        return "&gt;", nil
}</span>

func (p *parser) callonComparisonOp12() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp12()
}</span>

func (c *current) onComparisonOp14() (any, error) <span class="cov0" title="0">{
        return "IN", nil
}</span>

func (p *parser) callonComparisonOp14() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp14()
}</span>

func (c *current) onComparisonOp16() (any, error) <span class="cov0" title="0">{
        return "LIKE", nil
}</span>

func (p *parser) callonComparisonOp16() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp16()
}</span>

func (c *current) onComparisonOp18() (any, error) <span class="cov0" title="0">{
        return "MATCHES", nil
}</span>

func (p *parser) callonComparisonOp18() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp18()
}</span>

func (c *current) onComparisonOp20() (any, error) <span class="cov0" title="0">{
        return "CONTAINS", nil
}</span>

func (p *parser) callonComparisonOp20() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComparisonOp20()
}</span>

func (c *current) onLogicalOp2() (any, error) <span class="cov8" title="1">{
        return "AND", nil
}</span>

func (p *parser) callonLogicalOp2() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onLogicalOp2()
}</span>

func (c *current) onLogicalOp4() (any, error) <span class="cov0" title="0">{
        return "OR", nil
}</span>

func (p *parser) callonLogicalOp4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onLogicalOp4()
}</span>

func (c *current) onBooleanLiteral2() (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "boolean",
                "value": true,
        }, nil

}</span>

func (p *parser) callonBooleanLiteral2() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onBooleanLiteral2()
}</span>

func (c *current) onBooleanLiteral4() (any, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "boolean",
                "value": false,
        }, nil

}</span>

func (p *parser) callonBooleanLiteral4() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onBooleanLiteral4()
}</span>

func (c *current) onNumber1(sign, digits, decimal any) (any, error) <span class="cov8" title="1">{
        val, err := strconv.ParseFloat(string(c.text), 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{
                "type":  "number",
                "value": val,
        }, nil</span>
}

func (p *parser) callonNumber1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onNumber1(stack["sign"], stack["digits"], stack["decimal"])
}</span>

func (c *current) onStringLiteral2(chars any) (any, error) <span class="cov8" title="1">{
        var builder strings.Builder
        if chars != nil </span><span class="cov8" title="1">{
                for _, char := range chars.([]interface{}) </span><span class="cov8" title="1">{
                        builder.WriteString(char.(string))
                }</span>
        }
        <span class="cov8" title="1">return map[string]interface{}{
                "type":  "string",
                "value": builder.String(),
        }, nil</span>

}

func (p *parser) callonStringLiteral2() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onStringLiteral2(stack["chars"])
}</span>

func (c *current) onStringLiteral9(chars any) (any, error) <span class="cov0" title="0">{
        var builder strings.Builder
        if chars != nil </span><span class="cov0" title="0">{
                for _, char := range chars.([]interface{}) </span><span class="cov0" title="0">{
                        builder.WriteString(char.(string))
                }</span>
        }
        <span class="cov0" title="0">return map[string]interface{}{
                "type":  "string",
                "value": builder.String(),
        }, nil</span>

}

func (p *parser) callonStringLiteral9() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onStringLiteral9(stack["chars"])
}</span>

func (c *current) onDoubleStringChar3() (any, error) <span class="cov8" title="1">{
        return string(c.text), nil
}</span>

func (p *parser) callonDoubleStringChar3() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onDoubleStringChar3()
}</span>

func (c *current) onSingleStringChar3() (any, error) <span class="cov0" title="0">{
        return string(c.text), nil
}</span>

func (p *parser) callonSingleStringChar3() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onSingleStringChar3()
}</span>

func (c *current) onEscapeSequence1(char any) (any, error) <span class="cov0" title="0">{
        switch char </span>{
        case "n":<span class="cov0" title="0">
                return "\n", nil</span>
        case "t":<span class="cov0" title="0">
                return "\t", nil</span>
        case "r":<span class="cov0" title="0">
                return "\r", nil</span>
        case "\\":<span class="cov0" title="0">
                return "\\", nil</span>
        case "\"":<span class="cov0" title="0">
                return "\"", nil</span>
        case "'":<span class="cov0" title="0">
                return "'", nil</span>
        default:<span class="cov0" title="0">
                return "\\" + char.(string), nil</span>
        }
}

func (p *parser) callonEscapeSequence1() (any, error) <span class="cov0" title="0">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onEscapeSequence1(stack["char"])
}</span>

func (c *current) onRemoveFact1(typeName, factID any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "retraction",
                "typeName": typeName,
                "factID":   factID,
        }, nil
}</span>

func (p *parser) callonRemoveFact1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onRemoveFact1(stack["typeName"], stack["factID"])
}</span>

func (c *current) onFactID1(chars any) (any, error) <span class="cov8" title="1">{
        return string(c.text), nil
}</span>

func (p *parser) callonFactID1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactID1(stack["chars"])
}</span>

func (c *current) onFact1(typeName, fields any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "type":     "fact",
                "typeName": typeName,
                "fields":   fields,
        }, nil
}</span>

func (p *parser) callonFact1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFact1(stack["typeName"], stack["fields"])
}</span>

func (c *current) onFactFieldList1(first, rest any) (any, error) <span class="cov8" title="1">{
        fields := []interface{}{first}
        if rest != nil </span><span class="cov8" title="1">{
                for _, item := range rest.([]interface{}) </span><span class="cov8" title="1">{
                        fields = append(fields, item.([]interface{})[3])
                }</span>
        }
        <span class="cov8" title="1">return fields, nil</span>
}

func (p *parser) callonFactFieldList1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactFieldList1(stack["first"], stack["rest"])
}</span>

func (c *current) onFactField1(name, value any) (any, error) <span class="cov8" title="1">{
        return map[string]interface{}{
                "name":  name,
                "value": value,
        }, nil
}</span>

func (p *parser) callonFactField1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactField1(stack["name"], stack["value"])
}</span>

func (c *current) onFactValue5() (any, error) <span class="cov8" title="1">{
        // ComplexIdentifier pour les valeurs non-quotées complexes comme des IDs
        return map[string]interface{}{
                "type":  "identifier",
                "value": string(c.text),
        }, nil
}</span>

func (p *parser) callonFactValue5() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onFactValue5()
}</span>

func (c *current) onComplexIdentifier1() (any, error) <span class="cov8" title="1">{
        return string(c.text), nil
}</span>

func (p *parser) callonComplexIdentifier1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onComplexIdentifier1()
}</span>

func (c *current) onIdentName1() (any, error) <span class="cov8" title="1">{
        return string(c.text), nil
}</span>

func (p *parser) callonIdentName1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onIdentName1()
}</span>

func (c *current) onLineComment1(CommentText any) (any, error) <span class="cov8" title="1">{
        return nil, nil // Les commentaires ne retournent rien
}</span>

func (p *parser) callonLineComment1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onLineComment1(stack["CommentText"])
}</span>

func (c *current) onBlockComment1(CommentText any) (any, error) <span class="cov8" title="1">{
        return nil, nil // Les commentaires ne retournent rien
}</span>

func (p *parser) callonBlockComment1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onBlockComment1(stack["CommentText"])
}</span>

func (c *current) onEndOfLineComment1(CommentText any) (any, error) <span class="cov8" title="1">{
        return nil, nil // Support pour commentaires style shell/Python
}</span>

func (p *parser) callonEndOfLineComment1() (any, error) <span class="cov8" title="1">{
        stack := p.vstack[len(p.vstack)-1]
        _ = stack
        return p.cur.onEndOfLineComment1(stack["CommentText"])
}</span>

var (
        // errNoRule is returned when the grammar to parse has no rule.
        errNoRule = errors.New("grammar has no rule")

        // errInvalidEntrypoint is returned when the specified entrypoint rule
        // does not exit.
        errInvalidEntrypoint = errors.New("invalid entrypoint")

        // errInvalidEncoding is returned when the source is not properly
        // utf8-encoded.
        errInvalidEncoding = errors.New("invalid encoding")

        // errMaxExprCnt is used to signal that the maximum number of
        // expressions have been parsed.
        errMaxExprCnt = errors.New("max number of expressions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// MaxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func MaxExpressions(maxExprCnt uint64) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                oldMaxExprCnt := p.maxExprCnt
                p.maxExprCnt = maxExprCnt
                return MaxExpressions(oldMaxExprCnt)
        }</span>
}

// Entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func Entrypoint(ruleName string) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                oldEntrypoint := p.entrypoint
                p.entrypoint = ruleName
                if ruleName == "" </span><span class="cov0" title="0">{
                        p.entrypoint = g.rules[0].name
                }</span>
                <span class="cov0" title="0">return Entrypoint(oldEntrypoint)</span>
        }
}

// Statistics adds a user provided Stats struct to the parser to allow
// the user to process the results after the parsing has finished.
// Also the key for the "no match" counter is set.
//
// Example usage:
//
//        input := "input"
//        stats := Stats{}
//        _, err := Parse("input-file", []byte(input), Statistics(&amp;stats, "no match"))
//        if err != nil {
//            log.Panicln(err)
//        }
//        b, err := json.MarshalIndent(stats.ChoiceAltCnt, "", "  ")
//        if err != nil {
//            log.Panicln(err)
//        }
//        fmt.Println(string(b))
func Statistics(stats *Stats, choiceNoMatch string) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                oldStats := p.Stats
                p.Stats = stats
                oldChoiceNoMatch := p.choiceNoMatch
                p.choiceNoMatch = choiceNoMatch
                if p.Stats.ChoiceAltCnt == nil </span><span class="cov0" title="0">{
                        p.Stats.ChoiceAltCnt = make(map[string]map[string]int)
                }</span>
                <span class="cov0" title="0">return Statistics(oldStats, oldChoiceNoMatch)</span>
        }
}

// Debug creates an Option to set the debug flag to b. When set to true,
// debugging information is printed to stdout while parsing.
//
// The default is false.
func Debug(b bool) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.debug
                p.debug = b
                return Debug(old)
        }</span>
}

// Memoize creates an Option to set the memoize flag to b. When set to true,
// the parser will cache all results so each expression is evaluated only
// once. This guarantees linear parsing time even for pathological cases,
// at the expense of more memory and slower times for typical cases.
//
// The default is false.
func Memoize(b bool) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.memoize
                p.memoize = b
                return Memoize(old)
        }</span>
}

// AllowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func AllowInvalidUTF8(b bool) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.allowInvalidUTF8
                p.allowInvalidUTF8 = b
                return AllowInvalidUTF8(old)
        }</span>
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.recover
                p.recover = b
                return Recover(old)
        }</span>
}

// GlobalStore creates an Option to set a key to a certain value in
// the globalStore.
func GlobalStore(key string, value any) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.cur.globalStore[key]
                p.cur.globalStore[key] = value
                return GlobalStore(key, old)
        }</span>
}

// InitState creates an Option to set a key to a certain value in
// the global "state" store.
func InitState(key string, value any) Option <span class="cov0" title="0">{
        return func(p *parser) Option </span><span class="cov0" title="0">{
                old := p.cur.state[key]
                p.cur.state[key] = value
                return InitState(key, old)
        }</span>
}

// ParseFile parses the file identified by filename.
func ParseFile(filename string, opts ...Option) (i any, err error) <span class="cov8" title="1">{
        f, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := f.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }()
        <span class="cov8" title="1">return ParseReader(filename, f, opts...)</span>
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func ParseReader(filename string, r io.Reader, opts ...Option) (any, error) <span class="cov8" title="1">{
        b, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return Parse(filename, b, opts...)</span>
}

// Parse parses the data from b using filename as information in the
// error messages.
func Parse(filename string, b []byte, opts ...Option) (any, error) <span class="cov8" title="1">{
        return newParser(filename, b, opts...).parse(g)
}</span>

// position records a position in the text.
type position struct {
        line, col, offset int
}

func (p position) String() string <span class="cov0" title="0">{
        return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}</span>

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
        position
        rn rune
        w  int
}

type current struct {
        pos  position // start position of the match
        text []byte   // raw text of the match

        // state is a store for arbitrary key,value pairs that the user wants to be
        // tied to the backtracking of the parser.
        // This is always rolled back if a parsing rule fails.
        state storeDict

        // globalStore is a general store for the user to store arbitrary key-value
        // pairs that they need to manage and that they do not want tied to the
        // backtracking of the parser. This is only modified by the user and never
        // rolled back by the parser. It is always up to the user to keep this in a
        // consistent state.
        globalStore storeDict
}

type storeDict map[string]any

// the AST types...

type grammar struct {
        pos   position
        rules []*rule
}

type rule struct {
        pos         position
        name        string
        displayName string
        expr        any
}

type choiceExpr struct {
        pos          position
        alternatives []any
}

type actionExpr struct {
        pos  position
        expr any
        run  func(*parser) (any, error)
}

type recoveryExpr struct {
        pos          position
        expr         any
        recoverExpr  any
        failureLabel []string
}

type seqExpr struct {
        pos   position
        exprs []any
}

type throwExpr struct {
        pos   position
        label string
}

type labeledExpr struct {
        pos   position
        label string
        expr  any
}

type expr struct {
        pos  position
        expr any
}

type (
        andExpr        expr
        notExpr        expr
        zeroOrOneExpr  expr
        zeroOrMoreExpr expr
        oneOrMoreExpr  expr
)

type ruleRefExpr struct {
        pos  position
        name string
}

type stateCodeExpr struct {
        pos position
        run func(*parser) error
}

type andCodeExpr struct {
        pos position
        run func(*parser) (bool, error)
}

type notCodeExpr struct {
        pos position
        run func(*parser) (bool, error)
}

type litMatcher struct {
        pos        position
        val        string
        ignoreCase bool
        want       string
}

type charClassMatcher struct {
        pos             position
        val             string
        basicLatinChars [128]bool
        chars           []rune
        ranges          []rune
        classes         []*unicode.RangeTable
        ignoreCase      bool
        inverted        bool
}

type anyMatcher position

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) <span class="cov0" title="0">{
        *e = append(*e, err)
}</span>

func (e errList) err() error <span class="cov8" title="1">{
        if len(e) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">e.dedupe()
        return e</span>
}

func (e *errList) dedupe() <span class="cov0" title="0">{
        var cleaned []error
        set := make(map[string]bool)
        for _, err := range *e </span><span class="cov0" title="0">{
                if msg := err.Error(); !set[msg] </span><span class="cov0" title="0">{
                        set[msg] = true
                        cleaned = append(cleaned, err)
                }</span>
        }
        <span class="cov0" title="0">*e = cleaned</span>
}

func (e errList) Error() string <span class="cov0" title="0">{
        switch len(e) </span>{
        case 0:<span class="cov0" title="0">
                return ""</span>
        case 1:<span class="cov0" title="0">
                return e[0].Error()</span>
        default:<span class="cov0" title="0">
                var buf bytes.Buffer

                for i, err := range e </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                buf.WriteRune('\n')
                        }</span>
                        <span class="cov0" title="0">buf.WriteString(err.Error())</span>
                }
                <span class="cov0" title="0">return buf.String()</span>
        }
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
        Inner    error
        pos      position
        prefix   string
        expected []string
}

// Error returns the error message.
func (p *parserError) Error() string <span class="cov0" title="0">{
        return p.prefix + ": " + p.Inner.Error()
}</span>

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser <span class="cov8" title="1">{
        stats := Stats{
                ChoiceAltCnt: make(map[string]map[string]int),
        }

        p := &amp;parser{
                filename: filename,
                errs:     new(errList),
                data:     b,
                pt:       savepoint{position: position{line: 1}},
                recover:  true,
                cur: current{
                        state:       make(storeDict),
                        globalStore: make(storeDict),
                },
                maxFailPos:      position{col: 1, line: 1},
                maxFailExpected: make([]string, 0, 20),
                Stats:           &amp;stats,
                // start rule is rule [0] unless an alternate entrypoint is specified
                entrypoint: g.rules[0].name,
        }
        p.setOptions(opts)

        if p.maxExprCnt == 0 </span><span class="cov8" title="1">{
                p.maxExprCnt = math.MaxUint64
        }</span>

        <span class="cov8" title="1">return p</span>
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) <span class="cov8" title="1">{
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(p)
        }</span>
}

type resultTuple struct {
        v   any
        b   bool
        end savepoint
}

const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
        // ExprCnt counts the number of expressions processed during parsing
        // This value is compared to the maximum number of expressions allowed
        // (set by the MaxExpressions option).
        ExprCnt uint64

        // ChoiceAltCnt is used to count for each ordered choice expression,
        // which alternative is used how may times.
        // These numbers allow to optimize the order of the ordered choice expression
        // to increase the performance of the parser
        //
        // The outer key of ChoiceAltCnt is composed of the name of the rule as well
        // as the line and the column of the ordered choice.
        // The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
        // For each alternative the number of matches are counted. If an ordered choice does not
        // match, a special counter is incremented. The name of this counter is set with
        // the parser option Statistics.
        // For an alternative to be included in ChoiceAltCnt, it has to match at least once.
        ChoiceAltCnt map[string]map[string]int
}

type parser struct {
        filename string
        pt       savepoint
        cur      current

        data []byte
        errs *errList

        depth   int
        recover bool
        debug   bool

        memoize bool
        // memoization table for the packrat algorithm:
        // map[offset in source] map[expression or rule] {value, match}
        memo map[int]map[any]resultTuple

        // rules table, maps the rule identifier to the rule node
        rules map[string]*rule
        // variables stack, map of label to value
        vstack []map[string]any
        // rule stack, allows identification of the current rule in errors
        rstack []*rule

        // parse fail
        maxFailPos            position
        maxFailExpected       []string
        maxFailInvertExpected bool

        // max number of expressions to be parsed
        maxExprCnt uint64
        // entrypoint for the parser
        entrypoint string

        allowInvalidUTF8 bool

        *Stats

        choiceNoMatch string
        // recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
        recoveryStack []map[string]any
}

// push a variable set on the vstack.
func (p *parser) pushV() <span class="cov8" title="1">{
        if cap(p.vstack) == len(p.vstack) </span><span class="cov8" title="1">{
                // create new empty slot in the stack
                p.vstack = append(p.vstack, nil)
        }</span> else<span class="cov8" title="1"> {
                // slice to 1 more
                p.vstack = p.vstack[:len(p.vstack)+1]
        }</span>

        // get the last args set
        <span class="cov8" title="1">m := p.vstack[len(p.vstack)-1]
        if m != nil &amp;&amp; len(m) == 0 </span><span class="cov8" title="1">{
                // empty map, all good
                return
        }</span>

        <span class="cov8" title="1">m = make(map[string]any)
        p.vstack[len(p.vstack)-1] = m</span>
}

// pop a variable set from the vstack.
func (p *parser) popV() <span class="cov8" title="1">{
        // if the map is not empty, clear it
        m := p.vstack[len(p.vstack)-1]
        if len(m) &gt; 0 </span><span class="cov8" title="1">{
                // GC that map
                p.vstack[len(p.vstack)-1] = nil
        }</span>
        <span class="cov8" title="1">p.vstack = p.vstack[:len(p.vstack)-1]</span>
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr any) <span class="cov0" title="0">{
        if cap(p.recoveryStack) == len(p.recoveryStack) </span><span class="cov0" title="0">{
                // create new empty slot in the stack
                p.recoveryStack = append(p.recoveryStack, nil)
        }</span> else<span class="cov0" title="0"> {
                // slice to 1 more
                p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
        }</span>

        <span class="cov0" title="0">m := make(map[string]any, len(labels))
        for _, fl := range labels </span><span class="cov0" title="0">{
                m[fl] = expr
        }</span>
        <span class="cov0" title="0">p.recoveryStack[len(p.recoveryStack)-1] = m</span>
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() <span class="cov0" title="0">{
        // GC that map
        p.recoveryStack[len(p.recoveryStack)-1] = nil

        p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}</span>

func (p *parser) print(prefix, s string) string <span class="cov0" title="0">{
        if !p.debug </span><span class="cov0" title="0">{
                return s
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s %d:%d:%d: %s [%#U]\n",
                prefix, p.pt.line, p.pt.col, p.pt.offset, s, p.pt.rn)
        return s</span>
}

func (p *parser) printIndent(mark string, s string) string <span class="cov0" title="0">{
        return p.print(strings.Repeat(" ", p.depth)+mark, s)
}</span>

func (p *parser) in(s string) string <span class="cov0" title="0">{
        res := p.printIndent("&gt;", s)
        p.depth++
        return res
}</span>

func (p *parser) out(s string) string <span class="cov0" title="0">{
        p.depth--
        return p.printIndent("&lt;", s)
}</span>

func (p *parser) addErr(err error) <span class="cov0" title="0">{
        p.addErrAt(err, p.pt.position, []string{})
}</span>

func (p *parser) addErrAt(err error, pos position, expected []string) <span class="cov0" title="0">{
        var buf bytes.Buffer
        if p.filename != "" </span><span class="cov0" title="0">{
                buf.WriteString(p.filename)
        }</span>
        <span class="cov0" title="0">if buf.Len() &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(":")
        }</span>
        <span class="cov0" title="0">buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
        if len(p.rstack) &gt; 0 </span><span class="cov0" title="0">{
                if buf.Len() &gt; 0 </span><span class="cov0" title="0">{
                        buf.WriteString(": ")
                }</span>
                <span class="cov0" title="0">rule := p.rstack[len(p.rstack)-1]
                if rule.displayName != "" </span><span class="cov0" title="0">{
                        buf.WriteString("rule " + rule.displayName)
                }</span> else<span class="cov0" title="0"> {
                        buf.WriteString("rule " + rule.name)
                }</span>
        }
        <span class="cov0" title="0">pe := &amp;parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
        p.errs.add(pe)</span>
}

func (p *parser) failAt(fail bool, pos position, want string) <span class="cov8" title="1">{
        // process fail if parsing fails and not inverted or parsing succeeds and invert is set
        if fail == p.maxFailInvertExpected </span><span class="cov8" title="1">{
                if pos.offset &lt; p.maxFailPos.offset </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">if pos.offset &gt; p.maxFailPos.offset </span><span class="cov8" title="1">{
                        p.maxFailPos = pos
                        p.maxFailExpected = p.maxFailExpected[:0]
                }</span>

                <span class="cov8" title="1">if p.maxFailInvertExpected </span><span class="cov8" title="1">{
                        want = "!" + want
                }</span>
                <span class="cov8" title="1">p.maxFailExpected = append(p.maxFailExpected, want)</span>
        }
}

// read advances the parser to the next rune.
func (p *parser) read() <span class="cov8" title="1">{
        p.pt.offset += p.pt.w
        rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
        p.pt.rn = rn
        p.pt.w = n
        p.pt.col++
        if rn == '\n' </span><span class="cov8" title="1">{
                p.pt.line++
                p.pt.col = 0
        }</span>

        <span class="cov8" title="1">if rn == utf8.RuneError &amp;&amp; n == 1 </span><span class="cov0" title="0">{ // see utf8.DecodeRune
                if !p.allowInvalidUTF8 </span><span class="cov0" title="0">{
                        p.addErr(errInvalidEncoding)
                }</span>
        }
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("restore"))
        }</span>
        <span class="cov8" title="1">if pt.offset == p.pt.offset </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">p.pt = pt</span>
}

// Cloner is implemented by any value that has a Clone method, which returns a
// copy of the value. This is mainly used for types which are not passed by
// value (e.g map, slice, chan) or structs that contain such types.
//
// This is used in conjunction with the global state feature to create proper
// copies of the state to allow the parser to properly restore the state in
// the case of backtracking.
type Cloner interface {
        Clone() any
}

var statePool = &amp;sync.Pool{
        New: func() any <span class="cov8" title="1">{ return make(storeDict) }</span>,
}

func (sd storeDict) Discard() <span class="cov8" title="1">{
        for k := range sd </span><span class="cov0" title="0">{
                delete(sd, k)
        }</span>
        <span class="cov8" title="1">statePool.Put(sd)</span>
}

// clone and return parser current state.
func (p *parser) cloneState() storeDict <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("cloneState"))
        }</span>

        <span class="cov8" title="1">state := statePool.Get().(storeDict)
        for k, v := range p.cur.state </span><span class="cov0" title="0">{
                if c, ok := v.(Cloner); ok </span><span class="cov0" title="0">{
                        state[k] = c.Clone()
                }</span> else<span class="cov0" title="0"> {
                        state[k] = v
                }</span>
        }
        <span class="cov8" title="1">return state</span>
}

// restore parser current state to the state storeDict.
// every restoreState should applied only one time for every cloned state
func (p *parser) restoreState(state storeDict) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("restoreState"))
        }</span>
        <span class="cov8" title="1">p.cur.state.Discard()
        p.cur.state = state</span>
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte <span class="cov8" title="1">{
        return p.data[start.position.offset:p.pt.position.offset]
}</span>

func (p *parser) getMemoized(node any) (resultTuple, bool) <span class="cov0" title="0">{
        if len(p.memo) == 0 </span><span class="cov0" title="0">{
                return resultTuple{}, false
        }</span>
        <span class="cov0" title="0">m := p.memo[p.pt.offset]
        if len(m) == 0 </span><span class="cov0" title="0">{
                return resultTuple{}, false
        }</span>
        <span class="cov0" title="0">res, ok := m[node]
        return res, ok</span>
}

func (p *parser) setMemoized(pt savepoint, node any, tuple resultTuple) <span class="cov0" title="0">{
        if p.memo == nil </span><span class="cov0" title="0">{
                p.memo = make(map[int]map[any]resultTuple)
        }</span>
        <span class="cov0" title="0">m := p.memo[pt.offset]
        if m == nil </span><span class="cov0" title="0">{
                m = make(map[any]resultTuple)
                p.memo[pt.offset] = m
        }</span>
        <span class="cov0" title="0">m[node] = tuple</span>
}

func (p *parser) buildRulesTable(g *grammar) <span class="cov8" title="1">{
        p.rules = make(map[string]*rule, len(g.rules))
        for _, r := range g.rules </span><span class="cov8" title="1">{
                p.rules[r.name] = r
        }</span>
}

func (p *parser) parse(g *grammar) (val any, err error) <span class="cov8" title="1">{
        if len(g.rules) == 0 </span><span class="cov0" title="0">{
                p.addErr(errNoRule)
                return nil, p.errs.err()
        }</span>

        // TODO : not super critical but this could be generated
        <span class="cov8" title="1">p.buildRulesTable(g)

        if p.recover </span><span class="cov8" title="1">{
                // panic can be used in action code to stop parsing immediately
                // and return the panic as an error.
                defer func() </span><span class="cov8" title="1">{
                        if e := recover(); e != nil </span><span class="cov0" title="0">{
                                if p.debug </span><span class="cov0" title="0">{
                                        defer p.out(p.in("panic handler"))
                                }</span>
                                <span class="cov0" title="0">val = nil
                                switch e := e.(type) </span>{
                                case error:<span class="cov0" title="0">
                                        p.addErr(e)</span>
                                default:<span class="cov0" title="0">
                                        p.addErr(fmt.Errorf("%v", e))</span>
                                }
                                <span class="cov0" title="0">err = p.errs.err()</span>
                        }
                }()
        }

        <span class="cov8" title="1">startRule, ok := p.rules[p.entrypoint]
        if !ok </span><span class="cov0" title="0">{
                p.addErr(errInvalidEntrypoint)
                return nil, p.errs.err()
        }</span>

        <span class="cov8" title="1">p.read() // advance to first rune
        val, ok = p.parseRuleWrap(startRule)
        if !ok </span><span class="cov0" title="0">{
                if len(*p.errs) == 0 </span><span class="cov0" title="0">{
                        // If parsing fails, but no errors have been recorded, the expected values
                        // for the farthest parser position are returned as error.
                        maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
                        for _, v := range p.maxFailExpected </span><span class="cov0" title="0">{
                                maxFailExpectedMap[v] = struct{}{}
                        }</span>
                        <span class="cov0" title="0">expected := make([]string, 0, len(maxFailExpectedMap))
                        eof := false
                        if _, ok := maxFailExpectedMap["!."]; ok </span><span class="cov0" title="0">{
                                delete(maxFailExpectedMap, "!.")
                                eof = true
                        }</span>
                        <span class="cov0" title="0">for k := range maxFailExpectedMap </span><span class="cov0" title="0">{
                                expected = append(expected, k)
                        }</span>
                        <span class="cov0" title="0">sort.Strings(expected)
                        if eof </span><span class="cov0" title="0">{
                                expected = append(expected, "EOF")
                        }</span>
                        <span class="cov0" title="0">p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)</span>
                }

                <span class="cov0" title="0">return nil, p.errs.err()</span>
        }
        <span class="cov8" title="1">return val, p.errs.err()</span>
}

func listJoin(list []string, sep string, lastSep string) string <span class="cov0" title="0">{
        switch len(list) </span>{
        case 0:<span class="cov0" title="0">
                return ""</span>
        case 1:<span class="cov0" title="0">
                return list[0]</span>
        default:<span class="cov0" title="0">
                return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]</span>
        }
}

func (p *parser) parseRuleMemoize(rule *rule) (any, bool) <span class="cov0" title="0">{
        res, ok := p.getMemoized(rule)
        if ok </span><span class="cov0" title="0">{
                p.restore(res.end)
                return res.v, res.b
        }</span>

        <span class="cov0" title="0">startMark := p.pt
        val, ok := p.parseRule(rule)
        p.setMemoized(startMark, rule, resultTuple{val, ok, p.pt})

        return val, ok</span>
}

func (p *parser) parseRuleWrap(rule *rule) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseRule " + rule.name))
        }</span>
        <span class="cov8" title="1">var (
                val       any
                ok        bool
                startMark = p.pt
        )

        if p.memoize </span><span class="cov0" title="0">{
                val, ok = p.parseRuleMemoize(rule)
        }</span> else<span class="cov8" title="1"> {
                val, ok = p.parseRule(rule)
        }</span>

        <span class="cov8" title="1">if ok &amp;&amp; p.debug </span><span class="cov0" title="0">{
                p.printIndent("MATCH", string(p.sliceFrom(startMark)))
        }</span>
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseRule(rule *rule) (any, bool) <span class="cov8" title="1">{
        p.rstack = append(p.rstack, rule)
        p.pushV()
        val, ok := p.parseExprWrap(rule.expr)
        p.popV()
        p.rstack = p.rstack[:len(p.rstack)-1]
        return val, ok
}</span>

func (p *parser) parseExprWrap(expr any) (any, bool) <span class="cov8" title="1">{
        var pt savepoint

        if p.memoize </span><span class="cov0" title="0">{
                res, ok := p.getMemoized(expr)
                if ok </span><span class="cov0" title="0">{
                        p.restore(res.end)
                        return res.v, res.b
                }</span>
                <span class="cov0" title="0">pt = p.pt</span>
        }

        <span class="cov8" title="1">val, ok := p.parseExpr(expr)

        if p.memoize </span><span class="cov0" title="0">{
                p.setMemoized(pt, expr, resultTuple{val, ok, p.pt})
        }</span>
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseExpr(expr any) (any, bool) <span class="cov8" title="1">{
        p.ExprCnt++
        if p.ExprCnt &gt; p.maxExprCnt </span><span class="cov0" title="0">{
                panic(errMaxExprCnt)</span>
        }

        <span class="cov8" title="1">var val any
        var ok bool
        switch expr := expr.(type) </span>{
        case *actionExpr:<span class="cov8" title="1">
                val, ok = p.parseActionExpr(expr)</span>
        case *andCodeExpr:<span class="cov0" title="0">
                val, ok = p.parseAndCodeExpr(expr)</span>
        case *andExpr:<span class="cov0" title="0">
                val, ok = p.parseAndExpr(expr)</span>
        case *anyMatcher:<span class="cov8" title="1">
                val, ok = p.parseAnyMatcher(expr)</span>
        case *charClassMatcher:<span class="cov8" title="1">
                val, ok = p.parseCharClassMatcher(expr)</span>
        case *choiceExpr:<span class="cov8" title="1">
                val, ok = p.parseChoiceExpr(expr)</span>
        case *labeledExpr:<span class="cov8" title="1">
                val, ok = p.parseLabeledExpr(expr)</span>
        case *litMatcher:<span class="cov8" title="1">
                val, ok = p.parseLitMatcher(expr)</span>
        case *notCodeExpr:<span class="cov0" title="0">
                val, ok = p.parseNotCodeExpr(expr)</span>
        case *notExpr:<span class="cov8" title="1">
                val, ok = p.parseNotExpr(expr)</span>
        case *oneOrMoreExpr:<span class="cov8" title="1">
                val, ok = p.parseOneOrMoreExpr(expr)</span>
        case *recoveryExpr:<span class="cov0" title="0">
                val, ok = p.parseRecoveryExpr(expr)</span>
        case *ruleRefExpr:<span class="cov8" title="1">
                val, ok = p.parseRuleRefExpr(expr)</span>
        case *seqExpr:<span class="cov8" title="1">
                val, ok = p.parseSeqExpr(expr)</span>
        case *stateCodeExpr:<span class="cov0" title="0">
                val, ok = p.parseStateCodeExpr(expr)</span>
        case *throwExpr:<span class="cov0" title="0">
                val, ok = p.parseThrowExpr(expr)</span>
        case *zeroOrMoreExpr:<span class="cov8" title="1">
                val, ok = p.parseZeroOrMoreExpr(expr)</span>
        case *zeroOrOneExpr:<span class="cov8" title="1">
                val, ok = p.parseZeroOrOneExpr(expr)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unknown expression type %T", expr))</span>
        }
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseActionExpr(act *actionExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseActionExpr"))
        }</span>

        <span class="cov8" title="1">start := p.pt
        val, ok := p.parseExprWrap(act.expr)
        if ok </span><span class="cov8" title="1">{
                p.cur.pos = start.position
                p.cur.text = p.sliceFrom(start)
                state := p.cloneState()
                actVal, err := act.run(p)
                if err != nil </span><span class="cov0" title="0">{
                        p.addErrAt(err, start.position, []string{})
                }</span>
                <span class="cov8" title="1">p.restoreState(state)

                val = actVal</span>
        }
        <span class="cov8" title="1">if ok &amp;&amp; p.debug </span><span class="cov0" title="0">{
                p.printIndent("MATCH", string(p.sliceFrom(start)))
        }</span>
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseAndCodeExpr"))
        }</span>

        <span class="cov0" title="0">state := p.cloneState()

        ok, err := and.run(p)
        if err != nil </span><span class="cov0" title="0">{
                p.addErr(err)
        }</span>
        <span class="cov0" title="0">p.restoreState(state)

        return nil, ok</span>
}

func (p *parser) parseAndExpr(and *andExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseAndExpr"))
        }</span>

        <span class="cov0" title="0">pt := p.pt
        state := p.cloneState()
        p.pushV()
        _, ok := p.parseExprWrap(and.expr)
        p.popV()
        p.restoreState(state)
        p.restore(pt)

        return nil, ok</span>
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseAnyMatcher"))
        }</span>

        <span class="cov8" title="1">if p.pt.rn == utf8.RuneError &amp;&amp; p.pt.w == 0 </span><span class="cov8" title="1">{
                // EOF - see utf8.DecodeRune
                p.failAt(false, p.pt.position, ".")
                return nil, false
        }</span>
        <span class="cov8" title="1">start := p.pt
        p.read()
        p.failAt(true, start.position, ".")
        return p.sliceFrom(start), true</span>
}

func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseCharClassMatcher"))
        }</span>

        <span class="cov8" title="1">cur := p.pt.rn
        start := p.pt

        // can't match EOF
        if cur == utf8.RuneError &amp;&amp; p.pt.w == 0 </span><span class="cov8" title="1">{ // see utf8.DecodeRune
                p.failAt(false, start.position, chr.val)
                return nil, false
        }</span>

        <span class="cov8" title="1">if chr.ignoreCase </span><span class="cov0" title="0">{
                cur = unicode.ToLower(cur)
        }</span>

        // try to match in the list of available chars
        <span class="cov8" title="1">for _, rn := range chr.chars </span><span class="cov8" title="1">{
                if rn == cur </span><span class="cov8" title="1">{
                        if chr.inverted </span><span class="cov0" title="0">{
                                p.failAt(false, start.position, chr.val)
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">p.read()
                        p.failAt(true, start.position, chr.val)
                        return p.sliceFrom(start), true</span>
                }
        }

        // try to match in the list of ranges
        <span class="cov8" title="1">for i := 0; i &lt; len(chr.ranges); i += 2 </span><span class="cov8" title="1">{
                if cur &gt;= chr.ranges[i] &amp;&amp; cur &lt;= chr.ranges[i+1] </span><span class="cov8" title="1">{
                        if chr.inverted </span><span class="cov0" title="0">{
                                p.failAt(false, start.position, chr.val)
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">p.read()
                        p.failAt(true, start.position, chr.val)
                        return p.sliceFrom(start), true</span>
                }
        }

        // try to match in the list of Unicode classes
        <span class="cov8" title="1">for _, cl := range chr.classes </span><span class="cov0" title="0">{
                if unicode.Is(cl, cur) </span><span class="cov0" title="0">{
                        if chr.inverted </span><span class="cov0" title="0">{
                                p.failAt(false, start.position, chr.val)
                                return nil, false
                        }</span>
                        <span class="cov0" title="0">p.read()
                        p.failAt(true, start.position, chr.val)
                        return p.sliceFrom(start), true</span>
                }
        }

        <span class="cov8" title="1">if chr.inverted </span><span class="cov0" title="0">{
                p.read()
                p.failAt(true, start.position, chr.val)
                return p.sliceFrom(start), true
        }</span>
        <span class="cov8" title="1">p.failAt(false, start.position, chr.val)
        return nil, false</span>
}

func (p *parser) incChoiceAltCnt(ch *choiceExpr, altI int) <span class="cov8" title="1">{
        choiceIdent := fmt.Sprintf("%s %d:%d", p.rstack[len(p.rstack)-1].name, ch.pos.line, ch.pos.col)
        m := p.ChoiceAltCnt[choiceIdent]
        if m == nil </span><span class="cov8" title="1">{
                m = make(map[string]int)
                p.ChoiceAltCnt[choiceIdent] = m
        }</span>
        // We increment altI by 1, so the keys do not start at 0
        <span class="cov8" title="1">alt := strconv.Itoa(altI + 1)
        if altI == choiceNoMatch </span><span class="cov8" title="1">{
                alt = p.choiceNoMatch
        }</span>
        <span class="cov8" title="1">m[alt]++</span>
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseChoiceExpr"))
        }</span>

        <span class="cov8" title="1">for altI, alt := range ch.alternatives </span><span class="cov8" title="1">{
                // dummy assignment to prevent compile error if optimized
                _ = altI

                state := p.cloneState()

                p.pushV()
                val, ok := p.parseExprWrap(alt)
                p.popV()
                if ok </span><span class="cov8" title="1">{
                        p.incChoiceAltCnt(ch, altI)
                        return val, ok
                }</span>
                <span class="cov8" title="1">p.restoreState(state)</span>
        }
        <span class="cov8" title="1">p.incChoiceAltCnt(ch, choiceNoMatch)
        return nil, false</span>
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseLabeledExpr"))
        }</span>

        <span class="cov8" title="1">p.pushV()
        val, ok := p.parseExprWrap(lab.expr)
        p.popV()
        if ok &amp;&amp; lab.label != "" </span><span class="cov8" title="1">{
                m := p.vstack[len(p.vstack)-1]
                m[lab.label] = val
        }</span>
        <span class="cov8" title="1">return val, ok</span>
}

func (p *parser) parseLitMatcher(lit *litMatcher) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseLitMatcher"))
        }</span>

        <span class="cov8" title="1">start := p.pt
        for _, want := range lit.val </span><span class="cov8" title="1">{
                cur := p.pt.rn
                if lit.ignoreCase </span><span class="cov0" title="0">{
                        cur = unicode.ToLower(cur)
                }</span>
                <span class="cov8" title="1">if cur != want </span><span class="cov8" title="1">{
                        p.failAt(false, start.position, lit.want)
                        p.restore(start)
                        return nil, false
                }</span>
                <span class="cov8" title="1">p.read()</span>
        }
        <span class="cov8" title="1">p.failAt(true, start.position, lit.want)
        return p.sliceFrom(start), true</span>
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseNotCodeExpr"))
        }</span>

        <span class="cov0" title="0">state := p.cloneState()

        ok, err := not.run(p)
        if err != nil </span><span class="cov0" title="0">{
                p.addErr(err)
        }</span>
        <span class="cov0" title="0">p.restoreState(state)

        return nil, !ok</span>
}

func (p *parser) parseNotExpr(not *notExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseNotExpr"))
        }</span>

        <span class="cov8" title="1">pt := p.pt
        state := p.cloneState()
        p.pushV()
        p.maxFailInvertExpected = !p.maxFailInvertExpected
        _, ok := p.parseExprWrap(not.expr)
        p.maxFailInvertExpected = !p.maxFailInvertExpected
        p.popV()
        p.restoreState(state)
        p.restore(pt)

        return nil, !ok</span>
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseOneOrMoreExpr"))
        }</span>

        <span class="cov8" title="1">var vals []any

        for </span><span class="cov8" title="1">{
                p.pushV()
                val, ok := p.parseExprWrap(expr.expr)
                p.popV()
                if !ok </span><span class="cov8" title="1">{
                        if len(vals) == 0 </span><span class="cov8" title="1">{
                                // did not match once, no match
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">return vals, true</span>
                }
                <span class="cov8" title="1">vals = append(vals, val)</span>
        }
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseRecoveryExpr (" + strings.Join(recover.failureLabel, ",") + ")"))
        }</span>

        <span class="cov0" title="0">p.pushRecovery(recover.failureLabel, recover.recoverExpr)
        val, ok := p.parseExprWrap(recover.expr)
        p.popRecovery()

        return val, ok</span>
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseRuleRefExpr " + ref.name))
        }</span>

        <span class="cov8" title="1">if ref.name == "" </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%s: invalid rule: missing name", ref.pos))</span>
        }

        <span class="cov8" title="1">rule := p.rules[ref.name]
        if rule == nil </span><span class="cov0" title="0">{
                p.addErr(fmt.Errorf("undefined rule: %s", ref.name))
                return nil, false
        }</span>
        <span class="cov8" title="1">return p.parseRuleWrap(rule)</span>
}

func (p *parser) parseSeqExpr(seq *seqExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseSeqExpr"))
        }</span>

        <span class="cov8" title="1">vals := make([]any, 0, len(seq.exprs))

        pt := p.pt
        state := p.cloneState()
        for _, expr := range seq.exprs </span><span class="cov8" title="1">{
                val, ok := p.parseExprWrap(expr)
                if !ok </span><span class="cov8" title="1">{
                        p.restoreState(state)
                        p.restore(pt)
                        return nil, false
                }</span>
                <span class="cov8" title="1">vals = append(vals, val)</span>
        }
        <span class="cov8" title="1">return vals, true</span>
}

func (p *parser) parseStateCodeExpr(state *stateCodeExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseStateCodeExpr"))
        }</span>

        <span class="cov0" title="0">err := state.run(p)
        if err != nil </span><span class="cov0" title="0">{
                p.addErr(err)
        }</span>
        <span class="cov0" title="0">return nil, true</span>
}

func (p *parser) parseThrowExpr(expr *throwExpr) (any, bool) <span class="cov0" title="0">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseThrowExpr"))
        }</span>

        <span class="cov0" title="0">for i := len(p.recoveryStack) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok </span><span class="cov0" title="0">{
                        if val, ok := p.parseExprWrap(recoverExpr); ok </span><span class="cov0" title="0">{
                                return val, ok
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, false</span>
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseZeroOrMoreExpr"))
        }</span>

        <span class="cov8" title="1">var vals []any

        for </span><span class="cov8" title="1">{
                p.pushV()
                val, ok := p.parseExprWrap(expr.expr)
                p.popV()
                if !ok </span><span class="cov8" title="1">{
                        return vals, true
                }</span>
                <span class="cov8" title="1">vals = append(vals, val)</span>
        }
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (any, bool) <span class="cov8" title="1">{
        if p.debug </span><span class="cov0" title="0">{
                defer p.out(p.in("parseZeroOrOneExpr"))
        }</span>

        <span class="cov8" title="1">p.pushV()
        val, _ := p.parseExprWrap(expr.expr)
        p.popV()
        // whether it matched or not, consider it a match
        return val, true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package constraint

import (
        "fmt"
)

// ProgramState maintains the cumulative state of parsed types, rules, and facts
// across multiple file parsing operations
type ProgramState struct {
        Types       map[string]*TypeDefinition `json:"types"`
        Rules       []*Expression              `json:"rules"`
        Facts       []*Fact                    `json:"facts"`
        FilesParsed []string                   `json:"files_parsed"`
        Errors      []ValidationError          `json:"errors"`
}

// NewProgramState creates a new empty program state
func NewProgramState() *ProgramState <span class="cov8" title="1">{
        return &amp;ProgramState{
                Types:       make(map[string]*TypeDefinition),
                Rules:       make([]*Expression, 0),
                Facts:       make([]*Fact, 0),
                FilesParsed: make([]string, 0),
                Errors:      make([]ValidationError, 0),
        }
}</span>

// ParseAndMerge parses a file and merges the results into the program state
// It validates that new rules and facts are compatible with existing type definitions
func (ps *ProgramState) ParseAndMerge(filename string) error <span class="cov8" title="1">{
        // Parse the file
        result, err := ParseConstraintFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing file %s: %w", filename, err)
        }</span>

        // Convert to program structure
        <span class="cov8" title="1">program, err := ConvertResultToProgram(result)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error converting result for %s: %w", filename, err)
        }</span>

        // Merge types (new types or validate existing ones)
        <span class="cov8" title="1">err = ps.mergeTypes(program.Types, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging types from %s: %w", filename, err)
        }</span>

        // Merge and validate rules
        <span class="cov8" title="1">err = ps.mergeRules(program.Expressions, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging rules from %s: %w", filename, err)
        }</span>

        // Merge and validate facts
        <span class="cov8" title="1">err = ps.mergeFacts(program.Facts, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging facts from %s: %w", filename, err)
        }</span>

        // Record the parsed file
        <span class="cov8" title="1">ps.FilesParsed = append(ps.FilesParsed, filename)

        return nil</span>
}

// ParseAndMergeContent parses content from a string and merges the results into the program state
// It validates that new rules and facts are compatible with existing type definitions
func (ps *ProgramState) ParseAndMergeContent(content, filename string) error <span class="cov8" title="1">{
        if ps == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ProgramState is nil")
        }</span>
        <span class="cov8" title="1">if filename == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("filename cannot be empty")
        }</span>
        <span class="cov8" title="1">if content == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("content cannot be empty")
        }</span>

        // Parse the content
        <span class="cov8" title="1">result, err := ParseConstraint(filename, []byte(content))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing content %s: %w", filename, err)
        }</span>

        // Convert to program structure
        <span class="cov8" title="1">program, err := ConvertResultToProgram(result)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error converting result for %s: %w", filename, err)
        }</span>

        // Merge types (new types or validate existing ones)
        <span class="cov8" title="1">err = ps.mergeTypes(program.Types, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging types from %s: %w", filename, err)
        }</span>

        // Merge and validate rules
        <span class="cov8" title="1">err = ps.mergeRules(program.Expressions, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging rules from %s: %w", filename, err)
        }</span>

        // Merge and validate facts
        <span class="cov8" title="1">err = ps.mergeFacts(program.Facts, filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error merging facts from %s: %w", filename, err)
        }</span>

        // Record the parsed file
        <span class="cov8" title="1">ps.FilesParsed = append(ps.FilesParsed, filename)

        return nil</span>
}

// mergeTypes merges new type definitions into the program state
func (ps *ProgramState) mergeTypes(newTypes []TypeDefinition, filename string) error <span class="cov8" title="1">{
        if ps == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ProgramState is nil")
        }</span>
        <span class="cov8" title="1">if ps.Types == nil </span><span class="cov0" title="0">{
                ps.Types = make(map[string]*TypeDefinition)
        }</span>

        <span class="cov8" title="1">for _, typeDef := range newTypes </span><span class="cov8" title="1">{
                // Create a copy with filename information
                newType := &amp;TypeDefinition{
                        Type:   typeDef.Type,
                        Name:   typeDef.Name,
                        Fields: typeDef.Fields,
                }

                // Check if type already exists
                if existingType, exists := ps.Types[typeDef.Name]; exists </span><span class="cov8" title="1">{
                        // Validate compatibility
                        if !ps.areTypesCompatible(existingType, newType) </span><span class="cov8" title="1">{
                                return fmt.Errorf("type %s redefined incompatibly in %s",
                                        typeDef.Name, filename)
                        }</span>
                        // Use the more detailed definition
                        <span class="cov8" title="1">if len(newType.Fields) &gt; len(existingType.Fields) </span><span class="cov8" title="1">{
                                ps.Types[typeDef.Name] = newType
                        }</span>
                } else<span class="cov8" title="1"> {
                        ps.Types[typeDef.Name] = newType
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// mergeRules merges new rules and validates them against existing types
func (ps *ProgramState) mergeRules(newRules []Expression, filename string) error <span class="cov8" title="1">{
        if ps == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ProgramState is nil")
        }</span>

        <span class="cov8" title="1">for _, rule := range newRules </span><span class="cov8" title="1">{
                // Create a copy of the rule
                newRule := &amp;Expression{
                        Type:        rule.Type,
                        Set:         rule.Set,
                        Constraints: rule.Constraints,
                        Action:      rule.Action,
                }

                // Validate rule against existing types
                err := ps.validateRule(newRule, filename)
                if err != nil </span><span class="cov8" title="1">{
                        // Non-blocking error: record and continue
                        ps.Errors = append(ps.Errors, ValidationError{
                                File:    filename,
                                Type:    "rule",
                                Message: err.Error(),
                                Line:    0,
                        })
                        fmt.Printf("⚠️  Skipping invalid rule in %s: %v\n", filename, err)
                        continue</span>
                }

                <span class="cov8" title="1">ps.Rules = append(ps.Rules, newRule)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// mergeFacts merges new facts and validates them against existing types
func (ps *ProgramState) mergeFacts(newFacts []Fact, filename string) error <span class="cov8" title="1">{
        if ps == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ProgramState is nil")
        }</span>

        <span class="cov8" title="1">for _, fact := range newFacts </span><span class="cov8" title="1">{
                // Create a copy of the fact
                newFact := &amp;Fact{
                        Type:     fact.Type,
                        TypeName: fact.TypeName,
                        Fields:   fact.Fields,
                }

                // Validate fact against existing types
                err := ps.validateFact(newFact, filename)
                if err != nil </span><span class="cov8" title="1">{
                        // Non-blocking error: record and continue
                        ps.Errors = append(ps.Errors, ValidationError{
                                File:    filename,
                                Type:    "fact",
                                Message: err.Error(),
                                Line:    0,
                        })
                        fmt.Printf("⚠️  Skipping invalid fact in %s: %v\n", filename, err)
                        continue</span>
                }

                <span class="cov8" title="1">ps.Facts = append(ps.Facts, newFact)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateRule validates a rule against existing type definitions
func (ps *ProgramState) validateRule(rule *Expression, filename string) error <span class="cov8" title="1">{
        // Extract variables from the set
        variables := make(map[string]string)
        for _, variable := range rule.Set.Variables </span><span class="cov8" title="1">{
                variables[variable.Name] = variable.DataType
        }</span>

        // Validate each variable type exists
        <span class="cov8" title="1">for varName, varType := range variables </span><span class="cov8" title="1">{
                if _, exists := ps.Types[varType]; !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("variable %s references undefined type %s in %s", varName, varType, filename)
                }</span>
        }

        // Validate field accesses in constraints and action
        <span class="cov8" title="1">err := ps.validateFieldAccesses(rule.Constraints, variables)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("constraint validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">if rule.Action != nil </span><span class="cov8" title="1">{
                err = ps.validateFieldAccesses(rule.Action, variables)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("action validation failed: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateFact validates a fact against existing type definitions
func (ps *ProgramState) validateFact(fact *Fact, filename string) error <span class="cov8" title="1">{
        // Check if type exists
        typeDef, exists := ps.Types[fact.TypeName]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("fact references undefined type %s in %s", fact.TypeName, filename)
        }</span>

        // Create a map of field definitions for easy lookup
        <span class="cov8" title="1">fieldDefs := make(map[string]Field)
        for _, field := range typeDef.Fields </span><span class="cov8" title="1">{
                fieldDefs[field.Name] = field
        }</span>

        // Validate each field in the fact
        <span class="cov8" title="1">for _, factField := range fact.Fields </span><span class="cov8" title="1">{
                // Find field definition
                fieldDef, found := fieldDefs[factField.Name]
                if !found </span><span class="cov8" title="1">{
                        return fmt.Errorf("fact contains undefined field %s for type %s in %s",
                                factField.Name, fact.TypeName, filename)
                }</span>

                // Validate field value type
                <span class="cov8" title="1">err := ps.validateFactValue(factField.Value, fieldDef.Type)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("field %s validation failed in %s: %w", factField.Name, filename, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ToProgram converts the program state back to a Program structure
func (ps *ProgramState) ToProgram() *Program <span class="cov8" title="1">{
        // Convert types
        var types []TypeDefinition
        for _, typeDef := range ps.Types </span><span class="cov8" title="1">{
                types = append(types, *typeDef)
        }</span>

        // Convert rules
        <span class="cov8" title="1">var expressions []Expression
        for _, rule := range ps.Rules </span><span class="cov8" title="1">{
                expressions = append(expressions, *rule)
        }</span>

        // Convert facts
        <span class="cov8" title="1">var facts []Fact
        for _, fact := range ps.Facts </span><span class="cov8" title="1">{
                facts = append(facts, *fact)
        }</span>

        <span class="cov8" title="1">return &amp;Program{
                Types:       types,
                Expressions: expressions,
                Facts:       facts,
        }</span>
}

// Helper functions

func (ps *ProgramState) areTypesCompatible(type1, type2 *TypeDefinition) bool <span class="cov8" title="1">{
        if type1.Name != type2.Name </span><span class="cov8" title="1">{
                return false
        }</span>

        // Create field maps for comparison
        <span class="cov8" title="1">fields1 := make(map[string]string)
        fields2 := make(map[string]string)

        for _, field := range type1.Fields </span><span class="cov8" title="1">{
                fields1[field.Name] = field.Type
        }</span>
        <span class="cov8" title="1">for _, field := range type2.Fields </span><span class="cov8" title="1">{
                fields2[field.Name] = field.Type
        }</span>

        // Check that all common fields have the same type
        <span class="cov8" title="1">for name, type1 := range fields1 </span><span class="cov8" title="1">{
                if type2, exists := fields2[name]; exists </span><span class="cov8" title="1">{
                        if type1 != type2 </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}

func (ps *ProgramState) validateFieldAccesses(data interface{}, variables map[string]string) error <span class="cov8" title="1">{
        // Recursively scan for fieldAccess patterns
        return ps.scanForFieldAccess(data, variables)
}</span>

func (ps *ProgramState) scanForFieldAccess(data interface{}, variables map[string]string) error <span class="cov8" title="1">{
        switch v := data.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                // Check if this is a fieldAccess
                if objType, hasType := v["type"].(string); hasType &amp;&amp; objType == "fieldAccess" </span><span class="cov8" title="1">{
                        object := getStringValue(v, "object")
                        field := getStringValue(v, "field")

                        // Validate the field access
                        if varType, exists := variables[object]; exists </span><span class="cov8" title="1">{
                                if typeDef, typeExists := ps.Types[varType]; typeExists </span><span class="cov8" title="1">{
                                        fieldFound := false
                                        for _, fieldDef := range typeDef.Fields </span><span class="cov8" title="1">{
                                                if fieldDef.Name == field </span><span class="cov8" title="1">{
                                                        fieldFound = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if !fieldFound </span><span class="cov8" title="1">{
                                                return fmt.Errorf("field %s.%s not found in type %s", object, field, varType)
                                        }</span>
                                }
                        }
                }

                // Recursively check all map values
                <span class="cov8" title="1">for _, value := range v </span><span class="cov8" title="1">{
                        err := ps.scanForFieldAccess(value, variables)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        case []interface{}:<span class="cov8" title="1">
                // Recursively check all slice elements
                for _, item := range v </span><span class="cov8" title="1">{
                        err := ps.scanForFieldAccess(item, variables)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (ps *ProgramState) validateFactValue(value FactValue, expectedType string) error <span class="cov8" title="1">{
        // Basic type validation
        switch expectedType </span>{
        case "string":<span class="cov8" title="1">
                if value.Type != "string" &amp;&amp; value.Type != "identifier" </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected string, got %s", value.Type)
                }</span>
        case "number":<span class="cov8" title="1">
                if value.Type != "number" </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected number, got %s", value.Type)
                }</span>
        case "bool":<span class="cov8" title="1">
                if value.Type != "boolean" </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected boolean, got %s", value.Type)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getStringValue(m map[string]interface{}, key string) string <span class="cov8" title="1">{
        if value, exists := m[key]; exists </span><span class="cov8" title="1">{
                if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package constraint

import "fmt"

// HasErrors returns true if there are any validation errors
func (ps *ProgramState) HasErrors() bool <span class="cov8" title="1">{
        return len(ps.Errors) &gt; 0
}</span>

// GetErrorCount returns the number of validation errors
func (ps *ProgramState) GetErrorCount() int <span class="cov8" title="1">{
        return len(ps.Errors)
}</span>

// GetErrors returns a copy of all validation errors
func (ps *ProgramState) GetErrors() []ValidationError <span class="cov8" title="1">{
        // Return a copy to prevent external modifications
        errors := make([]ValidationError, len(ps.Errors))
        copy(errors, ps.Errors)
        return errors
}</span>

// PrintErrors prints all validation errors to console
func (ps *ProgramState) PrintErrors() <span class="cov8" title="1">{
        for _, err := range ps.Errors </span><span class="cov8" title="1">{
                fmt.Printf("⚠️  Error in %s: %s (line %d): %s\n",
                        err.File, err.Type, err.Line, err.Message)
        }</span>
}

// AddError adds a validation error to the program state
func (ps *ProgramState) AddError(err ValidationError) <span class="cov8" title="1">{
        ps.Errors = append(ps.Errors, err)
}</span>

// ClearErrors removes all validation errors
func (ps *ProgramState) ClearErrors() <span class="cov8" title="1">{
        ps.Errors = []ValidationError{}
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
