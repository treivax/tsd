// Grammaire PEG Complète et Cohérente avec le Réseau RETE
// Cette grammaire supporte tous les constructs nécessaires pour une intégration complète
// avec les noeuds du réseau RETE : AlphaNode, BetaNode, NotNode, ExistsNode, AccumulateNode, TerminalNode
//
// Commande pour générer le parser: pigeon -o parser.go constraint.peg
{
package constraint

import (
    "fmt"
    "strconv"
    "strings"
)
}

Start <- _ statements:StatementList _ EOF {
    // Séparer types, expressions, faits et retractions
    types := []interface{}{}
    expressions := []interface{}{}
    facts := []interface{}{}
    retractions := []interface{}{}

    if statements != nil {
        for _, stmt := range statements.([]interface{}) {
            if stmtMap, ok := stmt.(map[string]interface{}); ok {
                if stmtMap["type"] == "typeDefinition" {
                    types = append(types, stmt)
                } else if stmtMap["type"] == "expression" {
                    expressions = append(expressions, stmt)
                } else if stmtMap["type"] == "fact" {
                    facts = append(facts, stmt)
                } else if stmtMap["type"] == "retraction" {
                    retractions = append(retractions, stmt)
                }
            }
        }
    }

    return map[string]interface{}{
        "types": types,
        "expressions": expressions,
        "facts": facts,
        "retractions": retractions,
    }, nil
}

StatementList <- statements:(Statement _)* {
    result := []interface{}{}
    if statements != nil {
        for _, stmt := range statements.([]interface{}) {
            result = append(result, stmt.([]interface{})[0])
        }
    }
    return result, nil
}

Statement <- TypeDefinition / Expression / RemoveFact / Fact

TypeDefinition <- "type" _ name:IdentName _ ":" _ "<" _ fields:FieldList _ ">" {
    return map[string]interface{}{
        "type": "typeDefinition",
        "name": name,
        "fields": fields,
    }, nil
}

FieldList <- first:Field rest:(_ "," _ Field)* {
    fields := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            fields = append(fields, item.([]interface{})[3])
        }
    }
    return fields, nil
}

Field <- name:IdentName _ ":" _ fieldType:AtomicType {
    return map[string]interface{}{
        "name": name,
        "type": fieldType,
    }, nil
}

AtomicType <- "string" { return "string", nil } /
              "number" { return "number", nil } /
              "bool"   { return "bool", nil }

Expression <- set:Set _ "/" _ constraints:Constraints _ action:Action {
    return map[string]interface{}{
        "type": "expression",
        "set": set,
        "constraints": constraints,
        "action": action,
    }, nil
}

Set <- "{" _ variables:TypedVariableList _ "}" {
    return map[string]interface{}{
        "type": "set",
        "variables": variables,
    }, nil
}

TypedVariableList <- first:TypedVariable rest:(_ "," _ TypedVariable)* {
    variables := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            variables = append(variables, item.([]interface{})[3])
        }
    }
    return variables, nil
}

TypedVariable <- name:IdentName _ ":" _ dataType:IdentName {
    return map[string]interface{}{
        "type": "typedVariable",
        "name": name,
        "dataType": dataType,
    }, nil
}

Constraints <- first:Constraint rest:(_ LogicalOp _ Constraint)* {
    if rest == nil || len(rest.([]interface{})) == 0 {
        return first, nil
    }

    operations := []map[string]interface{}{}
    for _, item := range rest.([]interface{}) {
        op := item.([]interface{})[1]
        right := item.([]interface{})[3]
        operations = append(operations, map[string]interface{}{
            "op": op,
            "right": right,
        })
    }

    return map[string]interface{}{
        "type": "logicalExpr",
        "left": first,
        "operations": operations,
    }, nil
}

Constraint <- "(" _ expr:Constraints _ ")" { return expr, nil } /
              NotConstraint /
              ExistsConstraint /
              AccumulateConstraint /
              left:ArithmeticExpr _ op:ComparisonOp _ right:ArithmeticExpr {
    return map[string]interface{}{
        "type": "comparison",
        "left": left,
        "operator": op,
        "right": right,
    }, nil
}

NotConstraint <- "NOT" _ "(" _ expr:Constraints _ ")" {
    return map[string]interface{}{
        "type": "notConstraint",
        "expression": expr,
    }, nil
}

ExistsConstraint <- "EXISTS" _ "(" _ variable:TypedVariable _ "/" _ condition:Constraints _ ")" {
    return map[string]interface{}{
        "type": "existsConstraint",
        "variable": variable,
        "condition": condition,
    }, nil
}

AccumulateConstraint <- accumFunc:AccumulateFunction _ "(" _ accumVar:TypedVariable _ "/" _ accumCond:Constraints _ accumField:(_ ";" _ FieldAccess)? _ ")" _ accumOp:ComparisonOp _ accumThreshold:ArithmeticExpr {
    fieldValue := ""
    if accumField != nil {
        fieldAccess := accumField.([]interface{})[3].(map[string]interface{})
        fieldValue = fieldAccess["field"].(string)
    }
    
    return map[string]interface{}{
        "type": "accumulateConstraint",
        "function": accumFunc,
        "variable": accumVar,
        "condition": accumCond,
        "field": fieldValue,
        "operator": accumOp,
        "threshold": accumThreshold,
    }, nil
}

AccumulateFunction <- "AVG" { return "AVG", nil } /
                     "COUNT" { return "COUNT", nil } /
                     "SUM" { return "SUM", nil } /
                     "MIN" { return "MIN", nil } /
                     "MAX" { return "MAX", nil }


ArithmeticExpr <- first:Term rest:(_ ("+" / "-") _ Term)* {
    if rest == nil || len(rest.([]interface{})) == 0 {
        return first, nil
    }

    result := first
    for _, item := range rest.([]interface{}) {
        op := item.([]interface{})[1]
        right := item.([]interface{})[3]
        result = map[string]interface{}{
            "type": "binaryOp",
            "left": result,
            "operator": op,
            "right": right,
        }
    }
    return result, nil
}

Term <- first:Factor rest:(_ ("*" / "/") _ Factor)* {
    if rest == nil || len(rest.([]interface{})) == 0 {
        return first, nil
    }

    result := first
    for _, item := range rest.([]interface{}) {
        op := item.([]interface{})[1]
        right := item.([]interface{})[3]
        result = map[string]interface{}{
            "type": "binaryOp",
            "left": result,
            "operator": op,
            "right": right,
        }
    }
    return result, nil
}

Factor <- "(" _ expr:ArithmeticExpr _ ")" { return expr, nil } /
          FunctionCall /
          FieldAccess /
          Number /
          StringLiteral /
          BooleanLiteral /
          ArrayLiteral /
          Variable

FieldAccess <- object:IdentName "." field:IdentName {
    return map[string]interface{}{
        "type": "fieldAccess",
        "object": object,
        "field": field,
    }, nil
}

Variable <- name:IdentName {
    return map[string]interface{}{
        "type": "variable",
        "name": name,
    }, nil
}

ArrayLiteral <- "[" _ elements:ArrayElementList? _ "]" {
    if elements == nil {
        elements = []interface{}{}
    }
    return map[string]interface{}{
        "type": "arrayLiteral",
        "elements": elements,
    }, nil
}

ArrayElementList <- first:ArithmeticExpr rest:(_ "," _ ArithmeticExpr)* {
    elements := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            elements = append(elements, item.([]interface{})[3])
        }
    }
    return elements, nil
}

FunctionCall <- name:FunctionName _ "(" _ args:FunctionArgList? _ ")" {
    if args == nil {
        args = []interface{}{}
    }
    return map[string]interface{}{
        "type": "functionCall",
        "name": name,
        "args": args,
    }, nil
}

FunctionName <- "LENGTH" { return "LENGTH", nil } /
                "SUBSTRING" { return "SUBSTRING", nil } /
                "UPPER" { return "UPPER", nil } /
                "LOWER" { return "LOWER", nil } /
                "TRIM" { return "TRIM", nil } /
                "ABS" { return "ABS", nil } /
                "ROUND" { return "ROUND", nil } /
                "FLOOR" { return "FLOOR", nil } /
                "CEIL" { return "CEIL", nil }

FunctionArgList <- first:ArithmeticExpr rest:(_ "," _ ArithmeticExpr)* {
    args := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            args = append(args, item.([]interface{})[3])
        }
    }
    return args, nil
}

Action <- "==>" _ job:JobCall {
    return map[string]interface{}{
        "type": "action",
        "job": job,
    }, nil
}

JobCall <- name:IdentName _ "(" _ args:ArgumentList? _ ")" {
    if args == nil {
        args = []interface{}{}
    }
    return map[string]interface{}{
        "type": "jobCall",
        "name": name,
        "args": args,
    }, nil
}

ArgumentList <- first:ArithmeticExpr rest:(_ "," _ ArithmeticExpr)* {
    arguments := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            arguments = append(arguments, item.([]interface{})[3])
        }
    }
    return arguments, nil
}

ComparisonOp <- "==" { return "==", nil } /
                "!=" { return "!=", nil } /
                "<=" { return "<=", nil } /
                ">=" { return ">=", nil } /
                "<"  { return "<", nil } /
                ">"  { return ">", nil } /
                "IN" { return "IN", nil } /
                "LIKE" { return "LIKE", nil } /
                "MATCHES" { return "MATCHES", nil } /
                "CONTAINS" { return "CONTAINS", nil }

LogicalOp <- "AND" { return "AND", nil } /
             "OR"  { return "OR", nil }

BooleanLiteral <- "true" {
        return map[string]interface{}{
            "type": "boolean",
            "value": true,
        }, nil
    } /
    "false" {
        return map[string]interface{}{
            "type": "boolean",
            "value": false,
        }, nil
    }

Number <- sign:"-"? digits:[0-9]+ decimal:("." [0-9]+)? {
    val, err := strconv.ParseFloat(string(c.text), 64)
    if err != nil {
        return nil, err
    }
    return map[string]interface{}{
        "type": "number",
        "value": val,
    }, nil
}

StringLiteral <- "\"" chars:DoubleStringChar* "\"" {
        var builder strings.Builder
        if chars != nil {
            for _, char := range chars.([]interface{}) {
                builder.WriteString(char.(string))
            }
        }
        return map[string]interface{}{
            "type": "string",
            "value": builder.String(),
        }, nil
    } /
    "'" chars:SingleStringChar* "'" {
        var builder strings.Builder
        if chars != nil {
            for _, char := range chars.([]interface{}) {
                builder.WriteString(char.(string))
            }
        }
        return map[string]interface{}{
            "type": "string",
            "value": builder.String(),
        }, nil
    }

DoubleStringChar <- EscapeSequence / (!'"' UnicodeChar) {
    return string(c.text), nil
}

SingleStringChar <- EscapeSequence / (!'\'' UnicodeChar) {
    return string(c.text), nil
}

EscapeSequence <- "\\" char:EscapeChar {
    switch char {
    case "n":
        return "\n", nil
    case "t":
        return "\t", nil
    case "r":
        return "\r", nil
    case "\\":
        return "\\", nil
    case "\"":
        return "\"", nil
    case "'":
        return "'", nil
    default:
        return "\\" + char.(string), nil
    }
}

EscapeChar <- "n" / "t" / "r" / "\\" / "\"" / "'" / .

UnicodeChar <- .

// RemoveFact définit le parsing d'une rétractation de fait avec le format: remove TypeName ID
RemoveFact <- "remove" _ typeName:IdentName _ factID:FactID {
    return map[string]interface{}{
        "type": "retraction",
        "typeName": typeName,
        "factID": factID,
    }, nil
}

// FactID est un identifiant pour un fait (peut contenir des caractères spéciaux)
FactID <- chars:([a-zA-Z0-9_-] / SpecialFactChar)+ {
    return string(c.text), nil
}

// Fact définit le parsing d'un fait avec le nouveau format TypeName(field:value, ...)
Fact <- typeName:IdentName "(" _ fields:FactFieldList _ ")" {
    return map[string]interface{}{
        "type": "fact",
        "typeName": typeName,
        "fields": fields,
    }, nil
}

FactFieldList <- first:FactField rest:(_ "," _ FactField)* {
    fields := []interface{}{first}
    if rest != nil {
        for _, item := range rest.([]interface{}) {
            fields = append(fields, item.([]interface{})[3])
        }
    }
    return fields, nil
}

FactField <- name:IdentName ":" _ value:FactValue {
    return map[string]interface{}{
        "name": name,
        "value": value,
    }, nil
}

FactValue <- StringLiteral / Number / BooleanLiteral / ComplexIdentifier {
    // ComplexIdentifier pour les valeurs non-quotées complexes comme des IDs
    return map[string]interface{}{
        "type": "identifier",
        "value": string(c.text),
    }, nil
}

ComplexIdentifier <- ComplexIdentStart ComplexIdentContinue* {
    return string(c.text), nil
}

ComplexIdentStart <- [a-zA-Z0-9_] / UnicodeLetterStart

ComplexIdentContinue <- [a-zA-Z0-9_-] / UnicodeLetterContinue / SpecialFactChar

// Caractères spéciaux autorisés dans les valeurs de faits
SpecialFactChar <- [-_:.]

IdentName <- IdentStart IdentContinue* {
    return string(c.text), nil
}

IdentStart <- [a-zA-Z_] / UnicodeLetterStart

IdentContinue <- [a-zA-Z0-9_-] / UnicodeLetterContinue / PunctuationChar

// Support pour les caractères étendus les plus courants (Latin étendu, accents français)
UnicodeLetterStart <- [\u00C0-\u00D6] / [\u00D8-\u00F6] / [\u00F8-\u017F] /
                      [\u0100-\u024F] / [\u1E00-\u1EFF] / [\u0370-\u03FF] /
                      [\u0400-\u04FF] / [\u0590-\u05FF] / [\u0600-\u06FF]

UnicodeLetterContinue <- [\u00C0-\u00D6] / [\u00D8-\u00F6] / [\u00F8-\u017F] /
                         [\u0100-\u024F] / [\u1E00-\u1EFF] / [\u0370-\u03FF] /
                         [\u0400-\u04FF] / [\u0590-\u05FF] / [\u0600-\u06FF] /
                         [\u0300-\u036F] / [\u1AB0-\u1AFF] / [\u1DC0-\u1DFF]

PunctuationChar <- [-_] / ['] / [\u2010-\u2015] / [\u2032-\u2037]

_ <- (Whitespace / Comment)*

Whitespace <- [ \t\r\n]

Comment <- LineComment / BlockComment / EndOfLineComment

LineComment <- "//" CommentText:(![\r\n] .)* {
    return nil, nil  // Les commentaires ne retournent rien
}

BlockComment <- "/*" CommentText:(!"*/" .)* "*/" {
    return nil, nil  // Les commentaires ne retournent rien
}

EndOfLineComment <- "#" CommentText:(![\r\n] .)* {
    return nil, nil  // Support pour commentaires style shell/Python
}

EOF <- !.
