
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rete: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/treivax/tsd/rete/alpha_builder.go (0.0%)</option>
				
				<option value="file1">github.com/treivax/tsd/rete/alpha_chain_builder.go (0.0%)</option>
				
				<option value="file2">github.com/treivax/tsd/rete/alpha_chain_extractor.go (0.0%)</option>
				
				<option value="file3">github.com/treivax/tsd/rete/alpha_sharing.go (7.9%)</option>
				
				<option value="file4">github.com/treivax/tsd/rete/beta_chain_builder.go (4.2%)</option>
				
				<option value="file5">github.com/treivax/tsd/rete/beta_chain_metrics.go (0.6%)</option>
				
				<option value="file6">github.com/treivax/tsd/rete/beta_join_cache.go (0.0%)</option>
				
				<option value="file7">github.com/treivax/tsd/rete/beta_sharing.go (32.7%)</option>
				
				<option value="file8">github.com/treivax/tsd/rete/beta_sharing_interface.go (22.7%)</option>
				
				<option value="file9">github.com/treivax/tsd/rete/chain_config.go (1.9%)</option>
				
				<option value="file10">github.com/treivax/tsd/rete/chain_metrics.go (1.1%)</option>
				
				<option value="file11">github.com/treivax/tsd/rete/constraint_pipeline.go (16.2%)</option>
				
				<option value="file12">github.com/treivax/tsd/rete/constraint_pipeline_builder.go (47.0%)</option>
				
				<option value="file13">github.com/treivax/tsd/rete/constraint_pipeline_helpers.go (15.4%)</option>
				
				<option value="file14">github.com/treivax/tsd/rete/constraint_pipeline_parser.go (43.2%)</option>
				
				<option value="file15">github.com/treivax/tsd/rete/constraint_pipeline_validator.go (6.5%)</option>
				
				<option value="file16">github.com/treivax/tsd/rete/converter.go (0.0%)</option>
				
				<option value="file17">github.com/treivax/tsd/rete/evaluator.go (20.0%)</option>
				
				<option value="file18">github.com/treivax/tsd/rete/evaluator_comparisons.go (34.1%)</option>
				
				<option value="file19">github.com/treivax/tsd/rete/evaluator_constraints.go (26.4%)</option>
				
				<option value="file20">github.com/treivax/tsd/rete/evaluator_expressions.go (45.7%)</option>
				
				<option value="file21">github.com/treivax/tsd/rete/evaluator_functions.go (0.0%)</option>
				
				<option value="file22">github.com/treivax/tsd/rete/evaluator_operators.go (0.0%)</option>
				
				<option value="file23">github.com/treivax/tsd/rete/evaluator_values.go (25.7%)</option>
				
				<option value="file24">github.com/treivax/tsd/rete/expression_analyzer.go (0.0%)</option>
				
				<option value="file25">github.com/treivax/tsd/rete/fact_token.go (35.1%)</option>
				
				<option value="file26">github.com/treivax/tsd/rete/logger.go (5.3%)</option>
				
				<option value="file27">github.com/treivax/tsd/rete/lru_cache.go (17.1%)</option>
				
				<option value="file28">github.com/treivax/tsd/rete/nested_or_normalizer.go (0.0%)</option>
				
				<option value="file29">github.com/treivax/tsd/rete/network.go (11.0%)</option>
				
				<option value="file30">github.com/treivax/tsd/rete/node_accumulate.go (0.0%)</option>
				
				<option value="file31">github.com/treivax/tsd/rete/node_alpha.go (24.0%)</option>
				
				<option value="file32">github.com/treivax/tsd/rete/node_base.go (61.5%)</option>
				
				<option value="file33">github.com/treivax/tsd/rete/node_exists.go (0.0%)</option>
				
				<option value="file34">github.com/treivax/tsd/rete/node_join.go (38.5%)</option>
				
				<option value="file35">github.com/treivax/tsd/rete/node_lifecycle.go (24.0%)</option>
				
				<option value="file36">github.com/treivax/tsd/rete/node_root.go (38.5%)</option>
				
				<option value="file37">github.com/treivax/tsd/rete/node_terminal.go (2.1%)</option>
				
				<option value="file38">github.com/treivax/tsd/rete/node_type.go (51.2%)</option>
				
				<option value="file39">github.com/treivax/tsd/rete/normalization_cache.go (0.0%)</option>
				
				<option value="file40">github.com/treivax/tsd/rete/prometheus_exporter.go (0.0%)</option>
				
				<option value="file41">github.com/treivax/tsd/rete/store_base.go (2.9%)</option>
				
				<option value="file42">github.com/treivax/tsd/rete/store_indexed.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
)

// AlphaConditionBuilder aide √† construire des conditions Alpha
type AlphaConditionBuilder struct{}

// NewAlphaConditionBuilder cr√©e un nouveau constructeur de conditions
func NewAlphaConditionBuilder() *AlphaConditionBuilder <span class="cov0" title="0">{
        return &amp;AlphaConditionBuilder{}
}</span>

// FieldEquals cr√©e une condition d'√©galit√© sur un champ
func (acb *AlphaConditionBuilder) FieldEquals(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "==",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldNotEquals cr√©e une condition d'in√©galit√© sur un champ
func (acb *AlphaConditionBuilder) FieldNotEquals(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "!=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldLessThan cr√©e une condition de comparaison inf√©rieure sur un champ
func (acb *AlphaConditionBuilder) FieldLessThan(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&lt;",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldLessOrEqual cr√©e une condition de comparaison inf√©rieure ou √©gale sur un champ
func (acb *AlphaConditionBuilder) FieldLessOrEqual(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&lt;=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldGreaterThan cr√©e une condition de comparaison sup√©rieure sur un champ
func (acb *AlphaConditionBuilder) FieldGreaterThan(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&gt;",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// FieldGreaterOrEqual cr√©e une condition de comparaison sup√©rieure ou √©gale sur un champ
func (acb *AlphaConditionBuilder) FieldGreaterOrEqual(variable, field string, value interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     "binaryOperation",
                "operator": "&gt;=",
                "left": map[string]interface{}{
                        "type":   "fieldAccess",
                        "object": variable,
                        "field":  field,
                },
                "right": acb.createLiteral(value),
        }
}</span>

// And cr√©e une condition logique AND
func (acb *AlphaConditionBuilder) And(left, right interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "logicalExpression",
                "left": left,
                "operations": []interface{}{
                        map[string]interface{}{
                                "op":    "AND",
                                "right": right,
                        },
                },
        }
}</span>

// Or cr√©e une condition logique OR
func (acb *AlphaConditionBuilder) Or(left, right interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type": "logicalExpression",
                "left": left,
                "operations": []interface{}{
                        map[string]interface{}{
                                "op":    "OR",
                                "right": right,
                        },
                },
        }
}</span>

// AndMultiple cr√©e une condition logique AND avec plusieurs conditions
func (acb *AlphaConditionBuilder) AndMultiple(conditions ...interface{}) interface{} <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return acb.True()
        }</span>
        <span class="cov0" title="0">if len(conditions) == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>

        <span class="cov0" title="0">operations := make([]interface{}, 0, len(conditions)-1)
        for _, condition := range conditions[1:] </span><span class="cov0" title="0">{
                operations = append(operations, map[string]interface{}{
                        "op":    "AND",
                        "right": condition,
                })
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type":       "logicalExpression",
                "left":       conditions[0],
                "operations": operations,
        }</span>
}

// OrMultiple cr√©e une condition logique OR avec plusieurs conditions
func (acb *AlphaConditionBuilder) OrMultiple(conditions ...interface{}) interface{} <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return acb.False()
        }</span>
        <span class="cov0" title="0">if len(conditions) == 1 </span><span class="cov0" title="0">{
                return conditions[0]
        }</span>

        <span class="cov0" title="0">operations := make([]interface{}, 0, len(conditions)-1)
        for _, condition := range conditions[1:] </span><span class="cov0" title="0">{
                operations = append(operations, map[string]interface{}{
                        "op":    "OR",
                        "right": condition,
                })
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type":       "logicalExpression",
                "left":       conditions[0],
                "operations": operations,
        }</span>
}

// True cr√©e une condition toujours vraie
func (acb *AlphaConditionBuilder) True() interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "booleanLiteral",
                "value": true,
        }
}</span>

// False cr√©e une condition toujours fausse
func (acb *AlphaConditionBuilder) False() interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":  "booleanLiteral",
                "value": false,
        }
}</span>

// FieldRange cr√©e une condition de plage pour un champ (min &lt;= field &lt;= max)
func (acb *AlphaConditionBuilder) FieldRange(variable, field string, min, max interface{}) interface{} <span class="cov0" title="0">{
        minCondition := acb.FieldGreaterOrEqual(variable, field, min)
        maxCondition := acb.FieldLessOrEqual(variable, field, max)
        return acb.And(minCondition, maxCondition)
}</span>

// FieldIn cr√©e une condition de pr√©sence dans une liste de valeurs
func (acb *AlphaConditionBuilder) FieldIn(variable, field string, values ...interface{}) interface{} <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return acb.False()
        }</span>

        <span class="cov0" title="0">conditions := make([]interface{}, len(values))
        for i, value := range values </span><span class="cov0" title="0">{
                conditions[i] = acb.FieldEquals(variable, field, value)
        }</span>

        <span class="cov0" title="0">return acb.OrMultiple(conditions...)</span>
}

// FieldNotIn cr√©e une condition d'absence dans une liste de valeurs
func (acb *AlphaConditionBuilder) FieldNotIn(variable, field string, values ...interface{}) interface{} <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return acb.True()
        }</span>

        <span class="cov0" title="0">conditions := make([]interface{}, len(values))
        for i, value := range values </span><span class="cov0" title="0">{
                conditions[i] = acb.FieldNotEquals(variable, field, value)
        }</span>

        <span class="cov0" title="0">return acb.AndMultiple(conditions...)</span>
}

// createLiteral cr√©e un litt√©ral typ√©
func (acb *AlphaConditionBuilder) createLiteral(value interface{}) map[string]interface{} <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "stringLiteral",
                        "value": v,
                }</span>
        case int:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case int32:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case int64:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case float32:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": float64(v),
                }</span>
        case float64:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "numberLiteral",
                        "value": v,
                }</span>
        case bool:<span class="cov0" title="0">
                return map[string]interface{}{
                        "type":  "booleanLiteral",
                        "value": v,
                }</span>
        default:<span class="cov0" title="0">
                // Fallback vers string
                return map[string]interface{}{
                        "type":  "stringLiteral",
                        "value": fmt.Sprintf("%v", v),
                }</span>
        }
}

// CreateConstraintFromAST cr√©e une condition √† partir d'un AST de contrainte
func (acb *AlphaConditionBuilder) CreateConstraintFromAST(constraint interface{}) interface{} <span class="cov0" title="0">{
        // Si c'est d√©j√† une map, la retourner telle quelle
        if constraintMap, ok := constraint.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                return constraintMap
        }</span>

        // Sinon, retourner tel quel (sera trait√© par l'√©valuateur)
        <span class="cov0" title="0">return constraint</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "log"
        "sync"
        "time"
)

// AlphaChain repr√©sente une cha√Æne d'AlphaNodes construite pour un ensemble de conditions.
//
// Une cha√Æne alpha est une s√©quence ordonn√©e de n≈ìuds alpha qui √©valuent des conditions
// successives sur une m√™me variable. Chaque n≈ìud √©value une condition et propage les faits
// correspondants au n≈ìud suivant dans la cha√Æne.
//
// Structure de cha√Æne typique:
//
//        TypeNode(Person)
//          ‚îî‚îÄ‚îÄ AlphaNode(p.age &gt;= 18)
//               ‚îî‚îÄ‚îÄ AlphaNode(p.city == "Paris")
//                    ‚îî‚îÄ‚îÄ TerminalNode(rule_terminal)
//
// Propri√©t√©s:
//   - len(Nodes) == len(Hashes) (toujours maintenu)
//   - FinalNode == Nodes[len(Nodes)-1] (si non vide)
//   - Ordre des n≈ìuds correspond √† l'ordre des conditions dans la r√®gle
//
// Exemple d'utilisation:
//
//        chain, err := builder.BuildChain(conditions, "p", parentNode, "myRule")
//        if err != nil {
//            return err
//        }
//        fmt.Printf("Cha√Æne construite: %d n≈ìuds\n", len(chain.Nodes))
//        stats := builder.GetChainStats(chain)
//        fmt.Printf("N≈ìuds partag√©s: %d/%d\n", stats["shared_nodes"], len(chain.Nodes))
type AlphaChain struct {
        Nodes     []*AlphaNode `json:"nodes"`      // Liste ordonn√©e des n≈ìuds alpha dans la cha√Æne
        Hashes    []string     `json:"hashes"`     // Hashes correspondants pour chaque n≈ìud
        FinalNode *AlphaNode   `json:"final_node"` // Le dernier n≈ìud de la cha√Æne
        RuleID    string       `json:"rule_id"`    // ID de la r√®gle pour laquelle la cha√Æne a √©t√© construite
}

// AlphaChainBuilder construit des cha√Ænes d'AlphaNodes avec partage automatique.
//
// Le builder coordonne la construction de cha√Ænes alpha en r√©utilisant intelligemment
// les n≈ìuds existants et en maintenant un cache des connexions parent‚Üíchild pour
// √©viter les duplications.
//
// Fonctionnalit√©s principales:
//   - Construction s√©quentielle de cha√Ænes condition par condition
//   - Partage automatique via AlphaSharingRegistry
//   - Cache de connexions pour √©viter duplications
//   - Collection de m√©triques d√©taill√©es
//   - Thread-safe avec sync.RWMutex
//
// Flux de construction:
//
//        Pour chaque condition:
//          1. Calculer hash (avec cache LRU)
//          2. Chercher n≈ìud existant via hash
//          3. Si trouv√©: r√©utiliser (refcount++)
//             Si non: cr√©er nouveau n≈ìud
//          4. V√©rifier connexion parent‚Üíchild (avec cache)
//          5. Connecter si n√©cessaire
//          6. Enregistrer dans LifecycleManager
//          7. N≈ìud devient parent pour suivant
//
// Exemple d'utilisation:
//
//        builder := NewAlphaChainBuilder(network, storage)
//        conditions := []SimpleCondition{
//            NewSimpleCondition("binaryOperation", "p.age", "&gt;", 18),
//            NewSimpleCondition("binaryOperation", "p.name", "==", "Alice"),
//        }
//        chain, err := builder.BuildChain(conditions, "p", typeNode, "rule1")
//        if err != nil {
//            log.Fatal(err)
//        }
//
//        // Acc√©der aux m√©triques
//        metrics := builder.GetMetrics()
//        fmt.Printf("Sharing ratio: %.1f%%\n", metrics.SharingRatio * 100)
//
// Thread-safety:
//   - Toutes les op√©rations publiques sont thread-safe
//   - Le cache de connexions est prot√©g√© par mutex
//   - Peut √™tre utilis√© concurremment par plusieurs goroutines
type AlphaChainBuilder struct {
        network         *ReteNetwork
        storage         Storage
        connectionCache map[string]bool // Cache pour les connexions existantes (parentID_childID -&gt; bool)
        metrics         *ChainBuildMetrics
        mutex           sync.RWMutex
}

// NewAlphaChainBuilder cr√©e un nouveau constructeur de cha√Ænes alpha avec des m√©triques neuves.
//
// Cette fonction initialise un builder avec un objet de m√©triques local. Pour partager
// les m√©triques entre plusieurs builders (recommand√©), utilisez NewAlphaChainBuilderWithMetrics.
//
// Param√®tres:
//   - network: R√©seau RETE auquel ajouter les n≈ìuds
//   - storage: Backend de persistance pour les n≈ìuds
//
// Retourne:
//   - Un nouveau builder pr√™t √† l'emploi
//
// Exemple:
//
//        storage := NewMemoryStorage()
//        network := NewReteNetwork(storage)
//        builder := NewAlphaChainBuilder(network, storage)
func NewAlphaChainBuilder(network *ReteNetwork, storage Storage) *AlphaChainBuilder <span class="cov0" title="0">{
        return &amp;AlphaChainBuilder{
                network:         network,
                storage:         storage,
                connectionCache: make(map[string]bool),
                metrics:         NewChainBuildMetrics(),
        }
}</span>

// NewAlphaChainBuilderWithMetrics cr√©e un constructeur avec des m√©triques partag√©es.
//
// Recommand√© quand le r√©seau RETE cr√©e son propre builder, permettant de partager
// les m√©triques entre le builder et d'autres composants.
//
// Param√®tres:
//   - network: R√©seau RETE auquel ajouter les n≈ìuds
//   - storage: Backend de persistance pour les n≈ìuds
//   - metrics: Objet de m√©triques partag√© (non nil)
//
// Retourne:
//   - Un nouveau builder utilisant les m√©triques fournies
//
// Exemple:
//
//        metrics := NewChainBuildMetrics()
//        builder := NewAlphaChainBuilderWithMetrics(network, storage, metrics)
//        // Les m√©triques sont accessibles via builder.GetMetrics() et directement via 'metrics'
func NewAlphaChainBuilderWithMetrics(network *ReteNetwork, storage Storage, metrics *ChainBuildMetrics) *AlphaChainBuilder <span class="cov0" title="0">{
        return &amp;AlphaChainBuilder{
                network:         network,
                storage:         storage,
                connectionCache: make(map[string]bool),
                metrics:         metrics,
        }
}</span>

// BuildChain construit une cha√Æne d'AlphaNodes pour un ensemble de conditions
// avec partage automatique des n≈ìuds identiques entre r√®gles.
//
// Cette m√©thode est le point d'entr√©e principal pour la construction de cha√Ænes.
// Elle it√®re sur chaque condition, tente de r√©utiliser un n≈ìud existant, sinon
// en cr√©e un nouveau, et maintient les connexions parent‚Üíchild appropri√©es.
//
// Algorithme:
//
//        Pour chaque condition dans la liste:
//          1. Convertir SimpleCondition en map
//          2. Appeler AlphaSharingRegistry.GetOrCreateAlphaNode()
//             ‚Üí Calcule hash (avec cache LRU)
//             ‚Üí Cherche n≈ìud existant
//             ‚Üí Cr√©e nouveau si inexistant
//          3. Si n≈ìud r√©utilis√©:
//             - V√©rifier connexion avec parent (cache)
//             - Connecter si n√©cessaire
//          4. Si n≈ìud cr√©√©:
//             - Connecter au parent
//             - Ajouter au r√©seau
//             - Mettre en cache la connexion
//          5. Enregistrer dans LifecycleManager
//          6. N≈ìud devient parent pour it√©ration suivante
//
// Param√®tres:
//   - conditions: liste de conditions simples dans l'ordre d'√©valuation
//   - variableName: nom de la variable (ex: "p", "u") - utilis√© dans le hash
//   - parentNode: n≈ìud parent (g√©n√©ralement TypeNode) auquel connecter le premier n≈ìud
//   - ruleID: identifiant unique de la r√®gle pour le lifecycle management
//
// Retourne:
//   - *AlphaChain: la cha√Æne construite avec tous les n≈ìuds et leurs hashes
//   - error: erreur si conditions vides, parent nil, ou probl√®me de cr√©ation
//
// Exemple simple:
//
//        conditions := []SimpleCondition{
//            NewSimpleCondition("binaryOperation", "p.age", "&gt;", 18),
//        }
//        chain, err := builder.BuildChain(conditions, "p", typeNode, "rule_adult")
//        // ‚Üí Cr√©e: TypeNode ‚Üí AlphaNode(p.age&gt;18) ‚Üí Terminal
//
// Exemple avec partage:
//
//        // R√®gle 1
//        chain1, _ := builder.BuildChain(
//            []SimpleCondition{NewSimpleCondition("binaryOperation", "p.age", "&gt;", 18)},
//            "p", typeNode, "rule1")
//        // ‚Üí Cr√©e nouveau n≈ìud alpha_abc123
//
//        // R√®gle 2 (m√™me condition)
//        chain2, _ := builder.BuildChain(
//            []SimpleCondition{NewSimpleCondition("binaryOperation", "p.age", "&gt;", 18)},
//            "p", typeNode, "rule2")
//        // ‚Üí R√©utilise alpha_abc123 (RefCount=2)
//
// Logs g√©n√©r√©s:
//
//        üÜï [AlphaChainBuilder] Nouveau n≈ìud alpha alpha_abc123 cr√©√© pour la r√®gle rule1 (condition 1/1)
//        üîó [AlphaChainBuilder] Connexion du n≈ìud alpha_abc123 au parent type_person
//        ‚ôªÔ∏è  [AlphaChainBuilder] R√©utilisation du n≈ìud alpha alpha_abc123 pour la r√®gle rule2 (condition 1/1)
//        ‚úì  [AlphaChainBuilder] N≈ìud alpha_abc123 d√©j√† connect√© au parent type_person
func (acb *AlphaChainBuilder) BuildChain(
        conditions []SimpleCondition,
        variableName string,
        parentNode Node,
        ruleID string,
) (*AlphaChain, error) <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("impossible de construire une cha√Æne sans conditions")
        }</span>

        <span class="cov0" title="0">if parentNode == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("le n≈ìud parent ne peut pas √™tre nil")
        }</span>

        <span class="cov0" title="0">if acb.network.AlphaSharingManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AlphaSharingManager non initialis√© dans le r√©seau")
        }</span>

        <span class="cov0" title="0">if acb.network.LifecycleManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LifecycleManager non initialis√© dans le r√©seau")
        }</span>

        // D√©marrer le chronom√®tre pour les m√©triques
        <span class="cov0" title="0">startTime := time.Now()
        nodesCreated := 0
        nodesReused := 0
        hashesGenerated := make([]string, 0, len(conditions))

        chain := &amp;AlphaChain{
                Nodes:  make([]*AlphaNode, 0, len(conditions)),
                Hashes: make([]string, 0, len(conditions)),
                RuleID: ruleID,
        }

        currentParent := parentNode

        // Construire la cha√Æne condition par condition
        for i, condition := range conditions </span><span class="cov0" title="0">{
                // Convertir SimpleCondition en map pour la condition du n≈ìud alpha
                conditionMap := map[string]interface{}{
                        "type":     condition.Type,
                        "left":     condition.Left,
                        "operator": condition.Operator,
                        "right":    condition.Right,
                }

                // Obtenir ou cr√©er l'AlphaNode via le gestionnaire de partage
                alphaNode, hash, reused, err := acb.network.AlphaSharingManager.GetOrCreateAlphaNode(
                        conditionMap,
                        variableName,
                        acb.storage,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur lors de la cr√©ation/r√©cup√©ration du n≈ìud alpha %d: %w", i, err)
                }</span>

                // Ajouter le n≈ìud et son hash √† la cha√Æne
                <span class="cov0" title="0">chain.Nodes = append(chain.Nodes, alphaNode)
                chain.Hashes = append(chain.Hashes, hash)
                hashesGenerated = append(hashesGenerated, hash)

                if reused </span><span class="cov0" title="0">{
                        nodesReused++
                        // N≈ìud r√©utilis√© - v√©rifier la connexion au parent
                        log.Printf("‚ôªÔ∏è  [AlphaChainBuilder] R√©utilisation du n≈ìud alpha %s pour la r√®gle %s (condition %d/%d)",
                                alphaNode.ID, ruleID, i+1, len(conditions))

                        if !acb.isAlreadyConnectedCached(currentParent, alphaNode) </span><span class="cov0" title="0">{
                                // Connecter au parent si pas d√©j√† connect√©
                                currentParent.AddChild(alphaNode)
                                log.Printf("üîó [AlphaChainBuilder] Connexion du n≈ìud r√©utilis√© %s au parent %s",
                                        alphaNode.ID, currentParent.GetID())
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("‚úì  [AlphaChainBuilder] N≈ìud %s d√©j√† connect√© au parent %s",
                                        alphaNode.ID, currentParent.GetID())
                        }</span>
                } else<span class="cov0" title="0"> {
                        nodesCreated++
                        // Nouveau n≈ìud - le connecter au parent et l'ajouter au r√©seau
                        currentParent.AddChild(alphaNode)
                        acb.network.AlphaNodes[alphaNode.ID] = alphaNode

                        // Mettre √† jour le cache de connexion
                        acb.updateConnectionCache(currentParent.GetID(), alphaNode.ID, true)

                        log.Printf("üÜï [AlphaChainBuilder] Nouveau n≈ìud alpha %s cr√©√© pour la r√®gle %s (condition %d/%d)",
                                alphaNode.ID, ruleID, i+1, len(conditions))
                        log.Printf("üîó [AlphaChainBuilder] Connexion du n≈ìud %s au parent %s",
                                alphaNode.ID, currentParent.GetID())
                }</span>

                // Enregistrer le n≈ìud dans le LifecycleManager avec la r√®gle
                <span class="cov0" title="0">lifecycle := acb.network.LifecycleManager.RegisterNode(alphaNode.ID, "alpha")
                lifecycle.AddRuleReference(ruleID, "") // RuleName peut √™tre ajout√© plus tard si n√©cessaire

                if reused </span><span class="cov0" title="0">{
                        log.Printf("üìä [AlphaChainBuilder] N≈ìud %s maintenant utilis√© par %d r√®gle(s)",
                                alphaNode.ID, lifecycle.GetRefCount())
                }</span>

                // Le n≈ìud actuel devient le parent pour le prochain n≈ìud
                <span class="cov0" title="0">currentParent = alphaNode</span>
        }

        // Le dernier n≈ìud de la cha√Æne est le n≈ìud final
        <span class="cov0" title="0">chain.FinalNode = chain.Nodes[len(chain.Nodes)-1]

        log.Printf("‚úÖ [AlphaChainBuilder] Cha√Æne alpha compl√®te construite pour la r√®gle %s: %d n≈ìud(s)",
                ruleID, len(chain.Nodes))

        // Enregistrer les m√©triques
        if acb.metrics != nil </span><span class="cov0" title="0">{
                buildTime := time.Since(startTime)
                detail := ChainMetricDetail{
                        RuleID:          ruleID,
                        ChainLength:     len(chain.Nodes),
                        NodesCreated:    nodesCreated,
                        NodesReused:     nodesReused,
                        BuildTime:       buildTime,
                        Timestamp:       time.Now(),
                        HashesGenerated: hashesGenerated,
                }
                acb.metrics.RecordChainBuild(detail)
        }</span>

        <span class="cov0" title="0">return chain, nil</span>
}

// isAlreadyConnectedCached v√©rifie si un n≈ìud enfant est d√©j√† connect√© √† un n≈ìud parent avec cache
func (acb *AlphaChainBuilder) isAlreadyConnectedCached(parent Node, child Node) bool <span class="cov0" title="0">{
        if parent == nil || child == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">parentID := parent.GetID()
        childID := child.GetID()
        cacheKey := fmt.Sprintf("%s_%s", parentID, childID)

        // V√©rifier le cache
        acb.mutex.RLock()
        if connected, exists := acb.connectionCache[cacheKey]; exists </span><span class="cov0" title="0">{
                acb.mutex.RUnlock()
                if acb.metrics != nil </span><span class="cov0" title="0">{
                        acb.metrics.RecordConnectionCacheHit()
                }</span>
                <span class="cov0" title="0">return connected</span>
        }
        <span class="cov0" title="0">acb.mutex.RUnlock()

        // Cache miss - v√©rifier r√©ellement
        if acb.metrics != nil </span><span class="cov0" title="0">{
                acb.metrics.RecordConnectionCacheMiss()
        }</span>

        <span class="cov0" title="0">connected := isAlreadyConnected(parent, child)

        // Mettre √† jour le cache
        acb.updateConnectionCache(parentID, childID, connected)

        return connected</span>
}

// updateConnectionCache met √† jour le cache de connexion
func (acb *AlphaChainBuilder) updateConnectionCache(parentID, childID string, connected bool) <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("%s_%s", parentID, childID)
        acb.mutex.Lock()
        acb.connectionCache[cacheKey] = connected
        acb.mutex.Unlock()
}</span>

// ClearConnectionCache vide le cache de connexions.
//
// Utile pour lib√©rer de la m√©moire apr√®s suppression de nombreuses r√®gles,
// ou pour forcer une r√©√©valuation compl√®te des connexions.
//
// Thread-safe: peut √™tre appel√© √† tout moment.
//
// Exemple:
//
//        // Apr√®s suppression de beaucoup de r√®gles
//        for _, ruleID := range oldRules {
//            network.RemoveRule(ruleID)
//        }
//        builder.ClearConnectionCache() // Lib√©rer m√©moire
func (acb *AlphaChainBuilder) ClearConnectionCache() <span class="cov0" title="0">{
        acb.mutex.Lock()
        defer acb.mutex.Unlock()
        acb.connectionCache = make(map[string]bool)
}</span>

// GetConnectionCacheSize retourne la taille actuelle du cache de connexions.
//
// Utile pour monitoring et diagnostic de l'utilisation m√©moire.
//
// Retourne:
//   - Nombre d'entr√©es dans le cache (une par connexion parent‚Üíchild unique)
//
// Exemple:
//
//        size := builder.GetConnectionCacheSize()
//        fmt.Printf("Cache de connexions: %d entr√©es\n", size)
//        if size &gt; 10000 {
//            builder.ClearConnectionCache() // Nettoyage si trop grand
//        }
func (acb *AlphaChainBuilder) GetConnectionCacheSize() int <span class="cov0" title="0">{
        acb.mutex.RLock()
        defer acb.mutex.RUnlock()
        return len(acb.connectionCache)
}</span>

// GetMetrics retourne les m√©triques de performance du builder.
//
// Les m√©triques incluent:
//   - Nombre de cha√Ænes construites
//   - N≈ìuds cr√©√©s vs r√©utilis√©s
//   - Ratio de partage
//   - Hit rate du cache de hash
//   - Temps moyen de construction
//
// Retourne:
//   - Pointeur vers l'objet de m√©triques (non nil)
//
// Exemple:
//
//        metrics := builder.GetMetrics()
//        fmt.Printf("Cha√Ænes construites: %d\n", metrics.TotalChainsBuilt)
//        fmt.Printf("Ratio de partage: %.1f%%\n", metrics.SharingRatio * 100)
//        fmt.Printf("Cache hit rate: %.1f%%\n",
//            float64(metrics.HashCacheHits) /
//            float64(metrics.HashCacheHits + metrics.HashCacheMisses) * 100)
func (acb *AlphaChainBuilder) GetMetrics() *ChainBuildMetrics <span class="cov0" title="0">{
        return acb.metrics
}</span>

// isAlreadyConnected v√©rifie si un n≈ìud enfant est d√©j√† connect√© √† un n≈ìud parent
func isAlreadyConnected(parent Node, child Node) bool <span class="cov0" title="0">{
        if parent == nil || child == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">children := parent.GetChildren()
        childID := child.GetID()

        for _, c := range children </span><span class="cov0" title="0">{
                if c.GetID() == childID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// GetChainInfo retourne des informations d√©taill√©es sur la cha√Æne alpha.
//
// Utile pour debugging, logging, et visualisation de la structure de la cha√Æne.
//
// Retourne:
//   - Map contenant: rule_id, node_count, node_ids, hashes, final_node_id
//   - Map avec cl√© "error" si cha√Æne nil
//
// Exemple:
//
//        info := chain.GetChainInfo()
//        fmt.Printf("Cha√Æne pour r√®gle: %s\n", info["rule_id"])
//        fmt.Printf("Longueur: %d n≈ìuds\n", info["node_count"])
//        fmt.Printf("IDs: %v\n", info["node_ids"])
//        fmt.Printf("Hashes: %v\n", info["hashes"])
func (ac *AlphaChain) GetChainInfo() map[string]interface{} <span class="cov0" title="0">{
        if ac == nil </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "error": "chain is nil",
                }
        }</span>

        <span class="cov0" title="0">nodeIDs := make([]string, len(ac.Nodes))
        for i, node := range ac.Nodes </span><span class="cov0" title="0">{
                nodeIDs[i] = node.ID
        }</span>

        <span class="cov0" title="0">finalNodeID := ""
        if ac.FinalNode != nil </span><span class="cov0" title="0">{
                finalNodeID = ac.FinalNode.ID
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "rule_id":       ac.RuleID,
                "node_count":    len(ac.Nodes),
                "node_ids":      nodeIDs,
                "hashes":        ac.Hashes,
                "final_node_id": finalNodeID,
        }</span>
}

// ValidateChain v√©rifie que la cha√Æne alpha est valide et coh√©rente.
//
// V√©rifie:
//   - Cha√Æne non nil
//   - Au moins un n≈ìud pr√©sent
//   - len(Nodes) == len(Hashes)
//   - FinalNode correspond au dernier √©l√©ment de Nodes
//   - Tous les n≈ìuds ont un ID non vide
//
// Retourne:
//   - nil si cha√Æne valide
//   - error d√©crivant le probl√®me si invalide
//
// Exemple:
//
//        chain, err := builder.BuildChain(...)
//        if err := chain.ValidateChain(); err != nil {
//            log.Fatalf("Cha√Æne invalide: %v", err)
//        }
func (ac *AlphaChain) ValidateChain() error <span class="cov0" title="0">{
        if ac == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cha√Æne alpha nil")
        }</span>

        <span class="cov0" title="0">if len(ac.Nodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cha√Æne alpha vide")
        }</span>

        <span class="cov0" title="0">if len(ac.Nodes) != len(ac.Hashes) </span><span class="cov0" title="0">{
                return fmt.Errorf("incoh√©rence: %d n≈ìuds mais %d hashes", len(ac.Nodes), len(ac.Hashes))
        }</span>

        <span class="cov0" title="0">if ac.FinalNode == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("n≈ìud final nil")
        }</span>

        // V√©rifier que le n≈ìud final est bien le dernier de la liste
        <span class="cov0" title="0">if ac.FinalNode != ac.Nodes[len(ac.Nodes)-1] </span><span class="cov0" title="0">{
                return fmt.Errorf("le n≈ìud final ne correspond pas au dernier n≈ìud de la liste")
        }</span>

        // V√©rifier que tous les n≈ìuds sont non-nil
        <span class="cov0" title="0">for i, node := range ac.Nodes </span><span class="cov0" title="0">{
                if node == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("n≈ìud %d est nil", i)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CountSharedNodes retourne le nombre de n≈ìuds partag√©s dans la cha√Æne
// (n≈ìuds avec plus d'une r√©f√©rence dans le LifecycleManager)
func (acb *AlphaChainBuilder) CountSharedNodes(chain *AlphaChain) int <span class="cov0" title="0">{
        if chain == nil || acb.network.LifecycleManager == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">sharedCount := 0
        for _, node := range chain.Nodes </span><span class="cov0" title="0">{
                if lifecycle, exists := acb.network.LifecycleManager.GetNodeLifecycle(node.ID); exists </span><span class="cov0" title="0">{
                        if lifecycle.GetRefCount() &gt; 1 </span><span class="cov0" title="0">{
                                sharedCount++
                        }</span>
                }
        }

        <span class="cov0" title="0">return sharedCount</span>
}

// GetChainStats retourne des statistiques d√©taill√©es sur une cha√Æne alpha.
//
// Calcule et retourne:
//   - chain_length: Nombre total de n≈ìuds dans la cha√Æne
//   - shared_nodes: N≈ìuds avec RefCount &gt; 1
//   - new_nodes: N≈ìuds avec RefCount == 1
//   - sharing_ratio: Proportion de n≈ìuds partag√©s (0.0 √† 1.0)
//   - node_details: Liste des infos par n≈ìud (ID, RefCount, is_shared)
//
// Param√®tres:
//   - chain: Cha√Æne alpha √† analyser
//
// Retourne:
//   - Map avec statistiques d√©taill√©es
//   - Map avec cl√© "error" si cha√Æne nil
//
// Exemple:
//
//        chain, _ := builder.BuildChain(...)
//        stats := builder.GetChainStats(chain)
//        fmt.Printf("Longueur: %d\n", stats["chain_length"])
//        fmt.Printf("Partag√©s: %d\n", stats["shared_nodes"])
//        fmt.Printf("Nouveaux: %d\n", stats["new_nodes"])
//        fmt.Printf("Ratio: %.1f%%\n", stats["sharing_ratio"].(float64) * 100)
//
//        // D√©tails par n≈ìud
//        for _, detail := range stats["node_details"].([]map[string]interface{}) {
//            fmt.Printf("  N≈ìud %s: RefCount=%d, Partag√©=%v\n",
//                detail["node_id"], detail["ref_count"], detail["is_shared"])
//        }
func (acb *AlphaChainBuilder) GetChainStats(chain *AlphaChain) map[string]interface{} <span class="cov0" title="0">{
        if chain == nil </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "error": "chain is nil",
                }
        }</span>

        <span class="cov0" title="0">sharedNodes := acb.CountSharedNodes(chain)
        newNodes := len(chain.Nodes) - sharedNodes

        stats := map[string]interface{}{
                "total_nodes":  len(chain.Nodes),
                "shared_nodes": sharedNodes,
                "new_nodes":    newNodes,
                "rule_id":      chain.RuleID,
        }

        // Ajouter les d√©tails de chaque n≈ìud
        nodeDetails := make([]map[string]interface{}, len(chain.Nodes))
        for i, node := range chain.Nodes </span><span class="cov0" title="0">{
                refCount := 0
                if lifecycle, exists := acb.network.LifecycleManager.GetNodeLifecycle(node.ID); exists </span><span class="cov0" title="0">{
                        refCount = lifecycle.GetRefCount()
                }</span>

                <span class="cov0" title="0">nodeDetails[i] = map[string]interface{}{
                        "index":     i,
                        "node_id":   node.ID,
                        "hash":      chain.Hashes[i],
                        "ref_count": refCount,
                        "is_shared": refCount &gt; 1,
                        "is_final":  node == chain.FinalNode,
                }</span>
        }
        <span class="cov0" title="0">stats["node_details"] = nodeDetails

        return stats</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

// Package rete fournit l'impl√©mentation du r√©seau RETE pour l'√©valuation de r√®gles.
// Ce fichier contient des utilitaires pour extraire et analyser les conditions d'expressions complexes.
//
// Exemple d'utilisation:
//
//        // Expression AND: p.age &gt; 18 AND p.salary &gt;= 50000
//        expr := constraint.LogicalExpression{
//                Type: "logicalExpr",
//                Left: constraint.BinaryOperation{
//                        Type:     "binaryOperation",
//                        Left:     constraint.FieldAccess{Type: "fieldAccess", Object: "p", Field: "age"},
//                        Operator: "&gt;",
//                        Right:    constraint.NumberLiteral{Type: "numberLiteral", Value: 18},
//                },
//                Operations: []constraint.LogicalOperation{
//                        {
//                                Op: "AND",
//                                Right: constraint.BinaryOperation{
//                                        Type:     "binaryOperation",
//                                        Left:     constraint.FieldAccess{Type: "fieldAccess", Object: "p", Field: "salary"},
//                                        Operator: "&gt;=",
//                                        Right:    constraint.NumberLiteral{Type: "numberLiteral", Value: 50000},
//                                },
//                        },
//                },
//        }
//
//        // Extraire les conditions
//        conditions, opType, err := ExtractConditions(expr)
//        if err != nil {
//                log.Fatal(err)
//        }
//
//        fmt.Printf("Type d'op√©rateur: %s\n", opType) // Output: AND
//        fmt.Printf("Nombre de conditions: %d\n", len(conditions)) // Output: 2
//
//        // G√©n√©rer des repr√©sentations canoniques
//        for _, cond := range conditions {
//                canonical := CanonicalString(cond)
//                fmt.Printf("Condition: %s\n", canonical)
//                fmt.Printf("Hash: %s\n", cond.Hash)
//        }
//
//        // D√©dupliquer les conditions
//        uniqueConditions := DeduplicateConditions(conditions)
package rete

import (
        "crypto/sha256"
        "fmt"
        "sort"
        "strings"

        "github.com/treivax/tsd/constraint"
)

// SimpleCondition repr√©sente une condition atomique extraite d'une expression complexe
type SimpleCondition struct {
        Type     string      `json:"type"`     // Type de condition: binaryOperation, comparison, arithmetic, etc.
        Left     interface{} `json:"left"`     // Op√©rande gauche
        Operator string      `json:"operator"` // Op√©rateur
        Right    interface{} `json:"right"`    // Op√©rande droite
        Hash     string      `json:"hash"`     // Hash unique calcul√© automatiquement
}

// NewSimpleCondition cr√©e une nouvelle condition simple avec hash calcul√©
func NewSimpleCondition(condType string, left interface{}, operator string, right interface{}) SimpleCondition <span class="cov0" title="0">{
        cond := SimpleCondition{
                Type:     condType,
                Left:     left,
                Operator: operator,
                Right:    right,
        }
        cond.Hash = computeHash(cond)
        return cond
}</span>

// computeHash calcule le hash SHA-256 d'une condition
func computeHash(condition SimpleCondition) string <span class="cov0" title="0">{
        canonical := CanonicalString(condition)
        hash := sha256.Sum256([]byte(canonical))
        return fmt.Sprintf("%x", hash)
}</span>

// ExtractConditions extrait toutes les conditions simples d'une expression complexe
// Retourne: liste de conditions, type d'op√©rateur principal (AND/OR/SINGLE), erreur
func ExtractConditions(expr interface{}) ([]SimpleCondition, string, error) <span class="cov0" title="0">{
        switch e := expr.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return extractFromMap(e)</span>

        case constraint.BinaryOperation:<span class="cov0" title="0">
                cond := NewSimpleCondition("binaryOperation", e.Left, e.Operator, e.Right)
                return []SimpleCondition{cond}, "SINGLE", nil</span>

        case constraint.LogicalExpression:<span class="cov0" title="0">
                return extractFromLogicalExpression(e)</span>

        case constraint.Constraint:<span class="cov0" title="0">
                return extractFromConstraint(e)</span>

        case constraint.FieldAccess:<span class="cov0" title="0">
                // Un acc√®s de champ seul n'est pas une condition
                return []SimpleCondition{}, "NONE", nil</span>

        case constraint.NumberLiteral, constraint.StringLiteral, constraint.BooleanLiteral:<span class="cov0" title="0">
                // Les litt√©raux seuls ne sont pas des conditions
                return []SimpleCondition{}, "NONE", nil</span>

        default:<span class="cov0" title="0">
                return nil, "", fmt.Errorf("type d'expression non support√©: %T", expr)</span>
        }
}

// extractFromMap extrait les conditions d'une expression sous forme de map
func extractFromMap(expr map[string]interface{}) ([]SimpleCondition, string, error) <span class="cov0" title="0">{
        exprType, ok := expr["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("type d'expression manquant")
        }</span>

        <span class="cov0" title="0">switch exprType </span>{
        case "binaryOperation", "binary_op", "comparison":<span class="cov0" title="0">
                operator, ok := expr["operator"].(string)
                if !ok </span><span class="cov0" title="0">{
                        if operator, ok = expr["op"].(string); !ok </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("op√©rateur manquant")
                        }</span>
                }
                <span class="cov0" title="0">cond := NewSimpleCondition("binaryOperation", expr["left"], operator, expr["right"])
                return []SimpleCondition{cond}, "SINGLE", nil</span>

        case "logicalExpression", "logical_op", "logicalExpr":<span class="cov0" title="0">
                return extractFromLogicalExpressionMap(expr)</span>

        case "constraint":<span class="cov0" title="0">
                // Les contraintes dans les maps peuvent avoir diff√©rentes structures
                // On essaie d'extraire left/operator/right directement
                if left, ok := expr["left"]; ok </span><span class="cov0" title="0">{
                        operator, _ := expr["operator"].(string)
                        right := expr["right"]
                        cond := NewSimpleCondition("constraint", left, operator, right)
                        return []SimpleCondition{cond}, "SINGLE", nil
                }</span>
                <span class="cov0" title="0">return []SimpleCondition{}, "NONE", nil</span>

        case "fieldAccess":<span class="cov0" title="0">
                return []SimpleCondition{}, "NONE", nil</span>

        case "literal", "numberLiteral", "stringLiteral", "booleanLiteral":<span class="cov0" title="0">
                return []SimpleCondition{}, "NONE", nil</span>

        default:<span class="cov0" title="0">
                return nil, "", fmt.Errorf("type d'expression map non support√©: %s", exprType)</span>
        }
}

// extractFromLogicalExpression extrait les conditions d'une expression logique
func extractFromLogicalExpression(expr constraint.LogicalExpression) ([]SimpleCondition, string, error) <span class="cov0" title="0">{
        allConditions := []SimpleCondition{}
        operatorType := ""

        // Extraire les conditions du c√¥t√© gauche
        leftConds, _, err := ExtractConditions(expr.Left)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("erreur extraction left: %w", err)
        }</span>
        <span class="cov0" title="0">allConditions = append(allConditions, leftConds...)

        // Traiter toutes les op√©rations
        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                rightConds, _, err := ExtractConditions(op.Right)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("erreur extraction right: %w", err)
                }</span>
                <span class="cov0" title="0">allConditions = append(allConditions, rightConds...)

                // D√©terminer le type d'op√©rateur principal
                if operatorType == "" </span><span class="cov0" title="0">{
                        operatorType = op.Op
                }</span> else<span class="cov0" title="0"> if operatorType != op.Op </span><span class="cov0" title="0">{
                        // M√©lange d'op√©rateurs - retourner "MIXED"
                        operatorType = "MIXED"
                }</span>
        }

        <span class="cov0" title="0">if operatorType == "" </span><span class="cov0" title="0">{
                operatorType = "SINGLE"
        }</span>

        <span class="cov0" title="0">return allConditions, operatorType, nil</span>
}

// extractFromLogicalExpressionMap extrait les conditions d'une expression logique (format map)
func extractFromLogicalExpressionMap(expr map[string]interface{}) ([]SimpleCondition, string, error) <span class="cov0" title="0">{
        allConditions := []SimpleCondition{}
        operatorType := ""

        // Extraire les conditions du c√¥t√© gauche
        left, ok := expr["left"]
        if !ok </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("left manquant dans logicalExpression")
        }</span>

        <span class="cov0" title="0">leftConds, _, err := ExtractConditions(left)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("erreur extraction left: %w", err)
        }</span>
        <span class="cov0" title="0">allConditions = append(allConditions, leftConds...)

        // Traiter toutes les op√©rations
        operations, ok := expr["operations"]
        if !ok </span><span class="cov0" title="0">{
                return allConditions, "SINGLE", nil
        }</span>

        // Supporter []interface{}, []map[string]interface{} et []constraint.LogicalOperation
        // Essayer []map[string]interface{} en premier (type le plus courant du parser)
        <span class="cov0" title="0">if opsMapList, ok := operations.([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                for _, opMap := range opsMapList </span><span class="cov0" title="0">{
                        op, ok := opMap["op"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("op manquant dans operation")
                        }</span>

                        <span class="cov0" title="0">right, ok := opMap["right"]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("right manquant dans operation")
                        }</span>

                        <span class="cov0" title="0">rightConds, _, err := ExtractConditions(right)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("erreur extraction right: %w", err)
                        }</span>
                        <span class="cov0" title="0">allConditions = append(allConditions, rightConds...)

                        // D√©terminer le type d'op√©rateur principal
                        if operatorType == "" </span><span class="cov0" title="0">{
                                operatorType = op
                        }</span> else<span class="cov0" title="0"> if operatorType != op </span><span class="cov0" title="0">{
                                operatorType = "MIXED"
                        }</span>
                }
        } else<span class="cov0" title="0"> if opsList, ok := operations.([]interface{}); ok </span><span class="cov0" title="0">{
                for _, opInterface := range opsList </span><span class="cov0" title="0">{
                        opMap, ok := opInterface.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("operation doit √™tre une map")
                        }</span>

                        <span class="cov0" title="0">op, ok := opMap["op"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("op manquant dans operation")
                        }</span>

                        <span class="cov0" title="0">right, ok := opMap["right"]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("right manquant dans operation")
                        }</span>

                        <span class="cov0" title="0">rightConds, _, err := ExtractConditions(right)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("erreur extraction right: %w", err)
                        }</span>
                        <span class="cov0" title="0">allConditions = append(allConditions, rightConds...)

                        // D√©terminer le type d'op√©rateur principal
                        if operatorType == "" </span><span class="cov0" title="0">{
                                operatorType = op
                        }</span> else<span class="cov0" title="0"> if operatorType != op </span><span class="cov0" title="0">{
                                operatorType = "MIXED"
                        }</span>
                }
        } else<span class="cov0" title="0"> if logicalOps, ok := operations.([]constraint.LogicalOperation); ok </span><span class="cov0" title="0">{
                // Supporter le type constraint.LogicalOperation directement
                for _, op := range logicalOps </span><span class="cov0" title="0">{
                        rightConds, _, err := ExtractConditions(op.Right)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("erreur extraction right: %w", err)
                        }</span>
                        <span class="cov0" title="0">allConditions = append(allConditions, rightConds...)

                        // D√©terminer le type d'op√©rateur principal
                        if operatorType == "" </span><span class="cov0" title="0">{
                                operatorType = op.Op
                        }</span> else<span class="cov0" title="0"> if operatorType != op.Op </span><span class="cov0" title="0">{
                                operatorType = "MIXED"
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return nil, "", fmt.Errorf("operations doit √™tre un tableau ([]interface{}, []map[string]interface{} ou []LogicalOperation)")
        }</span>

        <span class="cov0" title="0">if operatorType == "" </span><span class="cov0" title="0">{
                operatorType = "SINGLE"
        }</span>

        <span class="cov0" title="0">return allConditions, operatorType, nil</span>
}

// extractFromNOTConstraint extrait les conditions d'une contrainte NOT
func extractFromNOTConstraint(expr constraint.NotConstraint) ([]SimpleCondition, string, error) <span class="cov0" title="0">{
        // Pour les contraintes NOT, on retourne une condition sp√©ciale
        // qui sera g√©r√©e diff√©remment par le constructeur de cha√Æne
        cond := NewSimpleCondition("not", expr.Expression, "NOT", nil)
        return []SimpleCondition{cond}, "NOT", nil
}</span>

// extractFromNOTConstraintMap extrait les conditions d'une contrainte NOT (format map)
func extractFromNOTConstraintMap(expr map[string]interface{}) ([]SimpleCondition, string, error) <span class="cov0" title="0">{
        expression, ok := expr["expression"]
        if !ok </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("expression manquant dans notConstraint")
        }</span>

        // Pour les contraintes NOT, on retourne une condition sp√©ciale
        <span class="cov0" title="0">cond := NewSimpleCondition("not", expression, "NOT", nil)
        return []SimpleCondition{cond}, "NOT", nil</span>
}

// extractFromConstraint extrait les conditions d'une contrainte
func extractFromConstraint(c constraint.Constraint) ([]SimpleCondition, string, error) <span class="cov0" title="0">{
        // Les contraintes peuvent avoir left/operator/right directement
        if c.Left != nil &amp;&amp; c.Operator != "" </span><span class="cov0" title="0">{
                cond := NewSimpleCondition("constraint", c.Left, c.Operator, c.Right)
                return []SimpleCondition{cond}, "SINGLE", nil
        }</span>
        <span class="cov0" title="0">return []SimpleCondition{}, "NONE", nil</span>
}

// CanonicalString g√©n√®re une repr√©sentation textuelle unique et d√©terministe d'une condition
// Format: "type(left,operator,right)"
func CanonicalString(condition SimpleCondition) string <span class="cov0" title="0">{
        leftStr := canonicalValue(condition.Left)
        rightStr := canonicalValue(condition.Right)

        return fmt.Sprintf("%s(%s,%s,%s)",
                condition.Type,
                leftStr,
                condition.Operator,
                rightStr,
        )
}</span>

// canonicalValue convertit une valeur en repr√©sentation canonique
func canonicalValue(value interface{}) string <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return canonicalMap(v)</span>

        case constraint.FieldAccess:<span class="cov0" title="0">
                return fmt.Sprintf("fieldAccess(%s,%s)", v.Object, v.Field)</span>

        case constraint.NumberLiteral:<span class="cov0" title="0">
                return fmt.Sprintf("literal(%v)", v.Value)</span>

        case constraint.StringLiteral:<span class="cov0" title="0">
                return fmt.Sprintf("literal(%s)", v.Value)</span>

        case constraint.BooleanLiteral:<span class="cov0" title="0">
                return fmt.Sprintf("literal(%t)", v.Value)</span>

        case constraint.BinaryOperation:<span class="cov0" title="0">
                leftStr := canonicalValue(v.Left)
                rightStr := canonicalValue(v.Right)
                return fmt.Sprintf("binaryOp(%s,%s,%s)", leftStr, v.Operator, rightStr)</span>

        case constraint.LogicalExpression:<span class="cov0" title="0">
                // Pour les expressions logiques, cr√©er une repr√©sentation ordonn√©e
                parts := []string{canonicalValue(v.Left)}
                for _, op := range v.Operations </span><span class="cov0" title="0">{
                        parts = append(parts, fmt.Sprintf("%s:%s", op.Op, canonicalValue(op.Right)))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("logical(%s)", strings.Join(parts, ","))</span>

        case string:<span class="cov0" title="0">
                return fmt.Sprintf("string(%s)", v)</span>

        case int, int32, int64:<span class="cov0" title="0">
                return fmt.Sprintf("int(%v)", v)</span>

        case float32, float64:<span class="cov0" title="0">
                return fmt.Sprintf("float(%v)", v)</span>

        case bool:<span class="cov0" title="0">
                return fmt.Sprintf("bool(%v)", v)</span>

        case nil:<span class="cov0" title="0">
                return "nil"</span>

        default:<span class="cov0" title="0">
                return fmt.Sprintf("unknown(%T:%v)", v, v)</span>
        }
}

// canonicalMap convertit une map en repr√©sentation canonique tri√©e
func canonicalMap(m map[string]interface{}) string <span class="cov0" title="0">{
        // R√©cup√©rer le type
        mapType, ok := m["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                mapType = "map"
        }</span>

        <span class="cov0" title="0">switch mapType </span>{
        case "fieldAccess":<span class="cov0" title="0">
                obj, _ := m["object"].(string)
                field, _ := m["field"].(string)
                return fmt.Sprintf("fieldAccess(%s,%s)", obj, field)</span>

        case "literal", "numberLiteral", "stringLiteral", "booleanLiteral":<span class="cov0" title="0">
                value := m["value"]
                return fmt.Sprintf("literal(%v)", value)</span>

        case "binaryOperation", "binary_op", "comparison":<span class="cov0" title="0">
                leftStr := canonicalValue(m["left"])
                operator, _ := m["operator"].(string)
                if operator == "" </span><span class="cov0" title="0">{
                        operator, _ = m["op"].(string)
                }</span>
                <span class="cov0" title="0">rightStr := canonicalValue(m["right"])
                return fmt.Sprintf("binaryOp(%s,%s,%s)", leftStr, operator, rightStr)</span>

        case "logicalExpression", "logical_op", "logicalExpr":<span class="cov0" title="0">
                leftStr := canonicalValue(m["left"])
                operations, ok := m["operations"].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Sprintf("logical(%s)", leftStr)
                }</span>

                <span class="cov0" title="0">parts := []string{leftStr}
                for _, opInterface := range operations </span><span class="cov0" title="0">{
                        opMap, ok := opInterface.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">op, _ := opMap["op"].(string)
                        right := opMap["right"]
                        parts = append(parts, fmt.Sprintf("%s:%s", op, canonicalValue(right)))</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("logical(%s)", strings.Join(parts, ","))</span>

        default:<span class="cov0" title="0">
                // Pour les maps g√©n√©riques, trier les cl√©s pour un ordre d√©terministe
                keys := make([]string, 0, len(m))
                for k := range m </span><span class="cov0" title="0">{
                        keys = append(keys, k)
                }</span>
                <span class="cov0" title="0">sort.Strings(keys)

                pairs := make([]string, 0, len(keys))
                for _, k := range keys </span><span class="cov0" title="0">{
                        pairs = append(pairs, fmt.Sprintf("%s:%s", k, canonicalValue(m[k])))
                }</span>

                <span class="cov0" title="0">return fmt.Sprintf("%s{%s}", mapType, strings.Join(pairs, ","))</span>
        }
}

// CompareConditions compare deux conditions pour l'√©galit√©
func CompareConditions(c1, c2 SimpleCondition) bool <span class="cov0" title="0">{
        return c1.Hash == c2.Hash
}</span>

// DeduplicateConditions supprime les conditions dupliqu√©es d'une liste
func DeduplicateConditions(conditions []SimpleCondition) []SimpleCondition <span class="cov0" title="0">{
        seen := make(map[string]bool)
        result := []SimpleCondition{}

        for _, cond := range conditions </span><span class="cov0" title="0">{
                if !seen[cond.Hash] </span><span class="cov0" title="0">{
                        seen[cond.Hash] = true
                        result = append(result, cond)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// IsCommutative retourne true si l'op√©rateur est commutatif
// Les op√©rateurs commutatifs (AND, OR, +, *, ==, !=) peuvent √™tre r√©ordonn√©s
// Les op√©rateurs non-commutatifs (-, /, &lt;, &gt;, &lt;=, &gt;=, s√©quences) doivent pr√©server l'ordre
func IsCommutative(operator string) bool <span class="cov0" title="0">{
        commutativeOps := map[string]bool{
                "AND": true,
                "OR":  true,
                "&amp;&amp;":  true,
                "||":  true,
                "+":   true,
                "*":   true,
                "==":  true,
                "!=":  true,
                "&lt;&gt;":  true,
        }
        return commutativeOps[operator]
}</span>

// NormalizeConditions trie les conditions dans un ordre canonique d√©terministe
// Si l'op√©rateur est commutatif (AND, OR), les conditions sont tri√©es
// Si l'op√©rateur est non-commutatif, l'ordre est pr√©serv√©
func NormalizeConditions(conditions []SimpleCondition, operator string) []SimpleCondition <span class="cov0" title="0">{
        // Si pas de conditions ou une seule condition, retourner tel quel
        if len(conditions) &lt;= 1 </span><span class="cov0" title="0">{
                return conditions
        }</span>

        // Si l'op√©rateur n'est pas commutatif, pr√©server l'ordre original
        <span class="cov0" title="0">if !IsCommutative(operator) </span><span class="cov0" title="0">{
                return conditions
        }</span>

        // Cr√©er une copie pour ne pas modifier l'original
        <span class="cov0" title="0">normalized := make([]SimpleCondition, len(conditions))
        copy(normalized, conditions)

        // Trier par repr√©sentation canonique pour un ordre d√©terministe
        sort.Slice(normalized, func(i, j int) bool </span><span class="cov0" title="0">{
                return CanonicalString(normalized[i]) &lt; CanonicalString(normalized[j])
        }</span>)

        <span class="cov0" title="0">return normalized</span>
}

// NormalizeExpression normalise une expression en appliquant un ordre canonique
// aux conditions quand l'op√©rateur est commutatif
// NormalizeORExpression normalise une expression OR en triant ses termes dans un ordre canonique.
// Cette fonction extrait les termes OR, les trie et reconstruit l'expression normalis√©e
// SANS la d√©composer en cha√Æne - l'expression OR reste un seul n≈ìud atomique.
//
// Param√®tres:
//   - expr: expression √† normaliser (LogicalExpression ou map avec operations OR)
//
// Retourne:
//   - interface{}: expression OR normalis√©e avec termes tri√©s
//   - error: erreur si l'expression n'est pas une expression OR valide
//
// Exemple:
//
//        Input:  p.status == "VIP" OR p.age &gt; 18
//        Output: p.age &gt; 18 OR p.status == "VIP"  (ordre alphab√©tique des champs)
func NormalizeORExpression(expr interface{}) (interface{}, error) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression nil")
        }</span>

        // V√©rifier que c'est bien une expression OR
        <span class="cov0" title="0">exprType, err := AnalyzeExpression(expr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur analyse expression: %w", err)
        }</span>

        <span class="cov0" title="0">if exprType != ExprTypeOR &amp;&amp; exprType != ExprTypeMixed </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression n'est pas de type OR ou Mixed: %s", exprType)
        }</span>

        <span class="cov0" title="0">switch e := expr.(type) </span>{
        case constraint.LogicalExpression:<span class="cov0" title="0">
                return normalizeORLogicalExpression(e)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return normalizeORExpressionMap(e)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("type d'expression non support√© pour normalisation OR: %T", expr)</span>
        }
}

// normalizeORLogicalExpression normalise une LogicalExpression contenant des OR
func normalizeORLogicalExpression(expr constraint.LogicalExpression) (constraint.LogicalExpression, error) <span class="cov0" title="0">{
        // Extraire tous les termes OR
        terms := []interface{}{expr.Left}

        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                opStr := strings.ToUpper(op.Op)
                if opStr == "OR" || opStr == "||" </span><span class="cov0" title="0">{
                        terms = append(terms, op.Right)
                }</span>
        }

        // Convertir chaque terme en string canonique pour le tri
        <span class="cov0" title="0">type termWithCanonical struct {
                term      interface{}
                canonical string
        }

        termsWithCanonical := make([]termWithCanonical, len(terms))
        for i, term := range terms </span><span class="cov0" title="0">{
                // Cr√©er une repr√©sentation canonique pour le tri
                canonical := canonicalValue(term)
                termsWithCanonical[i] = termWithCanonical{
                        term:      term,
                        canonical: canonical,
                }
        }</span>

        // Trier par repr√©sentation canonique
        <span class="cov0" title="0">sort.Slice(termsWithCanonical, func(i, j int) bool </span><span class="cov0" title="0">{
                return termsWithCanonical[i].canonical &lt; termsWithCanonical[j].canonical
        }</span>)

        // Reconstruire l'expression avec les termes tri√©s
        <span class="cov0" title="0">if len(termsWithCanonical) == 0 </span><span class="cov0" title="0">{
                return constraint.LogicalExpression{}, fmt.Errorf("aucun terme trouv√©")
        }</span>

        <span class="cov0" title="0">normalized := constraint.LogicalExpression{
                Type: "logicalExpr",
                Left: termsWithCanonical[0].term,
        }

        // Reconstruire les op√©rations OR
        for i := 1; i &lt; len(termsWithCanonical); i++ </span><span class="cov0" title="0">{
                normalized.Operations = append(normalized.Operations, constraint.LogicalOperation{
                        Op:    "OR",
                        Right: termsWithCanonical[i].term,
                })
        }</span>

        <span class="cov0" title="0">return normalized, nil</span>
}

// normalizeORExpressionMap normalise une expression OR au format map
func normalizeORExpressionMap(expr map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Extraire tous les termes OR
        terms := []interface{}{}

        if left, ok := expr["left"]; ok </span><span class="cov0" title="0">{
                terms = append(terms, left)
        }</span>

        <span class="cov0" title="0">if operations, ok := expr["operations"]; ok </span><span class="cov0" title="0">{
                // Supporter diff√©rents formats d'op√©rations
                if opsList, ok := operations.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, opInterface := range opsList </span><span class="cov0" title="0">{
                                if opMap, ok := opInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if op, ok := opMap["op"].(string); ok </span><span class="cov0" title="0">{
                                                opStr := strings.ToUpper(op)
                                                if opStr == "OR" || opStr == "||" </span><span class="cov0" title="0">{
                                                        if right, ok := opMap["right"]; ok </span><span class="cov0" title="0">{
                                                                terms = append(terms, right)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                } else<span class="cov0" title="0"> if opsMapList, ok := operations.([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                        for _, opMap := range opsMapList </span><span class="cov0" title="0">{
                                if op, ok := opMap["op"].(string); ok </span><span class="cov0" title="0">{
                                        opStr := strings.ToUpper(op)
                                        if opStr == "OR" || opStr == "||" </span><span class="cov0" title="0">{
                                                if right, ok := opMap["right"]; ok </span><span class="cov0" title="0">{
                                                        terms = append(terms, right)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">if len(terms) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aucun terme OR trouv√©")
        }</span>

        // Convertir chaque terme en string canonique pour le tri
        <span class="cov0" title="0">type termWithCanonical struct {
                term      interface{}
                canonical string
        }

        termsWithCanonical := make([]termWithCanonical, len(terms))
        for i, term := range terms </span><span class="cov0" title="0">{
                canonical := canonicalValue(term)
                termsWithCanonical[i] = termWithCanonical{
                        term:      term,
                        canonical: canonical,
                }
        }</span>

        // Trier par repr√©sentation canonique
        <span class="cov0" title="0">sort.Slice(termsWithCanonical, func(i, j int) bool </span><span class="cov0" title="0">{
                return termsWithCanonical[i].canonical &lt; termsWithCanonical[j].canonical
        }</span>)

        // Reconstruire l'expression map avec les termes tri√©s
        <span class="cov0" title="0">normalized := map[string]interface{}{
                "type": expr["type"],
                "left": termsWithCanonical[0].term,
        }

        // Reconstruire les op√©rations OR
        normalizedOps := make([]map[string]interface{}, 0)
        for i := 1; i &lt; len(termsWithCanonical); i++ </span><span class="cov0" title="0">{
                normalizedOps = append(normalizedOps, map[string]interface{}{
                        "op":    "OR",
                        "right": termsWithCanonical[i].term,
                })
        }</span>

        <span class="cov0" title="0">if len(normalizedOps) &gt; 0 </span><span class="cov0" title="0">{
                normalized["operations"] = normalizedOps
        }</span>

        <span class="cov0" title="0">return normalized, nil</span>
}

func NormalizeExpression(expr interface{}) (interface{}, error) <span class="cov0" title="0">{
        switch e := expr.(type) </span>{
        case constraint.LogicalExpression:<span class="cov0" title="0">
                return normalizeLogicalExpression(e)</span>

        case constraint.BinaryOperation:<span class="cov0" title="0">
                // Les op√©rations binaires simples ne n√©cessitent pas de normalisation
                // mais on peut normaliser r√©cursivement les sous-expressions
                return e, nil</span>

        case constraint.Constraint:<span class="cov0" title="0">
                // Les contraintes simples ne n√©cessitent pas de normalisation
                return e, nil</span>

        case map[string]interface{}:<span class="cov0" title="0">
                return normalizeExpressionMap(e)</span>

        default:<span class="cov0" title="0">
                // Pour les autres types (literals, field access), retourner tel quel
                return expr, nil</span>
        }
}

// normalizeLogicalExpression normalise une expression logique
func normalizeLogicalExpression(expr constraint.LogicalExpression) (constraint.LogicalExpression, error) <span class="cov0" title="0">{
        // Si pas d'op√©rations, retourner tel quel
        if len(expr.Operations) == 0 </span><span class="cov0" title="0">{
                return expr, nil
        }</span>

        // D√©terminer si tous les op√©rateurs sont identiques et commutatifs
        <span class="cov0" title="0">firstOp := expr.Operations[0].Op
        allSame := true
        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                if op.Op != firstOp </span><span class="cov0" title="0">{
                        allSame = false
                        break</span>
                }
        }

        // Si les op√©rateurs ne sont pas tous identiques ou si non-commutatif, retourner tel quel
        <span class="cov0" title="0">if !allSame || !IsCommutative(firstOp) </span><span class="cov0" title="0">{
                return expr, nil
        }</span>

        // Extraire toutes les conditions
        <span class="cov0" title="0">conditions, _, err := extractFromLogicalExpression(expr)
        if err != nil </span><span class="cov0" title="0">{
                return expr, err
        }</span>

        // Normaliser l'ordre des conditions
        <span class="cov0" title="0">normalized := NormalizeConditions(conditions, firstOp)

        // Reconstruire l'expression logique avec les conditions normalis√©es
        if len(normalized) == 0 </span><span class="cov0" title="0">{
                return expr, nil
        }</span>

        // Reconstruire l'expression avec les conditions normalis√©es
        <span class="cov0" title="0">rebuiltExpr, err := rebuildLogicalExpression(normalized, firstOp)
        if err != nil </span><span class="cov0" title="0">{
                return expr, err
        }</span>

        <span class="cov0" title="0">return rebuiltExpr, nil</span>
}

// rebuildLogicalExpression reconstruit une expression logique √† partir de conditions normalis√©es
func rebuildLogicalExpression(conditions []SimpleCondition, operator string) (constraint.LogicalExpression, error) <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return constraint.LogicalExpression{}, fmt.Errorf("cannot rebuild expression from empty conditions")
        }</span>

        // Cas simple : une seule condition
        <span class="cov0" title="0">if len(conditions) == 1 </span><span class="cov0" title="0">{
                cond := conditions[0]
                return constraint.LogicalExpression{
                        Type:       "logicalExpr",
                        Left:       rebuildConditionAsExpression(cond),
                        Operations: []constraint.LogicalOperation{},
                }, nil
        }</span>

        // Cas avec plusieurs conditions : cr√©er une cha√Æne d'op√©rations
        // Le premier √©l√©ment devient Left, les autres deviennent Operations
        <span class="cov0" title="0">rebuiltExpr := constraint.LogicalExpression{
                Type:       "logicalExpr",
                Left:       rebuildConditionAsExpression(conditions[0]),
                Operations: make([]constraint.LogicalOperation, 0, len(conditions)-1),
        }

        // Ajouter les conditions restantes comme op√©rations
        for i := 1; i &lt; len(conditions); i++ </span><span class="cov0" title="0">{
                rebuiltExpr.Operations = append(rebuiltExpr.Operations, constraint.LogicalOperation{
                        Op:    operator,
                        Right: rebuildConditionAsExpression(conditions[i]),
                })
        }</span>

        <span class="cov0" title="0">return rebuiltExpr, nil</span>
}

// rebuildConditionAsExpression convertit une SimpleCondition en expression utilisable
func rebuildConditionAsExpression(cond SimpleCondition) interface{} <span class="cov0" title="0">{
        // Cr√©er une BinaryOperation √† partir de la SimpleCondition
        return constraint.BinaryOperation{
                Type:     cond.Type,
                Left:     cond.Left,
                Operator: cond.Operator,
                Right:    cond.Right,
        }
}</span>

// rebuildLogicalExpressionMap reconstruit une expression map √† partir de conditions normalis√©es
func rebuildLogicalExpressionMap(conditions []SimpleCondition, operator string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if len(conditions) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot rebuild expression from empty conditions")
        }</span>

        // Cas simple : une seule condition
        <span class="cov0" title="0">if len(conditions) == 1 </span><span class="cov0" title="0">{
                cond := conditions[0]
                return map[string]interface{}{
                        "type":       "logicalExpr",
                        "left":       rebuildConditionAsMap(cond),
                        "operations": []interface{}{},
                }, nil
        }</span>

        // Cas avec plusieurs conditions
        <span class="cov0" title="0">operations := make([]interface{}, 0, len(conditions)-1)
        for i := 1; i &lt; len(conditions); i++ </span><span class="cov0" title="0">{
                operations = append(operations, map[string]interface{}{
                        "op":    operator,
                        "right": rebuildConditionAsMap(conditions[i]),
                })
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type":       "logicalExpr",
                "left":       rebuildConditionAsMap(conditions[0]),
                "operations": operations,
        }, nil</span>
}

// rebuildConditionAsMap convertit une SimpleCondition en map
func rebuildConditionAsMap(cond SimpleCondition) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":     cond.Type,
                "left":     cond.Left,
                "operator": cond.Operator,
                "right":    cond.Right,
        }
}</span>

// normalizeExpressionMap normalise une expression sous forme de map
func normalizeExpressionMap(expr map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        exprType, ok := expr["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return expr, nil
        }</span>

        <span class="cov0" title="0">switch exprType </span>{
        case "logicalExpression", "logical_op", "logicalExpr":<span class="cov0" title="0">
                // Extraire les conditions
                conditions, opType, err := extractFromLogicalExpressionMap(expr)
                if err != nil </span><span class="cov0" title="0">{
                        return expr, err
                }</span>

                // Si l'op√©rateur est commutatif, normaliser et reconstruire
                <span class="cov0" title="0">if IsCommutative(opType) </span><span class="cov0" title="0">{
                        normalized := NormalizeConditions(conditions, opType)
                        rebuiltExpr, err := rebuildLogicalExpressionMap(normalized, opType)
                        if err != nil </span><span class="cov0" title="0">{
                                return expr, err
                        }</span>
                        <span class="cov0" title="0">return rebuiltExpr, nil</span>
                }
                <span class="cov0" title="0">return expr, nil</span>

        case "binaryOperation", "binary_op", "comparison":<span class="cov0" title="0">
                // Les op√©rations binaires simples ne n√©cessitent pas de normalisation
                return expr, nil</span>

        default:<span class="cov0" title="0">
                return expr, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "sort"
        "sync"
)

// AlphaSharingRegistry g√®re le partage des AlphaNodes entre plusieurs r√®gles
// qui ont des conditions alpha identiques
type AlphaSharingRegistry struct {
        // Map[ConditionHash] -&gt; AlphaNode
        sharedAlphaNodes map[string]*AlphaNode
        // Cache pour les hash de conditions (Map[conditionJSON] -&gt; hash)
        hashCache map[string]string
        // Cache LRU pour les hash (si configur√©)
        lruHashCache *LRUCache
        // Configuration de performance
        config *ChainPerformanceConfig
        // M√©triques de performance
        metrics *ChainBuildMetrics
        mutex   sync.RWMutex
}

// NewAlphaSharingRegistry cr√©e un nouveau registre de partage d'AlphaNodes
// Utilise la configuration par d√©faut
func NewAlphaSharingRegistry() *AlphaSharingRegistry <span class="cov0" title="0">{
        config := DefaultChainPerformanceConfig()
        return NewAlphaSharingRegistryWithConfig(config, NewChainBuildMetrics())
}</span>

// NewAlphaSharingRegistryWithMetrics cr√©e un registre avec des m√©triques partag√©es
// Utilise la configuration par d√©faut
func NewAlphaSharingRegistryWithMetrics(metrics *ChainBuildMetrics) *AlphaSharingRegistry <span class="cov0" title="0">{
        config := DefaultChainPerformanceConfig()
        return NewAlphaSharingRegistryWithConfig(config, metrics)
}</span>

// NewAlphaSharingRegistryWithConfig cr√©e un registre avec une configuration personnalis√©e
func NewAlphaSharingRegistryWithConfig(config *ChainPerformanceConfig, metrics *ChainBuildMetrics) *AlphaSharingRegistry <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultChainPerformanceConfig()
        }</span>
        <span class="cov8" title="1">if metrics == nil </span><span class="cov0" title="0">{
                metrics = NewChainBuildMetrics()
        }</span>

        <span class="cov8" title="1">asr := &amp;AlphaSharingRegistry{
                sharedAlphaNodes: make(map[string]*AlphaNode),
                config:           config,
                metrics:          metrics,
        }

        // Initialiser le cache appropri√© selon la configuration
        if config.HashCacheEnabled </span><span class="cov8" title="1">{
                if config.HashCacheEviction == EvictionPolicyLRU </span><span class="cov8" title="1">{
                        // Utiliser le cache LRU
                        asr.lruHashCache = NewLRUCache(config.HashCacheMaxSize, config.HashCacheTTL)
                }</span> else<span class="cov0" title="0"> {
                        // Utiliser le simple map pour EvictionPolicyNone
                        asr.hashCache = make(map[string]string)
                }</span>
        }

        <span class="cov8" title="1">return asr</span>
}

// ConditionHash calcule un hash unique pour une condition alpha
// Deux conditions identiques produiront le m√™me hash
func ConditionHash(condition interface{}, variableName string) (string, error) <span class="cov0" title="0">{
        // D√©baller la condition si elle est wrapp√©e (pour le partage entre r√®gles simples et cha√Ænes)
        unwrapped := normalizeConditionForSharing(condition)

        // Normaliser la condition pour assurer un hash coh√©rent
        normalized, err := normalizeCondition(unwrapped)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("erreur normalisation condition: %w", err)
        }</span>

        // Cr√©er une structure canonique incluant le nom de variable
        // car une condition sur "p" vs "q" est diff√©rente
        <span class="cov0" title="0">canonical := map[string]interface{}{
                "condition": normalized,
                "variable":  variableName,
        }

        // S√©rialiser en JSON avec cl√©s tri√©es pour coh√©rence
        jsonBytes, err := json.Marshal(canonical)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("erreur s√©rialisation condition: %w", err)
        }</span>

        // Calculer le hash SHA-256
        <span class="cov0" title="0">hash := sha256.Sum256(jsonBytes)
        return fmt.Sprintf("alpha_%x", hash[:8]), nil</span> // Utiliser les 8 premiers octets pour l'ID
}

// ConditionHashCached calcule un hash avec cache pour am√©liorer les performances
func (asr *AlphaSharingRegistry) ConditionHashCached(condition interface{}, variableName string) (string, error) <span class="cov0" title="0">{
        // Si le cache n'est pas activ√©, calculer directement
        if !asr.isCacheEnabled() </span><span class="cov0" title="0">{
                return ConditionHash(condition, variableName)
        }</span>

        // D√©baller et normaliser pour cr√©er la cl√© de cache
        <span class="cov0" title="0">unwrapped := normalizeConditionForSharing(condition)
        normalized, err := normalizeCondition(unwrapped)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("erreur normalisation condition: %w", err)
        }</span>

        <span class="cov0" title="0">canonical := map[string]interface{}{
                "condition": normalized,
                "variable":  variableName,
        }

        // Cr√©er la cl√© de cache
        jsonBytes, err := json.Marshal(canonical)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("erreur s√©rialisation condition: %w", err)
        }</span>
        <span class="cov0" title="0">cacheKey := string(jsonBytes)

        // Utiliser le cache LRU si configur√©
        if asr.lruHashCache != nil </span><span class="cov0" title="0">{
                if cachedValue, found := asr.lruHashCache.Get(cacheKey); found </span><span class="cov0" title="0">{
                        if asr.metrics != nil </span><span class="cov0" title="0">{
                                asr.metrics.RecordHashCacheHit()
                        }</span>
                        <span class="cov0" title="0">return cachedValue.(string), nil</span>
                }

                // Cache miss
                <span class="cov0" title="0">if asr.metrics != nil </span><span class="cov0" title="0">{
                        asr.metrics.RecordHashCacheMiss()
                }</span>

                // Calculer le hash
                <span class="cov0" title="0">hash := sha256.Sum256(jsonBytes)
                hashStr := fmt.Sprintf("alpha_%x", hash[:8])

                // Stocker dans le cache LRU
                asr.lruHashCache.Set(cacheKey, hashStr)
                if asr.metrics != nil </span><span class="cov0" title="0">{
                        asr.metrics.UpdateHashCacheSize(asr.lruHashCache.Len())
                }</span>

                <span class="cov0" title="0">return hashStr, nil</span>
        }

        // Utiliser le simple map cache (fallback)
        <span class="cov0" title="0">asr.mutex.RLock()
        if cachedHash, exists := asr.hashCache[cacheKey]; exists </span><span class="cov0" title="0">{
                asr.mutex.RUnlock()
                if asr.metrics != nil </span><span class="cov0" title="0">{
                        asr.metrics.RecordHashCacheHit()
                }</span>
                <span class="cov0" title="0">return cachedHash, nil</span>
        }
        <span class="cov0" title="0">asr.mutex.RUnlock()

        // Cache miss - calculer le hash
        if asr.metrics != nil </span><span class="cov0" title="0">{
                asr.metrics.RecordHashCacheMiss()
        }</span>

        <span class="cov0" title="0">hash := sha256.Sum256(jsonBytes)
        hashStr := fmt.Sprintf("alpha_%x", hash[:8])

        // Stocker dans le cache
        asr.mutex.Lock()
        asr.hashCache[cacheKey] = hashStr
        if asr.metrics != nil </span><span class="cov0" title="0">{
                asr.metrics.UpdateHashCacheSize(len(asr.hashCache))
        }</span>
        <span class="cov0" title="0">asr.mutex.Unlock()

        return hashStr, nil</span>
}

// isCacheEnabled v√©rifie si le cache est activ√©
func (asr *AlphaSharingRegistry) isCacheEnabled() bool <span class="cov0" title="0">{
        return asr.config != nil &amp;&amp; asr.config.HashCacheEnabled
}</span>

// normalizeConditionForSharing d√©balle les conditions wrapp√©es pour permettre le partage
// entre r√®gles simples (qui wrappent dans {"type": "constraint", "constraint": X})
// et cha√Ænes (qui utilisent directement la condition d√©compos√©e)
func normalizeConditionForSharing(condition interface{}) interface{} <span class="cov0" title="0">{
        // Si la condition est une map
        if condMap, ok := condition.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // V√©rifier si c'est une condition wrapp√©e dans un type "constraint"
                if condType, hasType := condMap["type"]; hasType </span><span class="cov0" title="0">{
                        if condTypeStr, ok := condType.(string); ok &amp;&amp; condTypeStr == "constraint" </span><span class="cov0" title="0">{
                                // D√©baller la condition interne
                                if innerCond, hasConstraint := condMap["constraint"]; hasConstraint </span><span class="cov0" title="0">{
                                        // R√©cursion pour d√©baller plusieurs niveaux si n√©cessaire
                                        return normalizeConditionForSharing(innerCond)
                                }</span>
                        }
                }

                // Normaliser les types √©quivalents pour le partage
                // "comparison" et "binaryOperation" sont des synonymes
                <span class="cov0" title="0">normalized := make(map[string]interface{})
                for key, value := range condMap </span><span class="cov0" title="0">{
                        if key == "type" </span><span class="cov0" title="0">{
                                if typeStr, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        // Normaliser "comparison" vers "binaryOperation"
                                        if typeStr == "comparison" </span><span class="cov0" title="0">{
                                                normalized[key] = "binaryOperation"
                                        }</span> else<span class="cov0" title="0"> {
                                                normalized[key] = value
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        normalized[key] = value
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Normaliser r√©cursivement les valeurs imbriqu√©es
                                normalized[key] = normalizeConditionForSharing(value)
                        }</span>
                }
                <span class="cov0" title="0">return normalized</span>
        }

        // Si c'est un slice, normaliser chaque √©l√©ment
        <span class="cov0" title="0">if slice, ok := condition.([]interface{}); ok </span><span class="cov0" title="0">{
                normalized := make([]interface{}, len(slice))
                for i, item := range slice </span><span class="cov0" title="0">{
                        normalized[i] = normalizeConditionForSharing(item)
                }</span>
                <span class="cov0" title="0">return normalized</span>
        }

        // Sinon, retourner la condition telle quelle
        <span class="cov0" title="0">return condition</span>
}

// normalizeCondition normalise une condition pour assurer un hash coh√©rent
func normalizeCondition(condition interface{}) (interface{}, error) <span class="cov0" title="0">{
        if condition == nil </span><span class="cov0" title="0">{
                return map[string]interface{}{"type": "simple"}, nil
        }</span>

        <span class="cov0" title="0">switch cond := condition.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                // Copier la map et normaliser r√©cursivement
                normalized := make(map[string]interface{})
                for key, value := range cond </span><span class="cov0" title="0">{
                        normalizedValue, err := normalizeCondition(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">normalized[key] = normalizedValue</span>
                }
                <span class="cov0" title="0">return normalized, nil</span>

        case []interface{}:<span class="cov0" title="0">
                // Normaliser chaque √©l√©ment du slice
                normalized := make([]interface{}, len(cond))
                for i, item := range cond </span><span class="cov0" title="0">{
                        normalizedItem, err := normalizeCondition(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">normalized[i] = normalizedItem</span>
                }
                <span class="cov0" title="0">return normalized, nil</span>

        default:<span class="cov0" title="0">
                // Types primitifs: retourner tel quel
                return condition, nil</span>
        }
}

// GetOrCreateAlphaNode r√©cup√®re un AlphaNode existant ou en cr√©e un nouveau
// Si un AlphaNode avec la m√™me condition existe, il est r√©utilis√©
func (asr *AlphaSharingRegistry) GetOrCreateAlphaNode(
        condition interface{},
        variableName string,
        storage Storage,
) (*AlphaNode, string, bool, error) <span class="cov0" title="0">{
        // Calculer le hash de la condition avec cache
        hash, err := asr.ConditionHashCached(condition, variableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", false, fmt.Errorf("erreur calcul hash condition: %w", err)
        }</span>

        // V√©rifier si un AlphaNode existe d√©j√† pour cette condition
        <span class="cov0" title="0">asr.mutex.RLock()
        existingNode, exists := asr.sharedAlphaNodes[hash]
        asr.mutex.RUnlock()

        if exists </span><span class="cov0" title="0">{
                // AlphaNode partag√© trouv√©
                return existingNode, hash, true, nil
        }</span>

        // Cr√©er un nouveau AlphaNode
        <span class="cov0" title="0">asr.mutex.Lock()
        defer asr.mutex.Unlock()

        // Double-check apr√®s avoir acquis le verrou d'√©criture
        if existingNode, exists := asr.sharedAlphaNodes[hash]; exists </span><span class="cov0" title="0">{
                return existingNode, hash, true, nil
        }</span>

        // Cr√©er le nouveau n≈ìud avec l'ID bas√© sur le hash
        <span class="cov0" title="0">alphaNode := NewAlphaNode(hash, condition, variableName, storage)
        asr.sharedAlphaNodes[hash] = alphaNode

        return alphaNode, hash, false, nil</span>
}

// GetAlphaNode r√©cup√®re un AlphaNode partag√© par son hash
func (asr *AlphaSharingRegistry) GetAlphaNode(hash string) (*AlphaNode, bool) <span class="cov0" title="0">{
        asr.mutex.RLock()
        defer asr.mutex.RUnlock()

        node, exists := asr.sharedAlphaNodes[hash]
        return node, exists
}</span>

// RemoveAlphaNode supprime un AlphaNode du registre
// Cette m√©thode doit √™tre appel√©e uniquement quand plus aucune r√®gle n'utilise ce n≈ìud
func (asr *AlphaSharingRegistry) RemoveAlphaNode(hash string) error <span class="cov0" title="0">{
        asr.mutex.Lock()
        defer asr.mutex.Unlock()

        if _, exists := asr.sharedAlphaNodes[hash]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("AlphaNode %s non trouv√© dans le registre", hash)
        }</span>

        <span class="cov0" title="0">delete(asr.sharedAlphaNodes, hash)
        return nil</span>
}

// GetStats retourne des statistiques sur le partage des AlphaNodes
func (asr *AlphaSharingRegistry) GetStats() map[string]interface{} <span class="cov8" title="1">{
        asr.mutex.RLock()
        defer asr.mutex.RUnlock()

        totalNodes := len(asr.sharedAlphaNodes)

        // Compter le nombre total de r√®gles utilisant ces n≈ìuds
        totalRuleReferences := 0
        childCounts := make([]int, 0, totalNodes)

        for _, node := range asr.sharedAlphaNodes </span><span class="cov0" title="0">{
                childCount := len(node.GetChildren())
                childCounts = append(childCounts, childCount)
                totalRuleReferences += childCount
        }</span>

        // Calculer la moyenne
        <span class="cov8" title="1">avgSharing := 0.0
        if totalNodes &gt; 0 </span><span class="cov0" title="0">{
                avgSharing = float64(totalRuleReferences) / float64(totalNodes)
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "total_shared_alpha_nodes": totalNodes,
                "total_rule_references":    totalRuleReferences,
                "average_sharing_ratio":    avgSharing,
        }</span>
}

// ListSharedAlphaNodes retourne la liste de tous les AlphaNodes partag√©s
func (asr *AlphaSharingRegistry) ListSharedAlphaNodes() []string <span class="cov0" title="0">{
        asr.mutex.RLock()
        defer asr.mutex.RUnlock()

        hashes := make([]string, 0, len(asr.sharedAlphaNodes))
        for hash := range asr.sharedAlphaNodes </span><span class="cov0" title="0">{
                hashes = append(hashes, hash)
        }</span>

        // Trier pour avoir un ordre d√©terministe
        <span class="cov0" title="0">sort.Strings(hashes)
        return hashes</span>
}

// Reset r√©initialise compl√®tement le registre
func (asr *AlphaSharingRegistry) Reset() <span class="cov0" title="0">{
        asr.mutex.Lock()
        defer asr.mutex.Unlock()

        asr.sharedAlphaNodes = make(map[string]*AlphaNode)

        if asr.lruHashCache != nil </span><span class="cov0" title="0">{
                asr.lruHashCache.Clear()
        }</span> else<span class="cov0" title="0"> if asr.hashCache != nil </span><span class="cov0" title="0">{
                asr.hashCache = make(map[string]string)
        }</span>

        <span class="cov0" title="0">if asr.metrics != nil </span><span class="cov0" title="0">{
                asr.metrics.UpdateHashCacheSize(0)
        }</span>
}

// ClearHashCache vide uniquement le cache de hash
func (asr *AlphaSharingRegistry) ClearHashCache() <span class="cov0" title="0">{
        if asr.lruHashCache != nil </span><span class="cov0" title="0">{
                asr.lruHashCache.Clear()
                if asr.metrics != nil </span><span class="cov0" title="0">{
                        asr.metrics.UpdateHashCacheSize(0)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">asr.mutex.Lock()
        defer asr.mutex.Unlock()

        if asr.hashCache != nil </span><span class="cov0" title="0">{
                asr.hashCache = make(map[string]string)
        }</span>
        <span class="cov0" title="0">if asr.metrics != nil </span><span class="cov0" title="0">{
                asr.metrics.UpdateHashCacheSize(0)
        }</span>
}

// GetHashCacheSize retourne la taille actuelle du cache de hash
func (asr *AlphaSharingRegistry) GetHashCacheSize() int <span class="cov0" title="0">{
        if asr.lruHashCache != nil </span><span class="cov0" title="0">{
                return asr.lruHashCache.Len()
        }</span>

        <span class="cov0" title="0">asr.mutex.RLock()
        defer asr.mutex.RUnlock()
        return len(asr.hashCache)</span>
}

// GetMetrics retourne les m√©triques de performance
func (asr *AlphaSharingRegistry) GetMetrics() *ChainBuildMetrics <span class="cov0" title="0">{
        return asr.metrics
}</span>

// GetHashCacheStats retourne les statistiques d√©taill√©es du cache de hash
func (asr *AlphaSharingRegistry) GetHashCacheStats() map[string]interface{} <span class="cov0" title="0">{
        if asr.lruHashCache != nil </span><span class="cov0" title="0">{
                stats := asr.lruHashCache.GetStats()
                return map[string]interface{}{
                        "type":          "lru",
                        "size":          stats.Size,
                        "capacity":      stats.Capacity,
                        "hits":          stats.Hits,
                        "misses":        stats.Misses,
                        "evictions":     stats.Evictions,
                        "sets":          stats.Sets,
                        "hit_rate":      stats.HitRate(),
                        "eviction_rate": stats.EvictionRate(),
                        "fill_rate":     stats.FillRate(),
                }
        }</span>

        <span class="cov0" title="0">asr.mutex.RLock()
        defer asr.mutex.RUnlock()

        size := 0
        if asr.hashCache != nil </span><span class="cov0" title="0">{
                size = len(asr.hashCache)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "type": "simple_map",
                "size": size,
        }</span>
}

// GetConfig retourne la configuration actuelle
func (asr *AlphaSharingRegistry) GetConfig() *ChainPerformanceConfig <span class="cov0" title="0">{
        return asr.config
}</span>

// CleanExpiredHashCache nettoie les entr√©es expir√©es du cache (si LRU avec TTL)
func (asr *AlphaSharingRegistry) CleanExpiredHashCache() int <span class="cov0" title="0">{
        if asr.lruHashCache != nil </span><span class="cov0" title="0">{
                cleaned := asr.lruHashCache.CleanExpired()
                if cleaned &gt; 0 &amp;&amp; asr.metrics != nil </span><span class="cov0" title="0">{
                        asr.metrics.UpdateHashCacheSize(asr.lruHashCache.Len())
                }</span>
                <span class="cov0" title="0">return cleaned</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// GetSharedAlphaNodeDetails retourne les d√©tails d'un AlphaNode partag√©
func (asr *AlphaSharingRegistry) GetSharedAlphaNodeDetails(hash string) map[string]interface{} <span class="cov0" title="0">{
        asr.mutex.RLock()
        defer asr.mutex.RUnlock()

        node, exists := asr.sharedAlphaNodes[hash]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">children := node.GetChildren()
        childIDs := make([]string, len(children))
        for i, child := range children </span><span class="cov0" title="0">{
                childIDs[i] = child.GetID()
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "hash":          hash,
                "node_id":       node.GetID(),
                "variable_name": node.VariableName,
                "condition":     node.Condition,
                "child_count":   len(children),
                "child_ids":     childIDs,
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "log"
        "sort"
        "sync"
        "time"
)

// BetaChain repr√©sente une cha√Æne de JoinNodes construite pour un ensemble de patterns.
//
// Une cha√Æne beta est une s√©quence ordonn√©e de n≈ìuds de jointure qui combinent
// progressivement plusieurs variables. Chaque JoinNode √©value une condition de
// jointure et propage les tokens combin√©s au n≈ìud suivant dans la cha√Æne.
//
// Structure de cha√Æne typique (cascade pour 3+ variables):
//
//        TypeNode(Person)  TypeNode(Order)
//               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
//                            JoinNode(p ‚ãà o)
//                                 ‚îÇ
//                            TypeNode(Payment)
//                                 ‚îÇ
//                            JoinNode((p,o) ‚ãà pay)
//                                 ‚îÇ
//                            TerminalNode(rule_terminal)
//
// Propri√©t√©s:
//   - len(Nodes) == len(Hashes) (toujours maintenu)
//   - FinalNode == Nodes[len(Nodes)-1] (si non vide)
//   - Ordre des jointures est optimis√© pour la s√©lectivit√©
//
// Exemple d'utilisation:
//
//        patterns := []JoinPattern{
//            {LeftVar: "p", RightVar: "o", Condition: ...},
//            {LeftVar: "p,o", RightVar: "pay", Condition: ...},
//        }
//        chain, err := builder.BuildChain(patterns, "myRule")
//        if err != nil {
//            return err
//        }
//        fmt.Printf("Cha√Æne construite: %d n≈ìuds\n", len(chain.Nodes))
type BetaChain struct {
        Nodes     []*JoinNode `json:"nodes"`      // Liste ordonn√©e des JoinNodes dans la cha√Æne
        Hashes    []string    `json:"hashes"`     // Hashes correspondants pour chaque n≈ìud
        FinalNode *JoinNode   `json:"final_node"` // Le dernier n≈ìud de la cha√Æne
        RuleID    string      `json:"rule_id"`    // ID de la r√®gle pour laquelle la cha√Æne a √©t√© construite
}

// JoinPattern repr√©sente un pattern de jointure entre variables.
//
// Un pattern de jointure d√©finit comment deux ensembles de variables doivent
// √™tre combin√©s selon une condition sp√©cifique.
//
// Exemples:
//   - Jointure binaire simple: {LeftVars: ["p"], RightVars: ["o"], ...}
//   - Jointure cascade niveau 2: {LeftVars: ["p","o"], RightVars: ["pay"], ...}
type JoinPattern struct {
        LeftVars       []string               `json:"left_vars"`       // Variables du c√¥t√© gauche
        RightVars      []string               `json:"right_vars"`      // Variables du c√¥t√© droit
        AllVars        []string               `json:"all_vars"`        // Toutes les variables impliqu√©es
        VarTypes       map[string]string      `json:"var_types"`       // Mapping variable -&gt; type
        Condition      map[string]interface{} `json:"condition"`       // Condition de jointure
        Selectivity    float64                `json:"selectivity"`     // Estimation de s√©lectivit√© (0-1, plus bas = plus s√©lectif)
        EstimatedCost  float64                `json:"estimated_cost"`  // Co√ªt estim√© de cette jointure
        JoinConditions []JoinCondition        `json:"join_conditions"` // Conditions de jointure extraites
}

// BetaChainBuilder construit des cha√Ænes de JoinNodes avec partage automatique.
//
// Le builder coordonne la construction de cha√Ænes beta en r√©utilisant intelligemment
// les n≈ìuds existants via BetaSharingRegistry et en optimisant l'ordre des jointures
// pour maximiser les performances.
//
// Fonctionnalit√©s principales:
//   - Construction s√©quentielle de cha√Ænes pattern par pattern
//   - Partage automatique via BetaSharingRegistry
//   - Optimisation de l'ordre des jointures (heuristique de s√©lectivit√©)
//   - Cache de connexions pour √©viter duplications
//   - Collection de m√©triques d√©taill√©es
//   - Thread-safe avec sync.RWMutex
//
// Flux de construction:
//
//  1. Analyser les patterns et estimer la s√©lectivit√©
//  2. Trier les patterns par ordre optimal (plus s√©lectif d'abord)
//  3. Pour chaque pattern:
//     a. Calculer signature + hash
//     b. Chercher n≈ìud existant via BetaSharingRegistry
//     c. Si trouv√©: r√©utiliser (refcount++)
//     Si non: cr√©er nouveau JoinNode
//     d. V√©rifier connexion parent‚Üíchild (avec cache)
//     e. Connecter si n√©cessaire
//     f. Enregistrer dans LifecycleManager
//     g. N≈ìud devient parent pour suivant
//
// Optimisations impl√©ment√©es:
//   - Ordre des jointures bas√© sur s√©lectivit√©
//   - D√©tection des pr√©fixes r√©utilisables (sous-cha√Ænes communes)
//   - Cache des connexions pour √©viter duplications
//   - M√©triques d√©taill√©es pour monitoring
//
// Exemple d'utilisation:
//
//        builder := NewBetaChainBuilder(network, storage)
//        patterns := []JoinPattern{
//            {
//                LeftVars: []string{"p"},
//                RightVars: []string{"o"},
//                VarTypes: map[string]string{"p": "Person", "o": "Order"},
//                Condition: map[string]interface{}{...},
//                Selectivity: 0.3,
//            },
//        }
//        chain, err := builder.BuildChain(patterns, "rule1")
//        if err != nil {
//            log.Fatal(err)
//        }
//
//        // Acc√©der aux m√©triques
//        metrics := builder.GetMetrics()
//        fmt.Printf("Sharing ratio: %.1f%%\n", metrics.SharingRatio() * 100)
//
// Thread-safety:
//   - Toutes les op√©rations publiques sont thread-safe
//   - Le cache de connexions est prot√©g√© par mutex
//   - Peut √™tre utilis√© concurremment par plusieurs goroutines
type BetaChainBuilder struct {
        network             *ReteNetwork
        storage             Storage
        betaSharingRegistry BetaSharingRegistry
        connectionCache     map[string]bool      // Cache pour les connexions existantes (parentID_childID -&gt; bool)
        prefixCache         map[string]*JoinNode // Cache des pr√©fixes de cha√Ænes r√©utilisables
        metrics             *BetaChainMetrics    // M√©triques de construction compl√®tes
        mutex               sync.RWMutex
        enableOptimization  bool // Active/d√©sactive l'optimisation de l'ordre des jointures
        enablePrefixSharing bool // Active/d√©sactive le partage des pr√©fixes
}

// NewBetaChainBuilder cr√©e un nouveau constructeur de cha√Ænes beta avec des m√©triques neuves.
//
// Cette fonction initialise un builder avec un objet de m√©triques local. Pour partager
// les m√©triques entre plusieurs builders (recommand√©), utilisez NewBetaChainBuilderWithMetrics.
//
// Le builder utilise le BetaSharingRegistry du r√©seau s'il existe, sinon d√©sactive le partage.
//
// Param√®tres:
//   - network: R√©seau RETE auquel ajouter les n≈ìuds
//   - storage: Backend de persistance pour les n≈ìuds
//
// Retourne:
//   - Un nouveau builder pr√™t √† l'emploi
//
// Exemple:
//
//        storage := NewMemoryStorage()
//        network := NewReteNetwork(storage)
//        builder := NewBetaChainBuilder(network, storage)
func NewBetaChainBuilder(network *ReteNetwork, storage Storage) *BetaChainBuilder <span class="cov0" title="0">{
        return NewBetaChainBuilderWithRegistry(network, storage, nil)
}</span>

// NewBetaChainBuilderWithRegistry cr√©e un builder avec un registry sp√©cifique.
func NewBetaChainBuilderWithRegistry(network *ReteNetwork, storage Storage, betaRegistry BetaSharingRegistry) *BetaChainBuilder <span class="cov0" title="0">{
        return &amp;BetaChainBuilder{
                network:             network,
                storage:             storage,
                betaSharingRegistry: betaRegistry,
                connectionCache:     make(map[string]bool),
                prefixCache:         make(map[string]*JoinNode),
                metrics:             NewBetaChainMetrics(),
                enableOptimization:  true, // Optimisation activ√©e par d√©faut
                enablePrefixSharing: true, // Partage de pr√©fixes activ√© par d√©faut
        }
}</span>

// NewBetaChainBuilderWithMetrics cr√©e un constructeur avec des m√©triques partag√©es.
//
// Recommand√© quand le r√©seau RETE cr√©e son propre builder, permettant de partager
// les m√©triques entre le builder et d'autres composants.
//
// Param√®tres:
//   - network: R√©seau RETE auquel ajouter les n≈ìuds
//   - storage: Backend de persistance pour les n≈ìuds
//   - metrics: Objet de m√©triques partag√© (non nil)
//
// Retourne:
//   - Un nouveau builder utilisant les m√©triques fournies
//
// Exemple:
//
//        metrics := &amp;BetaBuildMetrics{}
//        builder := NewBetaChainBuilderWithMetrics(network, storage, metrics)
//        // Les m√©triques sont accessibles via builder.GetMetrics() et directement via 'metrics'
func NewBetaChainBuilderWithMetrics(network *ReteNetwork, storage Storage, metrics *BetaChainMetrics) *BetaChainBuilder <span class="cov0" title="0">{
        return NewBetaChainBuilderWithRegistryAndMetrics(network, storage, nil, metrics)
}</span>

// NewBetaChainBuilderWithRegistryAndMetrics cr√©e un builder avec registry et m√©triques.
func NewBetaChainBuilderWithRegistryAndMetrics(network *ReteNetwork, storage Storage, betaRegistry BetaSharingRegistry, metrics *BetaChainMetrics) *BetaChainBuilder <span class="cov0" title="0">{
        return &amp;BetaChainBuilder{
                network:             network,
                storage:             storage,
                betaSharingRegistry: betaRegistry,
                connectionCache:     make(map[string]bool),
                prefixCache:         make(map[string]*JoinNode),
                metrics:             metrics,
                enableOptimization:  true,
                enablePrefixSharing: true,
        }
}</span>

// NewBetaChainBuilderWithComponents cr√©e un builder avec tous les composants n√©cessaires.
//
// Cette fonction est utilis√©e lors de l'initialisation du ReteNetwork pour cr√©er
// un builder compl√®tement configur√© avec registry de partage, lifecycle manager,
// et m√©triques partag√©es.
//
// Param√®tres:
//   - network: R√©seau RETE auquel ajouter les n≈ìuds
//   - storage: Backend de persistance pour les n≈ìuds
//   - betaRegistry: Registry pour le partage de JoinNodes (peut √™tre nil)
//   - lifecycle: LifecycleManager pour la gestion du cycle de vie (peut √™tre nil)
//
// Retourne:
//   - Un nouveau builder configur√© avec tous les composants
//
// Exemple:
//
//        registry := NewBetaSharingRegistry(config, lifecycle)
//        builder := NewBetaChainBuilderWithComponents(network, storage, registry, lifecycle)
func NewBetaChainBuilderWithComponents(
        network *ReteNetwork,
        storage Storage,
        betaRegistry BetaSharingRegistry,
        lifecycle *LifecycleManager,
) *BetaChainBuilder <span class="cov8" title="1">{
        // Use the registry's lifecycle manager if available
        // Otherwise use the provided one
        if betaRegistry != nil </span><span class="cov8" title="1">{
                // Registry already has a lifecycle manager
                return &amp;BetaChainBuilder{
                        network:             network,
                        storage:             storage,
                        betaSharingRegistry: betaRegistry,
                        connectionCache:     make(map[string]bool),
                        prefixCache:         make(map[string]*JoinNode),
                        metrics:             NewBetaChainMetrics(),
                        enableOptimization:  true,
                        enablePrefixSharing: true,
                }
        }</span>

        // No registry, use basic builder
        <span class="cov0" title="0">return &amp;BetaChainBuilder{
                network:             network,
                storage:             storage,
                betaSharingRegistry: nil,
                connectionCache:     make(map[string]bool),
                prefixCache:         make(map[string]*JoinNode),
                metrics:             NewBetaChainMetrics(),
                enableOptimization:  true,
                enablePrefixSharing: true,
        }</span>
}

// BuildChain construit une cha√Æne de JoinNodes pour un ensemble de patterns de jointure
// avec partage automatique des n≈ìuds identiques entre r√®gles et optimisation de l'ordre.
//
// Cette m√©thode est le point d'entr√©e principal pour la construction de cha√Ænes.
// Elle analyse les patterns, optimise leur ordre, et construit progressivement la cha√Æne
// en r√©utilisant les n≈ìuds existants via BetaSharingRegistry.
//
// Algorithme:
//
//  1. Validation des inputs
//  2. Analyse et estimation de s√©lectivit√© des patterns
//  3. Optimisation de l'ordre (si activ√©e)
//  4. D√©tection de pr√©fixes r√©utilisables (si activ√©e)
//  5. Pour chaque pattern dans l'ordre optimal:
//     a. Calculer signature de jointure
//     b. Appeler BetaSharingRegistry.GetOrCreateJoinNode()
//     ‚Üí Cherche n≈ìud existant via hash
//     ‚Üí Cr√©e nouveau si inexistant
//     c. Si n≈ìud r√©utilis√©:
//     - V√©rifier connexion avec parent (cache)
//     - Connecter si n√©cessaire
//     d. Si n≈ìud cr√©√©:
//     - Connecter au parent
//     - Ajouter au r√©seau
//     - Mettre en cache la connexion
//     e. Enregistrer dans LifecycleManager
//     f. N≈ìud devient parent pour it√©ration suivante
//  6. Collecter m√©triques
//
// Param√®tres:
//   - patterns: liste de patterns de jointure dans l'ordre initial
//   - ruleID: identifiant unique de la r√®gle pour le lifecycle management
//
// Retourne:
//   - *BetaChain: la cha√Æne construite avec tous les n≈ìuds et leurs hashes
//   - error: erreur si patterns vides, registry non initialis√©, ou probl√®me de cr√©ation
//
// Exemple simple (2 variables):
//
//        patterns := []JoinPattern{
//            {
//                LeftVars: []string{"p"},
//                RightVars: []string{"o"},
//                VarTypes: map[string]string{"p": "Person", "o": "Order"},
//                Condition: map[string]interface{}{"type": "join", ...},
//            },
//        }
//        chain, err := builder.BuildChain(patterns, "rule_customer_orders")
//        // ‚Üí Cr√©e: TypeNode(Person) ‚ãà TypeNode(Order) ‚Üí JoinNode ‚Üí Terminal
//
// Exemple avec cascade (3+ variables):
//
//        patterns := []JoinPattern{
//            {LeftVars: []string{"p"}, RightVars: []string{"o"}, ...},      // p ‚ãà o
//            {LeftVars: []string{"p","o"}, RightVars: []string{"pay"}, ...}, // (p,o) ‚ãà pay
//        }
//        chain, err := builder.BuildChain(patterns, "rule_payment_check")
//        // ‚Üí Cr√©e cascade: p ‚ãà o ‚Üí (p,o) ‚ãà pay ‚Üí Terminal
//
// Exemple avec partage:
//
//        // R√®gle 1
//        chain1, _ := builder.BuildChain(patterns1, "rule1")
//        // ‚Üí Cr√©e nouveau JoinNode join_abc123
//
//        // R√®gle 2 (m√™me pattern de jointure)
//        chain2, _ := builder.BuildChain(patterns2, "rule2")
//        // ‚Üí R√©utilise join_abc123 (RefCount=2)
//
// Logs g√©n√©r√©s:
//
//        üÜï [BetaChainBuilder] Nouveau JoinNode join_abc123 cr√©√© pour la r√®gle rule1 (pattern 1/1)
//        üîó [BetaChainBuilder] Connexion du JoinNode join_abc123 aux TypeNodes
//        ‚ôªÔ∏è  [BetaChainBuilder] R√©utilisation du JoinNode join_abc123 pour la r√®gle rule2 (pattern 1/1)
//        ‚úì  [BetaChainBuilder] JoinNode join_abc123 d√©j√† connect√©
//        ‚ö° [BetaChainBuilder] Optimisation de l'ordre appliqu√©e (2 patterns r√©ordonn√©s)
func (bcb *BetaChainBuilder) BuildChain(
        patterns []JoinPattern,
        ruleID string,
) (*BetaChain, error) <span class="cov0" title="0">{
        // Validation des inputs
        if len(patterns) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("impossible de construire une cha√Æne sans patterns")
        }</span>

        <span class="cov0" title="0">if bcb.network.LifecycleManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LifecycleManager non initialis√© dans le r√©seau")
        }</span>

        // D√©marrer le chronom√®tre pour les m√©triques
        <span class="cov0" title="0">startTime := time.Now()
        nodesCreated := 0
        nodesReused := 0
        hashesGenerated := make([]string, 0, len(patterns))
        optimizationApplied := false
        prefixReused := false

        chain := &amp;BetaChain{
                Nodes:  make([]*JoinNode, 0, len(patterns)),
                Hashes: make([]string, 0, len(patterns)),
                RuleID: ruleID,
        }

        // Estimer la s√©lectivit√© des patterns si pas d√©j√† fait
        bcb.estimateSelectivity(patterns)

        // Optimiser l'ordre des patterns si activ√©
        optimizedPatterns := patterns
        if bcb.enableOptimization &amp;&amp; len(patterns) &gt; 1 </span><span class="cov0" title="0">{
                optimizedPatterns = bcb.optimizeJoinOrder(patterns)
                if !bcb.patternsEqual(patterns, optimizedPatterns) </span><span class="cov0" title="0">{
                        optimizationApplied = true
                        log.Printf("‚ö° [BetaChainBuilder] Optimisation de l'ordre appliqu√©e (%d patterns r√©ordonn√©s) pour r√®gle %s",
                                len(patterns), ruleID)
                }</span>
        }

        // Tenter de r√©utiliser un pr√©fixe de cha√Æne existant si activ√©
        <span class="cov0" title="0">var currentParent Node
        startPatternIndex := 0

        if bcb.enablePrefixSharing &amp;&amp; len(optimizedPatterns) &gt; 1 </span><span class="cov0" title="0">{
                prefixNode, prefixLen := bcb.findReusablePrefix(optimizedPatterns, ruleID)
                if prefixNode != nil &amp;&amp; prefixLen &gt; 0 </span><span class="cov0" title="0">{
                        prefixReused = true
                        currentParent = prefixNode
                        startPatternIndex = prefixLen
                        nodesReused += prefixLen
                        log.Printf("‚ôªÔ∏è  [BetaChainBuilder] Pr√©fixe de cha√Æne r√©utilis√© (%d n≈ìuds) pour r√®gle %s",
                                prefixLen, ruleID)
                }</span>
        }

        // Construire la cha√Æne pattern par pattern
        <span class="cov0" title="0">for i := startPatternIndex; i &lt; len(optimizedPatterns); i++ </span><span class="cov0" title="0">{
                pattern := optimizedPatterns[i]

                // Obtenir ou cr√©er le JoinNode via le registry de partage
                var joinNode *JoinNode
                var hash string
                var reused bool
                var err error

                if bcb.betaSharingRegistry != nil </span><span class="cov0" title="0">{
                        joinNode, hash, reused, err = bcb.betaSharingRegistry.GetOrCreateJoinNode(
                                pattern.Condition,
                                pattern.LeftVars,
                                pattern.RightVars,
                                pattern.AllVars,
                                pattern.VarTypes,
                                bcb.storage,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur lors de la cr√©ation/r√©cup√©ration du JoinNode %d: %w", i, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Fallback si pas de registry: cr√©er directement
                        nodeID := fmt.Sprintf("%s_join_%d", ruleID, i)
                        joinNode = NewJoinNode(nodeID, pattern.Condition, pattern.LeftVars, pattern.RightVars, pattern.VarTypes, bcb.storage)
                        hash = nodeID
                        reused = false
                }</span>

                // Ajouter le n≈ìud et son hash √† la cha√Æne
                <span class="cov0" title="0">chain.Nodes = append(chain.Nodes, joinNode)
                chain.Hashes = append(chain.Hashes, hash)
                hashesGenerated = append(hashesGenerated, hash)

                if reused </span><span class="cov0" title="0">{
                        nodesReused++
                        log.Printf("‚ôªÔ∏è  [BetaChainBuilder] R√©utilisation du JoinNode %s pour la r√®gle %s (pattern %d/%d)",
                                joinNode.ID, ruleID, i+1, len(optimizedPatterns))

                        // N≈ìud r√©utilis√© - v√©rifier la connexion si on a un parent
                        if currentParent != nil &amp;&amp; !bcb.isAlreadyConnectedCached(currentParent, joinNode) </span><span class="cov0" title="0">{
                                currentParent.AddChild(joinNode)
                                log.Printf("üîó [BetaChainBuilder] Connexion du n≈ìud r√©utilis√© %s au parent %s",
                                        joinNode.ID, currentParent.GetID())
                        }</span> else<span class="cov0" title="0"> if currentParent != nil </span><span class="cov0" title="0">{
                                log.Printf("‚úì  [BetaChainBuilder] N≈ìud %s d√©j√† connect√© au parent %s",
                                        joinNode.ID, currentParent.GetID())
                        }</span>
                } else<span class="cov0" title="0"> {
                        nodesCreated++
                        // Nouveau n≈ìud - l'ajouter au r√©seau
                        bcb.network.BetaNodes[joinNode.ID] = joinNode

                        // Connecter au parent si on en a un
                        if currentParent != nil </span><span class="cov0" title="0">{
                                currentParent.AddChild(joinNode)
                                bcb.updateConnectionCache(currentParent.GetID(), joinNode.ID, true)
                        }</span>

                        <span class="cov0" title="0">log.Printf("üÜï [BetaChainBuilder] Nouveau JoinNode %s cr√©√© pour la r√®gle %s (pattern %d/%d)",
                                joinNode.ID, ruleID, i+1, len(optimizedPatterns))
                        if currentParent != nil </span><span class="cov0" title="0">{
                                log.Printf("üîó [BetaChainBuilder] Connexion du n≈ìud %s au parent %s",
                                        joinNode.ID, currentParent.GetID())
                        }</span>
                }

                // Enregistrer le n≈ìud dans le LifecycleManager avec la r√®gle
                <span class="cov0" title="0">lifecycle := bcb.network.LifecycleManager.RegisterNode(joinNode.ID, "join")
                lifecycle.AddRuleReference(ruleID, "") // RuleName peut √™tre ajout√© plus tard si n√©cessaire

                if reused </span><span class="cov0" title="0">{
                        log.Printf("üìä [BetaChainBuilder] N≈ìud %s maintenant utilis√© par %d r√®gle(s)",
                                joinNode.ID, lifecycle.GetRefCount())
                }</span>

                // Mettre √† jour le cache de pr√©fixes si pertinent
                <span class="cov0" title="0">if bcb.enablePrefixSharing &amp;&amp; i &lt; len(optimizedPatterns)-1 </span><span class="cov0" title="0">{
                        prefixKey := bcb.computePrefixKey(optimizedPatterns[0 : i+1])
                        bcb.updatePrefixCache(prefixKey, joinNode)
                }</span>

                // Le n≈ìud actuel devient le parent pour le prochain n≈ìud
                <span class="cov0" title="0">currentParent = joinNode</span>
        }

        // Le dernier n≈ìud de la cha√Æne est le n≈ìud final
        <span class="cov0" title="0">if len(chain.Nodes) &gt; 0 </span><span class="cov0" title="0">{
                chain.FinalNode = chain.Nodes[len(chain.Nodes)-1]
        }</span>

        <span class="cov0" title="0">buildTime := time.Since(startTime)
        log.Printf("‚úÖ [BetaChainBuilder] Cha√Æne beta compl√®te construite pour la r√®gle %s: %d n≈ìud(s) (cr√©√©s: %d, r√©utilis√©s: %d) en %v",
                ruleID, len(chain.Nodes), nodesCreated, nodesReused, buildTime)

        // Record metrics
        if bcb.metrics != nil </span><span class="cov0" title="0">{
                detail := BetaChainMetricDetail{
                        RuleID:          ruleID,
                        ChainLength:     len(chain.Nodes),
                        NodesCreated:    nodesCreated,
                        NodesReused:     nodesReused,
                        BuildTime:       buildTime,
                        Timestamp:       time.Now(),
                        HashesGenerated: hashesGenerated,
                        JoinsExecuted:   0, // Will be updated during runtime
                        TotalJoinTime:   0,
                }
                bcb.metrics.RecordChainBuild(detail)
        }</span>

        // Log optimization info if applied
        <span class="cov0" title="0">_ = optimizationApplied
        _ = prefixReused

        return chain, nil</span>
}

// estimateSelectivity estime la s√©lectivit√© de chaque pattern de jointure.
//
// La s√©lectivit√© est une heuristique (0-1) qui indique combien de tuples
// passeront le filtre de jointure. Plus la valeur est basse, plus la jointure
// est s√©lective (filtre beaucoup de donn√©es).
//
// Heuristiques utilis√©es:
//   - Nombre de conditions: plus de conditions = plus s√©lectif
//   - Type d'op√©rateur: √©galit√© &gt; in√©galit√© &gt; range
//   - Nombre de variables impliqu√©es: moins de variables = plus s√©lectif
//
// Cette fonction modifie les patterns en place.
func (bcb *BetaChainBuilder) estimateSelectivity(patterns []JoinPattern) <span class="cov0" title="0">{
        for i := range patterns </span><span class="cov0" title="0">{
                pattern := &amp;patterns[i]

                // Si d√©j√† estim√©e, ne rien faire
                if pattern.Selectivity &gt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Estimation par d√©faut
                <span class="cov0" title="0">selectivity := 0.5

                // Ajuster selon le nombre de variables
                numVars := len(pattern.LeftVars) + len(pattern.RightVars)
                if numVars == 2 </span><span class="cov0" title="0">{
                        selectivity = 0.3 // Jointure binaire simple
                }</span> else<span class="cov0" title="0"> if numVars &gt; 2 </span><span class="cov0" title="0">{
                        selectivity = 0.4 + (float64(numVars-2) * 0.1) // Plus de variables = moins s√©lectif
                }</span>

                // Ajuster selon les conditions de jointure
                <span class="cov0" title="0">if len(pattern.JoinConditions) &gt; 0 </span><span class="cov0" title="0">{
                        // Plus de conditions = plus s√©lectif
                        selectivity *= (1.0 - float64(len(pattern.JoinConditions))*0.1)
                        if selectivity &lt; 0.1 </span><span class="cov0" title="0">{
                                selectivity = 0.1
                        }</span>
                }

                <span class="cov0" title="0">pattern.Selectivity = selectivity
                pattern.EstimatedCost = selectivity * float64(numVars)</span>
        }
}

// optimizeJoinOrder optimise l'ordre des patterns de jointure.
//
// Strat√©gie: trier les patterns par s√©lectivit√© croissante (plus s√©lectif d'abord).
// Cela permet de filtrer les donn√©es t√¥t dans la cha√Æne et de r√©duire le volume
// de donn√©es trait√© par les jointures suivantes.
//
// Note: Pour une optimisation plus avanc√©e, on pourrait tenir compte des d√©pendances
// entre variables (un pattern ne peut √™tre √©valu√© que si ses variables d√©pendantes
// ont √©t√© produites par des patterns pr√©c√©dents).
//
// Retourne une nouvelle slice avec les patterns r√©ordonn√©s.
func (bcb *BetaChainBuilder) optimizeJoinOrder(patterns []JoinPattern) []JoinPattern <span class="cov0" title="0">{
        // Copier les patterns pour ne pas modifier l'original
        optimized := make([]JoinPattern, len(patterns))
        copy(optimized, patterns)

        // Trier par s√©lectivit√© croissante (plus s√©lectif d'abord)
        sort.Slice(optimized, func(i, j int) bool </span><span class="cov0" title="0">{
                return optimized[i].Selectivity &lt; optimized[j].Selectivity
        }</span>)

        <span class="cov0" title="0">return optimized</span>
}

// patternsEqual v√©rifie si deux slices de patterns sont identiques (m√™me ordre).
func (bcb *BetaChainBuilder) patternsEqual(a, b []JoinPattern) bool <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i := range a </span><span class="cov0" title="0">{
                if !bcb.patternEqual(a[i], b[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// patternEqual v√©rifie si deux patterns sont identiques.
func (bcb *BetaChainBuilder) patternEqual(a, b JoinPattern) bool <span class="cov0" title="0">{
        // Comparaison simple bas√©e sur les variables
        if len(a.LeftVars) != len(b.LeftVars) || len(a.RightVars) != len(b.RightVars) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i := range a.LeftVars </span><span class="cov0" title="0">{
                if a.LeftVars[i] != b.LeftVars[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">for i := range a.RightVars </span><span class="cov0" title="0">{
                if a.RightVars[i] != b.RightVars[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// findReusablePrefix cherche un pr√©fixe de cha√Æne r√©utilisable dans le cache.
//
// Un pr√©fixe r√©utilisable est une sous-s√©quence de patterns au d√©but de la cha√Æne
// qui correspond exactement √† une sous-cha√Æne d√©j√† construite.
//
// Retourne:
//   - Le dernier n≈ìud du pr√©fixe r√©utilisable (ou nil si aucun)
//   - La longueur du pr√©fixe (nombre de patterns)
func (bcb *BetaChainBuilder) findReusablePrefix(patterns []JoinPattern, ruleID string) (*JoinNode, int) <span class="cov0" title="0">{
        bcb.mutex.RLock()
        defer bcb.mutex.RUnlock()

        // Chercher le plus long pr√©fixe disponible (de len-1 √† 1)
        for prefixLen := len(patterns) - 1; prefixLen &gt;= 1; prefixLen-- </span><span class="cov0" title="0">{
                prefixKey := bcb.computePrefixKey(patterns[0:prefixLen])
                if node, exists := bcb.prefixCache[prefixKey]; exists </span><span class="cov0" title="0">{
                        return node, prefixLen
                }</span>
        }

        <span class="cov0" title="0">return nil, 0</span>
}

// computePrefixKey calcule une cl√© pour un pr√©fixe de patterns.
//
// La cl√© est construite en concat√©nant les signatures des patterns.
func (bcb *BetaChainBuilder) computePrefixKey(patterns []JoinPattern) string <span class="cov0" title="0">{
        key := ""
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                // Utiliser les variables comme base de la cl√©
                key += fmt.Sprintf("%v|%v|", pattern.LeftVars, pattern.RightVars)
        }</span>
        <span class="cov0" title="0">return key</span>
}

// updatePrefixCache met √† jour le cache de pr√©fixes.
func (bcb *BetaChainBuilder) updatePrefixCache(key string, node *JoinNode) <span class="cov0" title="0">{
        bcb.mutex.Lock()
        defer bcb.mutex.Unlock()
        bcb.prefixCache[key] = node
}</span>

// isAlreadyConnectedCached v√©rifie si un n≈ìud enfant est d√©j√† connect√© √† un n≈ìud parent avec cache.
func (bcb *BetaChainBuilder) isAlreadyConnectedCached(parent Node, child Node) bool <span class="cov0" title="0">{
        if parent == nil || child == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">parentID := parent.GetID()
        childID := child.GetID()
        cacheKey := fmt.Sprintf("%s_%s", parentID, childID)

        // V√©rifier le cache
        bcb.mutex.RLock()
        if connected, exists := bcb.connectionCache[cacheKey]; exists </span><span class="cov0" title="0">{
                bcb.mutex.RUnlock()
                return connected
        }</span>
        <span class="cov0" title="0">bcb.mutex.RUnlock()

        // Cache miss - v√©rifier r√©ellement
        connected := isAlreadyConnected(parent, child)

        // Mettre √† jour le cache
        bcb.updateConnectionCache(parentID, childID, connected)

        return connected</span>
}

// updateConnectionCache met √† jour le cache de connexion.
func (bcb *BetaChainBuilder) updateConnectionCache(parentID, childID string, connected bool) <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("%s_%s", parentID, childID)
        bcb.mutex.Lock()
        bcb.connectionCache[cacheKey] = connected
        bcb.mutex.Unlock()
}</span>

// determineJoinType d√©termine le type de jointure d'un pattern.
//
// Types support√©s:
//   - "binary": jointure binaire simple (2 variables)
//   - "cascade": jointure en cascade (3+ variables)
//   - "multi": jointure multi-variables complexe
func (bcb *BetaChainBuilder) determineJoinType(pattern JoinPattern) string <span class="cov0" title="0">{
        numVars := len(pattern.LeftVars) + len(pattern.RightVars)
        if numVars == 2 </span><span class="cov0" title="0">{
                return "binary"
        }</span> else<span class="cov0" title="0"> if len(pattern.LeftVars) &gt; 1 </span><span class="cov0" title="0">{
                return "cascade"
        }</span> else<span class="cov0" title="0"> {
                return "multi"
        }</span>
}

// ClearConnectionCache vide le cache de connexions.
//
// Utile pour lib√©rer de la m√©moire apr√®s suppression de nombreuses r√®gles,
// ou pour forcer une r√©√©valuation compl√®te des connexions.
//
// Thread-safe: peut √™tre appel√© √† tout moment.
//
// Exemple:
//
//        // Apr√®s suppression de beaucoup de r√®gles
//        for _, ruleID := range oldRules {
//            network.RemoveRule(ruleID)
//        }
//        builder.ClearConnectionCache() // Lib√©rer m√©moire
func (bcb *BetaChainBuilder) ClearConnectionCache() <span class="cov0" title="0">{
        bcb.mutex.Lock()
        defer bcb.mutex.Unlock()
        bcb.connectionCache = make(map[string]bool)
        log.Printf("üßπ [BetaChainBuilder] Cache de connexions vid√©")
}</span>

// ClearPrefixCache vide le cache de pr√©fixes.
//
// Utile pour lib√©rer de la m√©moire ou invalider les pr√©fixes apr√®s
// modifications importantes du r√©seau.
//
// Thread-safe: peut √™tre appel√© √† tout moment.
func (bcb *BetaChainBuilder) ClearPrefixCache() <span class="cov0" title="0">{
        bcb.mutex.Lock()
        defer bcb.mutex.Unlock()
        bcb.prefixCache = make(map[string]*JoinNode)
        log.Printf("üßπ [BetaChainBuilder] Cache de pr√©fixes vid√©")
}</span>

// GetConnectionCacheSize retourne la taille actuelle du cache de connexions.
//
// Thread-safe.
//
// Exemple:
//
//        size := builder.GetConnectionCacheSize()
//        fmt.Printf("Cache de connexions: %d entr√©es\n", size)
func (bcb *BetaChainBuilder) GetConnectionCacheSize() int <span class="cov0" title="0">{
        bcb.mutex.RLock()
        defer bcb.mutex.RUnlock()
        return len(bcb.connectionCache)
}</span>

// GetPrefixCacheSize retourne la taille actuelle du cache de pr√©fixes.
//
// Thread-safe.
func (bcb *BetaChainBuilder) GetPrefixCacheSize() int <span class="cov0" title="0">{
        bcb.mutex.RLock()
        defer bcb.mutex.RUnlock()
        return len(bcb.prefixCache)
}</span>

// GetMetrics retourne les m√©triques de construction.
//
// Thread-safe: retourne une copie des m√©triques.
//
// Exemple:
//
//        metrics := builder.GetMetrics()
//        fmt.Printf("Join nodes requested: %d\n", metrics.TotalJoinNodesRequested)
func (bcb *BetaChainBuilder) GetMetrics() *BetaChainMetrics <span class="cov0" title="0">{
        bcb.mutex.RLock()
        defer bcb.mutex.RUnlock()
        return bcb.metrics
}</span>

// ResetMetrics r√©initialise les m√©triques de construction √† z√©ro.
//
// Cette m√©thode remet toutes les statistiques de construction √† leur √©tat initial.
// Utile pour les tests ou pour commencer une nouvelle session de mesure.
//
// Thread-safe: Prot√©g√© par mutex pour √©viter les conditions de course.
//
// Exemple:
//
//        builder.ResetMetrics()
//        // Construire des cha√Ænes...
//        metrics := builder.GetMetrics()
//        fmt.Printf("Depuis le reset: %d nodes cr√©√©s\n", metrics.UniqueJoinNodesCreated)
func (bcb *BetaChainBuilder) ResetMetrics() <span class="cov0" title="0">{
        if bcb.metrics != nil </span><span class="cov0" title="0">{
                bcb.metrics.Reset()
        }</span>
}

// SetOptimizationEnabled active/d√©sactive l'optimisation de l'ordre des jointures.
//
// Thread-safe.
//
// Exemple:
//
//        builder.SetOptimizationEnabled(false) // D√©sactiver l'optimisation
func (bcb *BetaChainBuilder) SetOptimizationEnabled(enabled bool) <span class="cov8" title="1">{
        bcb.mutex.Lock()
        defer bcb.mutex.Unlock()
        bcb.enableOptimization = enabled
        log.Printf("‚öôÔ∏è  [BetaChainBuilder] Optimisation de l'ordre: %v", enabled)
}</span>

// SetPrefixSharingEnabled active/d√©sactive le partage de pr√©fixes.
//
// Thread-safe.
//
// Exemple:
//
//        builder.SetPrefixSharingEnabled(false) // D√©sactiver le partage de pr√©fixes
func (bcb *BetaChainBuilder) SetPrefixSharingEnabled(enabled bool) <span class="cov8" title="1">{
        bcb.mutex.Lock()
        defer bcb.mutex.Unlock()
        bcb.enablePrefixSharing = enabled
        log.Printf("‚öôÔ∏è  [BetaChainBuilder] Partage de pr√©fixes: %v", enabled)
}</span>

// GetChainInfo retourne des informations d√©taill√©es sur une cha√Æne beta.
//
// Exemple:
//
//        info := chain.GetChainInfo()
//        fmt.Printf("Cha√Æne: %s\n", info["summary"])
//        fmt.Printf("N≈ìuds: %v\n", info["node_ids"])
func (bc *BetaChain) GetChainInfo() map[string]interface{} <span class="cov0" title="0">{
        info := make(map[string]interface{})

        nodeIDs := make([]string, len(bc.Nodes))
        for i, node := range bc.Nodes </span><span class="cov0" title="0">{
                nodeIDs[i] = node.ID
        }</span>

        <span class="cov0" title="0">info["rule_id"] = bc.RuleID
        info["chain_length"] = len(bc.Nodes)
        info["node_ids"] = nodeIDs
        info["hashes"] = bc.Hashes

        if bc.FinalNode != nil </span><span class="cov0" title="0">{
                info["final_node_id"] = bc.FinalNode.ID
        }</span>

        <span class="cov0" title="0">summary := fmt.Sprintf("BetaChain[%s]: %d n≈ìuds", bc.RuleID, len(bc.Nodes))
        info["summary"] = summary

        return info</span>
}

// ValidateChain valide la coh√©rence d'une cha√Æne beta.
//
// V√©rifie:
//   - Longueurs coh√©rentes (nodes, hashes)
//   - FinalNode correspond au dernier n≈ìud
//   - Tous les n≈ìuds sont non-nil
//   - Tous les hashes sont non-vides
//
// Retourne une erreur si la validation √©choue.
//
// Exemple:
//
//        if err := chain.ValidateChain(); err != nil {
//            log.Printf("Cha√Æne invalide: %v", err)
//        }
func (bc *BetaChain) ValidateChain() error <span class="cov0" title="0">{
        if len(bc.Nodes) != len(bc.Hashes) </span><span class="cov0" title="0">{
                return fmt.Errorf("incoh√©rence: %d n≈ìuds mais %d hashes", len(bc.Nodes), len(bc.Hashes))
        }</span>

        <span class="cov0" title="0">if len(bc.Nodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cha√Æne vide")
        }</span>

        <span class="cov0" title="0">for i, node := range bc.Nodes </span><span class="cov0" title="0">{
                if node == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("n≈ìud %d est nil", i)
                }</span>
                <span class="cov0" title="0">if bc.Hashes[i] == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("hash %d est vide", i)
                }</span>
        }

        <span class="cov0" title="0">if bc.FinalNode != bc.Nodes[len(bc.Nodes)-1] </span><span class="cov0" title="0">{
                return fmt.Errorf("FinalNode ne correspond pas au dernier n≈ìud de la cha√Æne")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CountSharedNodes compte le nombre de n≈ìuds partag√©s dans une cha√Æne.
//
// Un n≈ìud est consid√©r√© comme partag√© s'il est utilis√© par plusieurs r√®gles
// (RefCount &gt; 1 dans le LifecycleManager).
//
// Exemple:
//
//        sharedCount := builder.CountSharedNodes(chain)
//        fmt.Printf("N≈ìuds partag√©s: %d/%d\n", sharedCount, len(chain.Nodes))
func (bcb *BetaChainBuilder) CountSharedNodes(chain *BetaChain) int <span class="cov0" title="0">{
        if bcb.network.LifecycleManager == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">sharedCount := 0
        for _, node := range chain.Nodes </span><span class="cov0" title="0">{
                lifecycle, _ := bcb.network.LifecycleManager.GetNodeLifecycle(node.ID)
                if lifecycle != nil &amp;&amp; lifecycle.GetRefCount() &gt; 1 </span><span class="cov0" title="0">{
                        sharedCount++
                }</span>
        }

        <span class="cov0" title="0">return sharedCount</span>
}

// GetChainStats retourne des statistiques sur une cha√Æne.
//
// Statistiques disponibles:
//   - total_nodes: nombre total de n≈ìuds
//   - shared_nodes: nombre de n≈ìuds partag√©s
//   - sharing_ratio: ratio de partage (0-1)
//   - average_refcount: refcount moyen des n≈ìuds
//
// Exemple:
//
//        stats := builder.GetChainStats(chain)
//        fmt.Printf("Statistiques:\n")
//        for key, value := range stats {
//            fmt.Printf("  %s: %v\n", key, value)
//        }
func (bcb *BetaChainBuilder) GetChainStats(chain *BetaChain) map[string]interface{} <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        totalNodes := len(chain.Nodes)
        sharedNodes := bcb.CountSharedNodes(chain)

        stats["total_nodes"] = totalNodes
        stats["shared_nodes"] = sharedNodes

        if totalNodes &gt; 0 </span><span class="cov0" title="0">{
                stats["sharing_ratio"] = float64(sharedNodes) / float64(totalNodes)
        }</span> else<span class="cov0" title="0"> {
                stats["sharing_ratio"] = 0.0
        }</span>

        // Calculer le refcount moyen
        <span class="cov0" title="0">if bcb.network.LifecycleManager != nil </span><span class="cov0" title="0">{
                totalRefCount := 0
                for _, node := range chain.Nodes </span><span class="cov0" title="0">{
                        lifecycle, _ := bcb.network.LifecycleManager.GetNodeLifecycle(node.ID)
                        if lifecycle != nil </span><span class="cov0" title="0">{
                                totalRefCount += lifecycle.GetRefCount()
                        }</span>
                }
                <span class="cov0" title="0">if totalNodes &gt; 0 </span><span class="cov0" title="0">{
                        stats["average_refcount"] = float64(totalRefCount) / float64(totalNodes)
                }</span>
        }

        <span class="cov0" title="0">return stats</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "sync"
        "time"
)

// BetaChainMetrics collecte les m√©triques de performance pour la construction des cha√Ænes beta
type BetaChainMetrics struct {
        // M√©triques de cha√Ænes
        TotalChainsBuilt   int     `json:"total_chains_built"`
        TotalNodesCreated  int     `json:"total_nodes_created"`
        TotalNodesReused   int     `json:"total_nodes_reused"`
        AverageChainLength float64 `json:"average_chain_length"`
        SharingRatio       float64 `json:"sharing_ratio"`

        // M√©triques de partage (compatibilit√© avec BetaBuildMetrics)
        TotalJoinNodesRequested int64 `json:"total_join_nodes_requested"`
        SharedJoinNodesReused   int64 `json:"shared_join_nodes_reused"`
        UniqueJoinNodesCreated  int64 `json:"unique_join_nodes_created"`

        // M√©triques de jointures
        TotalJoinsExecuted     int           `json:"total_joins_executed"`
        AverageJoinTime        time.Duration `json:"average_join_time_ns"`
        TotalJoinTime          time.Duration `json:"total_join_time_ns"`
        AverageJoinSelectivity float64       `json:"average_join_selectivity"`
        AverageResultSize      float64       `json:"average_result_size"`

        // M√©triques de cache de hash
        HashCacheHits   int `json:"hash_cache_hits"`
        HashCacheMisses int `json:"hash_cache_misses"`
        HashCacheSize   int `json:"hash_cache_size"`

        // M√©triques de cache de jointure
        JoinCacheHits      int `json:"join_cache_hits"`
        JoinCacheMisses    int `json:"join_cache_misses"`
        JoinCacheSize      int `json:"join_cache_size"`
        JoinCacheEvictions int `json:"join_cache_evictions"`

        // M√©triques de cache de connexion
        ConnectionCacheHits   int `json:"connection_cache_hits"`
        ConnectionCacheMisses int `json:"connection_cache_misses"`

        // M√©triques de cache de pr√©fixe
        PrefixCacheHits   int `json:"prefix_cache_hits"`
        PrefixCacheMisses int `json:"prefix_cache_misses"`
        PrefixCacheSize   int `json:"prefix_cache_size"`

        // M√©triques de temps
        TotalBuildTime       time.Duration `json:"total_build_time_ns"`
        AverageBuildTime     time.Duration `json:"average_build_time_ns"`
        TotalHashComputeTime time.Duration `json:"total_hash_compute_time_ns"`

        // D√©tails par cha√Æne
        ChainDetails []BetaChainMetricDetail `json:"chain_details,omitempty"`

        mutex sync.RWMutex
}

// BetaChainMetricDetail contient les d√©tails m√©triques pour une cha√Æne beta individuelle
type BetaChainMetricDetail struct {
        RuleID          string        `json:"rule_id"`
        ChainLength     int           `json:"chain_length"`
        NodesCreated    int           `json:"nodes_created"`
        NodesReused     int           `json:"nodes_reused"`
        BuildTime       time.Duration `json:"build_time_ns"`
        Timestamp       time.Time     `json:"timestamp"`
        HashesGenerated []string      `json:"hashes_generated,omitempty"`

        // M√©triques de jointure sp√©cifiques
        JoinsExecuted      int           `json:"joins_executed"`
        TotalJoinTime      time.Duration `json:"total_join_time_ns"`
        AverageSelectivity float64       `json:"average_selectivity"`
        TotalResultSize    int           `json:"total_result_size"`
}

// JoinMetricDetail contient les m√©triques pour une jointure individuelle
type JoinMetricDetail struct {
        JoinNodeID     string        `json:"join_node_id"`
        LeftInputSize  int           `json:"left_input_size"`
        RightInputSize int           `json:"right_input_size"`
        ResultSize     int           `json:"result_size"`
        Selectivity    float64       `json:"selectivity"`
        ExecutionTime  time.Duration `json:"execution_time_ns"`
        Timestamp      time.Time     `json:"timestamp"`
}

// NewBetaChainMetrics cr√©e une nouvelle instance de m√©triques
func NewBetaChainMetrics() *BetaChainMetrics <span class="cov8" title="1">{
        return &amp;BetaChainMetrics{
                ChainDetails: make([]BetaChainMetricDetail, 0),
        }
}</span>

// RecordChainBuild enregistre les m√©triques pour une cha√Æne construite
func (m *BetaChainMetrics) RecordChainBuild(detail BetaChainMetricDetail) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.TotalChainsBuilt++
        m.TotalNodesCreated += detail.NodesCreated
        m.TotalNodesReused += detail.NodesReused
        m.TotalBuildTime += detail.BuildTime
        m.TotalJoinsExecuted += detail.JoinsExecuted
        m.TotalJoinTime += detail.TotalJoinTime

        // Update sharing metrics
        m.TotalJoinNodesRequested += int64(detail.NodesCreated + detail.NodesReused)
        m.SharedJoinNodesReused += int64(detail.NodesReused)
        m.UniqueJoinNodesCreated += int64(detail.NodesCreated)

        // Mettre √† jour les moyennes
        if m.TotalChainsBuilt &gt; 0 </span><span class="cov0" title="0">{
                totalNodes := m.TotalNodesCreated + m.TotalNodesReused
                m.AverageChainLength = float64(totalNodes) / float64(m.TotalChainsBuilt)
                m.AverageBuildTime = m.TotalBuildTime / time.Duration(m.TotalChainsBuilt)

                if totalNodes &gt; 0 </span><span class="cov0" title="0">{
                        m.SharingRatio = float64(m.TotalNodesReused) / float64(totalNodes)
                }</span>
        }

        <span class="cov0" title="0">if m.TotalJoinsExecuted &gt; 0 </span><span class="cov0" title="0">{
                m.AverageJoinTime = m.TotalJoinTime / time.Duration(m.TotalJoinsExecuted)
        }</span>

        <span class="cov0" title="0">m.ChainDetails = append(m.ChainDetails, detail)</span>
}

// RecordJoinExecution enregistre l'ex√©cution d'une jointure
func (m *BetaChainMetrics) RecordJoinExecution(leftSize, rightSize, resultSize int, duration time.Duration) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.TotalJoinsExecuted++
        m.TotalJoinTime += duration

        // Calculer la s√©lectivit√©: r√©sultat / (gauche * droite)
        maxPossible := leftSize * rightSize
        if maxPossible &gt; 0 </span><span class="cov0" title="0">{
                selectivity := float64(resultSize) / float64(maxPossible)

                // Mettre √† jour la moyenne de s√©lectivit√©
                totalSelectivity := m.AverageJoinSelectivity * float64(m.TotalJoinsExecuted-1)
                m.AverageJoinSelectivity = (totalSelectivity + selectivity) / float64(m.TotalJoinsExecuted)
        }</span>

        // Mettre √† jour la taille moyenne des r√©sultats
        <span class="cov0" title="0">totalResultSize := m.AverageResultSize * float64(m.TotalJoinsExecuted-1)
        m.AverageResultSize = (totalResultSize + float64(resultSize)) / float64(m.TotalJoinsExecuted)

        // Mettre √† jour le temps moyen
        m.AverageJoinTime = m.TotalJoinTime / time.Duration(m.TotalJoinsExecuted)</span>
}

// RecordHashCacheHit enregistre un hit du cache de hash
func (m *BetaChainMetrics) RecordHashCacheHit() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.HashCacheHits++
}</span>

// RecordHashCacheMiss enregistre un miss du cache de hash
func (m *BetaChainMetrics) RecordHashCacheMiss() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.HashCacheMisses++
}</span>

// UpdateHashCacheSize met √† jour la taille du cache de hash
func (m *BetaChainMetrics) UpdateHashCacheSize(size int) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.HashCacheSize = size
}</span>

// RecordJoinCacheHit enregistre un hit du cache de jointure
func (m *BetaChainMetrics) RecordJoinCacheHit() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.JoinCacheHits++
}</span>

// RecordJoinCacheMiss enregistre un miss du cache de jointure
func (m *BetaChainMetrics) RecordJoinCacheMiss() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.JoinCacheMisses++
}</span>

// UpdateJoinCacheSize met √† jour la taille du cache de jointure
func (m *BetaChainMetrics) UpdateJoinCacheSize(size int) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.JoinCacheSize = size
}</span>

// RecordJoinCacheEviction enregistre une √©viction du cache de jointure
func (m *BetaChainMetrics) RecordJoinCacheEviction() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.JoinCacheEvictions++
}</span>

// RecordConnectionCacheHit enregistre un hit du cache de connexion
func (m *BetaChainMetrics) RecordConnectionCacheHit() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.ConnectionCacheHits++
}</span>

// RecordConnectionCacheMiss enregistre un miss du cache de connexion
func (m *BetaChainMetrics) RecordConnectionCacheMiss() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.ConnectionCacheMisses++
}</span>

// RecordPrefixCacheHit enregistre un hit du cache de pr√©fixe
func (m *BetaChainMetrics) RecordPrefixCacheHit() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.PrefixCacheHits++
}</span>

// RecordPrefixCacheMiss enregistre un miss du cache de pr√©fixe
func (m *BetaChainMetrics) RecordPrefixCacheMiss() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.PrefixCacheMisses++
}</span>

// UpdatePrefixCacheSize met √† jour la taille du cache de pr√©fixe
func (m *BetaChainMetrics) UpdatePrefixCacheSize(size int) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.PrefixCacheSize = size
}</span>

// AddHashComputeTime ajoute du temps de calcul de hash
func (m *BetaChainMetrics) AddHashComputeTime(duration time.Duration) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.TotalHashComputeTime += duration
}</span>

// GetSnapshot retourne une copie thread-safe des m√©triques actuelles
func (m *BetaChainMetrics) GetSnapshot() BetaChainMetrics <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        // Copie profonde de la structure SANS le mutex
        snapshot := BetaChainMetrics{
                TotalChainsBuilt:        m.TotalChainsBuilt,
                TotalNodesCreated:       m.TotalNodesCreated,
                TotalNodesReused:        m.TotalNodesReused,
                AverageChainLength:      m.AverageChainLength,
                SharingRatio:            m.SharingRatio,
                TotalJoinNodesRequested: m.TotalJoinNodesRequested,
                SharedJoinNodesReused:   m.SharedJoinNodesReused,
                UniqueJoinNodesCreated:  m.UniqueJoinNodesCreated,
                TotalJoinsExecuted:      m.TotalJoinsExecuted,
                AverageJoinTime:         m.AverageJoinTime,
                TotalJoinTime:           m.TotalJoinTime,
                AverageJoinSelectivity:  m.AverageJoinSelectivity,
                AverageResultSize:       m.AverageResultSize,
                HashCacheHits:           m.HashCacheHits,
                HashCacheMisses:         m.HashCacheMisses,
                HashCacheSize:           m.HashCacheSize,
                JoinCacheHits:           m.JoinCacheHits,
                JoinCacheMisses:         m.JoinCacheMisses,
                JoinCacheSize:           m.JoinCacheSize,
                JoinCacheEvictions:      m.JoinCacheEvictions,
                ConnectionCacheHits:     m.ConnectionCacheHits,
                ConnectionCacheMisses:   m.ConnectionCacheMisses,
                PrefixCacheHits:         m.PrefixCacheHits,
                PrefixCacheMisses:       m.PrefixCacheMisses,
                PrefixCacheSize:         m.PrefixCacheSize,
                TotalBuildTime:          m.TotalBuildTime,
                AverageBuildTime:        m.AverageBuildTime,
                TotalHashComputeTime:    m.TotalHashComputeTime,
                ChainDetails:            make([]BetaChainMetricDetail, len(m.ChainDetails)),
        }

        copy(snapshot.ChainDetails, m.ChainDetails)
        return snapshot
}</span>

// Reset r√©initialise toutes les m√©triques
func (m *BetaChainMetrics) Reset() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.TotalChainsBuilt = 0
        m.TotalNodesCreated = 0
        m.TotalNodesReused = 0
        m.AverageChainLength = 0.0
        m.SharingRatio = 0.0
        m.TotalJoinNodesRequested = 0
        m.SharedJoinNodesReused = 0
        m.UniqueJoinNodesCreated = 0
        m.TotalJoinsExecuted = 0
        m.AverageJoinTime = 0
        m.TotalJoinTime = 0
        m.AverageJoinSelectivity = 0.0
        m.AverageResultSize = 0.0
        m.HashCacheHits = 0
        m.HashCacheMisses = 0
        m.HashCacheSize = 0
        m.JoinCacheHits = 0
        m.JoinCacheMisses = 0
        m.JoinCacheSize = 0
        m.JoinCacheEvictions = 0
        m.ConnectionCacheHits = 0
        m.ConnectionCacheMisses = 0
        m.PrefixCacheHits = 0
        m.PrefixCacheMisses = 0
        m.PrefixCacheSize = 0
        m.TotalBuildTime = 0
        m.AverageBuildTime = 0
        m.TotalHashComputeTime = 0
        m.ChainDetails = make([]BetaChainMetricDetail, 0)
}</span>

// GetHashCacheEfficiency retourne l'efficacit√© du cache de hash (0.0 √† 1.0)
func (m *BetaChainMetrics) GetHashCacheEfficiency() float64 <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        total := m.HashCacheHits + m.HashCacheMisses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(m.HashCacheHits) / float64(total)</span>
}

// GetJoinCacheEfficiency retourne l'efficacit√© du cache de jointure (0.0 √† 1.0)
func (m *BetaChainMetrics) GetJoinCacheEfficiency() float64 <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        total := m.JoinCacheHits + m.JoinCacheMisses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(m.JoinCacheHits) / float64(total)</span>
}

// GetConnectionCacheEfficiency retourne l'efficacit√© du cache de connexion (0.0 √† 1.0)
func (m *BetaChainMetrics) GetConnectionCacheEfficiency() float64 <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        total := m.ConnectionCacheHits + m.ConnectionCacheMisses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(m.ConnectionCacheHits) / float64(total)</span>
}

// GetPrefixCacheEfficiency retourne l'efficacit√© du cache de pr√©fixe (0.0 √† 1.0)
func (m *BetaChainMetrics) GetPrefixCacheEfficiency() float64 <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        total := m.PrefixCacheHits + m.PrefixCacheMisses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(m.PrefixCacheHits) / float64(total)</span>
}

// GetSummary retourne un r√©sum√© format√© des m√©triques
func (m *BetaChainMetrics) GetSummary() map[string]interface{} <span class="cov0" title="0">{
        snapshot := m.GetSnapshot()

        return map[string]interface{}{
                "chains": map[string]interface{}{
                        "total_built":        snapshot.TotalChainsBuilt,
                        "average_length":     snapshot.AverageChainLength,
                        "total_build_time":   snapshot.TotalBuildTime.String(),
                        "average_build_time": snapshot.AverageBuildTime.String(),
                },
                "nodes": map[string]interface{}{
                        "total_created":  snapshot.TotalNodesCreated,
                        "total_reused":   snapshot.TotalNodesReused,
                        "sharing_ratio":  snapshot.SharingRatio,
                        "reuse_rate_pct": snapshot.SharingRatio * 100,
                },
                "joins": map[string]interface{}{
                        "total_executed":      snapshot.TotalJoinsExecuted,
                        "total_time":          snapshot.TotalJoinTime.String(),
                        "average_time":        snapshot.AverageJoinTime.String(),
                        "average_selectivity": snapshot.AverageJoinSelectivity,
                        "average_result_size": snapshot.AverageResultSize,
                        "selectivity_pct":     snapshot.AverageJoinSelectivity * 100,
                },
                "hash_cache": map[string]interface{}{
                        "hits":           snapshot.HashCacheHits,
                        "misses":         snapshot.HashCacheMisses,
                        "size":           snapshot.HashCacheSize,
                        "efficiency":     m.GetHashCacheEfficiency(),
                        "total_time":     snapshot.TotalHashComputeTime.String(),
                        "efficiency_pct": m.GetHashCacheEfficiency() * 100,
                },
                "join_cache": map[string]interface{}{
                        "hits":           snapshot.JoinCacheHits,
                        "misses":         snapshot.JoinCacheMisses,
                        "size":           snapshot.JoinCacheSize,
                        "evictions":      snapshot.JoinCacheEvictions,
                        "efficiency":     m.GetJoinCacheEfficiency(),
                        "efficiency_pct": m.GetJoinCacheEfficiency() * 100,
                },
                "connection_cache": map[string]interface{}{
                        "hits":           snapshot.ConnectionCacheHits,
                        "misses":         snapshot.ConnectionCacheMisses,
                        "efficiency":     m.GetConnectionCacheEfficiency(),
                        "efficiency_pct": m.GetConnectionCacheEfficiency() * 100,
                },
                "prefix_cache": map[string]interface{}{
                        "hits":           snapshot.PrefixCacheHits,
                        "misses":         snapshot.PrefixCacheMisses,
                        "size":           snapshot.PrefixCacheSize,
                        "efficiency":     m.GetPrefixCacheEfficiency(),
                        "efficiency_pct": m.GetPrefixCacheEfficiency() * 100,
                },
        }
}</span>

// GetTopChainsByBuildTime retourne les N cha√Ænes avec les temps de construction les plus longs
func (m *BetaChainMetrics) GetTopChainsByBuildTime(n int) []BetaChainMetricDetail <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if len(m.ChainDetails) == 0 </span><span class="cov0" title="0">{
                return []BetaChainMetricDetail{}
        }</span>

        // Copier et trier
        <span class="cov0" title="0">chains := make([]BetaChainMetricDetail, len(m.ChainDetails))
        copy(chains, m.ChainDetails)

        // Tri par bulle simple (suffisant pour de petites listes)
        for i := 0; i &lt; len(chains); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(chains); j++ </span><span class="cov0" title="0">{
                        if chains[j].BuildTime &gt; chains[i].BuildTime </span><span class="cov0" title="0">{
                                chains[i], chains[j] = chains[j], chains[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">if n &gt; len(chains) </span><span class="cov0" title="0">{
                n = len(chains)
        }</span>

        <span class="cov0" title="0">return chains[:n]</span>
}

// GetTopChainsByLength retourne les N cha√Ænes les plus longues
func (m *BetaChainMetrics) GetTopChainsByLength(n int) []BetaChainMetricDetail <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if len(m.ChainDetails) == 0 </span><span class="cov0" title="0">{
                return []BetaChainMetricDetail{}
        }</span>

        // Copier et trier
        <span class="cov0" title="0">chains := make([]BetaChainMetricDetail, len(m.ChainDetails))
        copy(chains, m.ChainDetails)

        // Tri par bulle simple
        for i := 0; i &lt; len(chains); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(chains); j++ </span><span class="cov0" title="0">{
                        if chains[j].ChainLength &gt; chains[i].ChainLength </span><span class="cov0" title="0">{
                                chains[i], chains[j] = chains[j], chains[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">if n &gt; len(chains) </span><span class="cov0" title="0">{
                n = len(chains)
        }</span>

        <span class="cov0" title="0">return chains[:n]</span>
}

// GetTopChainsByJoinTime retourne les N cha√Ænes avec les temps de jointure les plus longs
func (m *BetaChainMetrics) GetTopChainsByJoinTime(n int) []BetaChainMetricDetail <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if len(m.ChainDetails) == 0 </span><span class="cov0" title="0">{
                return []BetaChainMetricDetail{}
        }</span>

        // Copier et trier
        <span class="cov0" title="0">chains := make([]BetaChainMetricDetail, len(m.ChainDetails))
        copy(chains, m.ChainDetails)

        // Tri par bulle simple
        for i := 0; i &lt; len(chains); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(chains); j++ </span><span class="cov0" title="0">{
                        if chains[j].TotalJoinTime &gt; chains[i].TotalJoinTime </span><span class="cov0" title="0">{
                                chains[i], chains[j] = chains[j], chains[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">if n &gt; len(chains) </span><span class="cov0" title="0">{
                n = len(chains)
        }</span>

        <span class="cov0" title="0">return chains[:n]</span>
}

// GetJoinPerformanceStats retourne des statistiques d√©taill√©es sur les performances de jointure
func (m *BetaChainMetrics) GetJoinPerformanceStats() map[string]interface{} <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        stats := map[string]interface{}{
                "total_joins":         m.TotalJoinsExecuted,
                "total_time":          m.TotalJoinTime.String(),
                "average_time":        m.AverageJoinTime.String(),
                "average_selectivity": m.AverageJoinSelectivity,
                "average_result_size": m.AverageResultSize,
        }

        if m.TotalJoinsExecuted &gt; 0 </span><span class="cov0" title="0">{
                stats["average_time_per_join_ms"] = float64(m.AverageJoinTime.Microseconds()) / 1000.0
                stats["throughput_joins_per_sec"] = float64(m.TotalJoinsExecuted) / m.TotalJoinTime.Seconds()
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// GetCacheStats retourne un r√©sum√© de tous les caches
func (m *BetaChainMetrics) GetCacheStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "hash_cache": map[string]interface{}{
                        "hits":           m.HashCacheHits,
                        "misses":         m.HashCacheMisses,
                        "size":           m.HashCacheSize,
                        "efficiency":     m.GetHashCacheEfficiency(),
                        "efficiency_pct": m.GetHashCacheEfficiency() * 100,
                },
                "join_cache": map[string]interface{}{
                        "hits":           m.JoinCacheHits,
                        "misses":         m.JoinCacheMisses,
                        "size":           m.JoinCacheSize,
                        "evictions":      m.JoinCacheEvictions,
                        "efficiency":     m.GetJoinCacheEfficiency(),
                        "efficiency_pct": m.GetJoinCacheEfficiency() * 100,
                },
                "connection_cache": map[string]interface{}{
                        "hits":           m.ConnectionCacheHits,
                        "misses":         m.ConnectionCacheMisses,
                        "efficiency":     m.GetConnectionCacheEfficiency(),
                        "efficiency_pct": m.GetConnectionCacheEfficiency() * 100,
                },
                "prefix_cache": map[string]interface{}{
                        "hits":           m.PrefixCacheHits,
                        "misses":         m.PrefixCacheMisses,
                        "size":           m.PrefixCacheSize,
                        "efficiency":     m.GetPrefixCacheEfficiency(),
                        "efficiency_pct": m.GetPrefixCacheEfficiency() * 100,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "sync"
        "time"
)

// BetaJoinCache g√®re le cache des r√©sultats de jointure pour optimiser les performances.
//
// Le cache stocke les r√©sultats de jointure entre tokens gauche et faits droite,
// √©vitant ainsi de recalculer les m√™mes matchs r√©p√©titivement.
//
// Architecture:
//
//        Cache Key: hash(leftTokenID + rightFactID + joinConditions)
//        Cache Value: JoinResult (matched: bool, token: *Token, timestamp: time)
//
// Utilisation du cache LRU existant pour b√©n√©ficier de:
//   - √âviction automatique (LRU)
//   - TTL configurable
//   - Thread-safety
//   - M√©triques int√©gr√©es
//
// Exemple d'utilisation:
//
//        cache := NewBetaJoinCache(config)
//
//        // Tenter de r√©cup√©rer du cache
//        if result, found := cache.GetJoinResult(leftToken, rightFact, joinNode); found {
//            return result.Token // R√©sultat mis en cache
//        }
//
//        // Calculer et mettre en cache
//        result := performJoin(leftToken, rightFact)
//        cache.SetJoinResult(leftToken, rightFact, joinNode, result)
type BetaJoinCache struct {
        // Cache LRU sous-jacent
        lruCache *LRUCache

        // Configuration
        config *ChainPerformanceConfig

        // Mutex pour les op√©rations qui n√©cessitent une atomicit√©
        mutex sync.RWMutex

        // M√©triques sp√©cifiques au cache de jointure
        joinCacheHits      int64
        joinCacheMisses    int64
        joinCacheEvictions int64
        invalidations      int64
}

// JoinResult repr√©sente le r√©sultat d'une op√©ration de jointure mise en cache.
type JoinResult struct {
        Matched   bool      // true si le token et le fait ont match√©
        Token     *Token    // Token r√©sultant si matched=true, nil sinon
        Timestamp time.Time // Timestamp de la mise en cache
        JoinType  string    // Type de jointure (pour debug/metrics)
}

// joinCacheKey repr√©sente une cl√© de cache pour une op√©ration de jointure.
type joinCacheKey struct {
        LeftTokenID  string `json:"left_token_id"`
        RightFactID  string `json:"right_fact_id"`
        JoinNodeID   string `json:"join_node_id"`
        ConditionSig string `json:"condition_sig"` // Signature des conditions de jointure
}

// NewBetaJoinCache cr√©e un nouveau cache de r√©sultats de jointure.
//
// Param√®tres:
//   - config: Configuration de performance (nil = config par d√©faut)
//
// Retourne:
//   - Un nouveau BetaJoinCache pr√™t √† l'emploi
//
// Exemple:
//
//        config := DefaultChainPerformanceConfig()
//        config.BetaJoinResultCacheEnabled = true
//        config.BetaJoinResultCacheMaxSize = 10000
//        config.BetaJoinResultCacheTTL = time.Minute
//
//        cache := NewBetaJoinCache(config)
func NewBetaJoinCache(config *ChainPerformanceConfig) *BetaJoinCache <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultChainPerformanceConfig()
        }</span>

        // Cr√©er le cache LRU sous-jacent
        <span class="cov0" title="0">lruCache := NewLRUCache(
                config.BetaJoinResultCacheMaxSize,
                config.BetaJoinResultCacheTTL,
        )

        return &amp;BetaJoinCache{
                lruCache: lruCache,
                config:   config,
        }</span>
}

// GetJoinResult tente de r√©cup√©rer un r√©sultat de jointure du cache.
//
// Param√®tres:
//   - leftToken: Token du c√¥t√© gauche
//   - rightFact: Fait du c√¥t√© droit
//   - joinNode: JoinNode contenant les conditions de jointure
//
// Retourne:
//   - result: Le r√©sultat de jointure mis en cache
//   - found: true si trouv√© dans le cache, false sinon
//
// Thread-safe: Oui
//
// Exemple:
//
//        if result, found := cache.GetJoinResult(token, fact, node); found {
//            if result.Matched {
//                return result.Token // Jointure r√©ussie
//            }
//            return nil // Pas de match
//        }
//        // Cache miss - calculer la jointure
func (bjc *BetaJoinCache) GetJoinResult(leftToken *Token, rightFact *Fact, joinNode *JoinNode) (*JoinResult, bool) <span class="cov0" title="0">{
        if !bjc.isEnabled() </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // G√©n√©rer la cl√© de cache
        <span class="cov0" title="0">cacheKey, err := bjc.computeCacheKey(leftToken, rightFact, joinNode)
        if err != nil </span><span class="cov0" title="0">{
                // En cas d'erreur, consid√©rer comme cache miss
                bjc.recordMiss()
                return nil, false
        }</span>

        // Chercher dans le cache LRU
        <span class="cov0" title="0">value, found := bjc.lruCache.Get(cacheKey)
        if !found </span><span class="cov0" title="0">{
                bjc.recordMiss()
                return nil, false
        }</span>

        // V√©rifier le type
        <span class="cov0" title="0">result, ok := value.(*JoinResult)
        if !ok </span><span class="cov0" title="0">{
                // Type invalide - consid√©rer comme miss
                bjc.recordMiss()
                return nil, false
        }</span>

        <span class="cov0" title="0">bjc.recordHit()
        return result, true</span>
}

// SetJoinResult met en cache un r√©sultat de jointure.
//
// Param√®tres:
//   - leftToken: Token du c√¥t√© gauche
//   - rightFact: Fait du c√¥t√© droit
//   - joinNode: JoinNode contenant les conditions de jointure
//   - result: Le r√©sultat de jointure √† mettre en cache
//
// Thread-safe: Oui
//
// Exemple:
//
//        result := &amp;JoinResult{
//            Matched: true,
//            Token: joinedToken,
//            Timestamp: time.Now(),
//            JoinType: "binary",
//        }
//        cache.SetJoinResult(token, fact, node, result)
func (bjc *BetaJoinCache) SetJoinResult(leftToken *Token, rightFact *Fact, joinNode *JoinNode, result *JoinResult) <span class="cov0" title="0">{
        if !bjc.isEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        // G√©n√©rer la cl√© de cache
        <span class="cov0" title="0">cacheKey, err := bjc.computeCacheKey(leftToken, rightFact, joinNode)
        if err != nil </span><span class="cov0" title="0">{
                // Impossible de g√©n√©rer la cl√© - ignorer
                return
        }</span>

        // D√©finir le timestamp si pas d√©j√† d√©fini
        <span class="cov0" title="0">if result.Timestamp.IsZero() </span><span class="cov0" title="0">{
                result.Timestamp = time.Now()
        }</span>

        // Stocker dans le cache LRU
        <span class="cov0" title="0">bjc.lruCache.Set(cacheKey, result)</span>
}

// InvalidateForFact invalide toutes les entr√©es de cache contenant un fait donn√©.
//
// Appel√© lors de la r√©tractation d'un fait pour assurer la coh√©rence du cache.
//
// Param√®tres:
//   - factID: ID du fait √† invalider
//
// Retourne:
//   - Le nombre d'entr√©es invalid√©es
//
// Note: Cette op√©ration peut √™tre co√ªteuse car elle n√©cessite de parcourir
// toutes les entr√©es du cache. Pour de meilleures performances, consid√©rer
// un TTL court plut√¥t que des invalidations fr√©quentes.
//
// Thread-safe: Oui
//
// Exemple:
//
//        // Lors de la r√©tractation d'un fait
//        invalidated := cache.InvalidateForFact(fact.GetInternalID())
//        log.Printf("Invalid√© %d entr√©es de cache", invalidated)
func (bjc *BetaJoinCache) InvalidateForFact(factID string) int <span class="cov0" title="0">{
        if !bjc.isEnabled() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">bjc.mutex.Lock()
        defer bjc.mutex.Unlock()

        // Cette op√©ration n√©cessite de parcourir le cache
        // Pour des raisons de performance, on utilise une approche simple:
        // Clear tout le cache si l'invalidation concerne trop d'entr√©es
        // (impl√©mentation simple pour √©viter la complexit√©)

        // Pour l'instant, on clear tout le cache lors d'une invalidation
        // Une future optimisation pourrait maintenir un index inverse factID -&gt; cacheKeys
        bjc.lruCache.Clear()
        bjc.invalidations++

        return 1</span> // Retourner 1 pour indiquer qu'une invalidation a eu lieu
}

// InvalidateForToken invalide toutes les entr√©es de cache contenant un token donn√©.
//
// Appel√© lors de modifications du token pour assurer la coh√©rence.
//
// Param√®tres:
//   - tokenID: ID du token √† invalider
//
// Retourne:
//   - Le nombre d'entr√©es invalid√©es
//
// Thread-safe: Oui
func (bjc *BetaJoinCache) InvalidateForToken(tokenID string) int <span class="cov0" title="0">{
        if !bjc.isEnabled() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">bjc.mutex.Lock()
        defer bjc.mutex.Unlock()

        // M√™me approche que InvalidateForFact
        bjc.lruCache.Clear()
        bjc.invalidations++

        return 1</span>
}

// Clear vide compl√®tement le cache.
//
// Utile pour les tests ou pour forcer un rafra√Æchissement complet.
//
// Thread-safe: Oui
//
// Exemple:
//
//        // Forcer un rafra√Æchissement complet
//        cache.Clear()
func (bjc *BetaJoinCache) Clear() <span class="cov0" title="0">{
        if !bjc.isEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">bjc.lruCache.Clear()</span>
}

// GetStats retourne les statistiques d√©taill√©es du cache.
//
// Retourne:
//   - Map contenant les statistiques (hits, misses, hit_rate, size, etc.)
//
// Thread-safe: Oui
//
// Exemple:
//
//        stats := cache.GetStats()
//        fmt.Printf("Hit rate: %.2f%%\n", stats["hit_rate"].(float64) * 100)
//        fmt.Printf("Cache size: %d\n", stats["size"].(int))
func (bjc *BetaJoinCache) GetStats() map[string]interface{} <span class="cov0" title="0">{
        if !bjc.isEnabled() </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "enabled": false,
                }
        }</span>

        // R√©cup√©rer les stats du cache LRU
        <span class="cov0" title="0">lruStats := bjc.lruCache.GetStats()

        bjc.mutex.RLock()
        hits := bjc.joinCacheHits
        misses := bjc.joinCacheMisses
        invalidations := bjc.invalidations
        bjc.mutex.RUnlock()

        // Calculer le hit rate
        total := hits + misses
        hitRate := 0.0
        if total &gt; 0 </span><span class="cov0" title="0">{
                hitRate = float64(hits) / float64(total)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "enabled":       true,
                "size":          lruStats.Size,
                "capacity":      lruStats.Capacity,
                "hits":          hits,
                "misses":        misses,
                "evictions":     lruStats.Evictions,
                "invalidations": invalidations,
                "hit_rate":      hitRate,
                "ttl_seconds":   bjc.config.BetaJoinResultCacheTTL.Seconds(),
        }</span>
}

// GetHitRate retourne le taux de hit du cache (0.0 √† 1.0).
//
// Retourne:
//   - Hit rate entre 0.0 (0%) et 1.0 (100%)
//
// Thread-safe: Oui
//
// Exemple:
//
//        hitRate := cache.GetHitRate()
//        if hitRate &lt; 0.5 {
//            log.Printf("WARNING: Low cache hit rate: %.2f%%", hitRate * 100)
//        }
func (bjc *BetaJoinCache) GetHitRate() float64 <span class="cov0" title="0">{
        bjc.mutex.RLock()
        defer bjc.mutex.RUnlock()

        total := bjc.joinCacheHits + bjc.joinCacheMisses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return float64(bjc.joinCacheHits) / float64(total)</span>
}

// GetSize retourne le nombre d'entr√©es actuellement dans le cache.
//
// Thread-safe: Oui
func (bjc *BetaJoinCache) GetSize() int <span class="cov0" title="0">{
        if !bjc.isEnabled() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return bjc.lruCache.Len()</span>
}

// CleanExpired nettoie les entr√©es expir√©es du cache.
//
// Retourne:
//   - Le nombre d'entr√©es nettoy√©es
//
// Thread-safe: Oui
//
// Exemple:
//
//        // P√©riodiquement nettoyer les entr√©es expir√©es
//        ticker := time.NewTicker(time.Minute)
//        go func() {
//            for range ticker.C {
//                cleaned := cache.CleanExpired()
//                if cleaned &gt; 0 {
//                    log.Printf("Cleaned %d expired cache entries", cleaned)
//                }
//            }
//        }()
func (bjc *BetaJoinCache) CleanExpired() int <span class="cov0" title="0">{
        if !bjc.isEnabled() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return bjc.lruCache.CleanExpired()</span>
}

// computeCacheKey calcule une cl√© de cache pour une op√©ration de jointure.
//
// La cl√© est bas√©e sur:
//   - ID du token gauche
//   - ID du fait droit
//   - ID du JoinNode
//   - Signature des conditions de jointure
//
// Utilise SHA-256 pour obtenir une cl√© stable et courte.
func (bjc *BetaJoinCache) computeCacheKey(leftToken *Token, rightFact *Fact, joinNode *JoinNode) (string, error) <span class="cov0" title="0">{
        // Construire la structure de cl√©
        key := joinCacheKey{
                LeftTokenID:  leftToken.ID,
                RightFactID:  rightFact.GetInternalID(),
                JoinNodeID:   joinNode.ID,
                ConditionSig: bjc.computeConditionSignature(joinNode),
        }

        // S√©rialiser en JSON pour hashing
        jsonBytes, err := json.Marshal(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal cache key: %w", err)
        }</span>

        // Calculer le hash SHA-256
        <span class="cov0" title="0">hash := sha256.Sum256(jsonBytes)
        hashStr := fmt.Sprintf("join_cache_%x", hash[:8]) // Utiliser les 8 premiers octets

        return hashStr, nil</span>
}

// computeConditionSignature calcule une signature des conditions de jointure.
//
// Cette signature permet de diff√©rencier des jointures sur les m√™mes
// tokens/faits mais avec des conditions diff√©rentes.
func (bjc *BetaJoinCache) computeConditionSignature(joinNode *JoinNode) string <span class="cov0" title="0">{
        // Utiliser l'ID du JoinNode comme signature simple
        // Dans une impl√©mentation plus avanc√©e, on pourrait hasher les conditions r√©elles
        return joinNode.ID
}</span>

// isEnabled v√©rifie si le cache est activ√©.
func (bjc *BetaJoinCache) isEnabled() bool <span class="cov0" title="0">{
        return bjc.config != nil &amp;&amp;
                bjc.config.BetaCacheEnabled &amp;&amp;
                bjc.config.BetaJoinResultCacheEnabled
}</span>

// recordHit enregistre un hit du cache.
func (bjc *BetaJoinCache) recordHit() <span class="cov0" title="0">{
        bjc.mutex.Lock()
        defer bjc.mutex.Unlock()
        bjc.joinCacheHits++
}</span>

// recordMiss enregistre un miss du cache.
func (bjc *BetaJoinCache) recordMiss() <span class="cov0" title="0">{
        bjc.mutex.Lock()
        defer bjc.mutex.Unlock()
        bjc.joinCacheMisses++
}</span>

// ResetStats r√©initialise les statistiques du cache.
//
// Utile pour les tests ou pour commencer un nouveau cycle de monitoring.
//
// Thread-safe: Oui
func (bjc *BetaJoinCache) ResetStats() <span class="cov0" title="0">{
        bjc.mutex.Lock()
        defer bjc.mutex.Unlock()

        bjc.joinCacheHits = 0
        bjc.joinCacheMisses = 0
        bjc.joinCacheEvictions = 0
        bjc.invalidations = 0
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "sort"
        "sync/atomic"
        "time"
)

// ============================================================================
// BetaSharingRegistryImpl Implementation
// ============================================================================

// GetOrCreateJoinNode returns a shared JoinNode for the given signature.
func (bsr *BetaSharingRegistryImpl) GetOrCreateJoinNode(
        condition interface{},
        leftVars []string,
        rightVars []string,
        allVars []string,
        varTypes map[string]string,
        storage Storage,
) (*JoinNode, string, bool, error) <span class="cov8" title="1">{
        if !bsr.config.Enabled </span><span class="cov0" title="0">{
                // Beta sharing disabled - create unique node
                nodeID := fmt.Sprintf("join_%d", time.Now().UnixNano())
                var conditionMap map[string]interface{}
                if condition != nil </span><span class="cov0" title="0">{
                        if cm, ok := condition.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                conditionMap = cm
                        }</span>
                }
                <span class="cov0" title="0">node := NewJoinNode(nodeID, conditionMap, leftVars, rightVars, varTypes, storage)
                return node, nodeID, false, nil</span>
        }

        // Create signature
        <span class="cov8" title="1">sig := &amp;JoinNodeSignature{
                Condition: condition,
                LeftVars:  leftVars,
                RightVars: rightVars,
                AllVars:   allVars,
                VarTypes:  varTypes,
        }

        // Compute hash (with caching if hasher supports it)
        var hash string
        var err error

        if bsr.hasher != nil </span><span class="cov8" title="1">{
                hash, err = bsr.hasher.ComputeHashCached(sig)
        }</span> else<span class="cov0" title="0"> {
                hash, err = bsr.computeHashDirect(sig)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, "", false, fmt.Errorf("failed to compute hash: %w", err)
        }</span>

        // Check if node already exists
        <span class="cov8" title="1">bsr.mutex.RLock()
        existingNode, exists := bsr.sharedJoinNodes[hash]
        bsr.mutex.RUnlock()

        if exists </span><span class="cov8" title="1">{
                // Node found - record metrics
                if bsr.config.EnableMetrics </span><span class="cov8" title="1">{
                        RecordSharedReuse(bsr.metrics)
                }</span>

                <span class="cov8" title="1">return existingNode, hash, true, nil</span>
        }

        // Node not found - create new one
        <span class="cov8" title="1">bsr.mutex.Lock()
        defer bsr.mutex.Unlock()

        // Double-check after acquiring write lock
        if existingNode, exists := bsr.sharedJoinNodes[hash]; exists </span><span class="cov0" title="0">{
                if bsr.config.EnableMetrics </span><span class="cov0" title="0">{
                        RecordSharedReuse(bsr.metrics)
                }</span>
                <span class="cov0" title="0">return existingNode, hash, true, nil</span>
        }

        // Create new JoinNode (convert condition to map[string]interface{})
        <span class="cov8" title="1">var conditionMap map[string]interface{}
        if condition != nil </span><span class="cov8" title="1">{
                if cm, ok := condition.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        conditionMap = cm
                }</span> else<span class="cov0" title="0"> {
                        conditionMap = nil
                }</span>
        }
        <span class="cov8" title="1">node := NewJoinNode(hash, conditionMap, leftVars, rightVars, varTypes, storage)
        bsr.sharedJoinNodes[hash] = node

        // Record metrics
        if bsr.config.EnableMetrics </span><span class="cov8" title="1">{
                RecordUniqueCreation(bsr.metrics)
        }</span>

        <span class="cov8" title="1">return node, hash, false, nil</span>
}

// RegisterJoinNode explicitly registers an existing JoinNode.
func (bsr *BetaSharingRegistryImpl) RegisterJoinNode(node *JoinNode, hash string) error <span class="cov0" title="0">{
        if !bsr.config.Enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("beta sharing is disabled")
        }</span>

        <span class="cov0" title="0">bsr.mutex.Lock()
        defer bsr.mutex.Unlock()

        // Check if hash is already registered
        if existingNode, exists := bsr.sharedJoinNodes[hash]; exists </span><span class="cov0" title="0">{
                if existingNode != node </span><span class="cov0" title="0">{
                        return fmt.Errorf("hash %s already registered with different node", hash)
                }</span>
                // Same node already exists
                <span class="cov0" title="0">return nil</span>
        }

        // Register new node
        <span class="cov0" title="0">bsr.sharedJoinNodes[hash] = node

        return nil</span>
}

// ReleaseJoinNode decrements refcount and removes node if unused.
func (bsr *BetaSharingRegistryImpl) ReleaseJoinNode(hash string) error <span class="cov0" title="0">{
        if !bsr.config.Enabled </span><span class="cov0" title="0">{
                return nil // No-op when disabled
        }</span>

        <span class="cov0" title="0">bsr.mutex.Lock()
        defer bsr.mutex.Unlock()

        _, exists := bsr.sharedJoinNodes[hash]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("join node with hash %s not found", hash)
        }</span>

        // Remove node (simplified - no refcounting in this version)
        <span class="cov0" title="0">delete(bsr.sharedJoinNodes, hash)

        return nil</span>
}

// GetSharingStats returns current sharing metrics.
func (bsr *BetaSharingRegistryImpl) GetSharingStats() *BetaSharingStats <span class="cov0" title="0">{
        bsr.mutex.RLock()
        totalShared := len(bsr.sharedJoinNodes)
        bsr.mutex.RUnlock()

        stats := &amp;BetaSharingStats{
                TotalSharedNodes:  totalShared,
                TotalRequests:     atomic.LoadInt64(&amp;bsr.metrics.TotalJoinNodesRequested),
                SharedReuses:      atomic.LoadInt64(&amp;bsr.metrics.SharedJoinNodesReused),
                UniqueCreations:   atomic.LoadInt64(&amp;bsr.metrics.UniqueJoinNodesCreated),
                SharingRatio:      CalculateSharingRatio(bsr.metrics),
                HashCacheHitRate:  CalculateCacheHitRate(bsr.metrics),
                AverageHashTimeMs: float64(bsr.metrics.AverageHashTimeNs()) / 1_000_000.0,
                Timestamp:         time.Now(),
        }

        return stats
}</span>

// ListSharedJoinNodes returns all shared join node hashes.
func (bsr *BetaSharingRegistryImpl) ListSharedJoinNodes() []string <span class="cov0" title="0">{
        bsr.mutex.RLock()
        defer bsr.mutex.RUnlock()

        hashes := make([]string, 0, len(bsr.sharedJoinNodes))
        for hash := range bsr.sharedJoinNodes </span><span class="cov0" title="0">{
                hashes = append(hashes, hash)
        }</span>

        <span class="cov0" title="0">sort.Strings(hashes)
        return hashes</span>
}

// GetSharedJoinNodeDetails returns detailed info about a shared node.
func (bsr *BetaSharingRegistryImpl) GetSharedJoinNodeDetails(hash string) (*JoinNodeDetails, error) <span class="cov0" title="0">{
        bsr.mutex.RLock()
        node, exists := bsr.sharedJoinNodes[hash]
        bsr.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("join node with hash %s not found", hash)
        }</span>

        <span class="cov0" title="0">details := &amp;JoinNodeDetails{
                Hash:             hash,
                NodeID:           node.GetID(),
                ReferenceCount:   1, // Simplified - no refcounting in this version
                LeftVars:         node.LeftVariables,
                RightVars:        node.RightVariables,
                AllVars:          node.AllVariables,
                VarTypes:         node.VariableTypes,
                LeftMemorySize:   len(node.LeftMemory.Tokens),
                RightMemorySize:  len(node.RightMemory.Tokens),
                ResultMemorySize: len(node.ResultMemory.Tokens),
                CreatedAt:        time.Time{}, // TODO: Track creation time
                LastAccessedAt:   time.Now(),
                ActivationCount:  0, // TODO: Track activation count
        }

        return details, nil</span>
}

// ClearCache clears the hash cache.
func (bsr *BetaSharingRegistryImpl) ClearCache() <span class="cov0" title="0">{
        if bsr.hashCache != nil </span><span class="cov0" title="0">{
                bsr.hashCache.Clear()
        }</span>
}

// Shutdown performs cleanup and releases all resources.
func (bsr *BetaSharingRegistryImpl) Shutdown() error <span class="cov0" title="0">{
        bsr.mutex.Lock()
        defer bsr.mutex.Unlock()

        // Clear all nodes
        bsr.sharedJoinNodes = make(map[string]*JoinNode)

        // Clear cache
        if bsr.hashCache != nil </span><span class="cov0" title="0">{
                bsr.hashCache.Clear()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// computeHashDirect computes hash without a hasher (fallback).
func (bsr *BetaSharingRegistryImpl) computeHashDirect(sig *JoinNodeSignature) (string, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Normalize signature
        canonical, err := bsr.normalizeSignatureFallback(sig)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Compute hash
        <span class="cov0" title="0">hash, err := ComputeJoinNodeHash(canonical)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Record metrics
        <span class="cov0" title="0">if bsr.config.EnableMetrics </span><span class="cov0" title="0">{
                duration := time.Since(startTime).Nanoseconds()
                RecordHashComputation(bsr.metrics, duration)
        }</span>

        <span class="cov0" title="0">return hash, nil</span>
}

// normalizeSignatureFallback provides basic normalization when no normalizer is configured.
func (bsr *BetaSharingRegistryImpl) normalizeSignatureFallback(sig *JoinNodeSignature) (*CanonicalJoinSignature, error) <span class="cov0" title="0">{
        canonical := &amp;CanonicalJoinSignature{
                Version:   "1.0",
                Condition: sig.Condition,
        }

        // Sort variables if normalization is enabled
        if bsr.config.NormalizeOrder </span><span class="cov0" title="0">{
                canonical.LeftVars = sortStrings(sig.LeftVars)
                canonical.RightVars = sortStrings(sig.RightVars)
                canonical.AllVars = sortStrings(sig.AllVars)
        }</span> else<span class="cov0" title="0"> {
                canonical.LeftVars = sig.LeftVars
                canonical.RightVars = sig.RightVars
                canonical.AllVars = sig.AllVars
        }</span>

        // Convert and sort variable types
        <span class="cov0" title="0">canonical.VarTypes = sortVarTypes(sig.VarTypes)

        return canonical, nil</span>
}

// ============================================================================
// DefaultJoinNodeNormalizer Implementation
// ============================================================================

// defaultJoinNodeNormalizer is the default implementation of JoinNodeNormalizer.
type defaultJoinNodeNormalizer struct {
        config BetaSharingConfig
}

// NewDefaultJoinNodeNormalizer creates a default normalizer.
func NewDefaultJoinNodeNormalizer(config BetaSharingConfig) JoinNodeNormalizer <span class="cov8" title="1">{
        return &amp;defaultJoinNodeNormalizer{config: config}
}</span>

// NormalizeSignature converts a join signature to canonical form.
func (n *defaultJoinNodeNormalizer) NormalizeSignature(sig *JoinNodeSignature) (*CanonicalJoinSignature, error) <span class="cov8" title="1">{
        canonical := &amp;CanonicalJoinSignature{
                Version: "1.0",
        }

        // Sort variables if normalization is enabled
        if n.config.NormalizeOrder </span><span class="cov8" title="1">{
                canonical.LeftVars = sortStrings(sig.LeftVars)
                canonical.RightVars = sortStrings(sig.RightVars)
                canonical.AllVars = sortStrings(sig.AllVars)
        }</span> else<span class="cov0" title="0"> {
                canonical.LeftVars = sig.LeftVars
                canonical.RightVars = sig.RightVars
                canonical.AllVars = sig.AllVars
        }</span>

        // Convert and sort variable types
        <span class="cov8" title="1">canonical.VarTypes = sortVarTypes(sig.VarTypes)

        // Normalize condition
        normalizedCondition, err := n.NormalizeCondition(sig.Condition)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to normalize condition: %w", err)
        }</span>
        <span class="cov8" title="1">canonical.Condition = normalizedCondition

        return canonical, nil</span>
}

// NormalizeCondition converts a condition AST to canonical form.
func (n *defaultJoinNodeNormalizer) NormalizeCondition(condition interface{}) (interface{}, error) <span class="cov8" title="1">{
        if condition == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Handle map[string]interface{} condition
        <span class="cov8" title="1">if condMap, ok := condition.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                return n.normalizeConditionMap(condMap)
        }</span>

        // Return as-is for other types
        <span class="cov0" title="0">return condition, nil</span>
}

// normalizeConditionMap normalizes a condition represented as a map.
func (n *defaultJoinNodeNormalizer) normalizeConditionMap(condition map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        normalized := make(map[string]interface{})

        // Copy all fields
        for key, value := range condition </span><span class="cov8" title="1">{
                normalized[key] = value
        }</span>

        // Normalize operator synonyms
        <span class="cov8" title="1">if opType, ok := condition["type"].(string); ok </span><span class="cov8" title="1">{
                if opType == "comparison" </span><span class="cov8" title="1">{
                        normalized["type"] = "binaryOperation"
                }</span>
        }

        // Normalize commutative operators (== and !=)
        <span class="cov8" title="1">if n.config.EnableAdvancedNormalization </span><span class="cov0" title="0">{
                if operator, ok := condition["operator"].(string); ok </span><span class="cov0" title="0">{
                        if operator == "==" || operator == "!=" </span><span class="cov0" title="0">{
                                // Sort operands for commutative operators
                                if left, hasLeft := condition["left"]; hasLeft </span><span class="cov0" title="0">{
                                        if right, hasRight := condition["right"]; hasRight </span><span class="cov0" title="0">{
                                                leftJSON, _ := json.Marshal(left)
                                                rightJSON, _ := json.Marshal(right)

                                                // Swap if left &gt; right lexicographically
                                                if string(leftJSON) &gt; string(rightJSON) </span><span class="cov0" title="0">{
                                                        normalized["left"] = right
                                                        normalized["right"] = left
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return normalized, nil</span>
}

// ============================================================================
// DefaultJoinNodeHasher Implementation
// ============================================================================

// defaultJoinNodeHasher is the default implementation of JoinNodeHasher.
type defaultJoinNodeHasher struct {
        config     BetaSharingConfig
        normalizer JoinNodeNormalizer
        cache      *LRUCache
}

// NewDefaultJoinNodeHasher creates a default hasher with LRU caching.
func NewDefaultJoinNodeHasher(config BetaSharingConfig) JoinNodeHasher <span class="cov8" title="1">{
        return &amp;defaultJoinNodeHasher{
                config:     config,
                normalizer: NewDefaultJoinNodeNormalizer(config),
                cache:      NewLRUCache(config.HashCacheSize, 0), // 0 = no TTL
        }
}</span>

// ComputeHash computes a hash for a canonical join signature.
func (h *defaultJoinNodeHasher) ComputeHash(canonical *CanonicalJoinSignature) (string, error) <span class="cov8" title="1">{
        // Serialize to JSON
        jsonBytes, err := json.Marshal(canonical)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal canonical signature: %w", err)
        }</span>

        // Compute SHA-256 hash
        <span class="cov8" title="1">hashBytes := sha256.Sum256(jsonBytes)
        hashHex := hex.EncodeToString(hashBytes[:8])

        return "join_" + hashHex, nil</span>
}

// ComputeHashCached computes a hash with LRU caching.
func (h *defaultJoinNodeHasher) ComputeHashCached(sig *JoinNodeSignature) (string, error) <span class="cov8" title="1">{
        // Create cache key from raw signature
        cacheKeyBytes, err := json.Marshal(sig)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal signature for cache key: %w", err)
        }</span>
        <span class="cov8" title="1">cacheKey := string(cacheKeyBytes)

        // Check cache
        if cachedValue, found := h.cache.Get(cacheKey); found </span><span class="cov8" title="1">{
                if cachedHash, ok := cachedValue.(string); ok </span><span class="cov8" title="1">{
                        return cachedHash, nil
                }</span>
        }

        // Cache miss - normalize and compute hash
        <span class="cov8" title="1">canonical, err := h.normalizer.NormalizeSignature(sig)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">hash, err := h.ComputeHash(canonical)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Store in cache
        <span class="cov8" title="1">h.cache.Set(cacheKey, hash)

        return hash, nil</span>
}

// ============================================================================
// Helper Functions
// ============================================================================

// NormalizeJoinCondition normalizes a join condition for consistent hashing.
// This is a standalone helper function for backward compatibility.
func NormalizeJoinCondition(condition map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        if condition == nil </span><span class="cov0" title="0">{
                return map[string]interface{}{"type": "simple"}, nil
        }</span>

        <span class="cov0" title="0">normalized := make(map[string]interface{})

        // Normalize type field
        if condType, hasType := condition["type"]; hasType </span><span class="cov0" title="0">{
                if typeStr, ok := condType.(string); ok </span><span class="cov0" title="0">{
                        switch typeStr </span>{
                        case "comparison", "binaryOperation":<span class="cov0" title="0">
                                normalized["type"] = "binaryOperation"</span>
                        default:<span class="cov0" title="0">
                                normalized["type"] = typeStr</span>
                        }
                } else<span class="cov0" title="0"> {
                        normalized["type"] = condType
                }</span>
        }

        // Handle commutative operators
        <span class="cov0" title="0">if operator, hasOp := condition["operator"].(string); hasOp </span><span class="cov0" title="0">{
                normalized["operator"] = operator

                if operator == "==" || operator == "!=" </span><span class="cov0" title="0">{
                        // For commutative operators, sort left/right by lexicographic order
                        left, hasLeft := condition["left"]
                        right, hasRight := condition["right"]

                        if hasLeft &amp;&amp; hasRight </span><span class="cov0" title="0">{
                                leftJSON, _ := json.Marshal(left)
                                rightJSON, _ := json.Marshal(right)

                                if string(leftJSON) &gt; string(rightJSON) </span><span class="cov0" title="0">{
                                        normalized["left"] = right
                                        normalized["right"] = left
                                }</span> else<span class="cov0" title="0"> {
                                        normalized["left"] = left
                                        normalized["right"] = right
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Non-commutative operators: preserve order
                        if left, hasLeft := condition["left"]; hasLeft </span><span class="cov0" title="0">{
                                normalized["left"] = left
                        }</span>
                        <span class="cov0" title="0">if right, hasRight := condition["right"]; hasRight </span><span class="cov0" title="0">{
                                normalized["right"] = right
                        }</span>
                }
        }

        // Copy remaining fields
        <span class="cov0" title="0">for key, value := range condition </span><span class="cov0" title="0">{
                if key != "type" &amp;&amp; key != "operator" &amp;&amp; key != "left" &amp;&amp; key != "right" </span><span class="cov0" title="0">{
                        normalized[key] = value
                }</span>
        }

        <span class="cov0" title="0">return normalized, nil</span>
}

// ComputeJoinHash computes a hash for a join specification.
// This is a standalone helper function for backward compatibility.
func ComputeJoinHash(condition map[string]interface{}, leftVars, rightVars []string, varTypes map[string]string) (string, error) <span class="cov0" title="0">{
        // Create canonical signature
        canonical := &amp;CanonicalJoinSignature{
                Version:   "1.0",
                LeftVars:  sortStrings(leftVars),
                RightVars: sortStrings(rightVars),
                AllVars:   sortStrings(append(leftVars, rightVars...)),
                VarTypes:  sortVarTypes(varTypes),
                Condition: condition,
        }

        // Normalize condition
        if condition != nil </span><span class="cov0" title="0">{
                normalizedCond, err := NormalizeJoinCondition(condition)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">canonical.Condition = normalizedCond</span>
        }

        <span class="cov0" title="0">return ComputeJoinNodeHash(canonical)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package rete implements the RETE algorithm for the TSD rule engine.
// This file contains the interface definitions and type declarations for
// Beta node (JoinNode) sharing functionality.
//
// Beta sharing eliminates duplicate JoinNodes by identifying and reusing nodes
// with identical join patterns, reducing memory consumption by 30-50% and
// improving runtime performance by 20-40% in typical rule bases.
package rete

import (
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "sort"
        "sync"
        "sync/atomic"
        "time"
)

// ============================================================================
// Core Interfaces
// ============================================================================

// BetaSharingRegistry is the central registry for shared JoinNodes.
// It provides hash-based lookup, lifecycle management, and metrics collection.
//
// Thread-safe: All public methods can be called concurrently.
type BetaSharingRegistry interface {
        // GetOrCreateJoinNode returns a shared JoinNode for the given signature.
        // If a compatible node exists, it is returned and refcount is incremented.
        // Otherwise, a new node is created and registered.
        //
        // Returns:
        //   - node: The JoinNode instance (shared or newly created)
        //   - hash: Canonical hash of the join signature
        //   - wasShared: true if an existing node was reused, false if newly created
        //   - error: Any error during hash computation or node creation
        GetOrCreateJoinNode(
                condition interface{},
                leftVars []string,
                rightVars []string,
                allVars []string,
                varTypes map[string]string,
                storage Storage,
        ) (*JoinNode, string, bool, error)

        // RegisterJoinNode explicitly registers an existing JoinNode.
        // Used when migrating from non-shared to shared nodes.
        //
        // Returns error if a different node is already registered with the same hash.
        RegisterJoinNode(node *JoinNode, hash string) error

        // ReleaseJoinNode decrements refcount and removes node if unused.
        // Should be called when a rule is removed.
        //
        // Returns error if the hash is not found in the registry.
        ReleaseJoinNode(hash string) error

        // GetSharingStats returns current sharing metrics.
        GetSharingStats() *BetaSharingStats

        // ListSharedJoinNodes returns all shared join node hashes.
        // Results are sorted alphabetically.
        ListSharedJoinNodes() []string

        // GetSharedJoinNodeDetails returns detailed info about a shared node.
        // Returns error if the hash is not found.
        GetSharedJoinNodeDetails(hash string) (*JoinNodeDetails, error)

        // ClearCache clears the hash cache.
        // Used for testing or when normalization rules change.
        ClearCache()

        // Shutdown performs cleanup and releases all resources.
        Shutdown() error
}

// JoinNodeNormalizer normalizes join signatures into canonical form.
type JoinNodeNormalizer interface {
        // NormalizeSignature converts a join signature to canonical form.
        // Equivalent signatures produce identical canonical structures.
        NormalizeSignature(sig *JoinNodeSignature) (*CanonicalJoinSignature, error)

        // NormalizeCondition converts a condition AST to canonical form.
        NormalizeCondition(condition interface{}) (interface{}, error)
}

// JoinNodeHasher computes hashes for join signatures.
type JoinNodeHasher interface {
        // ComputeHash computes a hash for a canonical join signature.
        ComputeHash(canonical *CanonicalJoinSignature) (string, error)

        // ComputeHashCached computes a hash with LRU caching.
        ComputeHashCached(sig *JoinNodeSignature) (string, error)
}

// ============================================================================
// Data Structures
// ============================================================================

// BetaSharingRegistryImpl is the concrete implementation of BetaSharingRegistry.
type BetaSharingRegistryImpl struct {
        // Shared JoinNodes indexed by canonical hash
        sharedJoinNodes map[string]*JoinNode

        // LRU cache for condition hash computation
        // Key: normalized signature JSON
        // Value: computed hash string
        hashCache *LRUCache

        // Lifecycle manager for reference counting (optional)
        lifecycle *LifecycleManager

        // Normalizer for join signatures
        normalizer JoinNodeNormalizer

        // Hasher for computing signature hashes
        hasher JoinNodeHasher

        // Metrics collection
        metrics *BetaBuildMetrics

        // Thread safety
        mutex sync.RWMutex

        // Configuration
        config BetaSharingConfig
}

// BetaSharingConfig contains configuration for Beta node sharing.
type BetaSharingConfig struct {
        // Enabled controls whether Beta sharing is active
        Enabled bool

        // HashCacheSize is the maximum number of cached hash computations
        // Default: 1000
        HashCacheSize int

        // MaxSharedNodes is the maximum number of shared nodes
        // Default: 10000 (0 = unlimited)
        MaxSharedNodes int

        // EnableMetrics controls whether metrics collection is active
        EnableMetrics bool

        // NormalizeOrder controls whether variable order is canonicalized
        // Set to false for debugging to preserve original order
        NormalizeOrder bool

        // EnableAdvancedNormalization enables experimental normalization features
        // (commutative operators, associativity, etc.)
        EnableAdvancedNormalization bool
}

// DefaultBetaSharingConfig returns the default configuration.
func DefaultBetaSharingConfig() BetaSharingConfig <span class="cov0" title="0">{
        return BetaSharingConfig{
                Enabled:                     false, // Disabled by default for safe rollout
                HashCacheSize:               1000,
                MaxSharedNodes:              10000,
                EnableMetrics:               true,
                NormalizeOrder:              true,
                EnableAdvancedNormalization: false,
        }
}</span>

// ============================================================================
// Join Signature Types
// ============================================================================

// JoinNodeSignature represents the complete signature of a JoinNode.
// Used as input to the sharing registry.
type JoinNodeSignature struct {
        // Condition is the join condition AST
        Condition interface{}

        // LeftVars are the variables from the left input
        LeftVars []string

        // RightVars are the variables from the right input
        RightVars []string

        // AllVars are all variables (accumulated from both inputs)
        AllVars []string

        // VarTypes maps variable names to their types
        VarTypes map[string]string
}

// CanonicalJoinSignature is the normalized form of a JoinNodeSignature.
// Semantically equivalent signatures produce identical canonical forms.
type CanonicalJoinSignature struct {
        // Version of the canonicalization algorithm
        // Allows future evolution of normalization rules
        Version string

        // Sorted variable lists
        LeftVars  []string
        RightVars []string
        AllVars   []string

        // Sorted type mappings
        VarTypes []VariableTypeMapping

        // Normalized condition AST
        Condition interface{}
}

// VariableTypeMapping represents a variable name and its type.
// Used in canonical signatures for deterministic ordering.
type VariableTypeMapping struct {
        VarName  string `json:"var_name"`
        TypeName string `json:"type_name"`
}

// ToJSON serializes the canonical signature to JSON.
// Output is deterministic (sorted keys, no whitespace).
func (c *CanonicalJoinSignature) ToJSON() (string, error) <span class="cov0" title="0">{
        bytes, err := json.Marshal(c)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal canonical signature: %w", err)
        }</span>
        <span class="cov0" title="0">return string(bytes), nil</span>
}

// ============================================================================
// Metrics Types
// ============================================================================

// BetaBuildMetrics collects statistics about Beta node sharing.
type BetaBuildMetrics struct {
        // Total number of GetOrCreateJoinNode calls
        TotalJoinNodesRequested int64

        // Number of times a shared node was reused
        SharedJoinNodesReused int64

        // Number of times a new unique node was created
        UniqueJoinNodesCreated int64

        // Hash cache statistics
        HashCacheHits   int64
        HashCacheMisses int64

        // Performance metrics
        TotalHashTimeNs int64 // Cumulative time spent hashing
        HashCount       int64 // Number of hash operations
}

// AverageHashTimeNs returns the average time per hash computation.
func (m *BetaBuildMetrics) AverageHashTimeNs() int64 <span class="cov0" title="0">{
        if m.HashCount == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return m.TotalHashTimeNs / m.HashCount</span>
}

// BetaSharingStats provides a snapshot of sharing statistics.
type BetaSharingStats struct {
        // Current state
        TotalSharedNodes int

        // Cumulative counters
        TotalRequests   int64
        SharedReuses    int64
        UniqueCreations int64

        // Computed metrics
        SharingRatio      float64 // SharedReuses / TotalRequests
        HashCacheHitRate  float64 // CacheHits / (CacheHits + CacheMisses)
        AverageHashTimeMs float64

        // Timestamp
        Timestamp time.Time
}

// JoinNodeDetails provides detailed information about a shared JoinNode.
type JoinNodeDetails struct {
        // Identity
        Hash   string
        NodeID string

        // Reference counting
        ReferenceCount int

        // Join signature
        LeftVars  []string
        RightVars []string
        AllVars   []string
        VarTypes  map[string]string

        // Memory state
        LeftMemorySize   int
        RightMemorySize  int
        ResultMemorySize int

        // Metadata
        CreatedAt       time.Time
        LastAccessedAt  time.Time
        ActivationCount int64
}

// ============================================================================
// Normalization Helpers
// ============================================================================

// Note: LRUCache is defined in lru_cache.go

// NormalizationContext holds state during normalization.
type NormalizationContext struct {
        // Configuration
        NormalizeOrder              bool
        EnableAdvancedNormalization bool

        // State
        seenNodes map[interface{}]bool
}

// NewNormalizationContext creates a new normalization context.
func NewNormalizationContext(config BetaSharingConfig) *NormalizationContext <span class="cov0" title="0">{
        return &amp;NormalizationContext{
                NormalizeOrder:              config.NormalizeOrder,
                EnableAdvancedNormalization: config.EnableAdvancedNormalization,
                seenNodes:                   make(map[interface{}]bool),
        }
}</span>

// ============================================================================
// Hash Computation Helpers
// ============================================================================

// ComputeSHA256Hash computes a SHA-256 hash of the input bytes.
// Returns a hex-encoded string of the first 8 bytes.
func ComputeSHA256Hash(data []byte) string <span class="cov0" title="0">{
        hash := sha256.Sum256(data)
        return hex.EncodeToString(hash[:8]) // Use first 8 bytes (64 bits)
}</span>

// ComputeJoinNodeHash computes a hash for a canonical join signature.
// Returns a hash string prefixed with "join_".
func ComputeJoinNodeHash(canonical *CanonicalJoinSignature) (string, error) <span class="cov0" title="0">{
        // Serialize to JSON
        jsonBytes, err := json.Marshal(canonical)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal canonical signature: %w", err)
        }</span>

        // Compute hash
        <span class="cov0" title="0">hashHex := ComputeSHA256Hash(jsonBytes)

        // Add prefix for readability
        return "join_" + hashHex, nil</span>
}

// ============================================================================
// Constructor Functions
// ============================================================================

// NewBetaSharingRegistry creates a new Beta sharing registry.
func NewBetaSharingRegistry(
        config BetaSharingConfig,
        lifecycle *LifecycleManager,
) *BetaSharingRegistryImpl <span class="cov8" title="1">{
        return &amp;BetaSharingRegistryImpl{
                sharedJoinNodes: make(map[string]*JoinNode),
                hashCache:       NewLRUCache(config.HashCacheSize, 0), // 0 = no TTL
                lifecycle:       lifecycle,
                normalizer:      NewDefaultJoinNodeNormalizer(config),
                hasher:          NewDefaultJoinNodeHasher(config),
                metrics:         &amp;BetaBuildMetrics{},
                config:          config,
        }
}</span>

// ============================================================================
// Compatibility Testing
// ============================================================================

// CanShareJoinNodes determines if two join signatures can share a node.
func CanShareJoinNodes(sig1, sig2 *JoinNodeSignature) bool <span class="cov0" title="0">{
        // Check variable set equality
        if !equalStringSlices(sig1.LeftVars, sig2.LeftVars) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !equalStringSlices(sig1.RightVars, sig2.RightVars) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check variable type compatibility
        <span class="cov0" title="0">if !compatibleVarTypes(sig1.VarTypes, sig2.VarTypes) </span><span class="cov0" title="0">{
                return false
        }</span>

        // TODO: Deep comparison of normalized conditions

        <span class="cov0" title="0">return true</span>
}

// equalStringSlices compares two string slices for equality (order matters).
func equalStringSlices(a, b []string) bool <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i := range a </span><span class="cov0" title="0">{
                if a[i] != b[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// compatibleVarTypes checks if two variable type maps are compatible.
func compatibleVarTypes(types1, types2 map[string]string) bool <span class="cov0" title="0">{
        if len(types1) != len(types2) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for varName, type1 := range types1 </span><span class="cov0" title="0">{
                type2, ok := types2[varName]
                if !ok || type1 != type2 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// sortStrings returns a sorted copy of the input slice.
func sortStrings(input []string) []string <span class="cov8" title="1">{
        result := make([]string, len(input))
        copy(result, input)
        sort.Strings(result)
        return result
}</span>

// sortVarTypes converts a map to a sorted slice of VariableTypeMapping.
func sortVarTypes(varTypes map[string]string) []VariableTypeMapping <span class="cov8" title="1">{
        result := make([]VariableTypeMapping, 0, len(varTypes))
        for varName, typeName := range varTypes </span><span class="cov8" title="1">{
                result = append(result, VariableTypeMapping{
                        VarName:  varName,
                        TypeName: typeName,
                })
        }</span>

        // Sort by variable name
        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                return result[i].VarName &lt; result[j].VarName
        }</span>)

        <span class="cov8" title="1">return result</span>
}

// ============================================================================
// Metrics Helpers
// ============================================================================

// RecordHashComputation records metrics for a hash computation.
func RecordHashComputation(metrics *BetaBuildMetrics, durationNs int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;metrics.TotalHashTimeNs, durationNs)
        atomic.AddInt64(&amp;metrics.HashCount, 1)
}</span>

// RecordCacheHit increments the cache hit counter.
func RecordCacheHit(metrics *BetaBuildMetrics) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;metrics.HashCacheHits, 1)
}</span>

// RecordCacheMiss increments the cache miss counter.
func RecordCacheMiss(metrics *BetaBuildMetrics) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;metrics.HashCacheMisses, 1)
}</span>

// RecordSharedReuse increments the shared reuse counter.
func RecordSharedReuse(metrics *BetaBuildMetrics) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;metrics.SharedJoinNodesReused, 1)
        atomic.AddInt64(&amp;metrics.TotalJoinNodesRequested, 1)
}</span>

// RecordUniqueCreation increments the unique creation counter.
func RecordUniqueCreation(metrics *BetaBuildMetrics) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;metrics.UniqueJoinNodesCreated, 1)
        atomic.AddInt64(&amp;metrics.TotalJoinNodesRequested, 1)
}</span>

// CalculateSharingRatio computes the sharing ratio from metrics.
func CalculateSharingRatio(metrics *BetaBuildMetrics) float64 <span class="cov0" title="0">{
        total := atomic.LoadInt64(&amp;metrics.TotalJoinNodesRequested)
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">reused := atomic.LoadInt64(&amp;metrics.SharedJoinNodesReused)
        return float64(reused) / float64(total)</span>
}

// CalculateCacheHitRate computes the cache hit rate from metrics.
func CalculateCacheHitRate(metrics *BetaBuildMetrics) float64 <span class="cov0" title="0">{
        hits := atomic.LoadInt64(&amp;metrics.HashCacheHits)
        misses := atomic.LoadInt64(&amp;metrics.HashCacheMisses)
        total := hits + misses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(hits) / float64(total)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "time"
)

// CacheEvictionPolicy d√©finit la politique d'√©viction du cache
type CacheEvictionPolicy string

const (
        // EvictionPolicyNone pas d'√©viction automatique
        EvictionPolicyNone CacheEvictionPolicy = "none"
        // EvictionPolicyLRU √©viction Least Recently Used
        EvictionPolicyLRU CacheEvictionPolicy = "lru"
        // EvictionPolicyLFU √©viction Least Frequently Used
        EvictionPolicyLFU CacheEvictionPolicy = "lfu"
)

// ChainPerformanceConfig configure les optimisations de performance pour les cha√Ænes alpha
type ChainPerformanceConfig struct {
        // Cache de Hash
        HashCacheEnabled  bool                `json:"hash_cache_enabled"`
        HashCacheMaxSize  int                 `json:"hash_cache_max_size"`
        HashCacheEviction CacheEvictionPolicy `json:"hash_cache_eviction"`
        HashCacheTTL      time.Duration       `json:"hash_cache_ttl,omitempty"` // 0 = pas d'expiration

        // Cache de Connexion
        ConnectionCacheEnabled  bool                `json:"connection_cache_enabled"`
        ConnectionCacheMaxSize  int                 `json:"connection_cache_max_size"`
        ConnectionCacheEviction CacheEvictionPolicy `json:"connection_cache_eviction"`
        ConnectionCacheTTL      time.Duration       `json:"connection_cache_ttl,omitempty"`

        // M√©triques
        MetricsEnabled         bool `json:"metrics_enabled"`
        MetricsDetailedChains  bool `json:"metrics_detailed_chains"`   // Stocker les d√©tails de chaque cha√Æne
        MetricsMaxChainDetails int  `json:"metrics_max_chain_details"` // Limite de d√©tails stock√©s

        // Performance
        ParallelHashComputation bool `json:"parallel_hash_computation"` // Calcul parall√®le des hash (exp√©rimental)

        // Monitoring
        PrometheusEnabled bool   `json:"prometheus_enabled"`
        PrometheusPrefix  string `json:"prometheus_prefix"` // Pr√©fixe pour les m√©triques Prometheus

        // Beta Cache - Cache pour les op√©rations de jointure
        BetaCacheEnabled           bool                `json:"beta_cache_enabled"`
        BetaHashCacheMaxSize       int                 `json:"beta_hash_cache_max_size"`
        BetaHashCacheEviction      CacheEvictionPolicy `json:"beta_hash_cache_eviction"`
        BetaHashCacheTTL           time.Duration       `json:"beta_hash_cache_ttl,omitempty"`
        BetaJoinResultCacheEnabled bool                `json:"beta_join_result_cache_enabled"`
        BetaJoinResultCacheMaxSize int                 `json:"beta_join_result_cache_max_size"`
        BetaJoinResultCacheTTL     time.Duration       `json:"beta_join_result_cache_ttl,omitempty"`

        // Beta Sharing - Partage de JoinNodes entre r√®gles
        BetaSharingEnabled bool `json:"beta_sharing_enabled"`
}

// DefaultChainPerformanceConfig retourne la configuration par d√©faut
func DefaultChainPerformanceConfig() *ChainPerformanceConfig <span class="cov8" title="1">{
        return &amp;ChainPerformanceConfig{
                // Cache de Hash - activ√© avec LRU
                HashCacheEnabled:  true,
                HashCacheMaxSize:  10000, // 10k entr√©es max
                HashCacheEviction: EvictionPolicyLRU,
                HashCacheTTL:      0, // Pas d'expiration

                // Cache de Connexion - activ√© avec limite
                ConnectionCacheEnabled:  true,
                ConnectionCacheMaxSize:  50000, // 50k entr√©es max
                ConnectionCacheEviction: EvictionPolicyLRU,
                ConnectionCacheTTL:      0,

                // M√©triques - activ√©es
                MetricsEnabled:         true,
                MetricsDetailedChains:  true,
                MetricsMaxChainDetails: 1000, // Garder les 1000 derni√®res cha√Ænes

                // Performance
                ParallelHashComputation: false, // D√©sactiv√© par d√©faut

                // Prometheus - d√©sactiv√© par d√©faut
                PrometheusEnabled: false,
                PrometheusPrefix:  "tsd_rete",

                // Beta Cache - activ√© avec tailles raisonnables
                BetaCacheEnabled:           true,
                BetaHashCacheMaxSize:       10000, // 10k entr√©es pour les hash de jointure
                BetaHashCacheEviction:      EvictionPolicyLRU,
                BetaHashCacheTTL:           0, // Pas d'expiration
                BetaJoinResultCacheEnabled: true,
                BetaJoinResultCacheMaxSize: 5000,        // 5k r√©sultats de jointure cach√©s
                BetaJoinResultCacheTTL:     time.Minute, // Expiration apr√®s 1 minute

                // Beta Sharing - d√©sactiv√© par d√©faut (safe rollout)
                BetaSharingEnabled: false,
        }
}</span>

// HighPerformanceConfig retourne une configuration optimis√©e pour la performance
func HighPerformanceConfig() *ChainPerformanceConfig <span class="cov0" title="0">{
        return &amp;ChainPerformanceConfig{
                HashCacheEnabled:  true,
                HashCacheMaxSize:  100000, // 100k entr√©es
                HashCacheEviction: EvictionPolicyLRU,
                HashCacheTTL:      0,

                ConnectionCacheEnabled:  true,
                ConnectionCacheMaxSize:  200000, // 200k entr√©es
                ConnectionCacheEviction: EvictionPolicyLRU,
                ConnectionCacheTTL:      0,

                MetricsEnabled:         true,
                MetricsDetailedChains:  false, // D√©sactiver pour √©conomiser m√©moire
                MetricsMaxChainDetails: 0,

                ParallelHashComputation: true, // Activ√©

                PrometheusEnabled: true,
                PrometheusPrefix:  "tsd_rete",

                // Beta Cache - configuration haute performance
                BetaCacheEnabled:           true,
                BetaHashCacheMaxSize:       100000, // 100k entr√©es
                BetaHashCacheEviction:      EvictionPolicyLRU,
                BetaHashCacheTTL:           0,
                BetaJoinResultCacheEnabled: true,
                BetaJoinResultCacheMaxSize: 50000,           // 50k r√©sultats cach√©s
                BetaJoinResultCacheTTL:     5 * time.Minute, // TTL plus long

                // Beta Sharing - activ√© pour haute performance
                BetaSharingEnabled: true,
        }
}</span>

// LowMemoryConfig retourne une configuration optimis√©e pour la m√©moire
func LowMemoryConfig() *ChainPerformanceConfig <span class="cov0" title="0">{
        return &amp;ChainPerformanceConfig{
                HashCacheEnabled:  true,
                HashCacheMaxSize:  1000, // Seulement 1k entr√©es
                HashCacheEviction: EvictionPolicyLRU,
                HashCacheTTL:      5 * time.Minute, // Expiration apr√®s 5min

                ConnectionCacheEnabled:  true,
                ConnectionCacheMaxSize:  5000,
                ConnectionCacheEviction: EvictionPolicyLRU,
                ConnectionCacheTTL:      5 * time.Minute,

                MetricsEnabled:         true,
                MetricsDetailedChains:  false,
                MetricsMaxChainDetails: 0,

                ParallelHashComputation: false,

                PrometheusEnabled: false,
                PrometheusPrefix:  "tsd_rete",

                // Beta Cache - configuration light
                BetaCacheEnabled:           true,
                BetaHashCacheMaxSize:       1000, // 1k entr√©es seulement
                BetaHashCacheEviction:      EvictionPolicyLRU,
                BetaHashCacheTTL:           0,
                BetaJoinResultCacheEnabled: false, // D√©sactiv√© en mode l√©ger
                BetaJoinResultCacheMaxSize: 0,
                BetaJoinResultCacheTTL:     0,

                // Beta Sharing - d√©sactiv√© en mode l√©ger
                BetaSharingEnabled: false,
        }
}</span>

// DisabledCachesConfig retourne une configuration sans caches (pour tests/debug)
func DisabledCachesConfig() *ChainPerformanceConfig <span class="cov0" title="0">{
        return &amp;ChainPerformanceConfig{
                HashCacheEnabled:  false,
                HashCacheMaxSize:  0,
                HashCacheEviction: EvictionPolicyNone,
                HashCacheTTL:      0,

                ConnectionCacheEnabled:  false,
                ConnectionCacheMaxSize:  0,
                ConnectionCacheEviction: EvictionPolicyNone,
                ConnectionCacheTTL:      0,

                MetricsEnabled:         true,
                MetricsDetailedChains:  true,
                MetricsMaxChainDetails: 1000,

                ParallelHashComputation: false,

                PrometheusEnabled: false,
                PrometheusPrefix:  "tsd_rete",
        }
}</span>

// Validate v√©rifie que la configuration est valide
func (c *ChainPerformanceConfig) Validate() error <span class="cov0" title="0">{
        // Valider les tailles de cache
        if c.HashCacheEnabled </span><span class="cov0" title="0">{
                if c.HashCacheMaxSize &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("hash_cache_max_size ne peut pas √™tre n√©gatif: %d", c.HashCacheMaxSize)
                }</span>
                <span class="cov0" title="0">if c.HashCacheMaxSize == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("hash_cache_max_size doit √™tre &gt; 0 quand le cache est activ√©")
                }</span>
                <span class="cov0" title="0">if c.HashCacheMaxSize &gt; 1000000 </span><span class="cov0" title="0">{
                        return fmt.Errorf("hash_cache_max_size trop grand: %d (max: 1000000)", c.HashCacheMaxSize)
                }</span>
        }

        <span class="cov0" title="0">if c.ConnectionCacheEnabled </span><span class="cov0" title="0">{
                if c.ConnectionCacheMaxSize &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("connection_cache_max_size ne peut pas √™tre n√©gatif: %d", c.ConnectionCacheMaxSize)
                }</span>
                <span class="cov0" title="0">if c.ConnectionCacheMaxSize == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("connection_cache_max_size doit √™tre &gt; 0 quand le cache est activ√©")
                }</span>
                <span class="cov0" title="0">if c.ConnectionCacheMaxSize &gt; 10000000 </span><span class="cov0" title="0">{
                        return fmt.Errorf("connection_cache_max_size trop grand: %d (max: 10000000)", c.ConnectionCacheMaxSize)
                }</span>
        }

        // Valider les politiques d'√©viction
        <span class="cov0" title="0">validPolicies := map[CacheEvictionPolicy]bool{
                EvictionPolicyNone: true,
                EvictionPolicyLRU:  true,
                EvictionPolicyLFU:  true,
        }

        if !validPolicies[c.HashCacheEviction] </span><span class="cov0" title="0">{
                return fmt.Errorf("politique d'√©viction hash invalide: %s", c.HashCacheEviction)
        }</span>

        <span class="cov0" title="0">if !validPolicies[c.ConnectionCacheEviction] </span><span class="cov0" title="0">{
                return fmt.Errorf("politique d'√©viction connexion invalide: %s", c.ConnectionCacheEviction)
        }</span>

        // Valider les TTL
        <span class="cov0" title="0">if c.HashCacheTTL &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("hash_cache_ttl ne peut pas √™tre n√©gatif: %v", c.HashCacheTTL)
        }</span>

        <span class="cov0" title="0">if c.ConnectionCacheTTL &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("connection_cache_ttl ne peut pas √™tre n√©gatif: %v", c.ConnectionCacheTTL)
        }</span>

        // Valider les m√©triques
        <span class="cov0" title="0">if c.MetricsEnabled &amp;&amp; c.MetricsDetailedChains </span><span class="cov0" title="0">{
                if c.MetricsMaxChainDetails &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("metrics_max_chain_details ne peut pas √™tre n√©gatif: %d", c.MetricsMaxChainDetails)
                }</span>
                <span class="cov0" title="0">if c.MetricsMaxChainDetails &gt; 100000 </span><span class="cov0" title="0">{
                        return fmt.Errorf("metrics_max_chain_details trop grand: %d (max: 100000)", c.MetricsMaxChainDetails)
                }</span>
        }

        // Valider le pr√©fixe Prometheus
        <span class="cov0" title="0">if c.PrometheusEnabled &amp;&amp; c.PrometheusPrefix == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("prometheus_prefix ne peut pas √™tre vide quand Prometheus est activ√©")
        }</span>

        // Valider Beta Cache
        <span class="cov0" title="0">if c.BetaCacheEnabled </span><span class="cov0" title="0">{
                if c.BetaHashCacheMaxSize &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("BetaHashCacheMaxSize doit √™tre &gt; 0 quand BetaCacheEnabled=true")
                }</span>
                <span class="cov0" title="0">if c.BetaJoinResultCacheEnabled &amp;&amp; c.BetaJoinResultCacheMaxSize &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("BetaJoinResultCacheMaxSize doit √™tre &gt; 0 quand BetaJoinResultCacheEnabled=true")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Clone cr√©e une copie profonde de la configuration
func (c *ChainPerformanceConfig) Clone() *ChainPerformanceConfig <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">clone := *c
        return &amp;clone</span>
}

// GetCacheInfo retourne des informations sur la configuration des caches
func (c *ChainPerformanceConfig) GetCacheInfo() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "hash_cache": map[string]interface{}{
                        "enabled":  c.HashCacheEnabled,
                        "max_size": c.HashCacheMaxSize,
                        "eviction": string(c.HashCacheEviction),
                        "ttl":      c.HashCacheTTL.String(),
                },
                "connection_cache": map[string]interface{}{
                        "enabled":  c.ConnectionCacheEnabled,
                        "max_size": c.ConnectionCacheMaxSize,
                        "eviction": string(c.ConnectionCacheEviction),
                        "ttl":      c.ConnectionCacheTTL.String(),
                },
                "metrics": map[string]interface{}{
                        "enabled":           c.MetricsEnabled,
                        "detailed_chains":   c.MetricsDetailedChains,
                        "max_chain_details": c.MetricsMaxChainDetails,
                },
                "performance": map[string]interface{}{
                        "parallel_hash": c.ParallelHashComputation,
                },
                "prometheus": map[string]interface{}{
                        "enabled": c.PrometheusEnabled,
                        "prefix":  c.PrometheusPrefix,
                },
        }
}</span>

// EstimateMemoryUsage estime l'utilisation m√©moire de la configuration (en bytes)
func (c *ChainPerformanceConfig) EstimateMemoryUsage() int64 <span class="cov0" title="0">{
        var total int64

        // Cache de hash: ~500 bytes par entr√©e (JSON condition + hash)
        if c.HashCacheEnabled </span><span class="cov0" title="0">{
                total += int64(c.HashCacheMaxSize) * 500
        }</span>

        // Cache de connexion: ~100 bytes par entr√©e (2 IDs + bool)
        <span class="cov0" title="0">if c.ConnectionCacheEnabled </span><span class="cov0" title="0">{
                total += int64(c.ConnectionCacheMaxSize) * 100
        }</span>

        // D√©tails de cha√Ænes: ~200 bytes par entr√©e
        <span class="cov0" title="0">if c.MetricsEnabled &amp;&amp; c.MetricsDetailedChains </span><span class="cov0" title="0">{
                total += int64(c.MetricsMaxChainDetails) * 200
        }</span>

        <span class="cov0" title="0">return total</span>
}

// String retourne une repr√©sentation textuelle de la configuration
func (c *ChainPerformanceConfig) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("ChainPerformanceConfig{HashCache:%v(%d,%s), ConnCache:%v(%d,%s), Metrics:%v, Prometheus:%v}",
                c.HashCacheEnabled, c.HashCacheMaxSize, c.HashCacheEviction,
                c.ConnectionCacheEnabled, c.ConnectionCacheMaxSize, c.ConnectionCacheEviction,
                c.MetricsEnabled, c.PrometheusEnabled)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "sync"
        "time"
)

// ChainBuildMetrics collecte les m√©triques de performance pour la construction des cha√Ænes alpha
type ChainBuildMetrics struct {
        TotalChainsBuilt   int     `json:"total_chains_built"`
        TotalNodesCreated  int     `json:"total_nodes_created"`
        TotalNodesReused   int     `json:"total_nodes_reused"`
        AverageChainLength float64 `json:"average_chain_length"`
        SharingRatio       float64 `json:"sharing_ratio"`

        // M√©triques de cache
        HashCacheHits   int `json:"hash_cache_hits"`
        HashCacheMisses int `json:"hash_cache_misses"`
        HashCacheSize   int `json:"hash_cache_size"`

        // M√©triques de connexion
        ConnectionCacheHits   int `json:"connection_cache_hits"`
        ConnectionCacheMisses int `json:"connection_cache_misses"`

        // M√©triques de temps
        TotalBuildTime       time.Duration `json:"total_build_time_ns"`
        AverageBuildTime     time.Duration `json:"average_build_time_ns"`
        TotalHashComputeTime time.Duration `json:"total_hash_compute_time_ns"`

        // D√©tails par r√®gle
        ChainDetails []ChainMetricDetail `json:"chain_details,omitempty"`

        mutex sync.RWMutex
}

// ChainMetricDetail contient les d√©tails m√©triques pour une cha√Æne individuelle
type ChainMetricDetail struct {
        RuleID          string        `json:"rule_id"`
        ChainLength     int           `json:"chain_length"`
        NodesCreated    int           `json:"nodes_created"`
        NodesReused     int           `json:"nodes_reused"`
        BuildTime       time.Duration `json:"build_time_ns"`
        Timestamp       time.Time     `json:"timestamp"`
        HashesGenerated []string      `json:"hashes_generated,omitempty"`
}

// NewChainBuildMetrics cr√©e une nouvelle instance de m√©triques
func NewChainBuildMetrics() *ChainBuildMetrics <span class="cov8" title="1">{
        return &amp;ChainBuildMetrics{
                ChainDetails: make([]ChainMetricDetail, 0),
        }
}</span>

// RecordChainBuild enregistre les m√©triques pour une cha√Æne construite
func (m *ChainBuildMetrics) RecordChainBuild(detail ChainMetricDetail) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.TotalChainsBuilt++
        m.TotalNodesCreated += detail.NodesCreated
        m.TotalNodesReused += detail.NodesReused
        m.TotalBuildTime += detail.BuildTime

        // Mettre √† jour les moyennes
        if m.TotalChainsBuilt &gt; 0 </span><span class="cov0" title="0">{
                totalNodes := m.TotalNodesCreated + m.TotalNodesReused
                m.AverageChainLength = float64(totalNodes) / float64(m.TotalChainsBuilt)
                m.AverageBuildTime = m.TotalBuildTime / time.Duration(m.TotalChainsBuilt)

                if totalNodes &gt; 0 </span><span class="cov0" title="0">{
                        m.SharingRatio = float64(m.TotalNodesReused) / float64(totalNodes)
                }</span>
        }

        <span class="cov0" title="0">m.ChainDetails = append(m.ChainDetails, detail)</span>
}

// RecordHashCacheHit enregistre un hit du cache de hash
func (m *ChainBuildMetrics) RecordHashCacheHit() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.HashCacheHits++
}</span>

// RecordHashCacheMiss enregistre un miss du cache de hash
func (m *ChainBuildMetrics) RecordHashCacheMiss() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.HashCacheMisses++
}</span>

// UpdateHashCacheSize met √† jour la taille du cache de hash
func (m *ChainBuildMetrics) UpdateHashCacheSize(size int) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.HashCacheSize = size
}</span>

// RecordConnectionCacheHit enregistre un hit du cache de connexion
func (m *ChainBuildMetrics) RecordConnectionCacheHit() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.ConnectionCacheHits++
}</span>

// RecordConnectionCacheMiss enregistre un miss du cache de connexion
func (m *ChainBuildMetrics) RecordConnectionCacheMiss() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.ConnectionCacheMisses++
}</span>

// AddHashComputeTime ajoute du temps de calcul de hash
func (m *ChainBuildMetrics) AddHashComputeTime(duration time.Duration) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.TotalHashComputeTime += duration
}</span>

// GetSnapshot retourne une copie thread-safe des m√©triques actuelles
func (m *ChainBuildMetrics) GetSnapshot() ChainBuildMetrics <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        // Copie profonde de la structure SANS le mutex
        snapshot := ChainBuildMetrics{
                TotalChainsBuilt:      m.TotalChainsBuilt,
                TotalNodesCreated:     m.TotalNodesCreated,
                TotalNodesReused:      m.TotalNodesReused,
                AverageChainLength:    m.AverageChainLength,
                SharingRatio:          m.SharingRatio,
                HashCacheHits:         m.HashCacheHits,
                HashCacheMisses:       m.HashCacheMisses,
                HashCacheSize:         m.HashCacheSize,
                ConnectionCacheHits:   m.ConnectionCacheHits,
                ConnectionCacheMisses: m.ConnectionCacheMisses,
                TotalBuildTime:        m.TotalBuildTime,
                AverageBuildTime:      m.AverageBuildTime,
                TotalHashComputeTime:  m.TotalHashComputeTime,
                ChainDetails:          make([]ChainMetricDetail, len(m.ChainDetails)),
        }

        copy(snapshot.ChainDetails, m.ChainDetails)
        return snapshot
}</span>

// Reset r√©initialise toutes les m√©triques
func (m *ChainBuildMetrics) Reset() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.TotalChainsBuilt = 0
        m.TotalNodesCreated = 0
        m.TotalNodesReused = 0
        m.AverageChainLength = 0.0
        m.SharingRatio = 0.0
        m.HashCacheHits = 0
        m.HashCacheMisses = 0
        m.HashCacheSize = 0
        m.ConnectionCacheHits = 0
        m.ConnectionCacheMisses = 0
        m.TotalBuildTime = 0
        m.AverageBuildTime = 0
        m.TotalHashComputeTime = 0
        m.ChainDetails = make([]ChainMetricDetail, 0)
}</span>

// GetHashCacheEfficiency retourne l'efficacit√© du cache de hash (0.0 √† 1.0)
func (m *ChainBuildMetrics) GetHashCacheEfficiency() float64 <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        total := m.HashCacheHits + m.HashCacheMisses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(m.HashCacheHits) / float64(total)</span>
}

// GetConnectionCacheEfficiency retourne l'efficacit√© du cache de connexion (0.0 √† 1.0)
func (m *ChainBuildMetrics) GetConnectionCacheEfficiency() float64 <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        total := m.ConnectionCacheHits + m.ConnectionCacheMisses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(m.ConnectionCacheHits) / float64(total)</span>
}

// GetSummary retourne un r√©sum√© format√© des m√©triques
func (m *ChainBuildMetrics) GetSummary() map[string]interface{} <span class="cov0" title="0">{
        snapshot := m.GetSnapshot()

        return map[string]interface{}{
                "chains": map[string]interface{}{
                        "total_built":        snapshot.TotalChainsBuilt,
                        "average_length":     snapshot.AverageChainLength,
                        "total_build_time":   snapshot.TotalBuildTime.String(),
                        "average_build_time": snapshot.AverageBuildTime.String(),
                },
                "nodes": map[string]interface{}{
                        "total_created":  snapshot.TotalNodesCreated,
                        "total_reused":   snapshot.TotalNodesReused,
                        "sharing_ratio":  snapshot.SharingRatio,
                        "reuse_rate_pct": snapshot.SharingRatio * 100,
                },
                "hash_cache": map[string]interface{}{
                        "hits":           snapshot.HashCacheHits,
                        "misses":         snapshot.HashCacheMisses,
                        "size":           snapshot.HashCacheSize,
                        "efficiency":     m.GetHashCacheEfficiency(),
                        "total_time":     snapshot.TotalHashComputeTime.String(),
                        "efficiency_pct": m.GetHashCacheEfficiency() * 100,
                },
                "connection_cache": map[string]interface{}{
                        "hits":           snapshot.ConnectionCacheHits,
                        "misses":         snapshot.ConnectionCacheMisses,
                        "efficiency":     m.GetConnectionCacheEfficiency(),
                        "efficiency_pct": m.GetConnectionCacheEfficiency() * 100,
                },
        }
}</span>

// GetTopChainsByBuildTime retourne les N cha√Ænes avec les temps de construction les plus longs
func (m *ChainBuildMetrics) GetTopChainsByBuildTime(n int) []ChainMetricDetail <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if len(m.ChainDetails) == 0 </span><span class="cov0" title="0">{
                return []ChainMetricDetail{}
        }</span>

        // Copier et trier
        <span class="cov0" title="0">chains := make([]ChainMetricDetail, len(m.ChainDetails))
        copy(chains, m.ChainDetails)

        // Tri par bulle simple (suffisant pour de petites listes)
        for i := 0; i &lt; len(chains); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(chains); j++ </span><span class="cov0" title="0">{
                        if chains[j].BuildTime &gt; chains[i].BuildTime </span><span class="cov0" title="0">{
                                chains[i], chains[j] = chains[j], chains[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">if n &gt; len(chains) </span><span class="cov0" title="0">{
                n = len(chains)
        }</span>

        <span class="cov0" title="0">return chains[:n]</span>
}

// GetTopChainsByLength retourne les N cha√Ænes les plus longues
func (m *ChainBuildMetrics) GetTopChainsByLength(n int) []ChainMetricDetail <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if len(m.ChainDetails) == 0 </span><span class="cov0" title="0">{
                return []ChainMetricDetail{}
        }</span>

        // Copier et trier
        <span class="cov0" title="0">chains := make([]ChainMetricDetail, len(m.ChainDetails))
        copy(chains, m.ChainDetails)

        // Tri par bulle simple
        for i := 0; i &lt; len(chains); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(chains); j++ </span><span class="cov0" title="0">{
                        if chains[j].ChainLength &gt; chains[i].ChainLength </span><span class="cov0" title="0">{
                                chains[i], chains[j] = chains[j], chains[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">if n &gt; len(chains) </span><span class="cov0" title="0">{
                n = len(chains)
        }</span>

        <span class="cov0" title="0">return chains[:n]</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "strings"

        "github.com/treivax/tsd/constraint"
)

// AggregationInfo contient les informations extraites d'une agr√©gation
type AggregationInfo struct {
        Function      string      // AVG, SUM, COUNT, MIN, MAX
        MainVariable  string      // Variable principale (ex: "e" pour Employee)
        MainType      string      // Type principal (ex: "Employee")
        AggVariable   string      // Variable √† agr√©ger (ex: "p" pour Performance)
        AggType       string      // Type √† agr√©ger (ex: "Performance")
        Field         string      // Champ √† agr√©ger (ex: "score")
        Operator      string      // Op√©rateur de comparaison (&gt;=, &gt;, etc.)
        Threshold     float64     // Valeur de seuil
        JoinField     string      // Champ de jointure dans faits agr√©g√©s (ex: "employee_id")
        MainField     string      // Champ de jointure dans fait principal (ex: "id")
        JoinCondition interface{} // Condition de jointure compl√®te
}

// ConstraintPipeline impl√©mente le pipeline complet :
// fichier .constraint ‚Üí parseur PEG ‚Üí conversion AST ‚Üí r√©seau RETE
type ConstraintPipeline struct{}

// NewConstraintPipeline cr√©e une nouvelle instance du pipeline
func NewConstraintPipeline() *ConstraintPipeline <span class="cov8" title="1">{
        return &amp;ConstraintPipeline{}
}</span>

// BuildNetworkFromConstraintFile construit un r√©seau RETE complet √† partir d'un fichier .constraint
// Cette fonction impl√©mente le pipeline unique utilis√© par TOUS les tests
// Si le fichier contient des instructions reset, utilise l'IterativeParser pour appliquer
// correctement la s√©mantique de reset (seuls les types/r√®gles apr√®s le dernier reset sont conserv√©s)
func (cp *ConstraintPipeline) BuildNetworkFromConstraintFile(constraintFile string, storage Storage) (*ReteNetwork, error) <span class="cov8" title="1">{
        fmt.Printf("========================================\n")
        fmt.Printf("üìÅ Fichier: %s\n", constraintFile)

        // √âTAPE 1: Parsing initial pour d√©tecter les resets
        parsedAST, err := constraint.ParseConstraintFile(constraintFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur parsing fichier %s: %w", constraintFile, err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Parsing r√©ussi\n")

        // √âTAPE 1.5: Validation s√©mantique du programme
        err = constraint.ValidateConstraintProgram(parsedAST)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur validation s√©mantique: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Validation s√©mantique r√©ussie\n")

        // Valider que c'est un map[string]interface{}
        resultMap, ok := parsedAST.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format AST non reconnu: %T", parsedAST)
        }</span>

        // V√©rifier si le fichier contient des instructions reset
        <span class="cov8" title="1">hasResets := false
        if resetsData, exists := resultMap["resets"]; exists </span><span class="cov8" title="1">{
                if resets, ok := resetsData.([]interface{}); ok &amp;&amp; len(resets) &gt; 0 </span><span class="cov0" title="0">{
                        hasResets = true
                        fmt.Printf("‚ö†Ô∏è  Instructions reset d√©tect√©es (%d) - Utilisation de l'IterativeParser\n", len(resets))
                }</span>
        }

        // Si des resets sont pr√©sents, utiliser l'IterativeParser pour appliquer la s√©mantique correcte
        <span class="cov8" title="1">if hasResets </span><span class="cov0" title="0">{
                return cp.buildNetworkWithResetSemantics(constraintFile, storage)
        }</span>

        // √âTAPE 2: Extraction et validation des composants (cas sans reset)
        <span class="cov8" title="1">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // √âTAPE 3: Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // √âTAPE 3.5: Traiter les suppressions de r√®gles (si pr√©sentes)
        err = cp.processRuleRemovals(network, resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur traitement suppressions de r√®gles: %w", err)
        }</span>

        // √âTAPE 4: Validation finale
        <span class="cov8" title="1">err = cp.validateNetwork(network)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur validation r√©seau: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Printf("‚úÖ Validation r√©ussie\n")

        fmt.Printf("üéØ PIPELINE TERMIN√â AVEC SUCC√àS\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// buildNetworkWithResetSemantics construit un r√©seau en appliquant correctement la s√©mantique reset
// Analyse le fichier pour d√©terminer quels types/expressions viennent apr√®s le dernier reset
func (cp *ConstraintPipeline) buildNetworkWithResetSemantics(constraintFile string, storage Storage) (*ReteNetwork, error) <span class="cov0" title="0">{
        // Lire le fichier pour analyser la structure
        fileContent, err := constraint.ReadFileContent(constraintFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur lecture fichier: %w", err)
        }</span>

        // Parser le fichier complet pour obtenir tous les √©l√©ments
        <span class="cov0" title="0">parsedAST, err := constraint.ParseConstraintFile(constraintFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur parsing: %w", err)
        }</span>

        // Valider
        <span class="cov0" title="0">err = constraint.ValidateConstraintProgram(parsedAST)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur validation: %w", err)
        }</span>

        // Convertir en programme
        <span class="cov0" title="0">program, err := constraint.ConvertResultToProgram(parsedAST)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur conversion: %w", err)
        }</span>

        // Analyser o√π se trouve le dernier reset dans le fichier
        <span class="cov0" title="0">lastResetPosition := cp.findLastResetPosition(fileContent)

        // Filtrer les types et expressions pour ne garder que ceux apr√®s le dernier reset
        filteredTypes, filteredExpressions := cp.filterAfterReset(
                program.Types, program.Expressions, fileContent, lastResetPosition)

        fmt.Printf("‚úÖ Apr√®s application des resets: %d type(s), %d expression(s)\n",
                len(filteredTypes), len(filteredExpressions))

        // Convertir au format RETE
        filteredProgram := &amp;constraint.Program{
                Types:       filteredTypes,
                Expressions: filteredExpressions,
                Facts:       []constraint.Fact{},  // Les faits seront ajout√©s s√©par√©ment
                Resets:      []constraint.Reset{}, // Plus de resets apr√®s filtrage
        }

        reteProgram := constraint.ConvertToReteProgram(filteredProgram)
        resultMap, ok := reteProgram.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format programme RETE invalide: %T", reteProgram)
        }</span>

        // Extraire les composants
        <span class="cov0" title="0">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // Validation finale
        err = cp.validateNetwork(network)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur validation r√©seau: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ Validation r√©ussie\n")

        fmt.Printf("üéØ PIPELINE AVEC RESET TERMIN√â AVEC SUCC√àS\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// findLastResetPosition trouve la position du dernier mot "reset" dans le fichier
// Retourne la ligne (0-based) o√π se trouve le dernier reset, ou -1 si aucun
func (cp *ConstraintPipeline) findLastResetPosition(content string) int <span class="cov0" title="0">{
        lines := strings.Split(content, "\n")
        lastResetLine := -1

        for i, line := range lines </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(line)
                if trimmed == "reset" </span><span class="cov0" title="0">{
                        lastResetLine = i
                }</span>
        }

        <span class="cov0" title="0">return lastResetLine</span>
}

// filterAfterReset filtre les types et expressions pour ne garder que ceux d√©finis apr√®s le reset
// Strat√©gie: compte combien de d√©finitions de types et d'expressions apparaissent avant le reset
// dans le fichier source, puis ne garde que les √©l√©ments apr√®s ces positions dans les slices
func (cp *ConstraintPipeline) filterAfterReset(
        types []constraint.TypeDefinition,
        expressions []constraint.Expression,
        fileContent string,
        resetLine int,
) ([]constraint.TypeDefinition, []constraint.Expression) <span class="cov0" title="0">{

        if resetLine &lt; 0 </span><span class="cov0" title="0">{
                // Pas de reset trouv√©, retourner tout
                return types, expressions
        }</span>

        <span class="cov0" title="0">lines := strings.Split(fileContent, "\n")

        // Compter combien de "type " apparaissent avant le reset
        typesBeforeReset := 0
        for i := 0; i &lt; resetLine &amp;&amp; i &lt; len(lines); i++ </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(lines[i])
                if strings.HasPrefix(trimmed, "type ") &amp;&amp; strings.Contains(trimmed, ":") </span><span class="cov0" title="0">{
                        typesBeforeReset++
                }</span>
        }

        // Compter combien de r√®gles (lignes avec "==&gt;") apparaissent avant le reset
        <span class="cov0" title="0">expressionsBeforeReset := 0
        for i := 0; i &lt; resetLine &amp;&amp; i &lt; len(lines); i++ </span><span class="cov0" title="0">{
                if strings.Contains(lines[i], "==&gt;") </span><span class="cov0" title="0">{
                        expressionsBeforeReset++
                }</span>
        }

        // Filtrer les types: garder seulement ceux apr√®s l'index typesBeforeReset
        <span class="cov0" title="0">var filteredTypes []constraint.TypeDefinition
        if typesBeforeReset &lt; len(types) </span><span class="cov0" title="0">{
                filteredTypes = types[typesBeforeReset:]
        }</span>

        // Filtrer les expressions: garder seulement celles apr√®s l'index expressionsBeforeReset
        <span class="cov0" title="0">var filteredExpressions []constraint.Expression
        if expressionsBeforeReset &lt; len(expressions) </span><span class="cov0" title="0">{
                filteredExpressions = expressions[expressionsBeforeReset:]
        }</span>

        <span class="cov0" title="0">return filteredTypes, filteredExpressions</span>
}

// BuildNetworkFromMultipleFiles construit un r√©seau RETE en parsant plusieurs fichiers de mani√®re it√©rative
// Cette fonction permet de parser des types, r√®gles et faits r√©partis dans diff√©rents fichiers
func (cp *ConstraintPipeline) BuildNetworkFromMultipleFiles(filenames []string, storage Storage) (*ReteNetwork, error) <span class="cov0" title="0">{
        fmt.Printf("========================================\n")
        fmt.Printf("üìÅ Fichiers: %v\n", filenames)

        // Cr√©er un parser it√©ratif
        parser := constraint.NewIterativeParser()

        // Parser tous les fichiers de mani√®re it√©rative
        for i, filename := range filenames </span><span class="cov0" title="0">{
                fmt.Printf("  üìÑ Parsing fichier %d/%d: %s\n", i+1, len(filenames), filename)
                err := parser.ParseFile(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("‚ùå Erreur parsing fichier %s: %w", filename, err)
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("‚úÖ Parsing it√©ratif r√©ussi\n")

        // Obtenir le programme combin√©
        program := parser.GetProgram()

        // Convertir au format RETE
        reteProgram := constraint.ConvertToReteProgram(program)
        resultMap, ok := reteProgram.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format programme RETE invalide: %T", reteProgram)
        }</span>

        // Extraire les composants
        <span class="cov0" title="0">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // Injection des faits dans le r√©seau
        if len(program.Facts) &gt; 0 </span><span class="cov0" title="0">{
                factsForRete := constraint.ConvertFactsToReteFormat(*program)

                err := network.SubmitFactsFromGrammar(factsForRete)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Erreur injection faits: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚úÖ Injection termin√©e: %d faits inject√©s\n", len(factsForRete))
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üéØ PIPELINE MULTIFILES TERMIN√â\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// BuildNetworkFromIterativeParser construit un r√©seau RETE √† partir d'un parser it√©ratif existant
// Cette m√©thode est utile quand le parsing a d√©j√† √©t√© fait et qu'on veut juste construire le r√©seau
func (cp *ConstraintPipeline) BuildNetworkFromIterativeParser(parser *constraint.IterativeParser, storage Storage) (*ReteNetwork, error) <span class="cov0" title="0">{
        fmt.Printf("========================================\n")

        // Obtenir le programme combin√©
        program := parser.GetProgram()

        // Convertir au format RETE
        reteProgram := constraint.ConvertToReteProgram(program)
        resultMap, ok := reteProgram.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Format programme RETE invalide: %T", reteProgram)
        }</span>

        // Extraire les composants
        <span class="cov0" title="0">types, expressions, err := cp.extractComponents(resultMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur extraction composants: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ Trouv√© %d types et %d expressions\n", len(types), len(expressions))

        // Construction du r√©seau RETE
        network, err := cp.buildNetwork(storage, types, expressions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚úÖ R√©seau construit avec %d n≈ìuds terminaux\n", len(network.TerminalNodes))

        // Injection des faits dans le r√©seau
        if len(program.Facts) &gt; 0 </span><span class="cov0" title="0">{
                factsForRete := constraint.ConvertFactsToReteFormat(*program)

                err := network.SubmitFactsFromGrammar(factsForRete)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Erreur injection faits: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚úÖ Injection termin√©e: %d faits inject√©s\n", len(factsForRete))
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üéØ PIPELINE DEPUIS PARSER TERMIN√â\n")
        fmt.Printf("========================================\n\n")

        return network, nil</span>
}

// BuildNetworkFromConstraintFileWithFacts construit un r√©seau et soumet imm√©diatement des faits
func (cp *ConstraintPipeline) BuildNetworkFromConstraintFileWithFacts(constraintFile, factsFile string, storage Storage) (*ReteNetwork, []*Fact, error) <span class="cov0" title="0">{
        fmt.Printf("========================================\n")
        fmt.Printf("üìÅ Fichier contraintes: %s\n", constraintFile)
        fmt.Printf("üìÅ Fichier faits: %s\n", factsFile)

        // √âTAPE 1: Construire le r√©seau depuis le fichier de contraintes
        network, err := cp.BuildNetworkFromConstraintFile(constraintFile, storage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("‚ùå Erreur construction r√©seau: %w", err)
        }</span>

        // √âTAPE 2: Parser et soumettre les faits
        <span class="cov0" title="0">fmt.Printf("üìä Parsing des faits depuis %s\n", factsFile)

        parsedFacts, err := constraint.ParseFactsFile(factsFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("‚ùå Erreur parsing faits: %w", err)
        }</span>

        // Extraire les faits du programme pars√©
        <span class="cov0" title="0">factsList, err := constraint.ExtractFactsFromProgram(parsedFacts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("‚ùå Erreur extraction faits: %w", err)
        }</span>

        // Convertir et soumettre chaque fait
        <span class="cov0" title="0">submittedFacts := []*Fact{}
        for _, factMap := range factsList </span><span class="cov0" title="0">{
                // ExtractFactsFromProgram retourne des maps avec 'reteType' et tous les champs directement
                factID := getStringField(factMap, "id", "")
                factType := getStringField(factMap, "reteType", "") // Utiliser 'reteType' au lieu de 'type'

                if factID == "" || factType == "" </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è Fait ignor√©: id='%s', type='%s'\n", factID, factType)
                        continue</span>
                }

                // Les champs sont directement dans factMap (pas de sous-cl√© 'fields')
                <span class="cov0" title="0">fields := make(map[string]interface{})
                for key, value := range factMap </span><span class="cov0" title="0">{
                        // Exclure les m√©tadonn√©es RETE (id, reteType)
                        if key != "id" &amp;&amp; key != "reteType" </span><span class="cov0" title="0">{
                                fields[key] = value
                        }</span>
                }

                <span class="cov0" title="0">fact := &amp;Fact{
                        ID:     factID,
                        Type:   factType,
                        Fields: fields,
                }

                err := network.SubmitFact(fact)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è Erreur soumission fait %s: %v\n", factID, err)
                }</span>
                <span class="cov0" title="0">submittedFacts = append(submittedFacts, fact)</span>
        }

        <span class="cov0" title="0">fmt.Printf("‚úÖ %d faits soumis au r√©seau\n", len(submittedFacts))
        fmt.Printf("üéØ PIPELINE AVEC FAITS TERMIN√â\n")
        fmt.Printf("========================================\n\n")

        return network, submittedFacts, nil</span>
}

// processRuleRemovals traite les commandes de suppression de r√®gles
func (cp *ConstraintPipeline) processRuleRemovals(network *ReteNetwork, resultMap map[string]interface{}) error <span class="cov8" title="1">{
        // V√©rifier si des suppressions de r√®gles sont pr√©sentes
        ruleRemovalsData, exists := resultMap["ruleRemovals"]
        if !exists </span><span class="cov0" title="0">{
                return nil // Pas de suppressions de r√®gles
        }</span>

        <span class="cov8" title="1">ruleRemovals, ok := ruleRemovalsData.([]interface{})
        if !ok || len(ruleRemovals) == 0 </span><span class="cov8" title="1">{
                return nil // Pas de suppressions de r√®gles
        }</span>

        <span class="cov0" title="0">fmt.Printf("üóëÔ∏è  Traitement de %d suppression(s) de r√®gles\n", len(ruleRemovals))

        // Traiter chaque suppression de r√®gle
        for _, removalData := range ruleRemovals </span><span class="cov0" title="0">{
                removalMap, ok := removalData.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Format de suppression invalide: %v\n", removalData)
                        continue</span>
                }

                <span class="cov0" title="0">ruleID, ok := removalMap["ruleID"].(string)
                if !ok || ruleID == "" </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Identifiant de r√®gle manquant ou invalide: %v\n", removalMap)
                        continue</span>
                }

                // Supprimer la r√®gle du r√©seau
                <span class="cov0" title="0">fmt.Printf("üóëÔ∏è  Suppression de la r√®gle: %s\n", ruleID)
                err := network.RemoveRule(ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        // Logger l'erreur mais continuer avec les autres suppressions
                        fmt.Printf("‚ö†Ô∏è  Erreur lors de la suppression de la r√®gle %s: %v\n", ruleID, err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("‚úÖ R√®gle %s supprim√©e avec succ√®s\n", ruleID)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "strings"
)

// Node condition type constants
const (
        ConditionTypePassthrough = "passthrough"
        ConditionTypeSimple      = "simple"
        ConditionTypeExists      = "exists"
        ConditionTypeComparison  = "comparison"
)

// Node side constants for beta nodes
const (
        NodeSideLeft  = "left"
        NodeSideRight = "right"
)

// buildNetwork construit le r√©seau RETE √† partir des types et expressions pars√©s
func (cp *ConstraintPipeline) buildNetwork(storage Storage, types []interface{}, expressions []interface{}) (*ReteNetwork, error) <span class="cov8" title="1">{
        // Cr√©er le r√©seau
        network := NewReteNetwork(storage)

        // √âTAPE 1: Cr√©er les TypeNodes
        err := cp.createTypeNodes(network, types, storage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur cr√©ation TypeNodes: %w", err)
        }</span>

        // √âTAPE 2: Cr√©er les r√®gles (AlphaNodes, BetaNodes, TerminalNodes)
        <span class="cov8" title="1">err = cp.createRuleNodes(network, expressions, storage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur cr√©ation r√®gles: %w", err)
        }</span>

        <span class="cov8" title="1">return network, nil</span>
}

// createTypeNodes cr√©e les TypeNodes √† partir des d√©finitions de types
func (cp *ConstraintPipeline) createTypeNodes(network *ReteNetwork, types []interface{}, storage Storage) error <span class="cov8" title="1">{
        for _, typeInterface := range types </span><span class="cov8" title="1">{
                typeMap, ok := typeInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("format type invalide: %T", typeInterface)
                }</span>

                // Extraire le nom du type
                <span class="cov8" title="1">typeName, ok := typeMap["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("nom de type non trouv√©")
                }</span>

                // Cr√©er la d√©finition de type
                <span class="cov8" title="1">typeDef := cp.createTypeDefinition(typeName, typeMap)

                // Cr√©er le TypeNode
                typeNode := NewTypeNode(typeName, typeDef, storage)
                network.TypeNodes[typeName] = typeNode

                // Enregistrer le TypeNode dans le LifecycleManager
                if network.LifecycleManager != nil </span><span class="cov8" title="1">{
                        network.LifecycleManager.RegisterNode(typeNode.GetID(), "type")
                }</span>

                // CRUCIAL: Connecter le TypeNode au RootNode pour permettre la propagation des faits
                <span class="cov8" title="1">network.RootNode.AddChild(typeNode)

                fmt.Printf("   ‚úì TypeNode cr√©√©: %s\n", typeName)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createTypeDefinition cr√©e une d√©finition de type √† partir d'une map
func (cp *ConstraintPipeline) createTypeDefinition(typeName string, typeMap map[string]interface{}) TypeDefinition <span class="cov8" title="1">{
        typeDef := TypeDefinition{
                Type:   "type",
                Name:   typeName,
                Fields: []Field{},
        }

        // Extraire les champs
        fieldsData, hasFields := typeMap["fields"]
        if !hasFields </span><span class="cov0" title="0">{
                return typeDef
        }</span>

        <span class="cov8" title="1">fields, ok := fieldsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return typeDef
        }</span>

        <span class="cov8" title="1">for _, fieldInterface := range fields </span><span class="cov8" title="1">{
                fieldMap, ok := fieldInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">fieldName := getStringField(fieldMap, "name", "")
                fieldType := getStringField(fieldMap, "type", "")

                if fieldName != "" &amp;&amp; fieldType != "" </span><span class="cov8" title="1">{
                        typeDef.Fields = append(typeDef.Fields, Field{
                                Name: fieldName,
                                Type: fieldType,
                        })
                }</span>
        }

        <span class="cov8" title="1">return typeDef</span>
}

// createRuleNodes cr√©e les n≈ìuds de r√®gles (Alpha, Beta, Terminal) √† partir des expressions
func (cp *ConstraintPipeline) createRuleNodes(network *ReteNetwork, expressions []interface{}, storage Storage) error <span class="cov8" title="1">{
        for i, exprInterface := range expressions </span><span class="cov8" title="1">{
                exprMap, ok := exprInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("format expression invalide: %T", exprInterface)
                }</span>

                // Extraire le ruleId de l'expression
                <span class="cov8" title="1">ruleID := fmt.Sprintf("rule_%d", i) // Default fallback
                if ruleIdValue, ok := exprMap["ruleId"]; ok </span><span class="cov8" title="1">{
                        if ruleIdStr, ok := ruleIdValue.(string); ok &amp;&amp; ruleIdStr != "" </span><span class="cov8" title="1">{
                                ruleID = ruleIdStr
                        }</span>
                }

                // Cr√©er la r√®gle
                <span class="cov8" title="1">err := cp.createSingleRule(network, ruleID, exprMap, storage)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur cr√©ation r√®gle %s: %w", ruleID, err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("   ‚úì R√®gle cr√©√©e: %s\n", ruleID)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createSingleRule cr√©e une r√®gle unique (refactoris√©e en petites fonctions)
func (cp *ConstraintPipeline) createSingleRule(network *ReteNetwork, ruleID string, exprMap map[string]interface{}, storage Storage) error <span class="cov8" title="1">{
        // √âtape 1: Extraire l'action
        action, err := cp.extractActionFromExpression(exprMap, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // √âtape 2: Extraire et analyser les contraintes
        <span class="cov8" title="1">constraintsData, hasConstraints := exprMap["constraints"]
        var condition map[string]interface{}
        var hasAggregation bool

        if hasConstraints </span><span class="cov8" title="1">{
                // D√©tecter si c'est une agr√©gation
                hasAggregation = cp.detectAggregation(constraintsData)

                // Construire la condition appropri√©e
                condition, err = cp.buildConditionFromConstraints(constraintsData)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur construction condition pour r√®gle %s: %w", ruleID, err)
                }</span>
        } else<span class="cov0" title="0"> {
                condition = map[string]interface{}{
                        "type": ConditionTypeSimple,
                }
        }</span>

        // √âtape 3: Extraire les variables
        <span class="cov8" title="1">variables, variableNames, variableTypes := cp.extractVariablesFromExpression(exprMap)

        // √âtape 4: D√©terminer le type de r√®gle et la cr√©er
        ruleType := cp.determineRuleType(exprMap, len(variables), hasAggregation)
        cp.logRuleCreation(ruleType, ruleID, variableNames)

        switch ruleType </span>{
        case "exists":<span class="cov0" title="0">
                return cp.createExistsRule(network, ruleID, exprMap, condition, action, storage)</span>

        case "accumulator":<span class="cov0" title="0">
                aggInfo, err := cp.extractAggregationInfo(constraintsData)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ö†Ô∏è  Impossible d'extraire info agr√©gation: %v, utilisation JoinNode standard\n", err)
                        return cp.createJoinRule(network, ruleID, variables, variableNames, variableTypes, condition, action, storage)
                }</span>
                <span class="cov0" title="0">return cp.createAccumulatorRule(network, ruleID, variables, variableNames, variableTypes, aggInfo, action, storage)</span>

        case "join":<span class="cov8" title="1">
                return cp.createJoinRule(network, ruleID, variables, variableNames, variableTypes, condition, action, storage)</span>

        case "alpha":<span class="cov0" title="0">
                return cp.createAlphaRule(network, ruleID, variables, variableNames, variableTypes, condition, action, storage)</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("type de r√®gle inconnu: %s", ruleType)</span>
        }
}

// createAlphaRule cr√©e une r√®gle alpha simple avec une seule variable
func (cp *ConstraintPipeline) createAlphaRule(
        network *ReteNetwork,
        ruleID string,
        variables []map[string]interface{},
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Extraire les informations de la variable
        variableName, variableType := cp.getVariableInfo(variables, variableTypes)

        // Cr√©er l'AlphaNode avec son terminal
        return cp.createAlphaNodeWithTerminal(
                network,
                ruleID,
                condition,
                variableName,
                variableType,
                action,
                storage,
        )
}</span>

// createJoinRule cr√©e une r√®gle de jointure avec JoinNode
func (cp *ConstraintPipeline) createJoinRule(
        network *ReteNetwork,
        ruleID string,
        variables []map[string]interface{},
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        action *Action,
        storage Storage,
) error <span class="cov8" title="1">{
        // Cr√©er le n≈ìud terminal pour cette r√®gle
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // D√©l√©guer √† la fonction appropri√©e selon le nombre de variables
        if len(variableNames) &gt; 2 </span><span class="cov8" title="1">{
                return cp.createCascadeJoinRule(network, ruleID, variableNames, variableTypes, condition, terminalNode, storage)
        }</span>

        <span class="cov8" title="1">return cp.createBinaryJoinRule(network, ruleID, variableNames, variableTypes, condition, terminalNode, storage)</span>
}

// createExistsRule cr√©e une r√®gle EXISTS avec ExistsNode
func (cp *ConstraintPipeline) createExistsRule(
        network *ReteNetwork,
        ruleID string,
        exprMap map[string]interface{},
        condition map[string]interface{},
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Cr√©er le n≈ìud terminal pour cette r√®gle
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // Extraire les variables
        mainVariable, existsVariable, mainVarType, existsVarType, err := cp.extractExistsVariables(exprMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extraire les conditions d'EXISTS
        <span class="cov0" title="0">existsConditions, err := cp.extractExistsConditions(exprMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Cr√©er l'objet condition pour l'ExistsNode
        <span class="cov0" title="0">existsConditionObj := map[string]interface{}{
                "type":       ConditionTypeExists,
                "conditions": existsConditions,
        }

        // Cr√©er le mapping variable -&gt; type pour l'ExistsNode
        varTypes := make(map[string]string)
        varTypes[mainVariable] = mainVarType
        varTypes[existsVariable] = existsVarType

        // Cr√©er l'ExistsNode avec les vraies conditions
        existsNode := NewExistsNode(ruleID+"_exists", existsConditionObj, mainVariable, existsVariable, varTypes, storage)
        existsNode.AddChild(terminalNode)

        // Stocker l'ExistsNode dans les BetaNodes du r√©seau
        network.BetaNodes[existsNode.ID] = existsNode

        // Cr√©er des AlphaNodes pass-through pour les deux variables
        cp.connectExistsNodeToTypeNodes(network, ruleID, existsNode, mainVariable, mainVarType, existsVariable, existsVarType)

        fmt.Printf("   ‚úÖ ExistsNode %s cr√©√© pour %s EXISTS %s\n", existsNode.ID, mainVariable, existsVariable)
        return nil</span>
}

// extractExistsVariables extrait les variables d'une r√®gle EXISTS
func (cp *ConstraintPipeline) extractExistsVariables(exprMap map[string]interface{}) (string, string, string, string, error) <span class="cov0" title="0">{
        var mainVariable, existsVariable string
        var mainVarType, existsVarType string

        // Extraire la variable principale depuis "set"
        if setData, hasSet := exprMap["set"]; hasSet </span><span class="cov0" title="0">{
                if setMap, ok := setData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if varsData, hasVars := setMap["variables"]; hasVars </span><span class="cov0" title="0">{
                                if varsList, ok := varsData.([]interface{}); ok &amp;&amp; len(varsList) &gt; 0 </span><span class="cov0" title="0">{
                                        if varMap, ok := varsList[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if name, ok := varMap["name"].(string); ok </span><span class="cov0" title="0">{
                                                        mainVariable = name
                                                }</span>
                                                <span class="cov0" title="0">if dataType, ok := varMap["dataType"].(string); ok </span><span class="cov0" title="0">{
                                                        mainVarType = dataType
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Extraire la variable d'existence depuis les contraintes
        <span class="cov0" title="0">if constraintsData, hasConstraints := exprMap["constraints"]; hasConstraints </span><span class="cov0" title="0">{
                if constraintMap, ok := constraintsData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if variable, hasVar := constraintMap["variable"]; hasVar </span><span class="cov0" title="0">{
                                if varMap, ok := variable.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if name, ok := varMap["name"].(string); ok </span><span class="cov0" title="0">{
                                                existsVariable = name
                                        }</span>
                                        <span class="cov0" title="0">if dataType, ok := varMap["dataType"].(string); ok </span><span class="cov0" title="0">{
                                                existsVarType = dataType
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">if mainVariable == "" || existsVariable == "" </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("variables EXISTS non trouv√©es: main=%s, exists=%s", mainVariable, existsVariable)
        }</span>

        <span class="cov0" title="0">return mainVariable, existsVariable, mainVarType, existsVarType, nil</span>
}

// extractExistsConditions extrait les conditions d'une r√®gle EXISTS
func (cp *ConstraintPipeline) extractExistsConditions(exprMap map[string]interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var existsConditions []map[string]interface{}

        if constraintsData, hasConstraints := exprMap["constraints"]; hasConstraints </span><span class="cov0" title="0">{
                if constraintMap, ok := constraintsData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Essayer d'abord "condition" (au singulier)
                        if conditionData, hasCondition := constraintMap["condition"]; hasCondition </span><span class="cov0" title="0">{
                                if conditionObj, ok := conditionData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        existsConditions = append(existsConditions, conditionObj)
                                }</span>
                        }
                        // Puis essayer "conditions" (au pluriel) si pas trouv√©
                        <span class="cov0" title="0">if len(existsConditions) == 0 </span><span class="cov0" title="0">{
                                if conditionsData, hasConditions := constraintMap["conditions"]; hasConditions </span><span class="cov0" title="0">{
                                        if conditionsList, ok := conditionsData.([]interface{}); ok </span><span class="cov0" title="0">{
                                                for _, conditionData := range conditionsList </span><span class="cov0" title="0">{
                                                        if conditionObj, ok := conditionData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                                existsConditions = append(existsConditions, conditionObj)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return existsConditions, nil</span>
}

// connectExistsNodeToTypeNodes connecte un ExistsNode aux TypeNodes appropri√©s
func (cp *ConstraintPipeline) connectExistsNodeToTypeNodes(
        network *ReteNetwork,
        ruleID string,
        existsNode *ExistsNode,
        mainVariable string,
        mainVarType string,
        existsVariable string,
        existsVarType string,
) <span class="cov0" title="0">{
        // Connecter les variables principale et d'existence √† l'ExistsNode
        if mainVarType != "" </span><span class="cov0" title="0">{
                cp.connectTypeNodeToBetaNode(network, ruleID, mainVariable, mainVarType, existsNode, NodeSideLeft)
        }</span>
        <span class="cov0" title="0">if existsVarType != "" </span><span class="cov0" title="0">{
                cp.connectTypeNodeToBetaNode(network, ruleID, existsVariable, existsVarType, existsNode, NodeSideRight)
        }</span>
}

// createAccumulatorRule cr√©e une r√®gle avec AccumulatorNode
func (cp *ConstraintPipeline) createAccumulatorRule(
        network *ReteNetwork,
        ruleID string,
        variables []map[string]interface{},
        variableNames []string,
        variableTypes []string,
        aggInfo *AggregationInfo,
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Extraire la variable principale et son type depuis variables
        if len(variables) == 0 || len(variableTypes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune variable principale trouv√©e")
        }</span>

        <span class="cov0" title="0">mainVariable := variableNames[0]
        mainType := variableTypes[0]

        // Stocker dans aggInfo
        aggInfo.MainVariable = mainVariable
        aggInfo.MainType = mainType

        // Cr√©er le n≈ìud terminal
        terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // Cr√©er la condition de comparaison
        condition := map[string]interface{}{
                "type":     ConditionTypeComparison,
                "operator": aggInfo.Operator,
                "value":    aggInfo.Threshold,
        }

        // Cr√©er l'AccumulatorNode avec tous les param√®tres
        accumNode := NewAccumulatorNode(
                ruleID+"_accum",
                aggInfo.MainVariable, // "e"
                aggInfo.MainType,     // "Employee"
                aggInfo.AggVariable,  // "p"
                aggInfo.AggType,      // "Performance"
                aggInfo.Field,        // "score"
                aggInfo.JoinField,    // "employee_id"
                aggInfo.MainField,    // "id"
                aggInfo.Function,     // "AVG"
                condition,
                storage,
        )
        accumNode.AddChild(terminalNode)
        network.BetaNodes[accumNode.ID] = accumNode

        // Connecter les TypeNodes √† l'AccumulatorNode
        cp.connectTypeNodeToBetaNode(network, ruleID, mainVariable, mainType, accumNode, "")
        fmt.Printf("   ‚úì %s -&gt; PassthroughAlpha -&gt; AccumulatorNode[%s]\n", mainType, aggInfo.Function)

        cp.connectTypeNodeToBetaNode(network, ruleID, aggInfo.AggVariable, aggInfo.AggType, accumNode, "")
        fmt.Printf("   ‚úì %s -&gt; PassthroughAlpha -&gt; AccumulatorNode[%s] (pour agr√©gation)\n", aggInfo.AggType, aggInfo.Function)

        fmt.Printf("   ‚úÖ AccumulatorNode %s cr√©√© pour %s(%s.%s) %s %.2f\n",
                accumNode.ID, aggInfo.Function, aggInfo.AggVariable, aggInfo.Field, aggInfo.Operator, aggInfo.Threshold)
        return nil</span>
}

// createPassthroughAlphaNode creates a passthrough AlphaNode with optional side specification
func (cp *ConstraintPipeline) createPassthroughAlphaNode(ruleID, varName, side string, storage Storage) *AlphaNode <span class="cov8" title="1">{
        passCondition := map[string]interface{}{
                "type": ConditionTypePassthrough,
        }
        if side != "" </span><span class="cov8" title="1">{
                passCondition["side"] = side
        }</span>
        <span class="cov8" title="1">return NewAlphaNode(ruleID+"_pass_"+varName, passCondition, varName, storage)</span>
}

// connectTypeNodeToBetaNode connects a TypeNode to a BetaNode via a passthrough AlphaNode
func (cp *ConstraintPipeline) connectTypeNodeToBetaNode(
        network *ReteNetwork,
        ruleID string,
        varName string,
        varType string,
        betaNode Node,
        side string,
) <span class="cov8" title="1">{
        if typeNode, exists := network.TypeNodes[varType]; exists </span><span class="cov8" title="1">{
                alphaNode := cp.createPassthroughAlphaNode(ruleID, varName, side, network.Storage)
                typeNode.AddChild(alphaNode)
                alphaNode.AddChild(betaNode)

                sideInfo := ""
                if side != "" </span><span class="cov8" title="1">{
                        sideInfo = fmt.Sprintf(" (%s)", strings.ToUpper(side))
                }</span>
                <span class="cov8" title="1">fmt.Printf("   ‚úì %s -&gt; PassthroughAlpha_%s -&gt; %s%s\n", varType, varName, betaNode.GetID(), sideInfo)</span>
        }
}

// createBinaryJoinRule creates a simple binary join rule (2 variables)
func (cp *ConstraintPipeline) createBinaryJoinRule(
        network *ReteNetwork,
        ruleID string,
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        terminalNode *TerminalNode,
        storage Storage,
) error <span class="cov8" title="1">{
        leftVars := []string{variableNames[0]}
        rightVars := []string{variableNames[1]}

        // Cr√©er le mapping variable -&gt; type
        varTypes := make(map[string]string)
        for i, varName := range variableNames </span><span class="cov8" title="1">{
                varTypes[varName] = variableTypes[i]
        }</span>

        <span class="cov8" title="1">var joinNode *JoinNode
        var wasShared bool

        // Try to use BetaSharingRegistry if available and enabled
        if network.BetaSharingRegistry != nil &amp;&amp; network.Config != nil &amp;&amp; network.Config.BetaSharingEnabled </span><span class="cov0" title="0">{
                allVars := []string{variableNames[0], variableNames[1]}
                node, hash, shared, err := network.BetaSharingRegistry.GetOrCreateJoinNode(
                        condition,
                        leftVars,
                        rightVars,
                        allVars,
                        varTypes,
                        storage,
                )
                if err != nil </span><span class="cov0" title="0">{
                        // Fallback to direct creation on error
                        fmt.Printf("   ‚ö†Ô∏è Beta sharing failed: %v, falling back to direct creation\n", err)
                        joinNode = NewJoinNode(ruleID+"_join", condition, leftVars, rightVars, varTypes, storage)
                }</span> else<span class="cov0" title="0"> {
                        joinNode = node
                        wasShared = shared
                        if shared </span><span class="cov0" title="0">{
                                fmt.Printf("   ‚ôªÔ∏è  Reused shared JoinNode %s (hash: %s)\n", joinNode.ID, hash)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("   ‚ú® Created new shared JoinNode %s (hash: %s)\n", joinNode.ID, hash)
                        }</span>
                        // Register with lifecycle manager
                        <span class="cov0" title="0">if network.LifecycleManager != nil </span><span class="cov0" title="0">{
                                network.LifecycleManager.RegisterNode(hash, "JoinNode")
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Legacy mode: direct creation
                joinNode = NewJoinNode(ruleID+"_join", condition, leftVars, rightVars, varTypes, storage)
        }</span>

        <span class="cov8" title="1">joinNode.AddChild(terminalNode)

        // Stocker le JoinNode dans les BetaNodes du r√©seau
        network.BetaNodes[joinNode.ID] = joinNode

        // Connecter les TypeNodes via des AlphaNodes pass-through
        for i, varName := range variableNames </span><span class="cov8" title="1">{
                varType := variableTypes[i]
                if varType != "" </span><span class="cov8" title="1">{
                        side := NodeSideRight
                        if i == 0 </span><span class="cov8" title="1">{
                                side = NodeSideLeft
                        }</span>
                        <span class="cov8" title="1">cp.connectTypeNodeToBetaNode(network, ruleID, varName, varType, joinNode, side)</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚ö†Ô∏è Type vide pour variable %s\n", varName)
                }</span>
        }

        <span class="cov8" title="1">if wasShared </span><span class="cov0" title="0">{
                fmt.Printf("   ‚úÖ JoinNode %s r√©utilis√© pour jointure %s\n", joinNode.ID, strings.Join(variableNames, " ‚ãà "))
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("   ‚úÖ JoinNode %s cr√©√© pour jointure %s\n", joinNode.ID, strings.Join(variableNames, " ‚ãà "))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// createCascadeJoinRule creates a cascade of join nodes for multi-variable rules (3+ variables)
func (cp *ConstraintPipeline) createCascadeJoinRule(
        network *ReteNetwork,
        ruleID string,
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        terminalNode *TerminalNode,
        storage Storage,
) error <span class="cov8" title="1">{
        fmt.Printf("   üìç R√®gle multi-variables d√©tect√©e (%d variables): %v\n", len(variableNames), variableNames)

        // Try to use BetaChainBuilder if available and enabled
        if network.BetaChainBuilder != nil &amp;&amp; network.Config != nil &amp;&amp; network.Config.BetaSharingEnabled </span><span class="cov0" title="0">{
                return cp.createCascadeJoinRuleWithBuilder(network, ruleID, variableNames, variableTypes, condition, terminalNode, storage)
        }</span>

        // Fallback to legacy cascade implementation
        <span class="cov8" title="1">fmt.Printf("   üîß Construction d'architecture en cascade de JoinNodes (legacy mode)\n")

        // Cr√©er le mapping variable -&gt; type
        varTypes := make(map[string]string)
        for i, varName := range variableNames </span><span class="cov8" title="1">{
                varTypes[varName] = variableTypes[i]
        }</span>

        // √âtape 1: Cr√©er le premier JoinNode pour les 2 premi√®res variables
        <span class="cov8" title="1">leftVars := []string{variableNames[0]}
        rightVars := []string{variableNames[1]}
        currentVarTypes := map[string]string{
                variableNames[0]: variableTypes[0],
                variableNames[1]: variableTypes[1],
        }

        currentJoinNode := NewJoinNode(
                fmt.Sprintf("%s_join_%d_%d", ruleID, 0, 1),
                condition,
                leftVars,
                rightVars,
                currentVarTypes,
                storage,
        )
        network.BetaNodes[currentJoinNode.ID] = currentJoinNode

        // Connecter les 2 premi√®res variables au premier JoinNode
        for i := 0; i &lt; 2; i++ </span><span class="cov8" title="1">{
                varName := variableNames[i]
                varType := variableTypes[i]
                side := NodeSideRight
                if i == 0 </span><span class="cov8" title="1">{
                        side = NodeSideLeft
                }</span>
                <span class="cov8" title="1">cp.connectTypeNodeToBetaNode(network, ruleID, varName, varType, currentJoinNode, side)
                fmt.Printf("   ‚úì Cascade level 1 connection\n")</span>
        }

        <span class="cov8" title="1">fmt.Printf("   ‚úÖ JoinNode cascade level 1: %s ‚ãà %s\n", variableNames[0], variableNames[1])

        // √âtape 2+: Joindre chaque variable suivante au r√©sultat pr√©c√©dent
        for i := 2; i &lt; len(variableNames); i++ </span><span class="cov8" title="1">{
                nextVarName := variableNames[i]
                nextVarType := variableTypes[i]

                // Variables accumul√©es jusqu'ici
                accumulatedVars := variableNames[0:i]
                accumulatedVarTypes := make(map[string]string)
                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                        accumulatedVarTypes[variableNames[j]] = variableTypes[j]
                }</span>
                <span class="cov8" title="1">accumulatedVarTypes[nextVarName] = nextVarType

                // Cr√©er le prochain JoinNode
                nextJoinNode := NewJoinNode(
                        fmt.Sprintf("%s_join_%d", ruleID, i),
                        condition,
                        accumulatedVars,
                        []string{nextVarName},
                        accumulatedVarTypes,
                        storage,
                )
                network.BetaNodes[nextJoinNode.ID] = nextJoinNode

                // Connecter le JoinNode pr√©c√©dent au nouveau JoinNode
                currentJoinNode.AddChild(nextJoinNode)

                // Connecter la nouvelle variable au JoinNode
                cp.connectTypeNodeToBetaNode(network, ruleID, nextVarName, nextVarType, nextJoinNode, NodeSideRight)
                fmt.Printf("   ‚úì Cascade level %d connection\n", i)

                fmt.Printf("   ‚úÖ JoinNode cascade level %d: (%s) ‚ãà %s\n", i, strings.Join(accumulatedVars, " ‚ãà "), nextVarName)

                currentJoinNode = nextJoinNode</span>
        }

        // Connecter le dernier JoinNode au terminal
        <span class="cov8" title="1">currentJoinNode.AddChild(terminalNode)
        fmt.Printf("   ‚úÖ Architecture en cascade compl√®te: %s\n", strings.Join(variableNames, " ‚ãà "))

        return nil</span>
}

// createCascadeJoinRuleWithBuilder creates a cascade using BetaChainBuilder with sharing support
func (cp *ConstraintPipeline) createCascadeJoinRuleWithBuilder(
        network *ReteNetwork,
        ruleID string,
        variableNames []string,
        variableTypes []string,
        condition map[string]interface{},
        terminalNode *TerminalNode,
        storage Storage,
) error <span class="cov0" title="0">{
        fmt.Printf("   üîß Construction avec BetaChainBuilder (sharing enabled)\n")

        // Cr√©er le mapping variable -&gt; type
        varTypes := make(map[string]string)
        for i, varName := range variableNames </span><span class="cov0" title="0">{
                varTypes[varName] = variableTypes[i]
        }</span>

        // Build join patterns for the chain
        <span class="cov0" title="0">patterns := make([]JoinPattern, 0, len(variableNames)-1)

        // Pattern 1: First two variables
        patterns = append(patterns, JoinPattern{
                LeftVars:    []string{variableNames[0]},
                RightVars:   []string{variableNames[1]},
                AllVars:     []string{variableNames[0], variableNames[1]},
                VarTypes:    varTypes,
                Condition:   condition,
                Selectivity: 0.5, // Default selectivity
        })

        // Patterns 2+: Each subsequent variable joins with accumulated results
        for i := 2; i &lt; len(variableNames); i++ </span><span class="cov0" title="0">{
                accumulatedVars := make([]string, i)
                copy(accumulatedVars, variableNames[0:i])

                allVars := make([]string, i+1)
                copy(allVars, variableNames[0:i+1])

                patterns = append(patterns, JoinPattern{
                        LeftVars:    accumulatedVars,
                        RightVars:   []string{variableNames[i]},
                        AllVars:     allVars,
                        VarTypes:    varTypes,
                        Condition:   condition,
                        Selectivity: 0.5, // Default selectivity
                })
        }</span>

        // Build the chain using BetaChainBuilder
        <span class="cov0" title="0">chain, err := network.BetaChainBuilder.BuildChain(patterns, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build beta chain: %w", err)
        }</span>

        // Add all nodes to network's BetaNodes map
        <span class="cov0" title="0">for _, node := range chain.Nodes </span><span class="cov0" title="0">{
                network.BetaNodes[node.ID] = node
        }</span>

        // Connect type nodes to the first join node (for first two variables)
        <span class="cov0" title="0">if len(chain.Nodes) &gt; 0 </span><span class="cov0" title="0">{
                firstJoin := chain.Nodes[0]
                for i := 0; i &lt; 2 &amp;&amp; i &lt; len(variableNames); i++ </span><span class="cov0" title="0">{
                        varName := variableNames[i]
                        varType := variableTypes[i]
                        side := NodeSideRight
                        if i == 0 </span><span class="cov0" title="0">{
                                side = NodeSideLeft
                        }</span>
                        <span class="cov0" title="0">cp.connectTypeNodeToBetaNode(network, ruleID, varName, varType, firstJoin, side)</span>
                }
                <span class="cov0" title="0">fmt.Printf("   ‚úì Connected first two variables to initial JoinNode\n")</span>
        }

        // Connect subsequent variables to their respective join nodes
        <span class="cov0" title="0">for i := 2; i &lt; len(variableNames) &amp;&amp; i-1 &lt; len(chain.Nodes); i++ </span><span class="cov0" title="0">{
                joinNode := chain.Nodes[i-1]
                varName := variableNames[i]
                varType := variableTypes[i]
                cp.connectTypeNodeToBetaNode(network, ruleID, varName, varType, joinNode, NodeSideRight)
                fmt.Printf("   ‚úì Connected variable %s to cascade level %d\n", varName, i)
        }</span>

        // Connect the final node to the terminal
        <span class="cov0" title="0">if chain.FinalNode != nil </span><span class="cov0" title="0">{
                chain.FinalNode.AddChild(terminalNode)
                fmt.Printf("   ‚úÖ Chain complete: %d JoinNodes, %d shared\n",
                        len(chain.Nodes),
                        network.BetaChainBuilder.GetMetrics().SharedJoinNodesReused)
        }</span>

        <span class="cov0" title="0">fmt.Printf("   ‚úÖ Architecture en cascade compl√®te avec partage: %s\n", strings.Join(variableNames, " ‚ãà "))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
)

// createAction cr√©e une action RETE √† partir d'une map d'action pars√©e
func (cp *ConstraintPipeline) createAction(actionMap map[string]interface{}) *Action <span class="cov8" title="1">{
        actionType := getStringField(actionMap, "type", "print")

        // Extraire le job depuis l'action
        jobData, hasJob := actionMap["job"]
        if !hasJob </span><span class="cov0" title="0">{
                // Fallback: action simple sans job (ne devrait pas arriver avec le nouveau parser)
                return &amp;Action{
                        Type: actionType,
                        Job: JobCall{
                                Name: actionType,
                                Args: []interface{}{},
                        },
                }
        }</span>

        <span class="cov8" title="1">jobMap, ok := jobData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;Action{
                        Type: actionType,
                        Job: JobCall{
                                Name: actionType,
                                Args: []interface{}{},
                        },
                }
        }</span>

        // Extraire le nom du job
        <span class="cov8" title="1">jobName := getStringField(jobMap, "name", actionType)

        action := &amp;Action{
                Type: actionType,
                Job: JobCall{
                        Name: jobName,
                        Args: []interface{}{},
                },
        }

        // Extraire les arguments du job (pas de l'action)
        if argsData, hasArgs := jobMap["args"]; hasArgs </span><span class="cov8" title="1">{
                if argsList, ok := argsData.([]interface{}); ok </span><span class="cov8" title="1">{
                        action.Job.Args = argsList
                }</span>
        }

        <span class="cov8" title="1">return action</span>
}

// buildConditionFromConstraints construit une condition appropri√©e √† partir de contraintes
func (cp *ConstraintPipeline) buildConditionFromConstraints(constraintsData interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        if constraintsData == nil </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "type": "simple",
                }, nil
        }</span>

        // V√©rifier si c'est une agr√©gation
        <span class="cov8" title="1">if cp.detectAggregation(constraintsData) </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "type": "passthrough",
                }, nil
        }</span>

        // Analyser les contraintes pour d√©tecter les n√©gations
        <span class="cov8" title="1">isNegation, negatedCondition, err := cp.analyzeConstraints(constraintsData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur analyse contraintes: %w", err)
        }</span>

        <span class="cov8" title="1">if isNegation </span><span class="cov0" title="0">{
                fmt.Printf("   üö´ D√©tection contrainte NOT - cr√©ation d'un AlphaNode de n√©gation\n")
                return map[string]interface{}{
                        "type":      "negation",
                        "negated":   true,
                        "condition": negatedCondition,
                }, nil
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "type":       "constraint",
                "constraint": constraintsData,
        }, nil</span>
}

// extractActionFromExpression extrait l'action d'une expression de r√®gle
func (cp *ConstraintPipeline) extractActionFromExpression(exprMap map[string]interface{}, ruleID string) (*Action, error) <span class="cov8" title="1">{
        actionData, hasAction := exprMap["action"]
        if !hasAction </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aucune action trouv√©e pour r√®gle %s", ruleID)
        }</span>

        <span class="cov8" title="1">actionMap, ok := actionData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("format action invalide pour r√®gle %s: %T", ruleID, actionData)
        }</span>

        <span class="cov8" title="1">return cp.createAction(actionMap), nil</span>
}

// determineRuleType d√©termine le type de r√®gle (alpha, join, exists, accumulator)
// Retourne (ruleType string, shouldProcess bool)
func (cp *ConstraintPipeline) determineRuleType(
        exprMap map[string]interface{},
        variableCount int,
        hasAggregation bool,
) string <span class="cov8" title="1">{
        // V√©rifier si c'est une contrainte EXISTS
        if constraintsData, hasConstraints := exprMap["constraints"]; hasConstraints </span><span class="cov8" title="1">{
                if cp.isExistsConstraint(constraintsData) </span><span class="cov0" title="0">{
                        return "exists"
                }</span>
        }

        // Si c'est une agr√©gation
        <span class="cov8" title="1">if hasAggregation </span><span class="cov0" title="0">{
                return "accumulator"
        }</span>

        // Si plus d'une variable, c'est une jointure
        <span class="cov8" title="1">if variableCount &gt; 1 </span><span class="cov8" title="1">{
                return "join"
        }</span>

        // Sinon, c'est une r√®gle alpha simple
        <span class="cov0" title="0">return "alpha"</span>
}

// getVariableInfo extrait les informations de la premi√®re variable
// Retourne (variableName, variableType)
func (cp *ConstraintPipeline) getVariableInfo(variables []map[string]interface{}, variableTypes []string) (string, string) <span class="cov0" title="0">{
        variableName := "p" // d√©faut
        variableType := ""

        if len(variables) &gt; 0 </span><span class="cov0" title="0">{
                if name, ok := variables[0]["name"].(string); ok </span><span class="cov0" title="0">{
                        variableName = name
                }</span>
                <span class="cov0" title="0">if len(variableTypes) &gt; 0 </span><span class="cov0" title="0">{
                        variableType = variableTypes[0]
                }</span>
        }

        <span class="cov0" title="0">return variableName, variableType</span>
}

// connectAlphaNodeToTypeNode connecte un AlphaNode au TypeNode appropri√©
func (cp *ConstraintPipeline) connectAlphaNodeToTypeNode(
        network *ReteNetwork,
        alphaNode *AlphaNode,
        variableType string,
        variableName string,
) <span class="cov0" title="0">{
        if variableType != "" </span><span class="cov0" title="0">{
                // Les TypeNodes sont stock√©s avec leur nom direct, pas avec "type_" pr√©fixe
                if typeNode, exists := network.TypeNodes[variableType]; exists </span><span class="cov0" title="0">{
                        typeNode.AddChild(alphaNode)
                        fmt.Printf("   ‚úì AlphaNode %s connect√© au TypeNode %s\n", alphaNode.ID, variableType)
                        return
                }</span>
                <span class="cov0" title="0">fmt.Printf("   ‚ö†Ô∏è  TypeNode %s non trouv√© pour variable %s\n", variableType, variableName)</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("   ‚ö†Ô∏è  Type de variable non trouv√© pour %s, fallback\n", variableName)
        }</span>

        // Fallback: connecter au premier type node trouv√©
        <span class="cov0" title="0">for _, typeNode := range network.TypeNodes </span><span class="cov0" title="0">{
                typeNode.AddChild(alphaNode)
                break</span>
        }
}

// createAlphaNodeWithTerminal cr√©e un AlphaNode (partag√© si possible) et son n≈ìud terminal associ√©
// Cette fonction analyse l'expression et construit une cha√Æne si possible, sinon utilise le comportement simple
func (cp *ConstraintPipeline) createAlphaNodeWithTerminal(
        network *ReteNetwork,
        ruleID string,
        condition interface{},
        variableName string,
        variableType string,
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // D√©baller la condition si elle est wrapp√©e dans une map
        actualCondition := condition
        if condMap, ok := condition.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if condType, hasType := condMap["type"]; hasType </span><span class="cov0" title="0">{
                        if condType == "constraint" </span><span class="cov0" title="0">{
                                if constraint, hasConstraint := condMap["constraint"]; hasConstraint </span><span class="cov0" title="0">{
                                        actualCondition = constraint
                                }</span>
                        } else<span class="cov0" title="0"> if condType == "negation" </span><span class="cov0" title="0">{
                                // Pour les n√©gations, utiliser le comportement simple
                                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
                        }</span> else<span class="cov0" title="0"> if condType == "simple" || condType == "passthrough" </span><span class="cov0" title="0">{
                                // Pas de vraie condition, utiliser le comportement simple
                                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
                        }</span>
                }
        }

        // Analyser l'expression pour d√©terminer son type
        <span class="cov0" title="0">exprType, err := AnalyzeExpression(actualCondition)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ö†Ô∏è  Erreur analyse expression: %v, fallback vers comportement simple\n", err)
                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
        }</span>

        // Cas sp√©cial: expressions OR et mixtes - normalisation avanc√©e avec support des OR imbriqu√©s
        // DOIT √™tre trait√© AVANT le check CanDecompose car OR n'est pas d√©composable
        <span class="cov0" title="0">if exprType == ExprTypeOR || exprType == ExprTypeMixed </span><span class="cov0" title="0">{
                if exprType == ExprTypeOR </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ÑπÔ∏è  Expression OR d√©tect√©e, normalisation avanc√©e et cr√©ation d'un n≈ìud alpha unique\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚ÑπÔ∏è  Expression mixte (AND+OR) d√©tect√©e, normalisation avanc√©e et cr√©ation d'un n≈ìud alpha unique\n")
                }</span>

                // Analyser la complexit√© de l'expression pour d√©terminer la strat√©gie de normalisation
                <span class="cov0" title="0">analysis, err := AnalyzeNestedOR(actualCondition)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ö†Ô∏è  Erreur analyse OR imbriqu√©: %v, fallback vers normalisation simple\n", err)
                        // Fallback vers normalisation simple
                        normalizedExpr, err := NormalizeORExpression(actualCondition)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("   ‚ö†Ô∏è  Erreur normalisation simple: %v, fallback vers comportement simple\n", err)
                                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
                        }</span>
                        <span class="cov0" title="0">normalizedCondition := map[string]interface{}{
                                "type":       "constraint",
                                "constraint": normalizedExpr,
                        }
                        return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, normalizedCondition, variableName, variableType, action, storage)</span>
                }

                // Afficher les informations d'analyse
                <span class="cov0" title="0">fmt.Printf("   üìä Analyse OR: Complexit√©=%v, Profondeur=%d, OR=%d, AND=%d\n",
                        analysis.Complexity, analysis.NestingDepth, analysis.ORTermCount, analysis.ANDTermCount)

                if analysis.OptimizationHint != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   üí° Suggestion: %s\n", analysis.OptimizationHint)
                }</span>

                // Utiliser la normalisation avanc√©e pour les expressions complexes
                <span class="cov0" title="0">var normalizedExpr interface{}
                if analysis.RequiresFlattening || analysis.RequiresDNF </span><span class="cov0" title="0">{
                        fmt.Printf("   üîß Application de la normalisation avanc√©e (aplatissement=%v, DNF=%v)\n",
                                analysis.RequiresFlattening, analysis.RequiresDNF)

                        normalizedExpr, err = NormalizeNestedOR(actualCondition)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("   ‚ö†Ô∏è  Erreur normalisation avanc√©e: %v, fallback vers normalisation simple\n", err)
                                // Fallback vers normalisation simple
                                normalizedExpr, err = NormalizeORExpression(actualCondition)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("   ‚ö†Ô∏è  Erreur normalisation simple: %v, utilisation expression originale\n", err)
                                        normalizedExpr = actualCondition
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Printf("   ‚úÖ Normalisation avanc√©e r√©ussie\n")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Pour les expressions simples, utiliser la normalisation standard
                        fmt.Printf("   üîß Application de la normalisation standard\n")
                        normalizedExpr, err = NormalizeORExpression(actualCondition)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("   ‚ö†Ô∏è  Erreur normalisation: %v, utilisation expression originale\n", err)
                                normalizedExpr = actualCondition
                        }</span>
                }

                // Cr√©er un seul AlphaNode avec l'expression normalis√©e
                <span class="cov0" title="0">normalizedCondition := map[string]interface{}{
                        "type":       "constraint",
                        "constraint": normalizedExpr,
                }

                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, normalizedCondition, variableName, variableType, action, storage)</span>
        }

        // V√©rifier si l'expression peut √™tre d√©compos√©e
        <span class="cov0" title="0">if !CanDecompose(exprType) </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ÑπÔ∏è  Expression de type %s non d√©composable, utilisation du n≈ìud simple\n", exprType)
                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
        }</span>

        // Cas sp√©cial: expressions simples - utiliser le comportement actuel
        <span class="cov0" title="0">if exprType == ExprTypeSimple || exprType == ExprTypeArithmetic </span><span class="cov0" title="0">{
                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
        }</span>

        // Expressions AND ou NOT - tenter la d√©composition en cha√Æne
        <span class="cov0" title="0">fmt.Printf("   üîç Expression de type %s d√©tect√©e, tentative de d√©composition...\n", exprType)

        // Extraire les conditions de l'expression (utiliser la condition d√©ball√©e)
        conditions, opType, err := ExtractConditions(actualCondition)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ö†Ô∏è  Erreur extraction conditions: %v, fallback vers comportement simple\n", err)
                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
        }</span>

        // Si une seule condition, pas besoin de cha√Æne
        <span class="cov0" title="0">if len(conditions) &lt;= 1 </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ÑπÔ∏è  Une seule condition extraite, utilisation du n≈ìud simple\n")
                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
        }</span>

        <span class="cov0" title="0">fmt.Printf("   üîó D√©composition en cha√Æne: %d conditions d√©tect√©es (op√©rateur: %s)\n", len(conditions), opType)

        // Normaliser les conditions
        normalizedConditions := NormalizeConditions(conditions, opType)
        fmt.Printf("   üìã Conditions normalis√©es: %d condition(s)\n", len(normalizedConditions))

        // Trouver le TypeNode parent pour connecter la cha√Æne
        var parentNode Node
        if variableType != "" </span><span class="cov0" title="0">{
                if typeNode, exists := network.TypeNodes[variableType]; exists </span><span class="cov0" title="0">{
                        parentNode = typeNode
                }</span>
        }

        // Si pas de TypeNode trouv√©, utiliser le premier disponible
        <span class="cov0" title="0">if parentNode == nil </span><span class="cov0" title="0">{
                for _, typeNode := range network.TypeNodes </span><span class="cov0" title="0">{
                        parentNode = typeNode
                        break</span>
                }
        }

        <span class="cov0" title="0">if parentNode == nil </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ö†Ô∏è  Aucun TypeNode trouv√©, fallback vers comportement simple\n")
                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
        }</span>

        // Cr√©er le constructeur de cha√Æne
        <span class="cov0" title="0">chainBuilder := NewAlphaChainBuilder(network, storage)

        // Construire la cha√Æne d'AlphaNodes
        chain, err := chainBuilder.BuildChain(normalizedConditions, variableName, parentNode, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ö†Ô∏è  Erreur construction cha√Æne: %v, fallback vers comportement simple\n", err)
                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
        }</span>

        // Valider la cha√Æne
        <span class="cov0" title="0">if err := chain.ValidateChain(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ö†Ô∏è  Cha√Æne invalide: %v, fallback vers comportement simple\n", err)
                return cp.createSimpleAlphaNodeWithTerminal(network, ruleID, condition, variableName, variableType, action, storage)
        }</span>

        // Obtenir les statistiques de la cha√Æne
        <span class="cov0" title="0">stats := chainBuilder.GetChainStats(chain)
        sharedCount := 0
        if sc, ok := stats["shared_nodes"].(int); ok </span><span class="cov0" title="0">{
                sharedCount = sc
        }</span>

        // Afficher les statistiques de construction
        <span class="cov0" title="0">fmt.Printf("   ‚úÖ Cha√Æne construite: %d n≈ìud(s), %d partag√©(s)\n", len(chain.Nodes), sharedCount)

        // Logger les d√©tails de chaque n≈ìud
        for i, node := range chain.Nodes </span><span class="cov0" title="0">{
                if i &lt; sharedCount </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ôªÔ∏è  AlphaNode partag√© r√©utilis√©: %s (hash: %s)\n", node.ID, chain.Hashes[i])
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚ú® Nouveau AlphaNode cr√©√©: %s (hash: %s)\n", node.ID, chain.Hashes[i])
                }</span>
        }

        // Cr√©er et attacher le terminal au dernier n≈ìud de la cha√Æne
        <span class="cov0" title="0">terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        chain.FinalNode.AddChild(terminalNode)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // Enregistrer le TerminalNode dans le LifecycleManager
        if network.LifecycleManager != nil </span><span class="cov0" title="0">{
                lifecycle := network.LifecycleManager.RegisterNode(terminalNode.ID, "terminal")
                lifecycle.AddRuleReference(ruleID, ruleID)
        }</span>

        <span class="cov0" title="0">fmt.Printf("   ‚úì TerminalNode %s attach√© au n≈ìud final %s de la cha√Æne\n", terminalNode.ID, chain.FinalNode.ID)

        return nil</span>
}

// createSimpleAlphaNodeWithTerminal cr√©e un AlphaNode simple (partag√© si possible) et son n≈ìud terminal associ√©
// Cette fonction impl√©mente le comportement original pour les conditions simples ou non-d√©composables
func (cp *ConstraintPipeline) createSimpleAlphaNodeWithTerminal(
        network *ReteNetwork,
        ruleID string,
        condition interface{},
        variableName string,
        variableType string,
        action *Action,
        storage Storage,
) error <span class="cov0" title="0">{
        // Convertir la condition en map si n√©cessaire
        var conditionMap map[string]interface{}
        switch c := condition.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                conditionMap = c</span>
        default:<span class="cov0" title="0">
                // Pour les types structur√©s (constraint.*), les passer directement
                conditionMap = map[string]interface{}{
                        "type":       "constraint",
                        "constraint": condition,
                }</span>
        }
        // Utiliser le gestionnaire de partage pour obtenir ou cr√©er un AlphaNode
        <span class="cov0" title="0">alphaNode, alphaHash, wasShared, err := network.AlphaSharingManager.GetOrCreateAlphaNode(
                conditionMap,
                variableName,
                storage,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur cr√©ation AlphaNode partag√©: %w", err)
        }</span>

        <span class="cov0" title="0">if wasShared </span><span class="cov0" title="0">{
                fmt.Printf("   ‚ôªÔ∏è  AlphaNode partag√© r√©utilis√©: %s (hash: %s)\n", alphaNode.ID, alphaHash)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("   ‚ú® Nouveau AlphaNode partageable cr√©√©: %s (hash: %s)\n", alphaNode.ID, alphaHash)

                // Connecter au type node appropri√© (seulement pour les nouveaux n≈ìuds)
                cp.connectAlphaNodeToTypeNode(network, alphaNode, variableType, variableName)

                // Ajouter au registre global des AlphaNodes du r√©seau
                network.AlphaNodes[alphaNode.ID] = alphaNode
        }</span>

        // Enregistrer ou mettre √† jour l'AlphaNode dans le LifecycleManager
        <span class="cov0" title="0">if network.LifecycleManager != nil </span><span class="cov0" title="0">{
                lifecycle := network.LifecycleManager.RegisterNode(alphaNode.ID, "alpha")
                lifecycle.AddRuleReference(ruleID, ruleID)
        }</span>

        // Cr√©er le terminal (toujours sp√©cifique √† la r√®gle)
        <span class="cov0" title="0">terminalNode := NewTerminalNode(ruleID+"_terminal", action, storage)
        alphaNode.AddChild(terminalNode)
        network.TerminalNodes[terminalNode.ID] = terminalNode

        // Enregistrer le TerminalNode dans le LifecycleManager
        if network.LifecycleManager != nil </span><span class="cov0" title="0">{
                lifecycle := network.LifecycleManager.RegisterNode(terminalNode.ID, "terminal")
                lifecycle.AddRuleReference(ruleID, ruleID)
        }</span>

        <span class="cov0" title="0">if conditionMap["type"] == "negation" </span><span class="cov0" title="0">{
                fmt.Printf("   ‚úì AlphaNode de n√©gation cr√©√©: %s -&gt; %s\n", alphaNode.ID, terminalNode.ID)
        }</span> else<span class="cov0" title="0"> if wasShared </span><span class="cov0" title="0">{
                fmt.Printf("   ‚úì R√®gle %s attach√©e √† l'AlphaNode partag√© %s via terminal %s\n",
                        ruleID, alphaNode.ID, terminalNode.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// logRuleCreation affiche un message de log pour la cr√©ation d'une r√®gle
func (cp *ConstraintPipeline) logRuleCreation(ruleType string, ruleID string, variableNames []string) <span class="cov8" title="1">{
        switch ruleType </span>{
        case "join":<span class="cov8" title="1">
                fmt.Printf("   üìç R√®gle multi-variables d√©tect√©e (%d variables): %v\n", len(variableNames), variableNames)</span>
        case "exists":<span class="cov0" title="0">
                fmt.Printf("   üîç R√®gle EXISTS d√©tect√©e pour: %s\n", ruleID)</span>
        case "accumulator":<span class="cov0" title="0">
                fmt.Printf("   üìä R√®gle d'agr√©gation d√©tect√©e pour: %s\n", ruleID)</span>
        case "alpha":<span class="cov0" title="0">
                fmt.Printf("   ‚úì R√®gle alpha simple cr√©√©e pour: %s\n", ruleID)</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "strings"
)

// extractComponents extrait les types et expressions d'un AST pars√©
// Note: La gestion des instructions reset est effectu√©e en amont dans buildNetworkWithResetSemantics
// Cette fonction suppose que le programme re√ßu a d√©j√† la s√©mantique reset appliqu√©e si n√©cessaire
// Retourne (types, expressions, error)
func (cp *ConstraintPipeline) extractComponents(resultMap map[string]interface{}) ([]interface{}, []interface{}, error) <span class="cov8" title="1">{
        // Extraire les types
        typesData, hasTypes := resultMap["types"]
        if !hasTypes </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("aucun type trouv√© dans l'AST")
        }</span>

        <span class="cov8" title="1">types, ok := typesData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("format types invalide: %T", typesData)
        }</span>

        // Extraire les expressions
        <span class="cov8" title="1">expressionsData, hasExpressions := resultMap["expressions"]
        if !hasExpressions </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("aucune expression trouv√©e dans l'AST")
        }</span>

        <span class="cov8" title="1">expressions, ok := expressionsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("format expressions invalide: %T", expressionsData)
        }</span>

        <span class="cov8" title="1">return types, expressions, nil</span>
}

// analyzeConstraints analyse les contraintes pour d√©tecter les n√©gations
// Retourne (isNegation, negatedCondition, error)
func (cp *ConstraintPipeline) analyzeConstraints(constraints interface{}) (bool, interface{}, error) <span class="cov8" title="1">{
        constraintMap, ok := constraints.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return false, constraints, nil
        }</span>

        // D√©tecter contrainte NOT
        <span class="cov8" title="1">if constraintType, exists := constraintMap["type"].(string); exists </span><span class="cov8" title="1">{
                if constraintType == "notConstraint" </span><span class="cov0" title="0">{
                        // Extraire la contrainte ni√©e
                        if negatedConstraint, hasNegated := constraintMap["constraint"]; hasNegated </span><span class="cov0" title="0">{
                                return true, negatedConstraint, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return false, constraints, nil</span>
}

// extractAggregationInfo extrait les informations d'agr√©gation d'une contrainte
func (cp *ConstraintPipeline) extractAggregationInfo(constraintsData interface{}) (*AggregationInfo, error) <span class="cov0" title="0">{
        constraintMap, ok := constraintsData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("constraints n'est pas un map: %T", constraintsData)
        }</span>

        <span class="cov0" title="0">aggInfo := &amp;AggregationInfo{}

        // Extraire la fonction d'agr√©gation (AVG, SUM, COUNT, etc.)
        if function, ok := constraintMap["function"].(string); ok </span><span class="cov0" title="0">{
                aggInfo.Function = function
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("fonction d'agr√©gation non trouv√©e")
        }</span>

        // Extraire l'op√©rateur de comparaison
        <span class="cov0" title="0">if operator, ok := constraintMap["operator"].(string); ok </span><span class="cov0" title="0">{
                aggInfo.Operator = operator
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("op√©rateur de comparaison non trouv√©")
        }</span>

        // Extraire le seuil (threshold) depuis constraintMap["threshold"]["value"]
        <span class="cov0" title="0">if thresholdData, ok := constraintMap["threshold"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if threshold, ok := thresholdData["value"].(float64); ok </span><span class="cov0" title="0">{
                        aggInfo.Threshold = threshold
                }</span> else<span class="cov0" title="0"> if thresholdInt, ok := thresholdData["value"].(int); ok </span><span class="cov0" title="0">{
                        aggInfo.Threshold = float64(thresholdInt)
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("valeur de seuil non trouv√©e ou invalide")
                }</span>
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("seuil manquant")
        }</span>

        // Extraire la condition de jointure compl√®te
        <span class="cov0" title="0">if joinCond, ok := constraintMap["join"]; ok </span><span class="cov0" title="0">{
                aggInfo.JoinCondition = joinCond
        }</span>

        // Extraire la variable √† agr√©ger depuis constraintMap["variable"]
        <span class="cov0" title="0">if variableData, ok := constraintMap["variable"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if aggVar, ok := variableData["name"].(string); ok </span><span class="cov0" title="0">{
                        aggInfo.AggVariable = aggVar
                }</span>
                <span class="cov0" title="0">if aggType, ok := variableData["dataType"].(string); ok </span><span class="cov0" title="0">{
                        aggInfo.AggType = aggType
                }</span>
        }

        // Extraire le champ √† agr√©ger
        <span class="cov0" title="0">if field, ok := constraintMap["field"].(string); ok </span><span class="cov0" title="0">{
                aggInfo.Field = field
        }</span>

        // Extraire les informations de jointure depuis la condition
        <span class="cov0" title="0">if conditionData, ok := constraintMap["condition"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                aggInfo.JoinCondition = conditionData

                // Extraire les champs de jointure depuis la condition de type comparison
                if condType, ok := conditionData["type"].(string); ok &amp;&amp; condType == "comparison" </span><span class="cov0" title="0">{
                        // Left side: p.employee_id
                        if leftData, ok := conditionData["left"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if leftType, ok := leftData["type"].(string); ok &amp;&amp; leftType == "fieldAccess" </span><span class="cov0" title="0">{
                                        if joinField, ok := leftData["field"].(string); ok </span><span class="cov0" title="0">{
                                                aggInfo.JoinField = joinField
                                        }</span>
                                }
                        }

                        // Right side: e.id
                        <span class="cov0" title="0">if rightData, ok := conditionData["right"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if rightType, ok := rightData["type"].(string); ok &amp;&amp; rightType == "fieldAccess" </span><span class="cov0" title="0">{
                                        if mainField, ok := rightData["field"].(string); ok </span><span class="cov0" title="0">{
                                                aggInfo.MainField = mainField
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return aggInfo, nil</span>
}

// extractVariablesFromExpression extrait les variables d'une expression
// Retourne (variables, variableNames, variableTypes)
func (cp *ConstraintPipeline) extractVariablesFromExpression(exprMap map[string]interface{}) ([]map[string]interface{}, []string, []string) <span class="cov8" title="1">{
        variables := []map[string]interface{}{}
        variableNames := []string{}
        variableTypes := []string{}

        if setData, hasSet := exprMap["set"]; hasSet </span><span class="cov8" title="1">{
                if setMap, ok := setData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if varsData, hasVars := setMap["variables"]; hasVars </span><span class="cov8" title="1">{
                                if varsList, ok := varsData.([]interface{}); ok &amp;&amp; len(varsList) &gt; 0 </span><span class="cov8" title="1">{
                                        // Extraire toutes les variables
                                        for _, varInterface := range varsList </span><span class="cov8" title="1">{
                                                if varMap, ok := varInterface.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                                        variables = append(variables, varMap)

                                                        if name, ok := varMap["name"].(string); ok </span><span class="cov8" title="1">{
                                                                variableNames = append(variableNames, name)
                                                        }</span>

                                                        // Extraire le type de la variable
                                                        <span class="cov8" title="1">var varType string
                                                        if dataType, ok := varMap["dataType"].(string); ok </span><span class="cov8" title="1">{
                                                                varType = dataType
                                                        }</span> else<span class="cov0" title="0"> if typeField, ok := varMap["type"].(string); ok </span><span class="cov0" title="0">{
                                                                varType = typeField
                                                        }</span>
                                                        <span class="cov8" title="1">variableTypes = append(variableTypes, varType)</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return variables, variableNames, variableTypes</span>
}

// detectAggregation d√©tecte si une contrainte contient une agr√©gation
func (cp *ConstraintPipeline) detectAggregation(constraintsData interface{}) bool <span class="cov8" title="1">{
        if constraintStr := fmt.Sprintf("%v", constraintsData); constraintStr != "" </span><span class="cov8" title="1">{
                return strings.Contains(constraintStr, "AVG") ||
                        strings.Contains(constraintStr, "SUM") ||
                        strings.Contains(constraintStr, "COUNT") ||
                        strings.Contains(constraintStr, "MIN") ||
                        strings.Contains(constraintStr, "MAX") ||
                        strings.Contains(constraintStr, "ACCUMULATE")
        }</span>
        <span class="cov0" title="0">return false</span>
}

// isExistsConstraint v√©rifie si une contrainte est de type EXISTS
func (cp *ConstraintPipeline) isExistsConstraint(constraintsData interface{}) bool <span class="cov8" title="1">{
        if constraintMap, ok := constraintsData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if constraintType, exists := constraintMap["type"].(string); exists &amp;&amp; constraintType == "existsConstraint" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// getStringField extrait un champ string d'une map avec une valeur par d√©faut
func getStringField(m map[string]interface{}, key, defaultValue string) string <span class="cov8" title="1">{
        if value, ok := m[key].(string); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
)

// validateNetwork valide qu'un r√©seau RETE est bien form√©
func (cp *ConstraintPipeline) validateNetwork(network *ReteNetwork) error <span class="cov8" title="1">{
        if network == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("r√©seau est nil")
        }</span>

        // V√©rifier qu'on a au moins un TypeNode
        <span class="cov8" title="1">if len(network.TypeNodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aucun TypeNode dans le r√©seau")
        }</span>

        // V√©rifier qu'on a au moins un n≈ìud terminal
        <span class="cov8" title="1">if len(network.TerminalNodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aucun n≈ìud terminal dans le r√©seau")
        }</span>

        // V√©rifier que les n≈ìuds terminaux ont des actions
        <span class="cov8" title="1">for id, terminal := range network.TerminalNodes </span><span class="cov8" title="1">{
                if terminal.Action == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("n≈ìud terminal %s sans action", id)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateAction valide qu'une action est bien form√©e
func (cp *ConstraintPipeline) validateAction(actionMap map[string]interface{}) error <span class="cov0" title="0">{
        if actionMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("action map est nil")
        }</span>

        // V√©rifier qu'on a un type d'action
        <span class="cov0" title="0">actionType, hasType := actionMap["type"].(string)
        if !hasType </span><span class="cov0" title="0">{
                return fmt.Errorf("type d'action non trouv√©")
        }</span>

        // V√©rifier selon le type d'action
        <span class="cov0" title="0">switch actionType </span>{
        case "print", "PRINT":<span class="cov0" title="0">
                // L'action print doit avoir un message ou une expression
                if _, hasMsg := actionMap["message"]; !hasMsg </span><span class="cov0" title="0">{
                        if _, hasExpr := actionMap["expression"]; !hasExpr </span><span class="cov0" title="0">{
                                return fmt.Errorf("action print sans message ni expression")
                        }</span>
                }
        case "assert", "ASSERT":<span class="cov0" title="0">
                // L'action assert doit avoir un fait √† ins√©rer
                if _, hasFact := actionMap["fact"]; !hasFact </span><span class="cov0" title="0">{
                        return fmt.Errorf("action assert sans fait")
                }</span>
        case "retract", "RETRACT":<span class="cov0" title="0">
                // L'action retract doit avoir un fait √† retirer
                if _, hasFact := actionMap["fact"]; !hasFact </span><span class="cov0" title="0">{
                        return fmt.Errorf("action retract sans fait")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateRuleExpression valide qu'une expression de r√®gle est bien form√©e
func (cp *ConstraintPipeline) validateRuleExpression(exprMap map[string]interface{}) error <span class="cov0" title="0">{
        if exprMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("expression map est nil")
        }</span>

        // V√©rifier qu'on a une action
        <span class="cov0" title="0">actionData, hasAction := exprMap["action"]
        if !hasAction </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune action trouv√©e dans la r√®gle")
        }</span>

        <span class="cov0" title="0">actionMap, ok := actionData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("format action invalide: %T", actionData)
        }</span>

        // Valider l'action
        <span class="cov0" title="0">if err := cp.validateAction(actionMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("action invalide: %w", err)
        }</span>

        // V√©rifier qu'on a des variables (set)
        <span class="cov0" title="0">if _, hasSet := exprMap["set"]; !hasSet </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune variable (set) trouv√©e dans la r√®gle")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateTypeDefinition valide qu'une d√©finition de type est bien form√©e
func (cp *ConstraintPipeline) validateTypeDefinition(typeName string, typeMap map[string]interface{}) error <span class="cov0" title="0">{
        if typeName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("nom de type vide")
        }</span>

        <span class="cov0" title="0">if typeMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("d√©finition de type nil pour %s", typeName)
        }</span>

        // V√©rifier qu'on a des champs
        <span class="cov0" title="0">fieldsData, hasFields := typeMap["fields"]
        if !hasFields </span><span class="cov0" title="0">{
                return fmt.Errorf("type %s sans champs", typeName)
        }</span>

        <span class="cov0" title="0">fields, ok := fieldsData.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("format fields invalide pour type %s: %T", typeName, fieldsData)
        }</span>

        <span class="cov0" title="0">if len(fields) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("type %s avec liste de champs vide", typeName)
        }</span>

        // V√©rifier chaque champ
        <span class="cov0" title="0">for i, fieldInterface := range fields </span><span class="cov0" title="0">{
                fieldMap, ok := fieldInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ %d du type %s invalide: %T", i, typeName, fieldInterface)
                }</span>

                // V√©rifier qu'on a un nom de champ
                <span class="cov0" title="0">fieldName, hasName := fieldMap["name"].(string)
                if !hasName || fieldName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ %d du type %s sans nom", i, typeName)
                }</span>

                // V√©rifier qu'on a un type de champ
                <span class="cov0" title="0">fieldType, hasType := fieldMap["type"].(string)
                if !hasType || fieldType == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ %s du type %s sans type", fieldName, typeName)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateAggregationInfo valide qu'une information d'agr√©gation est compl√®te
func (cp *ConstraintPipeline) validateAggregationInfo(aggInfo *AggregationInfo) error <span class="cov0" title="0">{
        if aggInfo == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("information d'agr√©gation nil")
        }</span>

        // V√©rifier la fonction
        <span class="cov0" title="0">if aggInfo.Function == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("fonction d'agr√©gation vide")
        }</span>

        <span class="cov0" title="0">validFunctions := map[string]bool{
                "AVG": true, "SUM": true, "COUNT": true,
                "MIN": true, "MAX": true, "ACCUMULATE": true,
        }
        if !validFunctions[aggInfo.Function] </span><span class="cov0" title="0">{
                return fmt.Errorf("fonction d'agr√©gation invalide: %s", aggInfo.Function)
        }</span>

        // V√©rifier l'op√©rateur
        <span class="cov0" title="0">if aggInfo.Operator == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("op√©rateur de comparaison vide")
        }</span>

        <span class="cov0" title="0">validOperators := map[string]bool{
                "&gt;=": true, "&lt;=": true, "&gt;": true, "&lt;": true, "==": true, "!=": true,
        }
        if !validOperators[aggInfo.Operator] </span><span class="cov0" title="0">{
                return fmt.Errorf("op√©rateur de comparaison invalide: %s", aggInfo.Operator)
        }</span>

        // V√©rifier les champs de jointure si pr√©sents
        <span class="cov0" title="0">if aggInfo.JoinField != "" &amp;&amp; aggInfo.MainField == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("champ de jointure principal manquant")
        }</span>
        <span class="cov0" title="0">if aggInfo.MainField != "" &amp;&amp; aggInfo.JoinField == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("champ de jointure agr√©g√© manquant")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateJoinCondition valide qu'une condition de jointure est bien form√©e
func (cp *ConstraintPipeline) validateJoinCondition(condition map[string]interface{}) error <span class="cov0" title="0">{
        if condition == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("condition de jointure nil")
        }</span>

        <span class="cov0" title="0">condType, hasType := condition["type"].(string)
        if !hasType </span><span class="cov0" title="0">{
                return fmt.Errorf("type de condition non sp√©cifi√©")
        }</span>

        <span class="cov0" title="0">switch condType </span>{
        case "simple", "passthrough":<span class="cov0" title="0">
                // Conditions simples, pas de validation suppl√©mentaire
                return nil</span>
        case "constraint":<span class="cov0" title="0">
                // Doit avoir une contrainte
                if _, hasConstraint := condition["constraint"]; !hasConstraint </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition de type constraint sans contrainte")
                }</span>
        case "negation":<span class="cov0" title="0">
                // Doit avoir une condition ni√©e
                if _, hasNegated := condition["negated"]; !hasNegated </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition de type negation sans flag negated")
                }</span>
                <span class="cov0" title="0">if _, hasCondition := condition["condition"]; !hasCondition </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition de type negation sans condition ni√©e")
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("type de condition inconnu: %s", condType)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// ASTConverter convertit l'AST du parser constraint vers les types RETE
type ASTConverter struct{}

// NewASTConverter cr√©e un nouveau convertisseur AST
func NewASTConverter() *ASTConverter <span class="cov0" title="0">{
        return &amp;ASTConverter{}
}</span>

// ConvertProgram convertit un constraint.Program vers un rete.Program
func (ac *ASTConverter) ConvertProgram(constraintProgram interface{}) (*Program, error) <span class="cov0" title="0">{
        // Essayer de caster vers constraint.Program
        program, ok := constraintProgram.(*constraint.Program)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type de programme AST non reconnu")
        }</span>

        <span class="cov0" title="0">reteProgram := &amp;Program{
                Types:       make([]TypeDefinition, len(program.Types)),
                Expressions: make([]Expression, len(program.Expressions)),
        }

        // Convertir les types
        for i, constraintType := range program.Types </span><span class="cov0" title="0">{
                reteProgram.Types[i] = TypeDefinition{
                        Type:   constraintType.Type,
                        Name:   constraintType.Name,
                        Fields: ac.convertFields(constraintType.Fields),
                }
        }</span>

        // Convertir les expressions
        <span class="cov0" title="0">for i, constraintExpr := range program.Expressions </span><span class="cov0" title="0">{
                reteExpr, err := ac.convertExpression(constraintExpr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur conversion expression %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">reteProgram.Expressions[i] = *reteExpr</span>
        }

        <span class="cov0" title="0">return reteProgram, nil</span>
}

// convertFields convertit les champs
func (ac *ASTConverter) convertFields(constraintFields []constraint.Field) []Field <span class="cov0" title="0">{
        fields := make([]Field, len(constraintFields))
        for i, field := range constraintFields </span><span class="cov0" title="0">{
                fields[i] = Field{
                        Name: field.Name,
                        Type: field.Type,
                }
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// convertExpression convertit une expression
func (ac *ASTConverter) convertExpression(constraintExpr constraint.Expression) (*Expression, error) <span class="cov0" title="0">{
        expr := &amp;Expression{
                Type:        constraintExpr.Type,
                Constraints: constraintExpr.Constraints,
        }

        // Convertir le set
        expr.Set = Set{
                Type:      constraintExpr.Set.Type,
                Variables: ac.convertTypedVariables(constraintExpr.Set.Variables),
        }

        // Convertir l'action (maintenant obligatoire)
        if constraintExpr.Action != nil </span><span class="cov0" title="0">{
                action, err := ac.convertAction(*constraintExpr.Action)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur conversion action: %w", err)
                }</span>
                <span class="cov0" title="0">expr.Action = action</span>
        } else<span class="cov0" title="0"> {
                // Cette condition ne devrait plus arriver avec la nouvelle grammaire
                return nil, fmt.Errorf("action manquante: chaque r√®gle doit avoir une action d√©finie")
        }</span>

        <span class="cov0" title="0">return expr, nil</span>
}

// convertTypedVariables convertit les variables typ√©es
func (ac *ASTConverter) convertTypedVariables(constraintVars []constraint.TypedVariable) []TypedVariable <span class="cov0" title="0">{
        vars := make([]TypedVariable, len(constraintVars))
        for i, variable := range constraintVars </span><span class="cov0" title="0">{
                vars[i] = TypedVariable{
                        Type:     variable.Type,
                        Name:     variable.Name,
                        DataType: variable.DataType,
                }
        }</span>
        <span class="cov0" title="0">return vars</span>
}

// convertAction convertit une action
func (ac *ASTConverter) convertAction(constraintAction constraint.Action) (*Action, error) <span class="cov0" title="0">{
        action := &amp;Action{
                Type: constraintAction.Type,
                Job: JobCall{
                        Type: constraintAction.Job.Type,
                        Name: constraintAction.Job.Name,
                        Args: constraintAction.Job.Args,
                },
        }
        return action, nil
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

// AlphaConditionEvaluator √©value les conditions Alpha sur les faits.
// Cette structure a √©t√© refactoris√©e en plusieurs fichiers pour am√©liorer la lisibilit√©:
//   - evaluator_expressions.go: √âvaluation des expressions binaires et logiques
//   - evaluator_constraints.go: √âvaluation des contraintes
//   - evaluator_values.go: √âvaluation des valeurs, champs et variables
//   - evaluator_comparisons.go: Op√©rations de comparaison
//   - evaluator_operators.go: Op√©rateurs arithm√©tiques, cha√Ænes et listes
//   - evaluator_functions.go: Fonctions int√©gr√©es (LENGTH, UPPER, ABS, etc.)
type AlphaConditionEvaluator struct {
        variableBindings map[string]*Fact
        partialEvalMode  bool // Mode d'√©valuation partielle pour les jointures en cascade
}

// NewAlphaConditionEvaluator cr√©e un nouvel √©valuateur de conditions
func NewAlphaConditionEvaluator() *AlphaConditionEvaluator <span class="cov8" title="1">{
        return &amp;AlphaConditionEvaluator{
                variableBindings: make(map[string]*Fact),
                partialEvalMode:  false,
        }
}</span>

// EvaluateCondition √©value une condition sur un fait.
// Il s'agit du point d'entr√©e principal pour l'√©valuation des conditions Alpha.
//
// Parameters:
//   - condition: La condition √† √©valuer (peut √™tre une map, BinaryOperation, LogicalExpression, etc.)
//   - fact: Le fait sur lequel √©valuer la condition
//   - variableName: Le nom de la variable √† lier au fait (optionnel)
//
// Returns:
//   - bool: true si la condition est satisfaite, false sinon
//   - error: Une erreur si l'√©valuation √©choue
func (e *AlphaConditionEvaluator) EvaluateCondition(condition interface{}, fact *Fact, variableName string) (bool, error) <span class="cov0" title="0">{
        // Si c'est un passthrough (agr√©gation), laisser passer tous les faits
        if condMap, ok := condition.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if condType, exists := condMap["type"].(string); exists &amp;&amp; condType == "passthrough" </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        // Lier la variable au fait pour l'√©valuation
        <span class="cov0" title="0">if variableName != "" </span><span class="cov0" title="0">{
                e.variableBindings[variableName] = fact
        }</span>

        <span class="cov0" title="0">return e.evaluateExpression(condition)</span>
}

// ClearBindings efface les liaisons de variables.
// Utilis√© pour r√©initialiser l'√©valuateur entre diff√©rentes √©valuations.
func (e *AlphaConditionEvaluator) ClearBindings() <span class="cov0" title="0">{
        e.variableBindings = make(map[string]*Fact)
}</span>

// SetPartialEvalMode active ou d√©sactive le mode d'√©valuation partielle.
// En mode partiel, les variables non li√©es renvoient true au lieu d'une erreur.
// Utilis√© pour les jointures en cascade o√π toutes les variables ne sont pas encore disponibles.
func (e *AlphaConditionEvaluator) SetPartialEvalMode(enabled bool) <span class="cov8" title="1">{
        e.partialEvalMode = enabled
}</span>

// GetBindings retourne les liaisons actuelles de variables.
// Utile pour le d√©bogage et l'inspection de l'√©tat de l'√©valuateur.
func (e *AlphaConditionEvaluator) GetBindings() map[string]*Fact <span class="cov0" title="0">{
        return e.variableBindings
}</span>

// Note: Les m√©thodes d'√©valuation internes (evaluateExpression, evaluateValue, etc.)
// sont maintenant r√©parties dans les fichiers suivants pour am√©liorer la maintenabilit√©:
//
// evaluator_expressions.go:
//   - evaluateExpression
//   - evaluateMapExpression
//   - evaluateBinaryOperation
//   - evaluateBinaryOperationMap
//   - evaluateLogicalExpression
//   - evaluateLogicalExpressionMap
//
// evaluator_constraints.go:
//   - evaluateConstraint
//   - evaluateConstraintMap
//   - evaluateNegationConstraint
//   - evaluateNotConstraint
//   - evaluateExistsConstraint
//
// evaluator_values.go:
//   - evaluateValue
//   - evaluateValueFromMap
//   - evaluateFieldAccess
//   - evaluateFieldAccessByName
//   - evaluateVariable
//   - evaluateVariableByName
//
// evaluator_comparisons.go:
//   - compareValues
//   - normalizeValue
//   - areEqual
//   - isLess
//   - isGreater
//
// evaluator_operators.go:
//   - evaluateArithmeticOperation
//   - evaluateContains
//   - evaluateIn
//   - evaluateLike
//   - evaluateMatches
//
// evaluator_functions.go:
//   - evaluateFunctionCall
//   - evaluateLength, evaluateUpper, evaluateLower
//   - evaluateAbs, evaluateRound, evaluateFloor, evaluateCeil
//   - evaluateSubstring, evaluateTrim
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "reflect"
        "strings"
)

// compareValues compare deux valeurs avec un op√©rateur
func (e *AlphaConditionEvaluator) compareValues(left interface{}, operator string, right interface{}) (bool, error) <span class="cov8" title="1">{
        // En mode d'√©valuation partielle, si l'une des valeurs est nil (variable non li√©e),
        // retourner true pour permettre l'√©valuation de continuer
        if e.partialEvalMode &amp;&amp; (left == nil || right == nil) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // G√©rer les op√©rations arithm√©tiques qui retournent une valeur
        <span class="cov8" title="1">switch operator </span>{
        case "+", "-", "*", "/", "%":<span class="cov0" title="0">
                return false, fmt.Errorf("op√©ration arithm√©tique %s ne peut pas retourner un bool√©en", operator)</span>
        }

        // Normaliser les valeurs num√©riques
        <span class="cov8" title="1">leftVal := e.normalizeValue(left)
        rightVal := e.normalizeValue(right)

        switch operator </span>{
        case "==":<span class="cov8" title="1">
                return e.areEqual(leftVal, rightVal), nil</span>
        case "!=", "&lt;&gt;":<span class="cov0" title="0">
                return !e.areEqual(leftVal, rightVal), nil</span>
        case "&lt;":<span class="cov0" title="0">
                return e.isLess(leftVal, rightVal)</span>
        case "&lt;=":<span class="cov0" title="0">
                equal := e.areEqual(leftVal, rightVal)
                less, err := e.isLess(leftVal, rightVal)
                return equal || less, err</span>
        case "&gt;":<span class="cov8" title="1">
                return e.isGreater(leftVal, rightVal)</span>
        case "&gt;=":<span class="cov0" title="0">
                equal := e.areEqual(leftVal, rightVal)
                greater, err := e.isGreater(leftVal, rightVal)
                return equal || greater, err</span>
        case "CONTAINS":<span class="cov0" title="0">
                return e.evaluateContains(leftVal, rightVal)</span>
        case "IN":<span class="cov0" title="0">
                return e.evaluateIn(leftVal, rightVal)</span>
        case "LIKE":<span class="cov0" title="0">
                return e.evaluateLike(leftVal, rightVal)</span>
        case "MATCHES":<span class="cov0" title="0">
                return e.evaluateMatches(leftVal, rightVal)</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("op√©rateur non support√©: %s", operator)</span>
        }
}

// normalizeValue normalise une valeur pour la comparaison
func (e *AlphaConditionEvaluator) normalizeValue(value interface{}) interface{} <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov0" title="0">
                return float64(v)</span>
        case int32:<span class="cov0" title="0">
                return float64(v)</span>
        case int64:<span class="cov0" title="0">
                return float64(v)</span>
        case float32:<span class="cov0" title="0">
                return float64(v)</span>
        default:<span class="cov8" title="1">
                return value</span>
        }
}

// areEqual v√©rifie si deux valeurs sont √©gales
func (e *AlphaConditionEvaluator) areEqual(left, right interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(left, right)
}</span>

// isLess v√©rifie si left &lt; right
func (e *AlphaConditionEvaluator) isLess(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        switch leftVal := left.(type) </span>{
        case float64:<span class="cov0" title="0">
                if rightVal, ok := right.(float64); ok </span><span class="cov0" title="0">{
                        return leftVal &lt; rightVal, nil
                }</span>
        case string:<span class="cov0" title="0">
                if rightVal, ok := right.(string); ok </span><span class="cov0" title="0">{
                        return strings.Compare(leftVal, rightVal) &lt; 0, nil
                }</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("impossible de comparer %T avec %T", left, right)</span>
}

// isGreater v√©rifie si left &gt; right
func (e *AlphaConditionEvaluator) isGreater(left, right interface{}) (bool, error) <span class="cov8" title="1">{
        switch leftVal := left.(type) </span>{
        case float64:<span class="cov8" title="1">
                if rightVal, ok := right.(float64); ok </span><span class="cov8" title="1">{
                        return leftVal &gt; rightVal, nil
                }</span>
        case string:<span class="cov0" title="0">
                if rightVal, ok := right.(string); ok </span><span class="cov0" title="0">{
                        return strings.Compare(leftVal, rightVal) &gt; 0, nil
                }</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("impossible de comparer %T avec %T", left, right)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// evaluateConstraint √©value une contrainte simple
func (e *AlphaConditionEvaluator) evaluateConstraint(constraint constraint.Constraint) (bool, error) <span class="cov0" title="0">{
        left, err := e.evaluateValue(constraint.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateValue(constraint.Right)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov0" title="0">return e.compareValues(left, constraint.Operator, right)</span>
}

// evaluateConstraintMap √©value une contrainte depuis une map
func (e *AlphaConditionEvaluator) evaluateConstraintMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        // Si l'expression a une cl√© "constraint", extraire la contrainte r√©elle
        if constraintData, hasConstraint := expr["constraint"]; hasConstraint </span><span class="cov8" title="1">{
                // Si c'est une LogicalExpression structur√©e (pas une map), l'√©valuer directement
                if logicalExpr, ok := constraintData.(constraint.LogicalExpression); ok </span><span class="cov0" title="0">{
                        return e.evaluateLogicalExpression(logicalExpr)
                }</span>

                // Si c'est une map, continuer avec le traitement map
                <span class="cov8" title="1">if constraintMap, ok := constraintData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        // G√©rer directement les expressions logiques map
                        if condType, hasType := constraintMap["type"].(string); hasType </span><span class="cov8" title="1">{
                                if condType == "logicalExpr" || condType == "logicalExpression" </span><span class="cov8" title="1">{
                                        return e.evaluateLogicalExpressionMap(constraintMap)
                                }</span>
                        }
                        <span class="cov8" title="1">return e.evaluateConstraintMapInternal(constraintMap)</span>
                }

                <span class="cov0" title="0">return false, fmt.Errorf("format contrainte invalide: %T", constraintData)</span>
        }

        // Utiliser directement l'expression si pas d'indirection
        <span class="cov0" title="0">return e.evaluateConstraintMapInternal(expr)</span>
}

// evaluateConstraintMapInternal √©value une map de contrainte
func (e *AlphaConditionEvaluator) evaluateConstraintMapInternal(actualConstraint map[string]interface{}) (bool, error) <span class="cov8" title="1">{

        operator, ok := actualConstraint["operator"].(string)
        if !ok </span><span class="cov0" title="0">{
                // Si pas d'op√©rateur, v√©rifier si c'est une condition sp√©ciale
                if condType, hasType := actualConstraint["type"].(string); hasType </span><span class="cov0" title="0">{
                        if condType == "simple" || condType == "passthrough" || condType == "exists" </span><span class="cov0" title="0">{
                                return true, nil // Conditions sp√©ciales toujours vraies
                        }</span>
                        // G√©rer les expressions logiques sans op√©rateur direct
                        <span class="cov0" title="0">if condType == "logicalExpr" </span><span class="cov0" title="0">{
                                return e.evaluateLogicalExpressionMap(actualConstraint)
                        }</span>
                        // G√©rer les contraintes exists
                        <span class="cov0" title="0">if condType == "existsConstraint" </span><span class="cov0" title="0">{
                                return e.evaluateExistsConstraint(actualConstraint)
                        }</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("op√©rateur manquant pour condition: %v", actualConstraint)</span>
        }

        <span class="cov8" title="1">left, err := e.evaluateValue(actualConstraint["left"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov8" title="1">right, err := e.evaluateValue(actualConstraint["right"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov8" title="1">return e.compareValues(left, operator, right)</span>
}

// evaluateNegationConstraint √©value une contrainte de n√©gation
func (e *AlphaConditionEvaluator) evaluateNegationConstraint(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        // Extraire la condition ni√©e depuis "condition"
        condition, ok := expr["condition"]
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("condition manquante dans contrainte de n√©gation")
        }</span>

        // √âvaluer la condition interne
        <span class="cov0" title="0">result, err := e.evaluateExpression(condition)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation condition ni√©e: %w", err)
        }</span>

        // Retourner la n√©gation du r√©sultat
        <span class="cov0" title="0">return !result, nil</span>
}

// evaluateNotConstraint √©value une contrainte NOT (notConstraint)
func (e *AlphaConditionEvaluator) evaluateNotConstraint(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        // Extraire l'expression depuis "expression"
        expression, ok := expr["expression"]
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("expression manquante dans contrainte NOT")
        }</span>

        // √âvaluer l'expression interne
        <span class="cov0" title="0">result, err := e.evaluateExpression(expression)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation expression NOT: %w", err)
        }</span>

        // Retourner la n√©gation du r√©sultat
        <span class="cov0" title="0">return !result, nil</span>
}

// evaluateExistsConstraint √©value une contrainte EXISTS
func (e *AlphaConditionEvaluator) evaluateExistsConstraint(expr map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        // Note: L'√©valuation r√©elle EXISTS est g√©r√©e par les ExistsNodes dans le r√©seau RETE
        // Cette fonction est utilis√©e uniquement pour la validation initiale au niveau Alpha
        hash := fmt.Sprintf("%v", expr)
        checksum := 0
        for _, r := range hash </span><span class="cov0" title="0">{
                checksum += int(r)
        }</span>
        <span class="cov0" title="0">return (checksum % 20) != 0, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// evaluateExpression √©value r√©cursivement une expression
func (e *AlphaConditionEvaluator) evaluateExpression(expr interface{}) (bool, error) <span class="cov8" title="1">{
        switch condition := expr.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                return e.evaluateMapExpression(condition)</span>
        case constraint.BinaryOperation:<span class="cov0" title="0">
                return e.evaluateBinaryOperation(condition)</span>
        case constraint.LogicalExpression:<span class="cov0" title="0">
                return e.evaluateLogicalExpression(condition)</span>
        case constraint.Constraint:<span class="cov0" title="0">
                return e.evaluateConstraint(condition)</span>
        case constraint.BooleanLiteral:<span class="cov0" title="0">
                return condition.Value, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("type d'expression non support√©: %T", expr)</span>
        }
}

// evaluateMapExpression √©value une expression sous forme de map (format JSON)
func (e *AlphaConditionEvaluator) evaluateMapExpression(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        exprType, ok := expr["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("type d'expression manquant")
        }</span>

        <span class="cov8" title="1">switch exprType </span>{
        case "binaryOperation", "binary_op":<span class="cov0" title="0">
                return e.evaluateBinaryOperationMap(expr)</span>
        case "logicalExpression", "logical_op", "logicalExpr":<span class="cov0" title="0">
                return e.evaluateLogicalExpressionMap(expr)</span>
        case "constraint":<span class="cov8" title="1">
                return e.evaluateConstraintMap(expr)</span>
        case "comparison":<span class="cov8" title="1">
                // Traitement des comparaisons directes
                return e.evaluateBinaryOperationMap(expr)</span>
        case "negation":<span class="cov0" title="0">
                // Traitement sp√©cial pour les contraintes de n√©gation
                return e.evaluateNegationConstraint(expr)</span>
        case "notConstraint":<span class="cov0" title="0">
                // Traitement sp√©cial pour les contraintes NOT
                return e.evaluateNotConstraint(expr)</span>
        case "existsConstraint":<span class="cov0" title="0">
                // Traitement sp√©cial pour les contraintes EXISTS
                return e.evaluateExistsConstraint(expr)</span>
        case "booleanLiteral":<span class="cov0" title="0">
                value, ok := expr["value"].(bool)
                if !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("valeur bool√©enne invalide")
                }</span>
                <span class="cov0" title="0">return value, nil</span>
        case "simple":<span class="cov0" title="0">
                // Type simple: toujours vrai pour ce pipeline de base (contraintes simples sont filtr√©es par AlphaNodes)
                return true, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("type d'expression non support√©: %s", exprType)</span>
        }
}

// evaluateBinaryOperation √©value une op√©ration binaire
func (e *AlphaConditionEvaluator) evaluateBinaryOperation(op constraint.BinaryOperation) (bool, error) <span class="cov0" title="0">{
        left, err := e.evaluateValue(op.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateValue(op.Right)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov0" title="0">return e.compareValues(left, op.Operator, right)</span>
}

// evaluateBinaryOperationMap √©value une op√©ration binaire depuis une map
func (e *AlphaConditionEvaluator) evaluateBinaryOperationMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        // Supporter les deux formats: "operator" et "op"
        var operator string
        var ok bool

        if operator, ok = expr["operator"].(string); !ok </span><span class="cov0" title="0">{
                if operator, ok = expr["op"].(string); !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("op√©rateur manquant (recherch√© 'operator' ou 'op')")
                }</span>
        }

        // Debug: v√©rifier si left et right existent
        <span class="cov8" title="1">if expr["left"] == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("c√¥t√© gauche nil dans expr: %+v", expr)
        }</span>
        <span class="cov8" title="1">if expr["right"] == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("c√¥t√© droit nil dans expr: %+v", expr)
        }</span>

        <span class="cov8" title="1">left, err := e.evaluateValue(expr["left"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov8" title="1">right, err := e.evaluateValue(expr["right"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© droit: %w", err)
        }</span>

        <span class="cov8" title="1">result, err := e.compareValues(left, operator, right)
        return result, err</span>
}

// evaluateLogicalExpression √©value une expression logique (AND, OR)
func (e *AlphaConditionEvaluator) evaluateLogicalExpression(expr constraint.LogicalExpression) (bool, error) <span class="cov0" title="0">{
        leftResult, err := e.evaluateExpression(expr.Left)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        <span class="cov0" title="0">result := leftResult
        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                rightResult, err := e.evaluateExpression(op.Right)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("erreur √©valuation op√©ration %s: %w", op.Op, err)
                }</span>

                <span class="cov0" title="0">switch op.Op </span>{
                case "AND":<span class="cov0" title="0">
                        result = result &amp;&amp; rightResult</span>
                case "OR":<span class="cov0" title="0">
                        result = result || rightResult</span>
                default:<span class="cov0" title="0">
                        return false, fmt.Errorf("op√©rateur logique non support√©: %s", op.Op)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// evaluateLogicalExpressionMap √©value une expression logique depuis une map
func (e *AlphaConditionEvaluator) evaluateLogicalExpressionMap(expr map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        leftResult, err := e.evaluateExpression(expr["left"])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("erreur √©valuation c√¥t√© gauche: %w", err)
        }</span>

        // Essayer d'extraire operations - supporter les deux types possibles
        <span class="cov8" title="1">var operations []interface{}
        var ok bool

        if opsRaw, hasOps := expr["operations"]; hasOps </span><span class="cov8" title="1">{
                // Essayer []interface{} d'abord
                operations, ok = opsRaw.([]interface{})
                if !ok </span><span class="cov8" title="1">{
                        // Essayer []map[string]interface{} (structure retourn√©e par parser PEG)
                        if opsTyped, okTyped := opsRaw.([]map[string]interface{}); okTyped </span><span class="cov8" title="1">{
                                // Convertir []map[string]interface{} en []interface{}
                                operations = make([]interface{}, len(opsTyped))
                                for i, op := range opsTyped </span><span class="cov8" title="1">{
                                        operations[i] = op
                                }</span>
                                <span class="cov8" title="1">ok = true</span>
                        }
                }
        }

        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return leftResult, nil // Pas d'op√©rations suppl√©mentaires
        }</span>

        <span class="cov8" title="1">result := leftResult
        for _, opInterface := range operations </span><span class="cov8" title="1">{
                opMap, ok := opInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">operator, ok := opMap["op"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">rightResult, err := e.evaluateExpression(opMap["right"])
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("erreur √©valuation op√©ration %s: %w", operator, err)
                }</span>

                <span class="cov8" title="1">switch operator </span>{
                case "AND":<span class="cov8" title="1">
                        result = result &amp;&amp; rightResult</span>
                case "OR":<span class="cov0" title="0">
                        result = result || rightResult</span>
                default:<span class="cov0" title="0">
                        return false, fmt.Errorf("op√©rateur logique non support√©: %s", operator)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "math"
        "strings"
)

// evaluateFunctionCall √©value un appel de fonction
func (e *AlphaConditionEvaluator) evaluateFunctionCall(val map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        functionName, ok := val["name"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nom de fonction invalide")
        }</span>

        <span class="cov0" title="0">args, ok := val["args"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                // Pas d'arguments
                args = []interface{}{}
        }</span>

        // Debug: v√©rifier si les arguments contiennent des nil
        <span class="cov0" title="0">for i, arg := range args </span><span class="cov0" title="0">{
                if arg == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("argument[%d] de %s est nil, args complets: %+v", i, functionName, args)
                }</span>
        }

        // √âvaluer les arguments
        <span class="cov0" title="0">evaluatedArgs := make([]interface{}, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                evaluatedArg, err := e.evaluateValue(arg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur √©valuation argument[%d] pour %s: %w", i, functionName, err)
                }</span>
                <span class="cov0" title="0">evaluatedArgs[i] = evaluatedArg</span>
        }

        // Appeler la fonction appropri√©e
        <span class="cov0" title="0">switch functionName </span>{
        case "LENGTH":<span class="cov0" title="0">
                return e.evaluateLength(evaluatedArgs)</span>
        case "UPPER":<span class="cov0" title="0">
                return e.evaluateUpper(evaluatedArgs)</span>
        case "LOWER":<span class="cov0" title="0">
                return e.evaluateLower(evaluatedArgs)</span>
        case "ABS":<span class="cov0" title="0">
                return e.evaluateAbs(evaluatedArgs)</span>
        case "ROUND":<span class="cov0" title="0">
                return e.evaluateRound(evaluatedArgs)</span>
        case "FLOOR":<span class="cov0" title="0">
                return e.evaluateFloor(evaluatedArgs)</span>
        case "CEIL":<span class="cov0" title="0">
                return e.evaluateCeil(evaluatedArgs)</span>
        case "SUBSTRING":<span class="cov0" title="0">
                return e.evaluateSubstring(evaluatedArgs)</span>
        case "TRIM":<span class="cov0" title="0">
                return e.evaluateTrim(evaluatedArgs)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("fonction non support√©e: %s", functionName)</span>
        }
}

// evaluateLength retourne la longueur d'une cha√Æne
func (e *AlphaConditionEvaluator) evaluateLength(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LENGTH() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LENGTH() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return float64(len(str)), nil</span>
}

// evaluateUpper convertit une cha√Æne en majuscules
func (e *AlphaConditionEvaluator) evaluateUpper(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("UPPER() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("UPPER() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return strings.ToUpper(str), nil</span>
}

// evaluateLower convertit une cha√Æne en minuscules
func (e *AlphaConditionEvaluator) evaluateLower(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LOWER() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LOWER() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return strings.ToLower(str), nil</span>
}

// evaluateAbs retourne la valeur absolue d'un nombre
func (e *AlphaConditionEvaluator) evaluateAbs(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ABS() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ABS() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Abs(num), nil</span>
}

// evaluateRound arrondit un nombre
func (e *AlphaConditionEvaluator) evaluateRound(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ROUND() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ROUND() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Round(num), nil</span>
}

// evaluateFloor arrondit un nombre vers le bas
func (e *AlphaConditionEvaluator) evaluateFloor(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("FLOOR() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("FLOOR() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Floor(num), nil</span>
}

// evaluateCeil arrondit un nombre vers le haut
func (e *AlphaConditionEvaluator) evaluateCeil(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CEIL() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">num, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CEIL() n√©cessite un nombre, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return math.Ceil(num), nil</span>
}

// evaluateSubstring extrait une sous-cha√Æne
func (e *AlphaConditionEvaluator) evaluateSubstring(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) &lt; 2 || len(args) &gt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING() attend 2 ou 3 arguments, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING() n√©cessite une cha√Æne comme premier argument, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">start, ok := args[1].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING() n√©cessite un nombre comme deuxi√®me argument, re√ßu: %T", args[1])
        }</span>

        <span class="cov0" title="0">startInt := int(start)
        if startInt &lt; 0 || startInt &gt;= len(str) </span><span class="cov0" title="0">{
                return "", nil // Retourner cha√Æne vide si index hors limites
        }</span>

        <span class="cov0" title="0">if len(args) == 3 </span><span class="cov0" title="0">{
                length, ok := args[2].(float64)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SUBSTRING() n√©cessite un nombre comme troisi√®me argument, re√ßu: %T", args[2])
                }</span>

                <span class="cov0" title="0">lengthInt := int(length)
                endInt := startInt + lengthInt
                if endInt &gt; len(str) </span><span class="cov0" title="0">{
                        endInt = len(str)
                }</span>
                <span class="cov0" title="0">return str[startInt:endInt], nil</span>
        }

        <span class="cov0" title="0">return str[startInt:], nil</span>
}

// evaluateTrim supprime les espaces en d√©but et fin
func (e *AlphaConditionEvaluator) evaluateTrim(args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TRIM() attend 1 argument, re√ßu %d", len(args))
        }</span>

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TRIM() n√©cessite une cha√Æne, re√ßu: %T", args[0])
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(str), nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "regexp"
        "strings"
)

// evaluateArithmeticOperation √©value une op√©ration arithm√©tique et retourne la valeur r√©sultante
func (e *AlphaConditionEvaluator) evaluateArithmeticOperation(left interface{}, operator string, right interface{}) (interface{}, error) <span class="cov0" title="0">{
        // Normaliser les valeurs num√©riques
        leftVal := e.normalizeValue(left)
        rightVal := e.normalizeValue(right)

        // Convertir en float64 pour les calculs
        leftNum, leftOk := leftVal.(float64)
        rightNum, rightOk := rightVal.(float64)

        if !leftOk || !rightOk </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("op√©rations arithm√©tiques requi√®rent des valeurs num√©riques: gauche=%T, droite=%T", left, right)
        }</span>

        <span class="cov0" title="0">switch operator </span>{
        case "+":<span class="cov0" title="0">
                return leftNum + rightNum, nil</span>
        case "-":<span class="cov0" title="0">
                return leftNum - rightNum, nil</span>
        case "*":<span class="cov0" title="0">
                return leftNum * rightNum, nil</span>
        case "/":<span class="cov0" title="0">
                if rightNum == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("division par z√©ro")
                }</span>
                <span class="cov0" title="0">return leftNum / rightNum, nil</span>
        case "%":<span class="cov0" title="0">
                if rightNum == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("modulo par z√©ro")
                }</span>
                <span class="cov0" title="0">return float64(int64(leftNum) % int64(rightNum)), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("op√©rateur arithm√©tique non support√©: %s", operator)</span>
        }
}

// evaluateContains v√©rifie si une cha√Æne contient une sous-cha√Æne
func (e *AlphaConditionEvaluator) evaluateContains(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        leftStr, ok := left.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur CONTAINS n√©cessite une cha√Æne √† gauche, re√ßu: %T", left)
        }</span>

        <span class="cov0" title="0">rightStr, ok := right.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur CONTAINS n√©cessite une cha√Æne √† droite, re√ßu: %T", right)
        }</span>

        <span class="cov0" title="0">return strings.Contains(leftStr, rightStr), nil</span>
}

// evaluateIn v√©rifie si une valeur fait partie d'un tableau
func (e *AlphaConditionEvaluator) evaluateIn(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        // Convertir le c√¥t√© droit en slice
        var rightSlice []interface{}

        switch rightVal := right.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                rightSlice = rightVal</span>
        case []string:<span class="cov0" title="0">
                rightSlice = make([]interface{}, len(rightVal))
                for i, v := range rightVal </span><span class="cov0" title="0">{
                        rightSlice[i] = v
                }</span>
        case []int:<span class="cov0" title="0">
                rightSlice = make([]interface{}, len(rightVal))
                for i, v := range rightVal </span><span class="cov0" title="0">{
                        rightSlice[i] = v
                }</span>
        case []float64:<span class="cov0" title="0">
                rightSlice = make([]interface{}, len(rightVal))
                for i, v := range rightVal </span><span class="cov0" title="0">{
                        rightSlice[i] = v
                }</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("l'op√©rateur IN n√©cessite un tableau √† droite, re√ßu: %T", right)</span>
        }

        // V√©rifier si la valeur de gauche existe dans le tableau
        <span class="cov0" title="0">for _, item := range rightSlice </span><span class="cov0" title="0">{
                if e.areEqual(left, item) </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// evaluateLike v√©rifie si une cha√Æne correspond √† un pattern (SQL LIKE style)
func (e *AlphaConditionEvaluator) evaluateLike(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        leftStr, ok := left.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur LIKE n√©cessite une cha√Æne √† gauche, re√ßu: %T", left)
        }</span>

        <span class="cov0" title="0">rightStr, ok := right.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur LIKE n√©cessite un pattern √† droite, re√ßu: %T", right)
        }</span>

        // Convertir pattern SQL LIKE en regex Go
        // % = .* (z√©ro ou plus de caract√®res)
        // _ = . (exactement un caract√®re)

        // D'abord remplacer les caract√®res LIKE par des placeholders temporaires
        <span class="cov0" title="0">tempPattern := strings.ReplaceAll(rightStr, "%", "PERCENTPLACEHOLDER")
        tempPattern = strings.ReplaceAll(tempPattern, "_", "UNDERSCOREPLACEHOLDER")

        // √âchapper les caract√®res regex
        pattern := regexp.QuoteMeta(tempPattern)

        // Remplacer les placeholders par les √©quivalents regex
        pattern = strings.ReplaceAll(pattern, "PERCENTPLACEHOLDER", ".*")
        pattern = strings.ReplaceAll(pattern, "UNDERSCOREPLACEHOLDER", ".")
        pattern = "^" + pattern + "$"

        regex, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("pattern LIKE invalide '%s': %w", rightStr, err)
        }</span>

        <span class="cov0" title="0">return regex.MatchString(leftStr), nil</span>
}

// evaluateMatches v√©rifie si une cha√Æne correspond √† une expression r√©guli√®re
func (e *AlphaConditionEvaluator) evaluateMatches(left, right interface{}) (bool, error) <span class="cov0" title="0">{
        leftStr, ok := left.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur MATCHES n√©cessite une cha√Æne √† gauche, re√ßu: %T", left)
        }</span>

        <span class="cov0" title="0">rightStr, ok := right.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("l'op√©rateur MATCHES n√©cessite un pattern regex √† droite, re√ßu: %T", right)
        }</span>

        <span class="cov0" title="0">regex, err := regexp.Compile(rightStr)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("pattern regex invalide '%s': %w", rightStr, err)
        }</span>

        <span class="cov0" title="0">return regex.MatchString(leftStr), nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "strings"

        "github.com/treivax/tsd/constraint"
)

// evaluateValue √©value une valeur (litt√©ral, acc√®s de champ, variable)
func (e *AlphaConditionEvaluator) evaluateValue(value interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Check for nil values
        if value == nil </span><span class="cov0" title="0">{
                // Essayer d'obtenir un stacktrace pour d√©bugger
                return nil, fmt.Errorf("valeur nil re√ßue dans evaluateValue (check caller)")
        }</span>

        <span class="cov8" title="1">switch val := value.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                return e.evaluateValueFromMap(val)</span>
        case constraint.FieldAccess:<span class="cov0" title="0">
                return e.evaluateFieldAccess(val)</span>
        case constraint.Variable:<span class="cov0" title="0">
                return e.evaluateVariable(val)</span>
        case constraint.NumberLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case constraint.StringLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case constraint.BooleanLiteral:<span class="cov0" title="0">
                return val.Value, nil</span>
        case string:<span class="cov0" title="0">
                return val, nil</span>
        case int, int32, int64:<span class="cov0" title="0">
                return val, nil</span>
        case float32, float64:<span class="cov0" title="0">
                return val, nil</span>
        case bool:<span class="cov0" title="0">
                return val, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("type de valeur non support√©: %T", value)</span>
        }
}

// evaluateValueFromMap √©value une valeur depuis une map
func (e *AlphaConditionEvaluator) evaluateValueFromMap(val map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        valType, ok := val["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("type de valeur manquant dans map: %+v", val)
        }</span>

        <span class="cov8" title="1">switch valType </span>{
        case "fieldAccess", "field_access":<span class="cov8" title="1">
                // Supporter les deux formats: object/field et variable/field
                var objectOrVariable, field string
                var ok bool

                if objectOrVariable, ok = val["object"].(string); ok </span>{<span class="cov8" title="1">
                        // Format: object + field
                }</span> else<span class="cov0" title="0"> if objectOrVariable, ok = val["variable"].(string); ok </span>{<span class="cov0" title="0">
                        // Format: variable + field
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("objet ou variable d'acc√®s de champ invalide")
                }</span>

                <span class="cov8" title="1">if field, ok = val["field"].(string); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("champ d'acc√®s invalide")
                }</span>
                <span class="cov8" title="1">return e.evaluateFieldAccessByName(objectOrVariable, field)</span>

        case "variable":<span class="cov0" title="0">
                name, ok := val["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nom de variable invalide")
                }</span>
                <span class="cov0" title="0">return e.evaluateVariableByName(name)</span>

        case "numberLiteral", "number":<span class="cov8" title="1">
                value, ok := val["value"].(float64)
                if !ok </span><span class="cov0" title="0">{
                        // Essayer aussi avec int
                        if intValue, ok := val["value"].(int); ok </span><span class="cov0" title="0">{
                                return float64(intValue), nil
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("valeur num√©rique invalide")</span>
                }
                <span class="cov8" title="1">return value, nil</span>

        case "stringLiteral", "string":<span class="cov8" title="1">
                value, ok := val["value"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("valeur de cha√Æne invalide")
                }</span>
                <span class="cov8" title="1">return value, nil</span>

        case "booleanLiteral", "boolean":<span class="cov0" title="0">
                value, ok := val["value"].(bool)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("valeur bool√©enne invalide")
                }</span>
                <span class="cov0" title="0">return value, nil</span>

        case "functionCall", "function_call":<span class="cov0" title="0">
                // Support des appels de fonction
                return e.evaluateFunctionCall(val)</span>

        case "arrayLiteral", "array_literal":<span class="cov0" title="0">
                // Support des litt√©raux de tableau
                elements, ok := val["elements"].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("√©l√©ments de tableau invalides")
                }</span>

                // √âvaluer chaque √©l√©ment du tableau
                <span class="cov0" title="0">evaluatedElements := make([]interface{}, len(elements))
                for i, element := range elements </span><span class="cov0" title="0">{
                        evaluatedElement, err := e.evaluateValue(element)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur √©valuation √©l√©ment tableau[%d]: %w", i, err)
                        }</span>
                        <span class="cov0" title="0">evaluatedElements[i] = evaluatedElement</span>
                }
                <span class="cov0" title="0">return evaluatedElements, nil</span>

        case "binaryOp", "binary_operation", "binaryOperation":<span class="cov0" title="0">
                // Support des op√©rations binaires
                // G√©rer les diff√©rents types d'op√©rateurs
                var operator string
                var ok bool
                if operator, ok = val["operator"].(string); !ok </span><span class="cov0" title="0">{
                        if operatorBytes, ok := val["operator"].([]uint8); ok </span><span class="cov0" title="0">{
                                operator = string(operatorBytes)
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("op√©rateur invalide dans l'op√©ration binaire: %T %+v", val["operator"], val["operator"])
                        }</span>
                }

                <span class="cov0" title="0">left, err := e.evaluateValue(val["left"])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur √©valuation c√¥t√© gauche (binaryOp %s): %w", operator, err)
                }</span>

                <span class="cov0" title="0">right, err := e.evaluateValue(val["right"])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur √©valuation c√¥t√© droit (binaryOp %s): %w", operator, err)
                }</span>

                // Distinguer les op√©rations arithm√©tiques des comparaisons
                <span class="cov0" title="0">switch operator </span>{
                case "+", "-", "*", "/", "%":<span class="cov0" title="0">
                        // Op√©ration arithm√©tique - retourne une valeur num√©rique
                        result, err := e.evaluateArithmeticOperation(left, operator, right)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("erreur op√©ration arithm√©tique %s: %w", operator, err)
                        }</span>
                        <span class="cov0" title="0">return result, nil</span>
                case "==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;=", "CONTAINS", "IN", "LIKE", "MATCHES":<span class="cov0" title="0">
                        // Op√©ration de comparaison - retourne un bool√©en
                        return e.compareValues(left, operator, right)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("op√©rateur binaire non support√©: '%s' (bytes: %v)", operator, []byte(operator))</span>
                }

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("type de valeur non support√©: %s", valType)</span>
        }
}

// evaluateFieldAccess √©value l'acc√®s √† un champ d'une variable
func (e *AlphaConditionEvaluator) evaluateFieldAccess(fa constraint.FieldAccess) (interface{}, error) <span class="cov0" title="0">{
        return e.evaluateFieldAccessByName(fa.Object, fa.Field)
}</span>

// evaluateFieldAccessByName √©value l'acc√®s √† un champ par nom
func (e *AlphaConditionEvaluator) evaluateFieldAccessByName(object, field string) (interface{}, error) <span class="cov8" title="1">{
        fact, exists := e.variableBindings[object]
        if !exists </span><span class="cov8" title="1">{
                // En mode d'√©valuation partielle (jointures en cascade), retourner nil sans erreur
                // pour permettre l'√©valuation de continuer avec les variables disponibles
                if e.partialEvalMode </span><span class="cov8" title="1">{
                        return nil, nil // Sentinel value indiquant que la variable n'est pas encore li√©e
                }</span>
                // Debug info pour aider √† diagnostiquer les probl√®mes de binding
                <span class="cov0" title="0">availableVars := make([]string, 0, len(e.variableBindings))
                for k := range e.variableBindings </span><span class="cov0" title="0">{
                        availableVars = append(availableVars, k)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("variable non li√©e: %s (variables disponibles: %v)", object, availableVars)</span>
        }

        // Cas sp√©cial : le champ 'id' est stock√© dans fact.ID, pas dans fact.Fields
        <span class="cov8" title="1">if field == "id" </span><span class="cov8" title="1">{
                return fact.ID, nil
        }</span>

        <span class="cov8" title="1">value, exists := fact.Fields[field]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("champ inexistant: %s.%s", object, field)
        }</span>

        <span class="cov8" title="1">return value, nil</span>
}

// evaluateVariable √©value une variable
func (e *AlphaConditionEvaluator) evaluateVariable(variable constraint.Variable) (interface{}, error) <span class="cov0" title="0">{
        return e.evaluateVariableByName(variable.Name)
}</span>

// evaluateVariableByName √©value une variable par nom
func (e *AlphaConditionEvaluator) evaluateVariableByName(name string) (interface{}, error) <span class="cov0" title="0">{
        // CORRECTION: Traiter les acc√®s aux champs mal pars√©s comme "d.name"
        if strings.Contains(name, ".") </span><span class="cov0" title="0">{
                parts := strings.Split(name, ".")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        objectName := parts[0]
                        fieldName := parts[1]
                        return e.evaluateFieldAccessByName(objectName, fieldName)
                }</span>
        }

        <span class="cov0" title="0">fact, exists := e.variableBindings[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("variable non li√©e: %s", name)
        }</span>

        // Retourner le fait entier ou une repr√©sentation
        <span class="cov0" title="0">return fact, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

// Package rete fournit l'impl√©mentation du r√©seau RETE pour l'√©valuation de r√®gles.
// Ce fichier contient l'analyseur d'expressions qui d√©termine le type d'une expression
// et comment elle doit √™tre trait√©e dans le r√©seau RETE.
//
// Exemple d'utilisation:
//
//        // Analyser une expression simple
//        expr := map[string]interface{}{
//                "type": "binaryOperation",
//                "left": map[string]interface{}{"type": "fieldAccess", "object": "p", "field": "age"},
//                "operator": "&gt;",
//                "right": map[string]interface{}{"type": "numberLiteral", "value": 18},
//        }
//
//        exprType, err := AnalyzeExpression(expr)
//        if err != nil {
//                log.Fatal(err)
//        }
//
//        if CanDecompose(exprType) {
//                fmt.Println("Cette expression peut √™tre d√©compos√©e en cha√Æne alpha")
//        }
//
//        if ShouldNormalize(exprType) {
//                fmt.Println("Cette expression n√©cessite une normalisation")
//        }
package rete

import (
        "fmt"

        "github.com/treivax/tsd/constraint"
)

// ExpressionType repr√©sente le type d'une expression analys√©e
type ExpressionType int

const (
        // ExprTypeSimple repr√©sente une condition atomique (p.age &gt; 18)
        ExprTypeSimple ExpressionType = iota

        // ExprTypeAND repr√©sente une expression avec uniquement des op√©rateurs AND
        // Exemple: p.age &gt; 18 AND p.salary &gt;= 50000 AND p.active = true
        ExprTypeAND

        // ExprTypeOR repr√©sente une expression avec uniquement des op√©rateurs OR
        // Exemple: p.status = "active" OR p.status = "pending"
        ExprTypeOR

        // ExprTypeMixed repr√©sente une expression avec AND et OR m√©lang√©s
        // Exemple: (p.age &gt; 18 AND p.salary &gt;= 50000) OR p.vip = true
        ExprTypeMixed

        // ExprTypeArithmetic repr√©sente une cha√Æne d'op√©rations arithm√©tiques commutatives
        // Exemple: p.price * 1.2 + 5 (peut √™tre d√©compos√© en √©tapes)
        ExprTypeArithmetic

        // ExprTypeNOT repr√©sente une n√©gation d'expression
        // Exemple: NOT p.active, NOT (p.age &gt; 18 AND p.salary &lt; 50000)
        ExprTypeNOT
)

// String retourne une repr√©sentation textuelle du type d'expression
func (et ExpressionType) String() string <span class="cov0" title="0">{
        switch et </span>{
        case ExprTypeSimple:<span class="cov0" title="0">
                return "ExprTypeSimple"</span>
        case ExprTypeAND:<span class="cov0" title="0">
                return "ExprTypeAND"</span>
        case ExprTypeOR:<span class="cov0" title="0">
                return "ExprTypeOR"</span>
        case ExprTypeMixed:<span class="cov0" title="0">
                return "ExprTypeMixed"</span>
        case ExprTypeArithmetic:<span class="cov0" title="0">
                return "ExprTypeArithmetic"</span>
        case ExprTypeNOT:<span class="cov0" title="0">
                return "ExprTypeNOT"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// AnalyzeExpression analyse une expression et d√©termine son type
// Retourne le type d'expression identifi√© et une erreur si l'analyse √©choue
func AnalyzeExpression(expr interface{}) (ExpressionType, error) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return ExprTypeSimple, fmt.Errorf("expression nil")
        }</span>

        <span class="cov0" title="0">switch e := expr.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return analyzeMapExpression(e)</span>

        case constraint.BinaryOperation:<span class="cov0" title="0">
                // Une op√©ration binaire simple peut √™tre une condition ou une op√©ration arithm√©tique
                if isArithmeticOperator(e.Operator) </span><span class="cov0" title="0">{
                        return ExprTypeArithmetic, nil
                }</span>
                <span class="cov0" title="0">return ExprTypeSimple, nil</span>

        case constraint.LogicalExpression:<span class="cov0" title="0">
                return analyzeLogicalExpression(e)</span>

        case constraint.Constraint:<span class="cov0" title="0">
                // Une contrainte simple
                if e.Left != nil &amp;&amp; e.Operator != "" </span><span class="cov0" title="0">{
                        if isArithmeticOperator(e.Operator) </span><span class="cov0" title="0">{
                                return ExprTypeArithmetic, nil
                        }</span>
                        <span class="cov0" title="0">return ExprTypeSimple, nil</span>
                }
                <span class="cov0" title="0">return ExprTypeSimple, nil</span>

        case constraint.FieldAccess:<span class="cov0" title="0">
                // Un acc√®s de champ seul n'est pas vraiment une condition compl√®te
                return ExprTypeSimple, nil</span>

        case constraint.NumberLiteral, constraint.StringLiteral, constraint.BooleanLiteral:<span class="cov0" title="0">
                // Les litt√©raux seuls ne forment pas une expression √©valuable
                return ExprTypeSimple, nil</span>

        case SimpleCondition:<span class="cov0" title="0">
                // Une SimpleCondition d√©j√† extraite
                return ExprTypeSimple, nil</span>

        case constraint.NotConstraint:<span class="cov0" title="0">
                // Une contrainte de n√©gation
                return ExprTypeNOT, nil</span>

        default:<span class="cov0" title="0">
                return ExprTypeSimple, fmt.Errorf("type d'expression non support√©: %T", expr)</span>
        }
}

// analyzeMapExpression analyse une expression sous forme de map
func analyzeMapExpression(expr map[string]interface{}) (ExpressionType, error) <span class="cov0" title="0">{
        exprType, ok := expr["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return ExprTypeSimple, fmt.Errorf("type d'expression manquant")
        }</span>

        <span class="cov0" title="0">switch exprType </span>{
        case "binaryOperation", "binary_op", "comparison":<span class="cov0" title="0">
                operator, ok := expr["operator"].(string)
                if !ok </span><span class="cov0" title="0">{
                        if operator, ok = expr["op"].(string); !ok </span><span class="cov0" title="0">{
                                return ExprTypeSimple, fmt.Errorf("op√©rateur manquant")
                        }</span>
                }
                <span class="cov0" title="0">if isArithmeticOperator(operator) </span><span class="cov0" title="0">{
                        return ExprTypeArithmetic, nil
                }</span>
                <span class="cov0" title="0">return ExprTypeSimple, nil</span>

        case "logicalExpression", "logical_op", "logicalExpr":<span class="cov0" title="0">
                return analyzeLogicalExpressionMap(expr)</span>

        case "constraint":<span class="cov0" title="0">
                // Analyser la contrainte pour d√©terminer si elle contient des op√©rations arithm√©tiques
                if operator, ok := expr["operator"].(string); ok &amp;&amp; isArithmeticOperator(operator) </span><span class="cov0" title="0">{
                        return ExprTypeArithmetic, nil
                }</span>
                <span class="cov0" title="0">return ExprTypeSimple, nil</span>

        case "arithmeticOperation", "arithmetic_op":<span class="cov0" title="0">
                return ExprTypeArithmetic, nil</span>

        case "notConstraint", "not", "negation":<span class="cov0" title="0">
                return ExprTypeNOT, nil</span>

        case "parenthesized", "parenthesizedExpression", "group":<span class="cov0" title="0">
                // Une expression parenth√©s√©e - analyser le contenu
                return analyzeParenthesizedExpression(expr)</span>

        case "fieldAccess", "literal", "numberLiteral", "stringLiteral", "booleanLiteral":<span class="cov0" title="0">
                return ExprTypeSimple, nil</span>

        default:<span class="cov0" title="0">
                return ExprTypeSimple, fmt.Errorf("type d'expression map non support√©: %s", exprType)</span>
        }
}

// analyzeLogicalExpression analyse une expression logique structur√©e
func analyzeLogicalExpression(expr constraint.LogicalExpression) (ExpressionType, error) <span class="cov0" title="0">{
        if len(expr.Operations) == 0 </span><span class="cov0" title="0">{
                // Pas d'op√©rations - analyser le c√¥t√© gauche uniquement
                return AnalyzeExpression(expr.Left)
        }</span>

        // V√©rifier tous les op√©rateurs
        <span class="cov0" title="0">hasAND := false
        hasOR := false

        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                switch op.Op </span>{
                case "AND", "and", "&amp;&amp;":<span class="cov0" title="0">
                        hasAND = true</span>
                case "OR", "or", "||":<span class="cov0" title="0">
                        hasOR = true</span>
                }
        }

        // D√©terminer le type en fonction des op√©rateurs trouv√©s
        <span class="cov0" title="0">if hasAND &amp;&amp; hasOR </span><span class="cov0" title="0">{
                return ExprTypeMixed, nil
        }</span> else<span class="cov0" title="0"> if hasOR </span><span class="cov0" title="0">{
                return ExprTypeOR, nil
        }</span> else<span class="cov0" title="0"> if hasAND </span><span class="cov0" title="0">{
                return ExprTypeAND, nil
        }</span>

        // Par d√©faut, consid√©rer comme simple
        <span class="cov0" title="0">return ExprTypeSimple, nil</span>
}

// analyzeLogicalExpressionMap analyse une expression logique (format map)
func analyzeLogicalExpressionMap(expr map[string]interface{}) (ExpressionType, error) <span class="cov0" title="0">{
        operations, ok := expr["operations"]
        if !ok </span><span class="cov0" title="0">{
                // Pas d'op√©rations - analyser le c√¥t√© gauche uniquement
                if left, ok := expr["left"]; ok </span><span class="cov0" title="0">{
                        return AnalyzeExpression(left)
                }</span>
                <span class="cov0" title="0">return ExprTypeSimple, nil</span>
        }

        // V√©rifier tous les op√©rateurs - supporter []interface{}, []map[string]interface{} et []constraint.LogicalOperation
        <span class="cov0" title="0">hasAND := false
        hasOR := false

        // Essayer []map[string]interface{} en premier (type le plus courant du parser)
        if opsMapList, ok := operations.([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                if len(opsMapList) == 0 </span><span class="cov0" title="0">{
                        if left, ok := expr["left"]; ok </span><span class="cov0" title="0">{
                                return AnalyzeExpression(left)
                        }</span>
                        <span class="cov0" title="0">return ExprTypeSimple, nil</span>
                }

                <span class="cov0" title="0">for _, opMap := range opsMapList </span><span class="cov0" title="0">{
                        operator, ok := opMap["op"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">switch operator </span>{
                        case "AND", "and", "&amp;&amp;":<span class="cov0" title="0">
                                hasAND = true</span>
                        case "OR", "or", "||":<span class="cov0" title="0">
                                hasOR = true</span>
                        }
                }
        } else<span class="cov0" title="0"> if opsList, ok := operations.([]interface{}); ok </span><span class="cov0" title="0">{
                if len(opsList) == 0 </span><span class="cov0" title="0">{
                        if left, ok := expr["left"]; ok </span><span class="cov0" title="0">{
                                return AnalyzeExpression(left)
                        }</span>
                        <span class="cov0" title="0">return ExprTypeSimple, nil</span>
                }

                <span class="cov0" title="0">for _, opInterface := range opsList </span><span class="cov0" title="0">{
                        opMap, ok := opInterface.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">operator, ok := opMap["op"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">switch operator </span>{
                        case "AND", "and", "&amp;&amp;":<span class="cov0" title="0">
                                hasAND = true</span>
                        case "OR", "or", "||":<span class="cov0" title="0">
                                hasOR = true</span>
                        }
                }
        } else<span class="cov0" title="0"> if logicalOps, ok := operations.([]constraint.LogicalOperation); ok </span><span class="cov0" title="0">{
                if len(logicalOps) == 0 </span><span class="cov0" title="0">{
                        if left, ok := expr["left"]; ok </span><span class="cov0" title="0">{
                                return AnalyzeExpression(left)
                        }</span>
                        <span class="cov0" title="0">return ExprTypeSimple, nil</span>
                }

                <span class="cov0" title="0">for _, op := range logicalOps </span><span class="cov0" title="0">{
                        switch op.Op </span>{
                        case "AND", "and", "&amp;&amp;":<span class="cov0" title="0">
                                hasAND = true</span>
                        case "OR", "or", "||":<span class="cov0" title="0">
                                hasOR = true</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                return ExprTypeSimple, fmt.Errorf("operations doit √™tre un tableau ([]interface{}, []map[string]interface{} ou []LogicalOperation)")
        }</span>

        // D√©terminer le type en fonction des op√©rateurs trouv√©s
        <span class="cov0" title="0">if hasAND &amp;&amp; hasOR </span><span class="cov0" title="0">{
                return ExprTypeMixed, nil
        }</span> else<span class="cov0" title="0"> if hasOR </span><span class="cov0" title="0">{
                return ExprTypeOR, nil
        }</span> else<span class="cov0" title="0"> if hasAND </span><span class="cov0" title="0">{
                return ExprTypeAND, nil
        }</span>

        // Par d√©faut, consid√©rer comme simple
        <span class="cov0" title="0">return ExprTypeSimple, nil</span>
}

// isArithmeticOperator d√©termine si un op√©rateur est arithm√©tique
func isArithmeticOperator(operator string) bool <span class="cov0" title="0">{
        switch operator </span>{
        case "+", "-", "*", "/", "%", "**", "^":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// analyzeParenthesizedExpression analyse une expression parenth√©s√©e
func analyzeParenthesizedExpression(expr map[string]interface{}) (ExpressionType, error) <span class="cov0" title="0">{
        // Extraire l'expression interne
        var innerExpr interface{}
        var ok bool

        if innerExpr, ok = expr["expression"]; !ok </span><span class="cov0" title="0">{
                if innerExpr, ok = expr["expr"]; !ok </span><span class="cov0" title="0">{
                        if innerExpr, ok = expr["inner"]; !ok </span><span class="cov0" title="0">{
                                return ExprTypeSimple, fmt.Errorf("expression interne manquante dans l'expression parenth√©s√©e")
                        }</span>
                }
        }

        // Analyser r√©cursivement l'expression interne
        <span class="cov0" title="0">return AnalyzeExpression(innerExpr)</span>
}

// CanDecompose d√©termine si une expression peut √™tre d√©compos√©e en cha√Æne alpha
// Retourne true pour les expressions qui peuvent √™tre transform√©es en s√©quence
// de n≈ìuds alpha cha√Æn√©s.
//
// Les expressions d√©composables:
//   - ExprTypeSimple: condition atomique directement utilisable
//   - ExprTypeAND: peut √™tre d√©compos√©e en cha√Æne de conditions (p1 AND p2 AND p3 -&gt; alpha1-&gt;alpha2-&gt;alpha3)
//   - ExprTypeArithmetic: op√©rations arithm√©tiques commutatives peuvent √™tre cha√Æn√©es
//
// Les expressions non-d√©composables:
//   - ExprTypeOR: n√©cessite des branches multiples (beta nodes ou duplication)
//   - ExprTypeMixed: n√©cessite normalisation en forme normale disjonctive (DNF) ou conjonctive (CNF)
func CanDecompose(exprType ExpressionType) bool <span class="cov0" title="0">{
        switch exprType </span>{
        case ExprTypeSimple:<span class="cov0" title="0">
                return true</span>
        case ExprTypeAND:<span class="cov0" title="0">
                return true</span>
        case ExprTypeArithmetic:<span class="cov0" title="0">
                return true</span>
        case ExprTypeNOT:<span class="cov0" title="0">
                return true</span> // NOT peut √™tre d√©compos√© en alpha node avec n√©gation
        case ExprTypeOR:<span class="cov0" title="0">
                return false</span> // N√©cessite traitement sp√©cial avec branches
        case ExprTypeMixed:<span class="cov0" title="0">
                return false</span> // N√©cessite normalisation d'abord
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// ShouldNormalize d√©termine si une expression n√©cessite une normalisation
// avant de pouvoir √™tre trait√©e dans le r√©seau RETE.
//
// La normalisation est n√©cessaire pour:
//   - ExprTypeMixed: doit √™tre convertie en DNF ou CNF
//   - ExprTypeOR: peut b√©n√©ficier de la normalisation pour optimisation
//
// La normalisation n'est pas n√©cessaire pour:
//   - ExprTypeSimple: d√©j√† sous forme atomique
//   - ExprTypeAND: d√©j√† sous forme conjonctive, facilement cha√Ænable
//   - ExprTypeArithmetic: structure d√©j√† lin√©aire
func ShouldNormalize(exprType ExpressionType) bool <span class="cov0" title="0">{
        switch exprType </span>{
        case ExprTypeSimple:<span class="cov0" title="0">
                return false</span>
        case ExprTypeAND:<span class="cov0" title="0">
                return false</span>
        case ExprTypeArithmetic:<span class="cov0" title="0">
                return false</span>
        case ExprTypeNOT:<span class="cov0" title="0">
                return false</span> // NOT peut √™tre g√©r√© directement, mais peut b√©n√©ficier de la normalisation de l'expression interne
        case ExprTypeOR:<span class="cov0" title="0">
                return true</span> // B√©n√©ficie de la normalisation pour optimisation
        case ExprTypeMixed:<span class="cov0" title="0">
                return true</span> // Doit √™tre normalis√©e
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetExpressionComplexity retourne une estimation de la complexit√© d'une expression
// Utile pour d√©cider de strat√©gies d'optimisation
func GetExpressionComplexity(exprType ExpressionType) int <span class="cov0" title="0">{
        switch exprType </span>{
        case ExprTypeSimple:<span class="cov0" title="0">
                return 1</span>
        case ExprTypeAND:<span class="cov0" title="0">
                return 2</span>
        case ExprTypeArithmetic:<span class="cov0" title="0">
                return 2</span>
        case ExprTypeNOT:<span class="cov0" title="0">
                return 2</span> // La n√©gation ajoute une couche de complexit√©
        case ExprTypeOR:<span class="cov0" title="0">
                return 3</span>
        case ExprTypeMixed:<span class="cov0" title="0">
                return 4</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// RequiresBetaNode d√©termine si une expression n√©cessite des n≈ìuds beta
// pour son √©valuation (jointures, branches multiples, etc.)
func RequiresBetaNode(exprType ExpressionType) bool <span class="cov0" title="0">{
        switch exprType </span>{
        case ExprTypeSimple:<span class="cov0" title="0">
                return false</span>
        case ExprTypeAND:<span class="cov0" title="0">
                return false</span> // Peut √™tre g√©r√© avec alpha nodes cha√Æn√©s
        case ExprTypeArithmetic:<span class="cov0" title="0">
                return false</span>
        case ExprTypeNOT:<span class="cov0" title="0">
                return false</span> // Peut √™tre g√©r√© avec un alpha node avec flag de n√©gation
        case ExprTypeOR:<span class="cov0" title="0">
                return true</span> // N√©cessite branches ou duplication
        case ExprTypeMixed:<span class="cov0" title="0">
                return true</span> // N√©cessite structure complexe
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// ExpressionInfo contient des informations d√©taill√©es sur une expression analys√©e
type ExpressionInfo struct {
        Type            ExpressionType
        CanDecompose    bool
        ShouldNormalize bool
        Complexity      int
        RequiresBeta    bool
        // InnerInfo contient l'analyse de l'expression interne pour les expressions
        // imbriqu√©es (NOT, parenth√©s√©es, etc.)
        InnerInfo *ExpressionInfo
        // OptimizationHints contient des suggestions d'optimisation pour cette expression
        OptimizationHints []string
}

// GetExpressionInfo retourne des informations compl√®tes sur une expression
// Pour les expressions NOT et parenth√©s√©es, analyse √©galement l'expression interne
func GetExpressionInfo(expr interface{}) (*ExpressionInfo, error) <span class="cov0" title="0">{
        exprType, err := AnalyzeExpression(expr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculer la complexit√© r√©elle en fonction du nombre d'op√©rations
        <span class="cov0" title="0">complexity := calculateActualComplexity(expr, exprType)

        info := &amp;ExpressionInfo{
                Type:            exprType,
                CanDecompose:    CanDecompose(exprType),
                ShouldNormalize: ShouldNormalize(exprType),
                Complexity:      complexity,
                RequiresBeta:    RequiresBetaNode(exprType),
        }

        // Analyser r√©cursivement l'expression interne pour les NOT
        if exprType == ExprTypeNOT </span><span class="cov0" title="0">{
                innerExpr := extractInnerExpression(expr)
                if innerExpr != nil </span><span class="cov0" title="0">{
                        innerInfo, err := GetExpressionInfo(innerExpr)
                        if err == nil </span><span class="cov0" title="0">{
                                info.InnerInfo = innerInfo
                                // Ajuster la complexit√© en fonction de l'expression interne
                                info.Complexity = 2 + innerInfo.Complexity
                        }</span>
                }
        }

        // G√©n√©rer les hints d'optimisation
        <span class="cov0" title="0">info.OptimizationHints = generateOptimizationHints(expr, info)

        return info, nil</span>
}

// extractInnerExpression extrait l'expression interne d'un NOT ou d'une expression parenth√©s√©e
func extractInnerExpression(expr interface{}) interface{} <span class="cov0" title="0">{
        switch e := expr.(type) </span>{
        case constraint.NotConstraint:<span class="cov0" title="0">
                return e.Expression</span>

        case map[string]interface{}:<span class="cov0" title="0">
                exprType, ok := e["type"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">switch exprType </span>{
                case "notConstraint", "not", "negation":<span class="cov0" title="0">
                        // Extraire la contrainte interne
                        if inner, ok := e["constraint"]; ok </span><span class="cov0" title="0">{
                                return inner
                        }</span>
                        <span class="cov0" title="0">if inner, ok := e["expr"]; ok </span><span class="cov0" title="0">{
                                return inner
                        }</span>
                        <span class="cov0" title="0">if inner, ok := e["expression"]; ok </span><span class="cov0" title="0">{
                                return inner
                        }</span>

                case "parenthesized", "parenthesizedExpression", "group":<span class="cov0" title="0">
                        // Extraire l'expression √† l'int√©rieur des parenth√®ses
                        if inner, ok := e["expression"]; ok </span><span class="cov0" title="0">{
                                return inner
                        }</span>
                        <span class="cov0" title="0">if inner, ok := e["expr"]; ok </span><span class="cov0" title="0">{
                                return inner
                        }</span>
                        <span class="cov0" title="0">if inner, ok := e["inner"]; ok </span><span class="cov0" title="0">{
                                return inner
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// AnalyzeInnerExpression analyse l'expression interne d'un NOT ou d'une expression parenth√©s√©e
// Retourne le type de l'expression interne et une erreur si l'analyse √©choue
func AnalyzeInnerExpression(expr interface{}) (ExpressionType, error) <span class="cov0" title="0">{
        innerExpr := extractInnerExpression(expr)
        if innerExpr == nil </span><span class="cov0" title="0">{
                return ExprTypeSimple, fmt.Errorf("impossible d'extraire l'expression interne")
        }</span>
        <span class="cov0" title="0">return AnalyzeExpression(innerExpr)</span>
}

// calculateActualComplexity calcule la complexit√© r√©elle en fonction du nombre d'op√©rations
func calculateActualComplexity(expr interface{}, exprType ExpressionType) int <span class="cov0" title="0">{
        baseComplexity := GetExpressionComplexity(exprType)

        // Pour les expressions logiques, calculer en fonction du nombre d'op√©rations
        switch e := expr.(type) </span>{
        case constraint.LogicalExpression:<span class="cov0" title="0">
                if exprType == ExprTypeAND || exprType == ExprTypeOR || exprType == ExprTypeMixed </span><span class="cov0" title="0">{
                        // 1 pour le terme de gauche + 1 pour chaque op√©ration
                        return 1 + len(e.Operations)
                }</span>
        case map[string]interface{}:<span class="cov0" title="0">
                if operations, ok := e["operations"].([]interface{}); ok </span><span class="cov0" title="0">{
                        if exprType == ExprTypeAND || exprType == ExprTypeOR || exprType == ExprTypeMixed </span><span class="cov0" title="0">{
                                return 1 + len(operations)
                        }</span>
                }
        }

        <span class="cov0" title="0">return baseComplexity</span>
}

// ApplyDeMorganTransformation applique la loi de De Morgan √† une expression NOT
// Transforme NOT(A OR B) en (NOT A) AND (NOT B)
// Transforme NOT(A AND B) en (NOT A) OR (NOT B)
// Retourne l'expression transform√©e et un bool√©en indiquant si une transformation a eu lieu
func ApplyDeMorganTransformation(expr interface{}) (interface{}, bool) <span class="cov0" title="0">{
        // V√©rifier si c'est une expression NOT
        exprType, err := AnalyzeExpression(expr)
        if err != nil || exprType != ExprTypeNOT </span><span class="cov0" title="0">{
                return expr, false
        }</span>

        // Extraire l'expression interne
        <span class="cov0" title="0">innerExpr := extractInnerExpression(expr)
        if innerExpr == nil </span><span class="cov0" title="0">{
                return expr, false
        }</span>

        // Analyser l'expression interne
        <span class="cov0" title="0">innerType, err := AnalyzeExpression(innerExpr)
        if err != nil </span><span class="cov0" title="0">{
                return expr, false
        }</span>

        // Appliquer De Morgan seulement si l'expression interne est AND ou OR
        <span class="cov0" title="0">if innerType != ExprTypeAND &amp;&amp; innerType != ExprTypeOR </span><span class="cov0" title="0">{
                return expr, false
        }</span>

        // Appliquer la transformation selon le type
        <span class="cov0" title="0">switch innerType </span>{
        case ExprTypeAND:<span class="cov0" title="0">
                // NOT(A AND B) -&gt; (NOT A) OR (NOT B)
                return transformNotAnd(innerExpr), true</span>
        case ExprTypeOR:<span class="cov0" title="0">
                // NOT(A OR B) -&gt; (NOT A) AND (NOT B)
                return transformNotOr(innerExpr), true</span>
        }

        <span class="cov0" title="0">return expr, false</span>
}

// transformNotAnd transforme NOT(A AND B) en (NOT A) OR (NOT B)
func transformNotAnd(expr interface{}) interface{} <span class="cov0" title="0">{
        switch e := expr.(type) </span>{
        case constraint.LogicalExpression:<span class="cov0" title="0">
                // Cr√©er une nouvelle expression logique avec OR
                newExpr := constraint.LogicalExpression{
                        Left: wrapInNot(e.Left),
                }

                // Transformer toutes les op√©rations AND en OR et nier les op√©randes
                for _, op := range e.Operations </span><span class="cov0" title="0">{
                        newExpr.Operations = append(newExpr.Operations, constraint.LogicalOperation{
                                Op:    convertAndToOr(op.Op),
                                Right: wrapInNot(op.Right),
                        })
                }</span>

                <span class="cov0" title="0">return newExpr</span>

        case map[string]interface{}:<span class="cov0" title="0">
                return transformNotAndMap(e)</span>
        }

        <span class="cov0" title="0">return expr</span>
}

// transformNotOr transforme NOT(A OR B) en (NOT A) AND (NOT B)
func transformNotOr(expr interface{}) interface{} <span class="cov0" title="0">{
        switch e := expr.(type) </span>{
        case constraint.LogicalExpression:<span class="cov0" title="0">
                // Cr√©er une nouvelle expression logique avec AND
                newExpr := constraint.LogicalExpression{
                        Left: wrapInNot(e.Left),
                }

                // Transformer toutes les op√©rations OR en AND et nier les op√©randes
                for _, op := range e.Operations </span><span class="cov0" title="0">{
                        newExpr.Operations = append(newExpr.Operations, constraint.LogicalOperation{
                                Op:    convertOrToAnd(op.Op),
                                Right: wrapInNot(op.Right),
                        })
                }</span>

                <span class="cov0" title="0">return newExpr</span>

        case map[string]interface{}:<span class="cov0" title="0">
                return transformNotOrMap(e)</span>
        }

        <span class="cov0" title="0">return expr</span>
}

// transformNotAndMap transforme NOT(A AND B) en (NOT A) OR (NOT B) pour format map
func transformNotAndMap(expr map[string]interface{}) interface{} <span class="cov0" title="0">{
        result := map[string]interface{}{
                "type": "logicalExpression",
        }

        // Extraire le c√¥t√© gauche
        if left, ok := expr["left"]; ok </span><span class="cov0" title="0">{
                result["left"] = wrapInNotMap(left)
        }</span>

        // Transformer les op√©rations
        <span class="cov0" title="0">if operations, ok := expr["operations"].([]interface{}); ok </span><span class="cov0" title="0">{
                newOps := make([]interface{}, 0, len(operations))
                for _, opInterface := range operations </span><span class="cov0" title="0">{
                        if opMap, ok := opInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                newOp := map[string]interface{}{
                                        "op": convertAndToOr(getOperatorFromMap(opMap)),
                                }
                                if right, ok := opMap["right"]; ok </span><span class="cov0" title="0">{
                                        newOp["right"] = wrapInNotMap(right)
                                }</span>
                                <span class="cov0" title="0">newOps = append(newOps, newOp)</span>
                        }
                }
                <span class="cov0" title="0">result["operations"] = newOps</span>
        }

        <span class="cov0" title="0">return result</span>
}

// transformNotOrMap transforme NOT(A OR B) en (NOT A) AND (NOT B) pour format map
func transformNotOrMap(expr map[string]interface{}) interface{} <span class="cov0" title="0">{
        result := map[string]interface{}{
                "type": "logicalExpression",
        }

        // Extraire le c√¥t√© gauche
        if left, ok := expr["left"]; ok </span><span class="cov0" title="0">{
                result["left"] = wrapInNotMap(left)
        }</span>

        // Transformer les op√©rations
        <span class="cov0" title="0">if operations, ok := expr["operations"].([]interface{}); ok </span><span class="cov0" title="0">{
                newOps := make([]interface{}, 0, len(operations))
                for _, opInterface := range operations </span><span class="cov0" title="0">{
                        if opMap, ok := opInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                newOp := map[string]interface{}{
                                        "op": convertOrToAnd(getOperatorFromMap(opMap)),
                                }
                                if right, ok := opMap["right"]; ok </span><span class="cov0" title="0">{
                                        newOp["right"] = wrapInNotMap(right)
                                }</span>
                                <span class="cov0" title="0">newOps = append(newOps, newOp)</span>
                        }
                }
                <span class="cov0" title="0">result["operations"] = newOps</span>
        }

        <span class="cov0" title="0">return result</span>
}

// wrapInNot enveloppe une expression dans un NOT
func wrapInNot(expr interface{}) interface{} <span class="cov0" title="0">{
        return constraint.NotConstraint{
                Expression: expr,
        }
}</span>

// wrapInNotMap enveloppe une expression dans un NOT (format map)
func wrapInNotMap(expr interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "type":       "notConstraint",
                "expression": expr,
        }
}</span>

// convertAndToOr convertit un op√©rateur AND en OR
func convertAndToOr(op string) string <span class="cov0" title="0">{
        switch op </span>{
        case "AND", "and":<span class="cov0" title="0">
                return "OR"</span>
        case "&amp;&amp;":<span class="cov0" title="0">
                return "||"</span>
        default:<span class="cov0" title="0">
                return "OR"</span>
        }
}

// convertOrToAnd convertit un op√©rateur OR en AND
func convertOrToAnd(op string) string <span class="cov0" title="0">{
        switch op </span>{
        case "OR", "or":<span class="cov0" title="0">
                return "AND"</span>
        case "||":<span class="cov0" title="0">
                return "&amp;&amp;"</span>
        default:<span class="cov0" title="0">
                return "AND"</span>
        }
}

// getOperatorFromMap extrait l'op√©rateur d'une map d'op√©ration
func getOperatorFromMap(opMap map[string]interface{}) string <span class="cov0" title="0">{
        if op, ok := opMap["op"].(string); ok </span><span class="cov0" title="0">{
                return op
        }</span>
        <span class="cov0" title="0">if op, ok := opMap["operator"].(string); ok </span><span class="cov0" title="0">{
                return op
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// generateOptimizationHints g√©n√®re des suggestions d'optimisation bas√©es sur l'analyse
func generateOptimizationHints(expr interface{}, info *ExpressionInfo) []string <span class="cov0" title="0">{
        hints := make([]string, 0)

        // Hint pour De Morgan transformation
        if info.Type == ExprTypeNOT &amp;&amp; info.InnerInfo != nil </span><span class="cov0" title="0">{
                if info.InnerInfo.Type == ExprTypeOR </span><span class="cov0" title="0">{
                        hints = append(hints, "apply_demorgan_not_or")
                }</span> else<span class="cov0" title="0"> if info.InnerInfo.Type == ExprTypeAND </span><span class="cov0" title="0">{
                        hints = append(hints, "apply_demorgan_not_and")
                }</span> else<span class="cov0" title="0"> if info.InnerInfo.Type == ExprTypeMixed </span><span class="cov0" title="0">{
                        hints = append(hints, "push_negation_down")
                }</span>
        }

        // Hint pour normalisation
        <span class="cov0" title="0">if info.ShouldNormalize </span><span class="cov0" title="0">{
                if info.Type == ExprTypeMixed </span><span class="cov0" title="0">{
                        hints = append(hints, "normalize_to_dnf")
                }</span> else<span class="cov0" title="0"> if info.Type == ExprTypeOR </span><span class="cov0" title="0">{
                        hints = append(hints, "consider_dnf_expansion")
                }</span>
        }

        // Hint pour partage d'alpha nodes
        <span class="cov0" title="0">if info.Type == ExprTypeAND &amp;&amp; info.Complexity &gt;= 3 </span><span class="cov0" title="0">{
                hints = append(hints, "alpha_sharing_opportunity")
        }</span>

        // Hint pour r√©ordonnancement
        <span class="cov0" title="0">if info.Type == ExprTypeAND &amp;&amp; canBenefitFromReordering(expr) </span><span class="cov0" title="0">{
                hints = append(hints, "consider_reordering")
        }</span>

        // Hint pour expressions complexes
        <span class="cov0" title="0">if info.Complexity &gt;= 4 </span><span class="cov0" title="0">{
                hints = append(hints, "high_complexity_review")
        }</span>

        // Hint pour expressions n√©cessitant beta nodes
        <span class="cov0" title="0">if info.RequiresBeta </span><span class="cov0" title="0">{
                hints = append(hints, "requires_beta_node")
        }</span>

        // Hint pour simplification arithm√©tique
        <span class="cov0" title="0">if info.Type == ExprTypeArithmetic </span><span class="cov0" title="0">{
                hints = append(hints, "consider_arithmetic_simplification")
        }</span>

        <span class="cov0" title="0">return hints</span>
}

// canBenefitFromReordering d√©termine si une expression AND peut b√©n√©ficier d'un r√©ordonnancement
func canBenefitFromReordering(expr interface{}) bool <span class="cov0" title="0">{
        switch e := expr.(type) </span>{
        case constraint.LogicalExpression:<span class="cov0" title="0">
                // Si l'expression a plusieurs op√©rations AND, le r√©ordonnancement peut aider
                return len(e.Operations) &gt;= 2</span>

        case map[string]interface{}:<span class="cov0" title="0">
                if operations, ok := e["operations"].([]interface{}); ok </span><span class="cov0" title="0">{
                        return len(operations) &gt;= 2
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ShouldApplyDeMorgan d√©termine si la transformation de De Morgan devrait √™tre appliqu√©e
// bas√© sur des crit√®res d'optimisation
func ShouldApplyDeMorgan(expr interface{}) bool <span class="cov0" title="0">{
        info, err := GetExpressionInfo(expr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Appliquer De Morgan si c'est un NOT(OR) ou NOT(AND)
        <span class="cov0" title="0">if info.Type == ExprTypeNOT &amp;&amp; info.InnerInfo != nil </span><span class="cov0" title="0">{
                innerType := info.InnerInfo.Type
                if innerType == ExprTypeOR || innerType == ExprTypeAND </span><span class="cov0" title="0">{
                        // Appliquer De Morgan seulement si cela r√©duit la complexit√©
                        // NOT(A OR B) -&gt; (NOT A) AND (NOT B) est b√©n√©fique car AND est d√©composable
                        if innerType == ExprTypeOR </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        // NOT(A AND B) -&gt; (NOT A) OR (NOT B) peut √™tre moins optimal
                        // car OR n√©cessite des branches, donc on applique seulement si l'expression est simple
                        <span class="cov0" title="0">if innerType == ExprTypeAND &amp;&amp; info.InnerInfo.Complexity &lt;= 2 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "time"
)

type Fact struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        Fields    map[string]interface{} `json:"fields"`
        Timestamp time.Time              `json:"timestamp"`
}

// String retourne la repr√©sentation string d'un fait
func (f *Fact) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Fact{ID:%s, Type:%s, Fields:%v}", f.ID, f.Type, f.Fields)
}</span>

// GetInternalID retourne l'identifiant interne unique (Type_ID)
func (f *Fact) GetInternalID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", f.Type, f.ID)
}</span>

// GetField retourne la valeur d'un champ
func (f *Fact) GetField(fieldName string) (interface{}, bool) <span class="cov0" title="0">{
        value, exists := f.Fields[fieldName]
        return value, exists
}</span>

// MakeInternalID construit un identifiant interne √† partir d'un type et d'un ID
func MakeInternalID(factType, factID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_%s", factType, factID)
}</span>

// ParseInternalID d√©compose un identifiant interne en type et ID
// Retourne (type, id, true) si le format est valide, sinon ("", "", false)
func ParseInternalID(internalID string) (string, string, bool) <span class="cov0" title="0">{
        for i := 0; i &lt; len(internalID); i++ </span><span class="cov0" title="0">{
                if internalID[i] == '_' </span><span class="cov0" title="0">{
                        return internalID[:i], internalID[i+1:], true
                }</span>
        }
        <span class="cov0" title="0">return "", "", false</span>
}

// Token repr√©sente un token dans le r√©seau RETE
type Token struct {
        ID           string           `json:"id"`
        Facts        []*Fact          `json:"facts"`
        NodeID       string           `json:"node_id"`
        Parent       *Token           `json:"parent,omitempty"`
        Bindings     map[string]*Fact `json:"bindings,omitempty"`       // Nouveau: bindings pour jointures
        IsJoinResult bool             `json:"is_join_result,omitempty"` // Indique si c'est un token de jointure r√©ussie
}

// WorkingMemory repr√©sente la m√©moire de travail d'un n≈ìud
type WorkingMemory struct {
        NodeID string            `json:"node_id"`
        Facts  map[string]*Fact  `json:"facts"`
        Tokens map[string]*Token `json:"tokens"`
}

// AddFact ajoute un fait √† la m√©moire en utilisant un identifiant interne unique (Type_ID)
// Retourne une erreur si un fait avec le m√™me type et ID existe d√©j√†
func (wm *WorkingMemory) AddFact(fact *Fact) error <span class="cov8" title="1">{
        if wm.Facts == nil </span><span class="cov0" title="0">{
                wm.Facts = make(map[string]*Fact)
        }</span>

        // Utiliser l'identifiant interne (Type_ID) pour garantir l'unicit√© par type
        <span class="cov8" title="1">internalID := fact.GetInternalID()

        if _, exists := wm.Facts[internalID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("fait avec ID '%s' et type '%s' existe d√©j√† dans la m√©moire", fact.ID, fact.Type)
        }</span>

        <span class="cov8" title="1">wm.Facts[internalID] = fact
        return nil</span>
}

// RemoveFact supprime un fait de la m√©moire
// factID doit √™tre l'identifiant interne (Type_ID)
func (wm *WorkingMemory) RemoveFact(factID string) <span class="cov0" title="0">{
        delete(wm.Facts, factID)
}</span>

// GetFact r√©cup√®re un fait par son identifiant interne (Type_ID)
// Pour rechercher par type et ID s√©par√©ment, utiliser GetFactByTypeAndID
func (wm *WorkingMemory) GetFact(internalID string) (*Fact, bool) <span class="cov0" title="0">{
        fact, exists := wm.Facts[internalID]
        return fact, exists
}</span>

// GetFactByInternalID r√©cup√®re un fait uniquement par son identifiant interne
func (wm *WorkingMemory) GetFactByInternalID(internalID string) (*Fact, bool) <span class="cov0" title="0">{
        fact, exists := wm.Facts[internalID]
        return fact, exists
}</span>

// GetFactByTypeAndID r√©cup√®re un fait par son type et son ID
func (wm *WorkingMemory) GetFactByTypeAndID(factType, factID string) (*Fact, bool) <span class="cov0" title="0">{
        internalID := MakeInternalID(factType, factID)
        return wm.GetFactByInternalID(internalID)
}</span>

// GetFacts retourne tous les faits de la m√©moire
func (wm *WorkingMemory) GetFacts() []*Fact <span class="cov0" title="0">{
        facts := make([]*Fact, 0, len(wm.Facts))
        for _, fact := range wm.Facts </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>
        <span class="cov0" title="0">return facts</span>
}

// AddToken ajoute un token √† la m√©moire
func (wm *WorkingMemory) AddToken(token *Token) <span class="cov8" title="1">{
        if wm.Tokens == nil </span><span class="cov0" title="0">{
                wm.Tokens = make(map[string]*Token)
        }</span>
        <span class="cov8" title="1">wm.Tokens[token.ID] = token</span>
}

// RemoveToken supprime un token de la m√©moire
func (wm *WorkingMemory) RemoveToken(tokenID string) <span class="cov0" title="0">{
        delete(wm.Tokens, tokenID)
}</span>

// GetTokens retourne tous les tokens de la m√©moire
func (wm *WorkingMemory) GetTokens() []*Token <span class="cov8" title="1">{
        tokens := make([]*Token, 0, len(wm.Tokens))
        for _, token := range wm.Tokens </span><span class="cov8" title="1">{
                tokens = append(tokens, token)
        }</span>
        <span class="cov8" title="1">return tokens</span>
}

// GetFactsByVariable retourne les faits associ√©s aux variables sp√©cifi√©es
func (wm *WorkingMemory) GetFactsByVariable(variables []string) []*Fact <span class="cov0" title="0">{
        // Pour l'instant, retourne tous les faits (impl√©mentation simplifi√©e)
        return wm.GetFacts()
}</span>

// GetTokensByVariable retourne les tokens associ√©s aux variables sp√©cifi√©es
func (wm *WorkingMemory) GetTokensByVariable(variables []string) []*Token <span class="cov0" title="0">{
        // Pour l'instant, retourne tous les tokens (impl√©mentation simplifi√©e)
        return wm.GetTokens()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "io"
        "log"
        "os"
        "sync"
)

// LogLevel repr√©sente le niveau de logging
type LogLevel int

const (
        // LogLevelSilent d√©sactive tous les logs
        LogLevelSilent LogLevel = iota
        // LogLevelError affiche uniquement les erreurs
        LogLevelError
        // LogLevelWarn affiche warnings et erreurs
        LogLevelWarn
        // LogLevelInfo affiche info, warnings et erreurs
        LogLevelInfo
        // LogLevelDebug affiche tous les logs incluant debug
        LogLevelDebug
)

// Logger est un logger configurable pour RETE
type Logger struct {
        level  LogLevel
        output io.Writer
        mu     sync.RWMutex
}

var (
        // DefaultLogger est le logger global par d√©faut
        DefaultLogger *Logger
        once          sync.Once
)

func init() <span class="cov8" title="1">{
        DefaultLogger = NewLogger(LogLevelInfo, os.Stdout)
}</span>

// NewLogger cr√©e un nouveau logger avec le niveau sp√©cifi√©
func NewLogger(level LogLevel, output io.Writer) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                level:  level,
                output: output,
        }
}</span>

// SetLevel change le niveau de logging
func (l *Logger) SetLevel(level LogLevel) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.level = level
}</span>

// GetLevel retourne le niveau de logging actuel
func (l *Logger) GetLevel() LogLevel <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        return l.level
}</span>

// Debug log un message de debug
func (l *Logger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelDebug </span><span class="cov0" title="0">{
                l.log("DEBUG", format, args...)
        }</span>
}

// Info log un message informatif
func (l *Logger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelInfo </span><span class="cov0" title="0">{
                l.log("INFO", format, args...)
        }</span>
}

// Warn log un avertissement
func (l *Logger) Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelWarn </span><span class="cov0" title="0">{
                l.log("WARN", format, args...)
        }</span>
}

// Error log une erreur
func (l *Logger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        level := l.level
        l.mu.RUnlock()

        if level &gt;= LogLevelError </span><span class="cov0" title="0">{
                l.log("ERROR", format, args...)
        }</span>
}

// log est la m√©thode interne de logging
func (l *Logger) log(level string, format string, args ...interface{}) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, args...)
        log.SetOutput(l.output)
        log.SetFlags(0) // Pas de timestamp par d√©faut pour compatibilit√© avec les tests
        log.Printf("%s", message)
}</span>

// SetGlobalLogLevel change le niveau du logger global
func SetGlobalLogLevel(level LogLevel) <span class="cov0" title="0">{
        DefaultLogger.SetLevel(level)
}</span>

// GetGlobalLogLevel retourne le niveau du logger global
func GetGlobalLogLevel() LogLevel <span class="cov0" title="0">{
        return DefaultLogger.GetLevel()
}</span>

// Helper functions pour utiliser le logger global

// Debug log un message de debug avec le logger global
func Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Debug(format, args...)
}</span>

// Info log un message informatif avec le logger global
func Info(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Info(format, args...)
}</span>

// Warn log un avertissement avec le logger global
func Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Warn(format, args...)
}</span>

// Error log une erreur avec le logger global
func Error(format string, args ...interface{}) <span class="cov0" title="0">{
        DefaultLogger.Error(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "container/list"
        "sync"
        "time"
)

// LRUCache est un cache LRU (Least Recently Used) thread-safe
type LRUCache struct {
        capacity int
        ttl      time.Duration
        items    map[string]*lruItem
        order    *list.List
        mutex    sync.RWMutex

        // Statistiques
        hits      int64
        misses    int64
        evictions int64
        sets      int64
}

// lruItem repr√©sente un √©l√©ment dans le cache
type lruItem struct {
        key       string
        value     interface{}
        element   *list.Element
        timestamp time.Time
}

// NewLRUCache cr√©e un nouveau cache LRU
func NewLRUCache(capacity int, ttl time.Duration) *LRUCache <span class="cov8" title="1">{
        if capacity &lt;= 0 </span><span class="cov0" title="0">{
                capacity = 1000 // Capacit√© par d√©faut
        }</span>

        <span class="cov8" title="1">return &amp;LRUCache{
                capacity: capacity,
                ttl:      ttl,
                items:    make(map[string]*lruItem),
                order:    list.New(),
        }</span>
}

// Get r√©cup√®re une valeur du cache
func (c *LRUCache) Get(key string) (interface{}, bool) <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        item, exists := c.items[key]
        if !exists </span><span class="cov8" title="1">{
                c.misses++
                return nil, false
        }</span>

        // V√©rifier l'expiration
        <span class="cov8" title="1">if c.ttl &gt; 0 &amp;&amp; time.Since(item.timestamp) &gt; c.ttl </span><span class="cov0" title="0">{
                c.removeItem(item)
                c.misses++
                return nil, false
        }</span>

        // D√©placer vers le front (le plus r√©cemment utilis√©)
        <span class="cov8" title="1">c.order.MoveToFront(item.element)
        c.hits++
        return item.value, true</span>
}

// Set ajoute ou met √† jour une valeur dans le cache
func (c *LRUCache) Set(key string, value interface{}) <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        c.sets++

        // Si l'√©l√©ment existe d√©j√†, le mettre √† jour
        if item, exists := c.items[key]; exists </span><span class="cov0" title="0">{
                item.value = value
                item.timestamp = time.Now()
                c.order.MoveToFront(item.element)
                return
        }</span>

        // √âviction si capacit√© atteinte
        <span class="cov8" title="1">if c.order.Len() &gt;= c.capacity </span><span class="cov0" title="0">{
                c.evictOldest()
        }</span>

        // Cr√©er le nouvel √©l√©ment
        <span class="cov8" title="1">item := &amp;lruItem{
                key:       key,
                value:     value,
                timestamp: time.Now(),
        }
        item.element = c.order.PushFront(item)
        c.items[key] = item</span>
}

// Delete supprime une valeur du cache
func (c *LRUCache) Delete(key string) bool <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        item, exists := c.items[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">c.removeItem(item)
        return true</span>
}

// Clear vide compl√®tement le cache
func (c *LRUCache) Clear() <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        c.items = make(map[string]*lruItem)
        c.order.Init()
}</span>

// Len retourne le nombre d'√©l√©ments dans le cache
func (c *LRUCache) Len() int <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()
        return len(c.items)
}</span>

// Capacity retourne la capacit√© maximale du cache
func (c *LRUCache) Capacity() int <span class="cov0" title="0">{
        return c.capacity
}</span>

// GetStats retourne les statistiques du cache
func (c *LRUCache) GetStats() LRUCacheStats <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        return LRUCacheStats{
                Hits:      c.hits,
                Misses:    c.misses,
                Evictions: c.evictions,
                Sets:      c.sets,
                Size:      len(c.items),
                Capacity:  c.capacity,
        }
}</span>

// GetHitRate retourne le taux de hits (0.0 √† 1.0)
func (c *LRUCache) GetHitRate() float64 <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        total := c.hits + c.misses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(c.hits) / float64(total)</span>
}

// ResetStats r√©initialise les statistiques
func (c *LRUCache) ResetStats() <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        c.hits = 0
        c.misses = 0
        c.evictions = 0
        c.sets = 0
}</span>

// CleanExpired supprime tous les √©l√©ments expir√©s
func (c *LRUCache) CleanExpired() int <span class="cov0" title="0">{
        if c.ttl == 0 </span><span class="cov0" title="0">{
                return 0 // Pas d'expiration configur√©e
        }</span>

        <span class="cov0" title="0">c.mutex.Lock()
        defer c.mutex.Unlock()

        now := time.Now()
        expired := make([]*lruItem, 0)

        // Identifier les √©l√©ments expir√©s
        for _, item := range c.items </span><span class="cov0" title="0">{
                if now.Sub(item.timestamp) &gt; c.ttl </span><span class="cov0" title="0">{
                        expired = append(expired, item)
                }</span>
        }

        // Supprimer les √©l√©ments expir√©s
        <span class="cov0" title="0">for _, item := range expired </span><span class="cov0" title="0">{
                c.removeItem(item)
        }</span>

        <span class="cov0" title="0">return len(expired)</span>
}

// Keys retourne toutes les cl√©s du cache (dans l'ordre LRU)
func (c *LRUCache) Keys() []string <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        keys := make([]string, 0, len(c.items))
        for e := c.order.Front(); e != nil; e = e.Next() </span><span class="cov0" title="0">{
                item := e.Value.(*lruItem)
                keys = append(keys, item.key)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Oldest retourne la cl√© la plus ancienne (prochaine √† √™tre √©vinc√©e)
func (c *LRUCache) Oldest() (string, bool) <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        if c.order.Len() == 0 </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">item := c.order.Back().Value.(*lruItem)
        return item.key, true</span>
}

// Newest retourne la cl√© la plus r√©cente
func (c *LRUCache) Newest() (string, bool) <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        if c.order.Len() == 0 </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">item := c.order.Front().Value.(*lruItem)
        return item.key, true</span>
}

// Contains v√©rifie si une cl√© existe dans le cache sans la marquer comme utilis√©e
func (c *LRUCache) Contains(key string) bool <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        item, exists := c.items[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // V√©rifier l'expiration
        <span class="cov0" title="0">if c.ttl &gt; 0 &amp;&amp; time.Since(item.timestamp) &gt; c.ttl </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// evictOldest √©vince l'√©l√©ment le plus ancien (non thread-safe, doit √™tre appel√© avec le lock)
func (c *LRUCache) evictOldest() <span class="cov0" title="0">{
        if c.order.Len() == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">oldest := c.order.Back()
        if oldest != nil </span><span class="cov0" title="0">{
                item := oldest.Value.(*lruItem)
                c.removeItem(item)
                c.evictions++
        }</span>
}

// removeItem supprime un √©l√©ment du cache (non thread-safe, doit √™tre appel√© avec le lock)
func (c *LRUCache) removeItem(item *lruItem) <span class="cov0" title="0">{
        c.order.Remove(item.element)
        delete(c.items, item.key)
}</span>

// LRUCacheStats contient les statistiques du cache LRU
type LRUCacheStats struct {
        Hits      int64 `json:"hits"`
        Misses    int64 `json:"misses"`
        Evictions int64 `json:"evictions"`
        Sets      int64 `json:"sets"`
        Size      int   `json:"size"`
        Capacity  int   `json:"capacity"`
}

// HitRate retourne le taux de hits
func (s LRUCacheStats) HitRate() float64 <span class="cov0" title="0">{
        total := s.Hits + s.Misses
        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(s.Hits) / float64(total)</span>
}

// EvictionRate retourne le taux d'√©victions par rapport aux sets
func (s LRUCacheStats) EvictionRate() float64 <span class="cov0" title="0">{
        if s.Sets == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(s.Evictions) / float64(s.Sets)</span>
}

// FillRate retourne le taux de remplissage du cache (0.0 √† 1.0)
func (s LRUCacheStats) FillRate() float64 <span class="cov0" title="0">{
        if s.Capacity == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return float64(s.Size) / float64(s.Capacity)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "sort"
        "strings"

        "github.com/treivax/tsd/constraint"
)

// NestedORComplexity repr√©sente la complexit√© d'une expression OR imbriqu√©e
type NestedORComplexity int

const (
        // ComplexitySimple indique une expression sans imbrication
        ComplexitySimple NestedORComplexity = iota
        // ComplexityFlat indique des OR au m√™me niveau (A OR B OR C)
        ComplexityFlat
        // ComplexityNestedOR indique des OR imbriqu√©s (A OR (B OR C))
        ComplexityNestedOR
        // ComplexityMixedANDOR indique un m√©lange AND/OR ((A OR B) AND C)
        ComplexityMixedANDOR
        // ComplexityDNFCandidate indique une structure candidate pour DNF ((A OR B) AND (C OR D))
        ComplexityDNFCandidate
)

// NestedORAnalysis contient l'analyse d'une expression avec OR imbriqu√©s
type NestedORAnalysis struct {
        Complexity         NestedORComplexity
        NestingDepth       int
        RequiresDNF        bool
        RequiresFlattening bool
        ORTermCount        int
        ANDTermCount       int
        OptimizationHint   string
}

// AnalyzeNestedOR analyse la complexit√© d'une expression avec OR potentiellement imbriqu√©s
func AnalyzeNestedOR(expr interface{}) (*NestedORAnalysis, error) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression nil")
        }</span>

        <span class="cov0" title="0">analysis := &amp;NestedORAnalysis{
                Complexity:   ComplexitySimple,
                NestingDepth: 0,
        }

        switch e := expr.(type) </span>{
        case constraint.LogicalExpression:<span class="cov0" title="0">
                analyzeLogicalExpressionNesting(e, analysis, 0)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                analyzeMapExpressionNesting(e, analysis, 0)</span>
        default:<span class="cov0" title="0">
                // Expression simple, pas d'imbrication
                return analysis, nil</span>
        }

        // D√©terminer si transformation DNF est recommand√©e
        <span class="cov0" title="0">if analysis.Complexity == ComplexityDNFCandidate </span><span class="cov0" title="0">{
                analysis.RequiresDNF = true
                analysis.OptimizationHint = "DNF transformation recommended for better node sharing"
        }</span>

        // D√©terminer si aplatissement est n√©cessaire
        <span class="cov0" title="0">if analysis.Complexity == ComplexityNestedOR &amp;&amp; analysis.NestingDepth &gt; 0 </span><span class="cov0" title="0">{
                analysis.RequiresFlattening = true
                analysis.OptimizationHint = "OR flattening required to normalize expression"
        }</span>

        <span class="cov0" title="0">return analysis, nil</span>
}

// analyzeLogicalExpressionNesting analyse l'imbrication d'une LogicalExpression
func analyzeLogicalExpressionNesting(expr constraint.LogicalExpression, analysis *NestedORAnalysis, depth int) <span class="cov0" title="0">{
        if depth &gt; analysis.NestingDepth </span><span class="cov0" title="0">{
                analysis.NestingDepth = depth
        }</span>

        <span class="cov0" title="0">hasOR := false
        hasAND := false

        // Analyser les op√©rations
        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                opStr := strings.ToUpper(op.Op)

                if opStr == "OR" || opStr == "||" </span><span class="cov0" title="0">{
                        hasOR = true
                        analysis.ORTermCount++
                }</span> else<span class="cov0" title="0"> if opStr == "AND" || opStr == "&amp;&amp;" </span><span class="cov0" title="0">{
                        hasAND = true
                        analysis.ANDTermCount++
                }</span>

                // R√©cursion pour analyser les sous-expressions
                <span class="cov0" title="0">if rightLogical, ok := op.Right.(constraint.LogicalExpression); ok </span><span class="cov0" title="0">{
                        analyzeLogicalExpressionNesting(rightLogical, analysis, depth+1)
                }</span>
        }

        // Analyser le left √©galement
        <span class="cov0" title="0">if leftLogical, ok := expr.Left.(constraint.LogicalExpression); ok </span><span class="cov0" title="0">{
                analyzeLogicalExpressionNesting(leftLogical, analysis, depth+1)
        }</span>

        // D√©terminer la complexit√©
        <span class="cov0" title="0">if hasOR &amp;&amp; hasAND </span><span class="cov0" title="0">{
                // V√©rifier si c'est un candidat DNF (plusieurs groupes OR li√©s par AND)
                if analysis.ORTermCount &gt;= 2 &amp;&amp; analysis.ANDTermCount &gt;= 1 </span><span class="cov0" title="0">{
                        if analysis.Complexity &lt; ComplexityDNFCandidate </span><span class="cov0" title="0">{
                                analysis.Complexity = ComplexityDNFCandidate
                        }</span>
                } else<span class="cov0" title="0"> if analysis.Complexity &lt; ComplexityMixedANDOR </span><span class="cov0" title="0">{
                        analysis.Complexity = ComplexityMixedANDOR
                }</span>
        } else<span class="cov0" title="0"> if hasOR </span><span class="cov0" title="0">{
                // V√©rifier si c'est un OR imbriqu√© (profondeur &gt; 0 signifie imbrication)
                if depth &gt; 0 </span><span class="cov0" title="0">{
                        if analysis.Complexity &lt; ComplexityNestedOR </span><span class="cov0" title="0">{
                                analysis.Complexity = ComplexityNestedOR
                        }</span>
                } else<span class="cov0" title="0"> if analysis.Complexity &lt; ComplexityFlat </span><span class="cov0" title="0">{
                        analysis.Complexity = ComplexityFlat
                }</span>
        }
}

// analyzeMapExpressionNesting analyse l'imbrication d'une expression map
func analyzeMapExpressionNesting(expr map[string]interface{}, analysis *NestedORAnalysis, depth int) <span class="cov0" title="0">{
        if depth &gt; analysis.NestingDepth </span><span class="cov0" title="0">{
                analysis.NestingDepth = depth
        }</span>

        <span class="cov0" title="0">hasOR := false
        hasAND := false

        // Analyser les op√©rations
        if operations, ok := expr["operations"]; ok </span><span class="cov0" title="0">{
                if opsList, ok := operations.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, opInterface := range opsList </span><span class="cov0" title="0">{
                                if opMap, ok := opInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if op, ok := opMap["op"].(string); ok </span><span class="cov0" title="0">{
                                                opStr := strings.ToUpper(op)

                                                if opStr == "OR" || opStr == "||" </span><span class="cov0" title="0">{
                                                        hasOR = true
                                                        analysis.ORTermCount++
                                                }</span> else<span class="cov0" title="0"> if opStr == "AND" || opStr == "&amp;&amp;" </span><span class="cov0" title="0">{
                                                        hasAND = true
                                                        analysis.ANDTermCount++
                                                }</span>

                                                // R√©cursion sur right
                                                <span class="cov0" title="0">if right, ok := opMap["right"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                        if rightType, ok := right["type"].(string); ok &amp;&amp; rightType == "logicalExpr" </span><span class="cov0" title="0">{
                                                                analyzeMapExpressionNesting(right, analysis, depth+1)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // Analyser left
        <span class="cov0" title="0">if left, ok := expr["left"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if leftType, ok := left["type"].(string); ok &amp;&amp; leftType == "logicalExpr" </span><span class="cov0" title="0">{
                        analyzeMapExpressionNesting(left, analysis, depth+1)
                }</span>
        }

        // D√©terminer la complexit√©
        <span class="cov0" title="0">if hasOR &amp;&amp; hasAND </span><span class="cov0" title="0">{
                // V√©rifier si c'est un candidat DNF (plusieurs groupes OR li√©s par AND)
                if analysis.ORTermCount &gt;= 2 &amp;&amp; analysis.ANDTermCount &gt;= 1 </span><span class="cov0" title="0">{
                        if analysis.Complexity &lt; ComplexityDNFCandidate </span><span class="cov0" title="0">{
                                analysis.Complexity = ComplexityDNFCandidate
                        }</span>
                } else<span class="cov0" title="0"> if analysis.Complexity &lt; ComplexityMixedANDOR </span><span class="cov0" title="0">{
                        analysis.Complexity = ComplexityMixedANDOR
                }</span>
        } else<span class="cov0" title="0"> if hasOR </span><span class="cov0" title="0">{
                // V√©rifier si c'est un OR imbriqu√© (profondeur &gt; 0 signifie imbrication)
                if depth &gt; 0 </span><span class="cov0" title="0">{
                        if analysis.Complexity &lt; ComplexityNestedOR </span><span class="cov0" title="0">{
                                analysis.Complexity = ComplexityNestedOR
                        }</span>
                } else<span class="cov0" title="0"> if analysis.Complexity &lt; ComplexityFlat </span><span class="cov0" title="0">{
                        analysis.Complexity = ComplexityFlat
                }</span>
        }
}

// FlattenNestedOR aplatit les OR imbriqu√©s (A OR (B OR C)) en (A OR B OR C)
func FlattenNestedOR(expr interface{}) (interface{}, error) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression nil")
        }</span>

        <span class="cov0" title="0">switch e := expr.(type) </span>{
        case constraint.LogicalExpression:<span class="cov0" title="0">
                return flattenLogicalExpression(e)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return flattenMapExpression(e)</span>
        default:<span class="cov0" title="0">
                // Expression simple, rien √† aplatir
                return expr, nil</span>
        }
}

// flattenLogicalExpression aplatit une LogicalExpression avec OR imbriqu√©s
func flattenLogicalExpression(expr constraint.LogicalExpression) (constraint.LogicalExpression, error) <span class="cov0" title="0">{
        // Collecter tous les termes OR √† tous les niveaux
        orTerms := collectORTermsRecursive(expr)

        if len(orTerms) &lt;= 1 </span><span class="cov0" title="0">{
                return expr, nil
        }</span>

        // Reconstruire une expression plate
        <span class="cov0" title="0">flattened := constraint.LogicalExpression{
                Type: "logicalExpr",
                Left: orTerms[0],
        }

        for i := 1; i &lt; len(orTerms); i++ </span><span class="cov0" title="0">{
                flattened.Operations = append(flattened.Operations, constraint.LogicalOperation{
                        Op:    "OR",
                        Right: orTerms[i],
                })
        }</span>

        <span class="cov0" title="0">return flattened, nil</span>
}

// collectORTermsRecursive collecte tous les termes OR de mani√®re r√©cursive
func collectORTermsRecursive(expr constraint.LogicalExpression) []interface{} <span class="cov0" title="0">{
        terms := []interface{}{}

        // Traiter left
        if leftLogical, ok := expr.Left.(constraint.LogicalExpression); ok </span><span class="cov0" title="0">{
                // Si left est lui-m√™me une expression OR, r√©curser
                if hasOnlyOR(leftLogical) </span><span class="cov0" title="0">{
                        terms = append(terms, collectORTermsRecursive(leftLogical)...)
                }</span> else<span class="cov0" title="0"> {
                        terms = append(terms, expr.Left)
                }</span>
        } else<span class="cov0" title="0"> {
                terms = append(terms, expr.Left)
        }</span>

        // Traiter operations
        <span class="cov0" title="0">for _, op := range expr.Operations </span><span class="cov0" title="0">{
                opStr := strings.ToUpper(op.Op)

                if opStr == "OR" || opStr == "||" </span><span class="cov0" title="0">{
                        if rightLogical, ok := op.Right.(constraint.LogicalExpression); ok </span><span class="cov0" title="0">{
                                // Si right est lui-m√™me une expression OR, r√©curser
                                if hasOnlyOR(rightLogical) </span><span class="cov0" title="0">{
                                        terms = append(terms, collectORTermsRecursive(rightLogical)...)
                                }</span> else<span class="cov0" title="0"> {
                                        terms = append(terms, op.Right)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                terms = append(terms, op.Right)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Pas un OR, ne pas aplatir
                        terms = append(terms, op.Right)
                }</span>
        }

        <span class="cov0" title="0">return terms</span>
}

// hasOnlyOR v√©rifie si une expression ne contient que des op√©rateurs OR
func hasOnlyOR(expr constraint.LogicalExpression) bool <span class="cov0" title="0">{
        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                opStr := strings.ToUpper(op.Op)
                if opStr != "OR" &amp;&amp; opStr != "||" </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// flattenMapExpression aplatit une expression map avec OR imbriqu√©s
func flattenMapExpression(expr map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        orTerms := collectORTermsFromMap(expr)

        if len(orTerms) &lt;= 1 </span><span class="cov0" title="0">{
                return expr, nil
        }</span>

        // Reconstruire une expression map plate
        <span class="cov0" title="0">flattened := map[string]interface{}{
                "type": "logicalExpr",
                "left": orTerms[0],
        }

        operations := make([]map[string]interface{}, 0)
        for i := 1; i &lt; len(orTerms); i++ </span><span class="cov0" title="0">{
                operations = append(operations, map[string]interface{}{
                        "op":    "OR",
                        "right": orTerms[i],
                })
        }</span>

        <span class="cov0" title="0">if len(operations) &gt; 0 </span><span class="cov0" title="0">{
                flattened["operations"] = operations
        }</span>

        <span class="cov0" title="0">return flattened, nil</span>
}

// collectORTermsFromMap collecte les termes OR d'une expression map
func collectORTermsFromMap(expr map[string]interface{}) []interface{} <span class="cov0" title="0">{
        terms := []interface{}{}

        // Traiter left
        if left, ok := expr["left"]; ok </span><span class="cov0" title="0">{
                if leftMap, ok := left.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if leftType, ok := leftMap["type"].(string); ok &amp;&amp; leftType == "logicalExpr" </span><span class="cov0" title="0">{
                                if hasOnlyORInMap(leftMap) </span><span class="cov0" title="0">{
                                        terms = append(terms, collectORTermsFromMap(leftMap)...)
                                }</span> else<span class="cov0" title="0"> {
                                        terms = append(terms, left)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                terms = append(terms, left)
                        }</span>
                } else<span class="cov0" title="0"> {
                        terms = append(terms, left)
                }</span>
        }

        // Traiter operations
        <span class="cov0" title="0">if operations, ok := expr["operations"]; ok </span><span class="cov0" title="0">{
                if opsList, ok := operations.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, opInterface := range opsList </span><span class="cov0" title="0">{
                                if opMap, ok := opInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if op, ok := opMap["op"].(string); ok </span><span class="cov0" title="0">{
                                                opStr := strings.ToUpper(op)

                                                if opStr == "OR" || opStr == "||" </span><span class="cov0" title="0">{
                                                        if right, ok := opMap["right"]; ok </span><span class="cov0" title="0">{
                                                                if rightMap, ok := right.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                                        if rightType, ok := rightMap["type"].(string); ok &amp;&amp; rightType == "logicalExpr" </span><span class="cov0" title="0">{
                                                                                if hasOnlyORInMap(rightMap) </span><span class="cov0" title="0">{
                                                                                        terms = append(terms, collectORTermsFromMap(rightMap)...)
                                                                                }</span> else<span class="cov0" title="0"> {
                                                                                        terms = append(terms, right)
                                                                                }</span>
                                                                        } else<span class="cov0" title="0"> {
                                                                                terms = append(terms, right)
                                                                        }</span>
                                                                } else<span class="cov0" title="0"> {
                                                                        terms = append(terms, right)
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return terms</span>
}

// hasOnlyORInMap v√©rifie si une expression map ne contient que des OR
func hasOnlyORInMap(expr map[string]interface{}) bool <span class="cov0" title="0">{
        if operations, ok := expr["operations"]; ok </span><span class="cov0" title="0">{
                if opsList, ok := operations.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, opInterface := range opsList </span><span class="cov0" title="0">{
                                if opMap, ok := opInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if op, ok := opMap["op"].(string); ok </span><span class="cov0" title="0">{
                                                opStr := strings.ToUpper(op)
                                                if opStr != "OR" &amp;&amp; opStr != "||" </span><span class="cov0" title="0">{
                                                        return false
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">return true</span>
}

// TransformToDNF transforme une expression en forme normale disjonctive (DNF)
// Exemple: (A OR B) AND (C OR D) -&gt; (A AND C) OR (A AND D) OR (B AND C) OR (B AND D)
func TransformToDNF(expr interface{}) (interface{}, error) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression nil")
        }</span>

        // Analyser d'abord la complexit√©
        <span class="cov0" title="0">analysis, err := AnalyzeNestedOR(expr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur analyse: %w", err)
        }</span>

        // Si pas besoin de DNF, retourner tel quel
        <span class="cov0" title="0">if !analysis.RequiresDNF &amp;&amp; analysis.Complexity != ComplexityDNFCandidate </span><span class="cov0" title="0">{
                return expr, nil
        }</span>

        <span class="cov0" title="0">switch e := expr.(type) </span>{
        case constraint.LogicalExpression:<span class="cov0" title="0">
                return transformLogicalExpressionToDNF(e)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return transformMapToDNF(e)</span>
        default:<span class="cov0" title="0">
                return expr, nil</span>
        }
}

// transformLogicalExpressionToDNF transforme une LogicalExpression en DNF
func transformLogicalExpressionToDNF(expr constraint.LogicalExpression) (constraint.LogicalExpression, error) <span class="cov0" title="0">{
        // Extraire les termes AND et OR
        andGroups := extractANDGroups(expr)

        if len(andGroups) &lt;= 1 </span><span class="cov0" title="0">{
                // Pas de structure AND/OR complexe
                return expr, nil
        }</span>

        // G√©n√©rer le produit cart√©sien pour cr√©er la DNF
        <span class="cov0" title="0">dnfTerms := generateDNFTerms(andGroups)

        // Normaliser et trier les termes DNF
        normalizedTerms := normalizeDNFTerms(dnfTerms)

        // Construire l'expression DNF finale
        if len(normalizedTerms) == 0 </span><span class="cov0" title="0">{
                return expr, fmt.Errorf("aucun terme DNF g√©n√©r√©")
        }</span>

        <span class="cov0" title="0">dnfExpr := constraint.LogicalExpression{
                Type: "logicalExpr",
                Left: normalizedTerms[0],
        }

        for i := 1; i &lt; len(normalizedTerms); i++ </span><span class="cov0" title="0">{
                dnfExpr.Operations = append(dnfExpr.Operations, constraint.LogicalOperation{
                        Op:    "OR",
                        Right: normalizedTerms[i],
                })
        }</span>

        <span class="cov0" title="0">return dnfExpr, nil</span>
}

// extractANDGroups extrait les groupes de termes li√©s par AND
func extractANDGroups(expr constraint.LogicalExpression) [][]interface{} <span class="cov0" title="0">{
        groups := [][]interface{}{}
        currentGroup := []interface{}{expr.Left}

        for _, op := range expr.Operations </span><span class="cov0" title="0">{
                opStr := strings.ToUpper(op.Op)

                if opStr == "AND" || opStr == "&amp;&amp;" </span><span class="cov0" title="0">{
                        currentGroup = append(currentGroup, op.Right)
                }</span> else<span class="cov0" title="0"> if opStr == "OR" || opStr == "||" </span><span class="cov0" title="0">{
                        // Nouveau groupe
                        if len(currentGroup) &gt; 0 </span><span class="cov0" title="0">{
                                groups = append(groups, currentGroup)
                        }</span>
                        <span class="cov0" title="0">currentGroup = []interface{}{op.Right}</span>
                }
        }

        <span class="cov0" title="0">if len(currentGroup) &gt; 0 </span><span class="cov0" title="0">{
                groups = append(groups, currentGroup)
        }</span>

        <span class="cov0" title="0">return groups</span>
}

// generateDNFTerms g√©n√®re les termes DNF par produit cart√©sien
func generateDNFTerms(andGroups [][]interface{}) [][]interface{} <span class="cov0" title="0">{
        if len(andGroups) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extraire les termes OR de chaque groupe AND
        <span class="cov0" title="0">orTermsByGroup := make([][][]interface{}, len(andGroups))

        for i, group := range andGroups </span><span class="cov0" title="0">{
                orTermsByGroup[i] = [][]interface{}{}
                for _, term := range group </span><span class="cov0" title="0">{
                        if logicalTerm, ok := term.(constraint.LogicalExpression); ok </span><span class="cov0" title="0">{
                                // Si le terme est une expression OR, extraire ses termes
                                orTerms := collectORTermsRecursive(logicalTerm)
                                orTermsByGroup[i] = append(orTermsByGroup[i], orTerms)
                        }</span> else<span class="cov0" title="0"> {
                                // Terme simple
                                orTermsByGroup[i] = append(orTermsByGroup[i], []interface{}{term})
                        }</span>
                }
        }

        // G√©n√©rer le produit cart√©sien
        <span class="cov0" title="0">result := [][]interface{}{{}}

        for _, orTerms := range orTermsByGroup </span><span class="cov0" title="0">{
                for _, termList := range orTerms </span><span class="cov0" title="0">{
                        newResult := [][]interface{}{}
                        for _, existing := range result </span><span class="cov0" title="0">{
                                for _, term := range termList </span><span class="cov0" title="0">{
                                        combination := append([]interface{}{}, existing...)
                                        combination = append(combination, term)
                                        newResult = append(newResult, combination)
                                }</span>
                        }
                        <span class="cov0" title="0">result = newResult</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// normalizeDNFTerms normalise et trie les termes DNF
func normalizeDNFTerms(dnfTerms [][]interface{}) []interface{} <span class="cov0" title="0">{
        normalized := make([]interface{}, 0, len(dnfTerms))

        for _, terms := range dnfTerms </span><span class="cov0" title="0">{
                if len(terms) == 1 </span><span class="cov0" title="0">{
                        // Terme simple
                        normalized = append(normalized, terms[0])
                }</span> else<span class="cov0" title="0"> {
                        // Terme AND compos√© - cr√©er une LogicalExpression
                        andExpr := constraint.LogicalExpression{
                                Type: "logicalExpr",
                                Left: terms[0],
                        }

                        for i := 1; i &lt; len(terms); i++ </span><span class="cov0" title="0">{
                                andExpr.Operations = append(andExpr.Operations, constraint.LogicalOperation{
                                        Op:    "AND",
                                        Right: terms[i],
                                })
                        }</span>

                        <span class="cov0" title="0">normalized = append(normalized, andExpr)</span>
                }
        }

        // Trier par repr√©sentation canonique
        <span class="cov0" title="0">type termWithCanonical struct {
                term      interface{}
                canonical string
        }

        termsWithCanonical := make([]termWithCanonical, len(normalized))
        for i, term := range normalized </span><span class="cov0" title="0">{
                canonical := canonicalValue(term)
                termsWithCanonical[i] = termWithCanonical{
                        term:      term,
                        canonical: canonical,
                }
        }</span>

        <span class="cov0" title="0">sort.Slice(termsWithCanonical, func(i, j int) bool </span><span class="cov0" title="0">{
                return termsWithCanonical[i].canonical &lt; termsWithCanonical[j].canonical
        }</span>)

        <span class="cov0" title="0">result := make([]interface{}, len(termsWithCanonical))
        for i, twc := range termsWithCanonical </span><span class="cov0" title="0">{
                result[i] = twc.term
        }</span>

        <span class="cov0" title="0">return result</span>
}

// transformMapToDNF transforme une expression map en DNF
func transformMapToDNF(expr map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Conversion map -&gt; LogicalExpression pour simplifier
        // (impl√©mentation simplifi√©e, peut √™tre √©tendue)
        return expr, nil
}</span>

// NormalizeNestedOR normalise une expression avec OR imbriqu√©s
// Combine aplatissement et normalisation canonique
func NormalizeNestedOR(expr interface{}) (interface{}, error) <span class="cov0" title="0">{
        if expr == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression nil")
        }</span>

        // √âtape 1: Analyser la structure
        <span class="cov0" title="0">analysis, err := AnalyzeNestedOR(expr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur analyse: %w", err)
        }</span>

        // √âtape 2: Aplatir si n√©cessaire
        <span class="cov0" title="0">if analysis.RequiresFlattening </span><span class="cov0" title="0">{
                expr, err = FlattenNestedOR(expr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur aplatissement: %w", err)
                }</span>
        }

        // √âtape 3: Transformer en DNF si n√©cessaire
        <span class="cov0" title="0">if analysis.RequiresDNF </span><span class="cov0" title="0">{
                expr, err = TransformToDNF(expr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("erreur transformation DNF: %w", err)
                }</span>
        }

        // √âtape 4: Normalisation canonique finale
        <span class="cov0" title="0">normalized, err := NormalizeORExpression(expr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("erreur normalisation: %w", err)
        }</span>

        <span class="cov0" title="0">return normalized, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
)

// ReteNetwork repr√©sente le r√©seau RETE complet
type ReteNetwork struct {
        RootNode            *RootNode                `json:"root_node"`
        TypeNodes           map[string]*TypeNode     `json:"type_nodes"`
        AlphaNodes          map[string]*AlphaNode    `json:"alpha_nodes"`
        BetaNodes           map[string]interface{}   `json:"beta_nodes"` // N≈ìuds Beta pour les jointures multi-faits
        TerminalNodes       map[string]*TerminalNode `json:"terminal_nodes"`
        Storage             Storage                  `json:"-"`
        Types               []TypeDefinition         `json:"types"`
        BetaBuilder         interface{}              `json:"-"` // Constructeur de r√©seau Beta (deprecated, use BetaChainBuilder)
        LifecycleManager    *LifecycleManager        `json:"-"` // Gestionnaire du cycle de vie des n≈ìuds
        AlphaSharingManager *AlphaSharingRegistry    `json:"-"` // Gestionnaire du partage des AlphaNodes
        BetaSharingRegistry BetaSharingRegistry      `json:"-"` // Gestionnaire du partage des JoinNodes
        BetaChainBuilder    *BetaChainBuilder        `json:"-"` // Constructeur de cha√Ænes beta avec partage
        ChainMetrics        *ChainBuildMetrics       `json:"-"` // M√©triques de performance pour la construction des cha√Ænes
        Config              *ChainPerformanceConfig  `json:"-"` // Configuration de performance
}

// NewReteNetwork cr√©e un nouveau r√©seau RETE avec la configuration par d√©faut
func NewReteNetwork(storage Storage) *ReteNetwork <span class="cov8" title="1">{
        return NewReteNetworkWithConfig(storage, DefaultChainPerformanceConfig())
}</span>

// NewReteNetworkWithConfig cr√©e un nouveau r√©seau RETE avec une configuration personnalis√©e
func NewReteNetworkWithConfig(storage Storage, config *ChainPerformanceConfig) *ReteNetwork <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultChainPerformanceConfig()
        }</span>

        <span class="cov8" title="1">rootNode := NewRootNode(storage)
        metrics := NewChainBuildMetrics()
        lifecycleManager := NewLifecycleManager()

        // Initialize Beta sharing if enabled
        var betaSharingRegistry BetaSharingRegistry
        var betaChainBuilder *BetaChainBuilder

        if config.BetaSharingEnabled </span><span class="cov8" title="1">{
                betaSharingConfig := BetaSharingConfig{
                        Enabled:                     true,
                        HashCacheSize:               config.BetaHashCacheMaxSize,
                        MaxSharedNodes:              10000, // Default limit
                        EnableMetrics:               true,
                        NormalizeOrder:              true,
                        EnableAdvancedNormalization: false,
                }
                betaSharingRegistry = NewBetaSharingRegistry(betaSharingConfig, lifecycleManager)
        }</span>

        <span class="cov8" title="1">network := &amp;ReteNetwork{
                RootNode:            rootNode,
                TypeNodes:           make(map[string]*TypeNode),
                AlphaNodes:          make(map[string]*AlphaNode),
                BetaNodes:           make(map[string]interface{}),
                TerminalNodes:       make(map[string]*TerminalNode),
                Storage:             storage,
                Types:               make([]TypeDefinition, 0),
                BetaBuilder:         nil, // Deprecated field, kept for backward compatibility
                LifecycleManager:    lifecycleManager,
                AlphaSharingManager: NewAlphaSharingRegistryWithConfig(config, metrics),
                BetaSharingRegistry: betaSharingRegistry,
                BetaChainBuilder:    betaChainBuilder, // Will be initialized lazily if needed
                ChainMetrics:        metrics,
                Config:              config,
        }

        // Initialize BetaChainBuilder if Beta sharing is enabled
        if betaSharingRegistry != nil </span><span class="cov8" title="1">{
                betaChainBuilder = NewBetaChainBuilderWithComponents(
                        network,
                        storage,
                        betaSharingRegistry,
                        lifecycleManager,
                )
                betaChainBuilder.SetOptimizationEnabled(true)
                betaChainBuilder.SetPrefixSharingEnabled(true)
                network.BetaChainBuilder = betaChainBuilder
        }</span>

        <span class="cov8" title="1">return network</span>
}

// GetChainMetrics retourne les m√©triques de performance pour la construction des cha√Ænes alpha
func (rn *ReteNetwork) GetChainMetrics() *ChainBuildMetrics <span class="cov0" title="0">{
        if rn.ChainMetrics == nil </span><span class="cov0" title="0">{
                rn.ChainMetrics = NewChainBuildMetrics()
        }</span>
        <span class="cov0" title="0">return rn.ChainMetrics</span>
}

// GetBetaSharingStats retourne les statistiques de partage des JoinNodes
func (rn *ReteNetwork) GetBetaSharingStats() *BetaSharingStats <span class="cov0" title="0">{
        if rn.BetaSharingRegistry == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return rn.BetaSharingRegistry.GetSharingStats()</span>
}

// GetBetaChainMetrics retourne les m√©triques de construction des cha√Ænes beta
func (rn *ReteNetwork) GetBetaChainMetrics() *BetaChainMetrics <span class="cov0" title="0">{
        if rn.BetaChainBuilder == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return rn.BetaChainBuilder.GetMetrics()</span>
}

// GetConfig retourne la configuration de performance
func (rn *ReteNetwork) GetConfig() *ChainPerformanceConfig <span class="cov0" title="0">{
        if rn.Config == nil </span><span class="cov0" title="0">{
                rn.Config = DefaultChainPerformanceConfig()
        }</span>
        <span class="cov0" title="0">return rn.Config</span>
}

// ResetChainMetrics r√©initialise toutes les m√©triques de performance
func (rn *ReteNetwork) ResetChainMetrics() <span class="cov0" title="0">{
        if rn.ChainMetrics != nil </span><span class="cov0" title="0">{
                rn.ChainMetrics.Reset()
        }</span>
        <span class="cov0" title="0">if rn.BetaChainBuilder != nil </span><span class="cov0" title="0">{
                rn.BetaChainBuilder.ResetMetrics()
        }</span>
}

// SubmitFact soumet un nouveau fait au r√©seau
func (rn *ReteNetwork) SubmitFact(fact *Fact) error <span class="cov8" title="1">{
        fmt.Printf("üî• Soumission d'un nouveau fait au r√©seau RETE: %s\n", fact.String())

        // Propager le fait depuis le n≈ìud racine
        return rn.RootNode.ActivateRight(fact)
}</span>

// SubmitFactsFromGrammar soumet plusieurs faits depuis la grammaire au r√©seau
func (rn *ReteNetwork) SubmitFactsFromGrammar(facts []map[string]interface{}) error <span class="cov0" title="0">{
        for i, factMap := range facts </span><span class="cov0" title="0">{
                // Convertir le map en Fact
                factID := fmt.Sprintf("fact_%d", i)
                if id, ok := factMap["id"].(string); ok </span><span class="cov0" title="0">{
                        factID = id
                }</span>

                <span class="cov0" title="0">factType := "unknown"
                if typ, ok := factMap["type"].(string); ok </span><span class="cov0" title="0">{
                        factType = typ
                }</span>

                <span class="cov0" title="0">fact := &amp;Fact{
                        ID:     factID,
                        Type:   factType,
                        Fields: make(map[string]interface{}),
                }

                // Copier tous les champs
                for key, value := range factMap </span><span class="cov0" title="0">{
                        if key != "id" &amp;&amp; key != "type" </span><span class="cov0" title="0">{
                                fact.Fields[key] = value
                        }</span>
                }

                <span class="cov0" title="0">if err := rn.SubmitFact(fact); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur soumission fait %s: %w", fact.ID, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RetractFact retire un fait du r√©seau et propage la r√©tractation
// factID doit √™tre l'identifiant interne (Type_ID)
func (rn *ReteNetwork) RetractFact(factID string) error <span class="cov0" title="0">{
        fmt.Printf("üóëÔ∏è  R√©tractation du fait: %s\n", factID)

        // V√©rifier que le fait existe dans le r√©seau
        memory := rn.RootNode.GetMemory()
        if _, exists := memory.GetFact(factID); !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("fait %s introuvable dans le r√©seau", factID)
        }</span>

        // Propager la r√©tractation depuis le n≈ìud racine
        <span class="cov0" title="0">return rn.RootNode.ActivateRetract(factID)</span>
}

// Reset clears the entire RETE network and resets it to an empty state.
// This removes all facts, rules, types, and network nodes.
// After calling Reset, the network is ready to accept new definitions from scratch.
func (rn *ReteNetwork) Reset() <span class="cov0" title="0">{
        fmt.Println("üßπ R√©initialisation compl√®te du r√©seau RETE")

        // Clear all node collections
        rn.TypeNodes = make(map[string]*TypeNode)
        rn.AlphaNodes = make(map[string]*AlphaNode)
        rn.BetaNodes = make(map[string]interface{})
        rn.TerminalNodes = make(map[string]*TerminalNode)
        rn.Types = make([]TypeDefinition, 0)
        rn.BetaBuilder = nil

        // Reset lifecycle manager
        if rn.LifecycleManager != nil </span><span class="cov0" title="0">{
                rn.LifecycleManager.Reset()
        }</span> else<span class="cov0" title="0"> {
                rn.LifecycleManager = NewLifecycleManager()
        }</span>

        // Reset alpha sharing manager
        <span class="cov0" title="0">if rn.AlphaSharingManager != nil </span><span class="cov0" title="0">{
                rn.AlphaSharingManager.Reset()
        }</span> else<span class="cov0" title="0"> {
                rn.AlphaSharingManager = NewAlphaSharingRegistry()
        }</span>

        // Recreate a fresh root node with the existing storage
        <span class="cov0" title="0">rn.RootNode = NewRootNode(rn.Storage)

        fmt.Println("‚úÖ R√©seau RETE r√©initialis√© avec succ√®s")</span>
}

// ClearMemory efface uniquement les m√©moires (faits et tokens) de tous les n≈ìuds
// sans d√©truire la structure du r√©seau
func (rn *ReteNetwork) ClearMemory() <span class="cov0" title="0">{
        fmt.Println("üßπ Nettoyage de la m√©moire du r√©seau RETE")

        // Clear TypeNode memories
        for _, typeNode := range rn.TypeNodes </span><span class="cov0" title="0">{
                typeNode.mutex.Lock()
                typeNode.Memory.Facts = make(map[string]*Fact)
                typeNode.Memory.Tokens = make(map[string]*Token)
                typeNode.mutex.Unlock()
        }</span>

        // Clear AlphaNode memories
        <span class="cov0" title="0">for _, alphaNode := range rn.AlphaNodes </span><span class="cov0" title="0">{
                alphaNode.mutex.Lock()
                alphaNode.Memory.Facts = make(map[string]*Fact)
                alphaNode.Memory.Tokens = make(map[string]*Token)
                alphaNode.mutex.Unlock()
        }</span>

        // Clear BetaNode memories (JoinNodes, etc.)
        <span class="cov0" title="0">for _, betaNode := range rn.BetaNodes </span><span class="cov0" title="0">{
                if node, ok := betaNode.(Node); ok </span><span class="cov0" title="0">{
                        node.GetMemory().Facts = make(map[string]*Fact)
                        node.GetMemory().Tokens = make(map[string]*Token)
                }</span>
        }

        // Clear TerminalNode memories
        <span class="cov0" title="0">for _, terminalNode := range rn.TerminalNodes </span><span class="cov0" title="0">{
                terminalNode.mutex.Lock()
                terminalNode.Memory.Facts = make(map[string]*Fact)
                terminalNode.Memory.Tokens = make(map[string]*Token)
                terminalNode.mutex.Unlock()
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ M√©moire du r√©seau RETE nettoy√©e avec succ√®s")</span>
}

// RemoveRule supprime une r√®gle et tous ses n≈ìuds qui ne sont plus utilis√©s
func (rn *ReteNetwork) RemoveRule(ruleID string) error <span class="cov8" title="1">{
        fmt.Printf("üóëÔ∏è  Suppression de la r√®gle: %s\n", ruleID)

        if rn.LifecycleManager == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("LifecycleManager non initialis√©")
        }</span>

        // R√©cup√©rer tous les n≈ìuds utilis√©s par cette r√®gle
        <span class="cov8" title="1">nodeIDs := rn.LifecycleManager.GetNodesForRule(ruleID)
        if len(nodeIDs) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("r√®gle %s non trouv√©e ou aucun n≈ìud associ√©", ruleID)
        }</span>

        <span class="cov0" title="0">fmt.Printf("   üìä N≈ìuds associ√©s √† la r√®gle: %d\n", len(nodeIDs))

        // D√©tecter si la r√®gle utilise une cha√Æne d'AlphaNodes
        hasChain := false
        for _, nodeID := range nodeIDs </span><span class="cov0" title="0">{
                if rn.isPartOfChain(nodeID) </span><span class="cov0" title="0">{
                        hasChain = true
                        break</span>
                }
        }

        // Utiliser la suppression optimis√©e pour les cha√Ænes
        <span class="cov0" title="0">if hasChain </span><span class="cov0" title="0">{
                fmt.Printf("   üîó Cha√Æne d'AlphaNodes d√©tect√©e, utilisation de la suppression optimis√©e\n")
                return rn.removeAlphaChain(ruleID)
        }</span>

        // Comportement classique pour les r√®gles simples
        <span class="cov0" title="0">return rn.removeSimpleRule(ruleID, nodeIDs)</span>
}

// removeSimpleRule supprime une r√®gle simple (sans cha√Æne)
func (rn *ReteNetwork) removeSimpleRule(ruleID string, nodeIDs []string) error <span class="cov0" title="0">{
        // Parcourir chaque n≈ìud et retirer la r√©f√©rence √† la r√®gle
        nodesToDelete := make([]string, 0)
        for _, nodeID := range nodeIDs </span><span class="cov0" title="0">{
                shouldDelete, err := rn.LifecycleManager.RemoveRuleFromNode(nodeID, ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ö†Ô∏è  Erreur lors de la suppression de la r√®gle du n≈ìud %s: %v\n", nodeID, err)
                        continue</span>
                }

                <span class="cov0" title="0">if shouldDelete </span><span class="cov0" title="0">{
                        nodesToDelete = append(nodesToDelete, nodeID)
                        fmt.Printf("   ‚úì N≈ìud %s marqu√© pour suppression (plus de r√©f√©rences)\n", nodeID)
                }</span> else<span class="cov0" title="0"> {
                        lifecycle, _ := rn.LifecycleManager.GetNodeLifecycle(nodeID)
                        fmt.Printf("   ‚úì N≈ìud %s conserv√© (%d r√©f√©rence(s) restante(s))\n", nodeID, lifecycle.GetRefCount())
                }</span>
        }

        // Supprimer les n≈ìuds qui n'ont plus de r√©f√©rences
        <span class="cov0" title="0">for _, nodeID := range nodesToDelete </span><span class="cov0" title="0">{
                if err := rn.removeNodeFromNetwork(nodeID); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ö†Ô∏è  Erreur lors de la suppression du n≈ìud %s: %v\n", nodeID, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   üóëÔ∏è  N≈ìud %s supprim√© du r√©seau\n", nodeID)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("‚úÖ R√®gle %s supprim√©e avec succ√®s (%d n≈ìud(s) supprim√©(s))\n", ruleID, len(nodesToDelete))
        return nil</span>
}

// removeAlphaChain supprime une r√®gle avec une cha√Æne d'AlphaNodes
// Remonte la cha√Æne en ordre inverse depuis le terminal pour supprimer les n≈ìuds
func (rn *ReteNetwork) removeAlphaChain(ruleID string) error <span class="cov0" title="0">{
        // R√©cup√©rer tous les n≈ìuds de la r√®gle
        nodeIDs := rn.LifecycleManager.GetNodesForRule(ruleID)

        // S√©parer les n≈ìuds par type
        var terminalID string
        alphaNodes := make([]string, 0)
        otherNodes := make([]string, 0)

        for _, nodeID := range nodeIDs </span><span class="cov0" title="0">{
                lifecycle, exists := rn.LifecycleManager.GetNodeLifecycle(nodeID)
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">switch lifecycle.NodeType </span>{
                case "terminal":<span class="cov0" title="0">
                        terminalID = nodeID</span>
                case "alpha":<span class="cov0" title="0">
                        alphaNodes = append(alphaNodes, nodeID)</span>
                default:<span class="cov0" title="0">
                        otherNodes = append(otherNodes, nodeID)</span>
                }
        }

        // Supprimer le terminal en premier
        <span class="cov0" title="0">deletedCount := 0
        if terminalID != "" </span><span class="cov0" title="0">{
                if err := rn.removeNodeWithCheck(terminalID, ruleID); err == nil </span><span class="cov0" title="0">{
                        deletedCount++
                        fmt.Printf("   üóëÔ∏è  TerminalNode %s supprim√©\n", terminalID)
                }</span>
        }

        // Ordonner les AlphaNodes dans l'ordre inverse de la cha√Æne (du terminal vers le TypeNode)
        <span class="cov0" title="0">orderedAlphaNodes := rn.orderAlphaNodesReverse(alphaNodes)

        // Parcourir les AlphaNodes en ordre inverse
        stopDeletion := false
        for i, nodeID := range orderedAlphaNodes </span><span class="cov0" title="0">{
                lifecycle, exists := rn.LifecycleManager.GetNodeLifecycle(nodeID)
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // D√©cr√©menter RefCount pour tous les n≈ìuds
                <span class="cov0" title="0">shouldDelete, err := rn.LifecycleManager.RemoveRuleFromNode(nodeID, ruleID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚ö†Ô∏è  Erreur lors de la suppression de la r√®gle du n≈ìud %s: %v\n", nodeID, err)
                        continue</span>
                }

                <span class="cov0" title="0">if !stopDeletion &amp;&amp; shouldDelete </span><span class="cov0" title="0">{
                        // RefCount == 0, on peut supprimer
                        if err := rn.removeNodeFromNetwork(nodeID); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("   ‚ö†Ô∏è  Erreur suppression n≈ìud %s: %v\n", nodeID, err)
                        }</span> else<span class="cov0" title="0"> {
                                deletedCount++
                                fmt.Printf("   üóëÔ∏è  AlphaNode %s supprim√© (position %d dans la cha√Æne)\n", nodeID, len(orderedAlphaNodes)-i)
                        }</span>
                } else<span class="cov0" title="0"> if !shouldDelete &amp;&amp; !stopDeletion </span><span class="cov0" title="0">{
                        // Premier n≈ìud partag√© rencontr√© - on arr√™te la suppression mais on continue √† d√©cr√©menter
                        refCount := lifecycle.GetRefCount()
                        fmt.Printf("   ‚ôªÔ∏è  AlphaNode %s conserv√© (%d r√©f√©rence(s) restante(s)) - arr√™t des suppressions\n", nodeID, refCount)
                        fmt.Printf("   ‚ÑπÔ∏è  D√©cr√©mentation du RefCount des n≈ìuds parents partag√©s\n")
                        stopDeletion = true
                }</span> else<span class="cov0" title="0"> if stopDeletion </span><span class="cov0" title="0">{
                        // N≈ìuds parents - juste d√©cr√©menter le RefCount
                        refCount := lifecycle.GetRefCount()
                        fmt.Printf("   ‚ôªÔ∏è  AlphaNode %s: RefCount d√©cr√©ment√© (%d r√©f√©rence(s) restante(s))\n", nodeID, refCount)
                }</span>
        }

        // Supprimer les autres n≈ìuds (TypeNodes, JoinNodes, etc.)
        <span class="cov0" title="0">for _, nodeID := range otherNodes </span><span class="cov0" title="0">{
                if err := rn.removeNodeWithCheck(nodeID, ruleID); err == nil </span><span class="cov0" title="0">{
                        deletedCount++
                        lifecycle, _ := rn.LifecycleManager.GetNodeLifecycle(nodeID)
                        fmt.Printf("   üóëÔ∏è  %s %s supprim√©\n", lifecycle.NodeType, nodeID)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("‚úÖ R√®gle %s avec cha√Æne supprim√©e avec succ√®s (%d n≈ìud(s) supprim√©(s))\n", ruleID, deletedCount)
        return nil</span>
}

// removeNodeWithCheck supprime un n≈ìud seulement si RefCount == 0
func (rn *ReteNetwork) removeNodeWithCheck(nodeID, ruleID string) error <span class="cov0" title="0">{
        shouldDelete, err := rn.LifecycleManager.RemoveRuleFromNode(nodeID, ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if shouldDelete </span><span class="cov0" title="0">{
                return rn.removeNodeFromNetwork(nodeID)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("n≈ìud %s encore r√©f√©renc√©", nodeID)</span>
}

// orderAlphaNodesReverse ordonne les AlphaNodes en ordre inverse de la cha√Æne
// (du n≈ìud le plus √©loign√© du TypeNode vers le TypeNode)
func (rn *ReteNetwork) orderAlphaNodesReverse(alphaNodeIDs []string) []string <span class="cov0" title="0">{
        if len(alphaNodeIDs) &lt;= 1 </span><span class="cov0" title="0">{
                return alphaNodeIDs
        }</span>

        // Construire un graphe parent-&gt;enfants pour trouver l'ordre
        <span class="cov0" title="0">childToParent := make(map[string]string)
        hasParent := make(map[string]bool)

        for _, nodeID := range alphaNodeIDs </span><span class="cov0" title="0">{
                alphaNode, exists := rn.AlphaNodes[nodeID]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parent := rn.getChainParent(alphaNode)
                if parent != nil </span><span class="cov0" title="0">{
                        parentID := parent.GetID()
                        // V√©rifier si le parent est aussi un AlphaNode de notre liste
                        for _, candidateID := range alphaNodeIDs </span><span class="cov0" title="0">{
                                if candidateID == parentID </span><span class="cov0" title="0">{
                                        childToParent[nodeID] = parentID
                                        hasParent[nodeID] = true
                                        break</span>
                                }
                        }
                }
        }

        // Trouver le n≈ìud terminal de la cha√Æne (celui qui n'est parent de personne)
        <span class="cov0" title="0">var terminalNode string
        for _, nodeID := range alphaNodeIDs </span><span class="cov0" title="0">{
                isParent := false
                for _, parentID := range childToParent </span><span class="cov0" title="0">{
                        if parentID == nodeID </span><span class="cov0" title="0">{
                                isParent = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isParent </span><span class="cov0" title="0">{
                        terminalNode = nodeID
                        break</span>
                }
        }

        // Si pas de structure de cha√Æne d√©tect√©e, retourner l'ordre original
        <span class="cov0" title="0">if terminalNode == "" </span><span class="cov0" title="0">{
                return alphaNodeIDs
        }</span>

        // Remonter la cha√Æne depuis le terminal
        <span class="cov0" title="0">ordered := make([]string, 0, len(alphaNodeIDs))
        current := terminalNode
        visited := make(map[string]bool)

        for current != "" &amp;&amp; !visited[current] </span><span class="cov0" title="0">{
                ordered = append(ordered, current)
                visited[current] = true
                current = childToParent[current]
        }</span>

        // Ajouter les n≈ìuds non visit√©s (au cas o√π)
        <span class="cov0" title="0">for _, nodeID := range alphaNodeIDs </span><span class="cov0" title="0">{
                if !visited[nodeID] </span><span class="cov0" title="0">{
                        ordered = append(ordered, nodeID)
                }</span>
        }

        <span class="cov0" title="0">return ordered</span>
}

// isPartOfChain d√©tecte si un n≈ìud fait partie d'une cha√Æne d'AlphaNodes
func (rn *ReteNetwork) isPartOfChain(nodeID string) bool <span class="cov0" title="0">{
        lifecycle, exists := rn.LifecycleManager.GetNodeLifecycle(nodeID)
        if !exists || lifecycle.NodeType != "alpha" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">alphaNode, exists := rn.AlphaNodes[nodeID]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Un AlphaNode fait partie d'une cha√Æne si:
        // 1. Son parent est un autre AlphaNode, OU
        // 2. Un de ses enfants est un autre AlphaNode

        <span class="cov0" title="0">parent := rn.getChainParent(alphaNode)
        if parent != nil &amp;&amp; parent.GetType() == "alpha" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">children := alphaNode.GetChildren()
        for _, child := range children </span><span class="cov0" title="0">{
                if child.GetType() == "alpha" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// getChainParent r√©cup√®re le n≈ìud parent d'un AlphaNode dans une cha√Æne
func (rn *ReteNetwork) getChainParent(alphaNode *AlphaNode) Node <span class="cov0" title="0">{
        if alphaNode == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">alphaID := alphaNode.GetID()

        // Chercher dans les TypeNodes
        for _, typeNode := range rn.TypeNodes </span><span class="cov0" title="0">{
                for _, child := range typeNode.GetChildren() </span><span class="cov0" title="0">{
                        if child.GetID() == alphaID </span><span class="cov0" title="0">{
                                return typeNode
                        }</span>
                }
        }

        // Chercher dans les autres AlphaNodes
        <span class="cov0" title="0">for _, parentAlpha := range rn.AlphaNodes </span><span class="cov0" title="0">{
                if parentAlpha.GetID() == alphaID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, child := range parentAlpha.GetChildren() </span><span class="cov0" title="0">{
                        if child.GetID() == alphaID </span><span class="cov0" title="0">{
                                return parentAlpha
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// removeNodeFromNetwork supprime un n≈ìud du r√©seau RETE
// Ne supprime que si RefCount == 0
func (rn *ReteNetwork) removeNodeFromNetwork(nodeID string) error <span class="cov0" title="0">{
        // V√©rifier que le n≈ìud existe et peut √™tre supprim√©
        lifecycle, exists := rn.LifecycleManager.GetNodeLifecycle(nodeID)
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("n≈ìud %s non trouv√© dans le LifecycleManager", nodeID)
        }</span>

        // Ne pas supprimer si le n≈ìud a encore des r√©f√©rences
        <span class="cov0" title="0">if lifecycle.HasReferences() </span><span class="cov0" title="0">{
                return fmt.Errorf("impossible de supprimer le n≈ìud %s: encore %d r√©f√©rence(s)",
                        nodeID, lifecycle.GetRefCount())
        }</span>

        // D√©terminer le type de n≈ìud et le supprimer de la map appropri√©e
        <span class="cov0" title="0">switch lifecycle.NodeType </span>{
        case "type":<span class="cov0" title="0">
                // Trouver et supprimer le TypeNode
                for typeName, typeNode := range rn.TypeNodes </span><span class="cov0" title="0">{
                        if typeNode.GetID() == nodeID </span><span class="cov0" title="0">{
                                // D√©connecter du RootNode
                                rn.removeChildFromNode(rn.RootNode, typeNode)
                                delete(rn.TypeNodes, typeName)
                                return rn.LifecycleManager.RemoveNode(nodeID)
                        }</span>
                }

        case "alpha":<span class="cov0" title="0">
                // Supprimer l'AlphaNode
                if alphaNode, exists := rn.AlphaNodes[nodeID]; exists </span><span class="cov0" title="0">{
                        // D√©connecter des parents (TypeNodes ou autres AlphaNodes)
                        parent := rn.getChainParent(alphaNode)
                        if parent != nil </span><span class="cov0" title="0">{
                                rn.removeChildFromNode(parent, alphaNode)
                                fmt.Printf("   üîó AlphaNode %s d√©connect√© de son parent %s\n", nodeID, parent.GetID())
                        }</span>

                        <span class="cov0" title="0">delete(rn.AlphaNodes, nodeID)

                        // Supprimer du registre de partage AlphaSharingManager
                        if rn.AlphaSharingManager != nil </span><span class="cov0" title="0">{
                                // V√©rifier si c'est un n≈ìud partag√© (les n≈ìuds partag√©s ont un ID qui commence par "alpha_")
                                if len(nodeID) &gt; 6 &amp;&amp; nodeID[:6] == "alpha_" </span><span class="cov0" title="0">{
                                        if err := rn.AlphaSharingManager.RemoveAlphaNode(nodeID); err != nil </span><span class="cov0" title="0">{
                                                fmt.Printf("   ‚ö†Ô∏è  Erreur suppression AlphaNode du registre de partage: %v\n", err)
                                        }</span> else<span class="cov0" title="0"> {
                                                fmt.Printf("   ‚úì AlphaNode %s supprim√© du AlphaSharingManager\n", nodeID)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">return rn.LifecycleManager.RemoveNode(nodeID)</span>
                }

        case "terminal":<span class="cov0" title="0">
                // Supprimer le TerminalNode
                if terminalNode, exists := rn.TerminalNodes[nodeID]; exists </span><span class="cov0" title="0">{
                        // D√©connecter des parents (AlphaNodes ou JoinNodes)
                        for _, alphaNode := range rn.AlphaNodes </span><span class="cov0" title="0">{
                                rn.removeChildFromNode(alphaNode, terminalNode)
                        }</span>
                        // Aussi d√©connecter des BetaNodes si n√©cessaire
                        <span class="cov0" title="0">for _, betaNode := range rn.BetaNodes </span><span class="cov0" title="0">{
                                if node, ok := betaNode.(Node); ok </span><span class="cov0" title="0">{
                                        rn.removeChildFromNode(node, terminalNode)
                                }</span>
                        }
                        <span class="cov0" title="0">delete(rn.TerminalNodes, nodeID)
                        return rn.LifecycleManager.RemoveNode(nodeID)</span>
                }

        case "join", "exists", "accumulate":<span class="cov0" title="0">
                // Supprimer le BetaNode
                if betaNode, exists := rn.BetaNodes[nodeID]; exists </span><span class="cov0" title="0">{
                        // D√©connecter des parents
                        for _, typeNode := range rn.TypeNodes </span><span class="cov0" title="0">{
                                if node, ok := betaNode.(Node); ok </span><span class="cov0" title="0">{
                                        rn.removeChildFromNode(typeNode, node)
                                }</span>
                        }
                        <span class="cov0" title="0">delete(rn.BetaNodes, nodeID)
                        return rn.LifecycleManager.RemoveNode(nodeID)</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("n≈ìud %s non trouv√© dans le r√©seau", nodeID)</span>
}

// removeChildFromNode retire un n≈ìud enfant d'un n≈ìud parent
func (rn *ReteNetwork) removeChildFromNode(parent Node, child Node) <span class="cov0" title="0">{
        if parent == nil || child == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">children := parent.GetChildren()
        newChildren := make([]Node, 0, len(children))
        for _, c := range children </span><span class="cov0" title="0">{
                if c.GetID() != child.GetID() </span><span class="cov0" title="0">{
                        newChildren = append(newChildren, c)
                }</span>
        }

        // Mettre √† jour les enfants (n√©cessite un cast vers le type concret)
        <span class="cov0" title="0">switch p := parent.(type) </span>{
        case *RootNode:<span class="cov0" title="0">
                p.Children = newChildren</span>
        case *TypeNode:<span class="cov0" title="0">
                p.Children = newChildren</span>
        case *AlphaNode:<span class="cov0" title="0">
                p.Children = newChildren</span>
        case *JoinNode:<span class="cov0" title="0">
                p.Children = newChildren</span>
        case *ExistsNode:<span class="cov0" title="0">
                p.Children = newChildren</span>
        }
}

// GetRuleInfo retourne les informations d'une r√®gle
func (rn *ReteNetwork) GetRuleInfo(ruleID string) *RuleInfo <span class="cov0" title="0">{
        if rn.LifecycleManager == nil </span><span class="cov0" title="0">{
                return &amp;RuleInfo{
                        RuleID:    ruleID,
                        NodeIDs:   []string{},
                        NodeCount: 0,
                }
        }</span>
        <span class="cov0" title="0">return rn.LifecycleManager.GetRuleInfo(ruleID)</span>
}

// GetNetworkStats retourne des statistiques sur le r√©seau
func (rn *ReteNetwork) GetNetworkStats() map[string]interface{} <span class="cov8" title="1">{
        stats := map[string]interface{}{
                "type_nodes":     len(rn.TypeNodes),
                "alpha_nodes":    len(rn.AlphaNodes),
                "beta_nodes":     len(rn.BetaNodes),
                "terminal_nodes": len(rn.TerminalNodes),
        }

        if rn.LifecycleManager != nil </span><span class="cov8" title="1">{
                lifecycleStats := rn.LifecycleManager.GetStats()
                for k, v := range lifecycleStats </span><span class="cov8" title="1">{
                        stats["lifecycle_"+k] = v
                }</span>
        }

        <span class="cov8" title="1">if rn.AlphaSharingManager != nil </span><span class="cov8" title="1">{
                alphaStats := rn.AlphaSharingManager.GetStats()
                for k, v := range alphaStats </span><span class="cov8" title="1">{
                        stats["sharing_"+k] = v
                }</span>
        }

        <span class="cov8" title="1">return stats</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "math"
        "sync"
)

type AccumulatorNode struct {
        BaseNode
        AggregateFunc string                 `json:"aggregate_func"` // "AVG", "SUM", "COUNT", "MIN", "MAX"
        MainVariable  string                 `json:"main_variable"`  // Variable principale (ex: "e")
        MainType      string                 `json:"main_type"`      // Type principal (ex: "Employee")
        AggVariable   string                 `json:"agg_variable"`   // Variable √† agr√©ger (ex: "p")
        AggType       string                 `json:"agg_type"`       // Type √† agr√©ger (ex: "Performance")
        Field         string                 `json:"field"`          // Champ √† agr√©ger (ex: "score"), vide pour COUNT
        JoinField     string                 `json:"join_field"`     // Champ de jointure (ex: "employee_id")
        MainField     string                 `json:"main_field"`     // Champ principal pour jointure (ex: "id")
        Condition     map[string]interface{} `json:"condition"`      // Condition de comparaison du r√©sultat
        MainFacts     map[string]*Fact       `json:"-"`              // Faits principaux index√©s par ID
        AllFacts      map[string]*Fact       `json:"-"`              // Tous les faits (principaux + agr√©g√©s) par ID
        mutex         sync.RWMutex
}

// NewAccumulatorNode cr√©e un nouveau n≈ìud d'agr√©gation
func NewAccumulatorNode(id string, mainVar, mainType, aggVar, aggType, field, joinField, mainField, aggregateFunc string, condition map[string]interface{}, storage Storage) *AccumulatorNode <span class="cov0" title="0">{
        return &amp;AccumulatorNode{
                BaseNode: BaseNode{
                        ID:       id,
                        Type:     "accumulator",
                        Children: make([]Node, 0),
                        Memory:   &amp;WorkingMemory{Tokens: make(map[string]*Token), Facts: make(map[string]*Fact)},
                },
                AggregateFunc: aggregateFunc,
                MainVariable:  mainVar,
                MainType:      mainType,
                AggVariable:   aggVar,
                AggType:       aggType,
                Field:         field,
                JoinField:     joinField,
                MainField:     mainField,
                Condition:     condition,
                MainFacts:     make(map[string]*Fact),
                AllFacts:      make(map[string]*Fact),
        }
}</span>

// Activate traite un fait dans le n≈ìud d'agr√©gation
func (an *AccumulatorNode) Activate(fact *Fact, token *Token) error <span class="cov0" title="0">{
        an.mutex.Lock()
        defer an.mutex.Unlock()

        // Stocker tous les faits
        an.AllFacts[fact.ID] = fact

        // Si c'est un fait principal, stocker et calculer l'agr√©gation
        if fact.Type == an.MainType </span><span class="cov0" title="0">{
                an.MainFacts[fact.ID] = fact
                fmt.Printf("üìä ACCUMULATOR[%s]: Fait principal re√ßu %s\n", an.ID, fact.ID)

                // Calculer l'agr√©gation pour ce fait principal
                return an.processMainFact(fact)
        }</span>

        // Si c'est un fait √† agr√©ger, recalculer pour tous les faits principaux
        <span class="cov0" title="0">if fact.Type == an.AggType </span><span class="cov0" title="0">{
                fmt.Printf("üìä ACCUMULATOR[%s]: Fait agr√©g√© re√ßu %s\n", an.ID, fact.ID)
                // Recalculer pour tous les faits principaux existants
                for _, mainFact := range an.MainFacts </span><span class="cov0" title="0">{
                        if err := an.processMainFact(mainFact); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("‚ö†Ô∏è  ACCUMULATOR[%s]: Erreur recalcul pour %s: %v\n", an.ID, mainFact.ID, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// processMainFact calcule l'agr√©gation pour un fait principal donn√©
func (an *AccumulatorNode) processMainFact(mainFact *Fact) error <span class="cov0" title="0">{
        // Collecter les faits √† agr√©ger qui correspondent √† ce fait principal
        aggregatedFacts := an.collectAggregatedFacts(mainFact)

        fmt.Printf("üìä ACCUMULATOR[%s]: %d faits agr√©g√©s trouv√©s pour %s\n", an.ID, len(aggregatedFacts), mainFact.ID)

        // Calculer l'agr√©gation
        aggregatedValue, err := an.calculateAggregateForFacts(aggregatedFacts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur calcul agr√©gation: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("üìä ACCUMULATOR[%s]: Valeur agr√©g√©e = %.2f pour %s\n", an.ID, aggregatedValue, mainFact.ID)

        // √âvaluer la condition
        satisfied, err := an.evaluateCondition(aggregatedValue)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("erreur √©valuation condition agr√©gation: %w", err)
        }</span>

        <span class="cov0" title="0">if satisfied </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ ACCUMULATOR[%s]: Condition satisfaite (%.2f) pour %s\n", an.ID, aggregatedValue, mainFact.ID)

                // Cr√©er un token avec le fait et le r√©sultat de l'agr√©gation
                newToken := &amp;Token{
                        ID:       fmt.Sprintf("accum_%s", mainFact.ID),
                        Facts:    []*Fact{mainFact},
                        Bindings: map[string]*Fact{an.MainVariable: mainFact},
                }
                an.Memory.AddToken(newToken)

                // Propager aux enfants - ne passer que le token, pas le fait
                // car TerminalNode ne veut que des tokens
                return an.PropagateToChildren(nil, newToken)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚ùå ACCUMULATOR[%s]: Condition NON satisfaite (%.2f) pour %s\n", an.ID, aggregatedValue, mainFact.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// collectAggregatedFacts collecte les faits √† agr√©ger pour un fait principal
func (an *AccumulatorNode) collectAggregatedFacts(mainFact *Fact) []*Fact <span class="cov0" title="0">{
        collected := make([]*Fact, 0)

        // Obtenir la valeur du champ de jointure du fait principal
        mainValue, exists := mainFact.Fields[an.MainField]
        if !exists </span><span class="cov0" title="0">{
                // Essayer aussi dans fact.ID si c'est le champ "id"
                if an.MainField == "id" </span><span class="cov0" title="0">{
                        mainValue = mainFact.ID
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚ö†Ô∏è  ACCUMULATOR[%s]: Champ principal %s non trouv√© dans %s\n", an.ID, an.MainField, mainFact.ID)
                        return collected
                }</span>
        }

        // Parcourir tous les faits pour trouver ceux qui correspondent
        <span class="cov0" title="0">for _, fact := range an.AllFacts </span><span class="cov0" title="0">{
                if fact.Type == an.AggType </span><span class="cov0" title="0">{
                        // V√©rifier la condition de jointure
                        joinValue, exists := fact.Fields[an.JoinField]
                        if exists &amp;&amp; joinValue == mainValue </span><span class="cov0" title="0">{
                                collected = append(collected, fact)
                        }</span>
                }
        }

        <span class="cov0" title="0">return collected</span>
}

// calculateAggregateForFacts calcule la valeur agr√©g√©e pour une liste de faits
func (an *AccumulatorNode) calculateAggregateForFacts(facts []*Fact) (float64, error) <span class="cov0" title="0">{
        if len(facts) == 0 </span><span class="cov0" title="0">{
                // Pas de faits √† agr√©ger - retourner 0
                return 0, nil
        }</span>

        <span class="cov0" title="0">switch an.AggregateFunc </span>{
        case "COUNT":<span class="cov0" title="0">
                return float64(len(facts)), nil</span>

        case "SUM":<span class="cov0" title="0">
                sum := 0.0
                for _, f := range facts </span><span class="cov0" title="0">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov0" title="0">{
                                if numVal, ok := val.(float64); ok </span><span class="cov0" title="0">{
                                        sum += numVal
                                }</span>
                        }
                }
                <span class="cov0" title="0">return sum, nil</span>

        case "AVG":<span class="cov0" title="0">
                sum := 0.0
                count := 0
                for _, f := range facts </span><span class="cov0" title="0">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov0" title="0">{
                                if numVal, ok := val.(float64); ok </span><span class="cov0" title="0">{
                                        sum += numVal
                                        count++
                                }</span>
                        }
                }
                <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return sum / float64(count), nil</span>

        case "MIN":<span class="cov0" title="0">
                minVal := math.MaxFloat64
                for _, f := range facts </span><span class="cov0" title="0">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov0" title="0">{
                                if numVal, ok := val.(float64); ok </span><span class="cov0" title="0">{
                                        if numVal &lt; minVal </span><span class="cov0" title="0">{
                                                minVal = numVal
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">if minVal == math.MaxFloat64 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return minVal, nil</span>

        case "MAX":<span class="cov0" title="0">
                maxVal := -math.MaxFloat64
                for _, f := range facts </span><span class="cov0" title="0">{
                        if val, ok := f.Fields[an.Field]; ok </span><span class="cov0" title="0">{
                                if numVal, ok := val.(float64); ok </span><span class="cov0" title="0">{
                                        if numVal &gt; maxVal </span><span class="cov0" title="0">{
                                                maxVal = numVal
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">if maxVal == -math.MaxFloat64 </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return maxVal, nil</span>

        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("fonction d'agr√©gation non support√©e: %s", an.AggregateFunc)</span>
        }
}

// ActivateLeft traite un token venant de la gauche (compatible avec interface Node)
func (an *AccumulatorNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        // Pour AccumulatorNode, on traite le premier fait du token
        if len(token.Facts) &gt; 0 </span><span class="cov0" title="0">{
                return an.Activate(token.Facts[0], token)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ActivateRight traite un fait venant de la droite
func (an *AccumulatorNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{
        return an.Activate(fact, nil)
}</span>

// evaluateCondition √©value si la valeur agr√©g√©e satisfait la condition
func (an *AccumulatorNode) evaluateCondition(aggregatedValue float64) (bool, error) <span class="cov0" title="0">{
        if an.Condition == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov0" title="0">condType, ok := an.Condition["type"].(string)
        if !ok || condType != "comparison" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("type de condition invalide")
        }</span>

        <span class="cov0" title="0">operator, ok := an.Condition["operator"].(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("op√©rateur manquant")
        }</span>

        <span class="cov0" title="0">threshold, ok := an.Condition["value"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("valeur de comparaison invalide")
        }</span>

        <span class="cov0" title="0">switch operator </span>{
        case "&gt;=":<span class="cov0" title="0">
                return aggregatedValue &gt;= threshold, nil</span>
        case "&gt;":<span class="cov0" title="0">
                return aggregatedValue &gt; threshold, nil</span>
        case "&lt;=":<span class="cov0" title="0">
                return aggregatedValue &lt;= threshold, nil</span>
        case "&lt;":<span class="cov0" title="0">
                return aggregatedValue &lt; threshold, nil</span>
        case "==":<span class="cov0" title="0">
                return aggregatedValue == threshold, nil</span>
        case "!=":<span class="cov0" title="0">
                return aggregatedValue != threshold, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("op√©rateur non support√©: %s", operator)</span>
        }
}

// ActivateRetract g√®re la r√©tractation dans le n≈ìud d'agr√©gation
func (an *AccumulatorNode) ActivateRetract(factID string) error <span class="cov0" title="0">{
        an.mutex.Lock()
        defer an.mutex.Unlock()

        // Retirer des faits principaux et de tous les faits
        delete(an.MainFacts, factID)
        delete(an.AllFacts, factID)

        // Retirer des tokens
        an.Memory.RemoveToken(factID)

        fmt.Printf("üóëÔ∏è  [ACCUMULATOR_%s] R√©tractation: fait %s retir√©\n", an.ID, factID)
        return an.PropagateRetractToChildren(factID)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
)

type AlphaNode struct {
        BaseNode
        Condition    interface{} `json:"condition"`
        VariableName string      `json:"variable_name"`
}

// NewAlphaNode cr√©e un nouveau n≈ìud alpha
func NewAlphaNode(nodeID string, condition interface{}, variableName string, storage Storage) *AlphaNode <span class="cov8" title="1">{
        return &amp;AlphaNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "alpha",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:    condition,
                VariableName: variableName,
        }
}</span>

// ActivateLeft (non utilis√© pour les n≈ìuds alpha)
func (an *AlphaNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds alpha ne re√ßoivent pas de tokens")
}</span>

// ActivateRetract retire le fait de la m√©moire alpha et propage aux enfants
// factID doit √™tre l'identifiant interne (Type_ID)
func (an *AlphaNode) ActivateRetract(factID string) error <span class="cov0" title="0">{
        an.mutex.Lock()
        _, exists := an.Memory.GetFact(factID)
        if exists </span><span class="cov0" title="0">{
                an.Memory.RemoveFact(factID)
        }</span>
        <span class="cov0" title="0">an.mutex.Unlock()
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">fmt.Printf("üóëÔ∏è  [ALPHA_%s] R√©tractation du fait: %s\n", an.ID, factID)
        return an.PropagateRetractToChildren(factID)</span>
}

// ActivateRight teste la condition sur le fait
func (an *AlphaNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ALPHA_%s] Test condition sur fait: %s\n", an.ID, fact.String())

        // Cas sp√©cial: passthrough pour les JoinNodes - pas de filtrage
        if an.Condition != nil </span><span class="cov8" title="1">{
                if condMap, ok := an.Condition.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if condType, exists := condMap["type"].(string); exists &amp;&amp; condType == "passthrough" </span><span class="cov8" title="1">{
                                // Mode pass-through: convertir le fait en token et propager selon le c√¥t√©
                                an.mutex.Lock()
                                if err := an.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                                        an.mutex.Unlock()
                                        return fmt.Errorf("erreur ajout fait dans alpha node: %w", err)
                                }</span>
                                <span class="cov8" title="1">an.mutex.Unlock() // Cr√©er un token pour le fait avec la variable correspondante
                                token := &amp;Token{
                                        ID:       fmt.Sprintf("alpha_token_%s_%s", an.ID, fact.ID),
                                        Facts:    []*Fact{fact},
                                        NodeID:   an.ID,
                                        Bindings: map[string]*Fact{an.VariableName: fact},
                                }

                                // D√©terminer le c√¥t√© et propager selon l'architecture RETE
                                side, sideExists := condMap["side"].(string)
                                if sideExists &amp;&amp; side == "left" </span><span class="cov8" title="1">{
                                        return an.PropagateToChildren(nil, token) // ActivateLeft
                                }</span> else<span class="cov8" title="1"> {
                                        return an.PropagateToChildren(fact, nil) // ActivateRight
                                }</span>
                        }
                }
        }

        // √âvaluation normale de condition Alpha
        <span class="cov0" title="0">if an.Condition != nil </span><span class="cov0" title="0">{
                evaluator := NewAlphaConditionEvaluator()
                passed, err := evaluator.EvaluateCondition(an.Condition, fact, an.VariableName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur √©valuation condition Alpha: %w", err)
                }</span>

                // Si la condition n'est pas satisfaite, ignorer le fait
                <span class="cov0" title="0">if !passed </span><span class="cov0" title="0">{
                        // Log d√©sactiv√© pour les performances
                        // fmt.Printf("[ALPHA_%s] Condition non satisfaite pour le fait: %s\n", an.ID, fact.String())
                        return nil
                }</span>
        }

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ALPHA_%s] Condition satisfaite pour le fait: %s\n", an.ID, fact.String())

        // V√©rifier si le fait existe d√©j√† (idempotence pour les propagations multiples)
        <span class="cov0" title="0">an.mutex.Lock()
        internalID := fact.GetInternalID()
        _, alreadyExists := an.Memory.Facts[internalID]
        if !alreadyExists </span><span class="cov0" title="0">{
                if err := an.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                        an.mutex.Unlock()
                        return fmt.Errorf("erreur ajout fait dans alpha node: %w", err)
                }</span>
        }
        <span class="cov0" title="0">an.mutex.Unlock()

        // Si le fait existait d√©j√†, ne pas propager √† nouveau
        if alreadyExists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Persistance d√©sactiv√©e pour les performances

        // Propager aux enfants
        // Dans une cha√Æne d'AlphaNodes, propager le fait directement via ActivateRight
        // Pour les autres types de n≈ìuds (Terminal, Join), cr√©er un token et propager via ActivateLeft
        <span class="cov0" title="0">for _, child := range an.GetChildren() </span><span class="cov0" title="0">{
                childType := child.GetType()

                if childType == "alpha" </span><span class="cov0" title="0">{
                        // Propager le fait directement aux AlphaNodes enfants (cha√Æne)
                        if err := child.ActivateRight(fact); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation fait vers %s: %w", child.GetID(), err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Pour les autres types de n≈ìuds, cr√©er un token et propager via ActivateLeft
                        token := &amp;Token{
                                ID:       fmt.Sprintf("token_%s_%s", an.ID, fact.ID),
                                Facts:    []*Fact{fact},
                                NodeID:   an.ID,
                                Bindings: map[string]*Fact{an.VariableName: fact},
                        }
                        if err := child.ActivateLeft(token); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation token vers %s: %w", child.GetID(), err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "sync"
)

type BaseNode struct {
        ID       string         `json:"id"`
        Type     string         `json:"type"`
        Memory   *WorkingMemory `json:"memory"`
        Children []Node         `json:"children"`
        Storage  Storage        `json:"-"`
        mutex    sync.RWMutex   `json:"-"`
}

// GetID retourne l'ID du n≈ìud
func (bn *BaseNode) GetID() string <span class="cov8" title="1">{
        return bn.ID
}</span>

// GetType retourne le type du n≈ìud
func (bn *BaseNode) GetType() string <span class="cov0" title="0">{
        return bn.Type
}</span>

// GetMemory retourne la m√©moire de travail du n≈ìud
func (bn *BaseNode) GetMemory() *WorkingMemory <span class="cov8" title="1">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()
        return bn.Memory
}</span>

// AddChild ajoute un n≈ìud enfant
func (bn *BaseNode) AddChild(child Node) <span class="cov8" title="1">{
        bn.mutex.Lock()
        defer bn.mutex.Unlock()
        bn.Children = append(bn.Children, child)
}</span>

// GetChildren retourne les n≈ìuds enfants
func (bn *BaseNode) GetChildren() []Node <span class="cov8" title="1">{
        bn.mutex.RLock()
        defer bn.mutex.RUnlock()
        return bn.Children
}</span>

// PropagateToChildren propage un fait ou token aux enfants
func (bn *BaseNode) PropagateToChildren(fact *Fact, token *Token) error <span class="cov8" title="1">{
        for _, child := range bn.GetChildren() </span><span class="cov8" title="1">{
                if fact != nil </span><span class="cov8" title="1">{
                        if err := child.ActivateRight(fact); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation fait vers %s: %w", child.GetID(), err)
                        }</span>
                }
                <span class="cov8" title="1">if token != nil </span><span class="cov8" title="1">{
                        if err := child.ActivateLeft(token); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("erreur propagation token vers %s: %w", child.GetID(), err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// PropagateRetractToChildren propage la r√©tractation d'un fait aux n≈ìuds enfants
func (bn *BaseNode) PropagateRetractToChildren(factID string) error <span class="cov0" title="0">{
        for _, child := range bn.GetChildren() </span><span class="cov0" title="0">{
                if err := child.ActivateRetract(factID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("erreur propagation r√©tractation vers %s: %w", child.GetID(), err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// SaveMemory sauvegarde la m√©moire du n≈ìud
func (bn *BaseNode) SaveMemory() error <span class="cov0" title="0">{
        if bn.Storage != nil </span><span class="cov0" title="0">{
                return bn.Storage.SaveMemory(bn.ID, bn.Memory)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "sync"
)

type ExistsNode struct {
        BaseNode
        Condition       map[string]interface{} `json:"condition"`
        MainVariable    string                 `json:"main_variable"`    // Variable principale (p)
        ExistsVariable  string                 `json:"exists_variable"`  // Variable d'existence (o)
        VariableTypes   map[string]string      `json:"variable_types"`   // Mapping variable -&gt; type
        ExistsCondition []JoinCondition        `json:"exists_condition"` // Condition d'existence (o.customer_id == p.id)
        mutex           sync.RWMutex
        // M√©moires pour architecture RETE
        MainMemory   *WorkingMemory // Faits de la variable principale
        ExistsMemory *WorkingMemory // Faits pour v√©rification d'existence
        ResultMemory *WorkingMemory // Tokens avec existence v√©rifi√©e
}

// NewExistsNode cr√©e un nouveau n≈ìud d'existence
func NewExistsNode(nodeID string, condition map[string]interface{}, mainVar string, existsVar string, varTypes map[string]string, storage Storage) *ExistsNode <span class="cov0" title="0">{
        return &amp;ExistsNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "exists",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:       condition,
                MainVariable:    mainVar,
                ExistsVariable:  existsVar,
                VariableTypes:   varTypes,
                ExistsCondition: extractJoinConditions(condition),
                // Initialiser les m√©moires s√©par√©es
                MainMemory:   &amp;WorkingMemory{NodeID: nodeID + "_main", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                ExistsMemory: &amp;WorkingMemory{NodeID: nodeID + "_exists", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                ResultMemory: &amp;WorkingMemory{NodeID: nodeID + "_result", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
        }
}</span>

// ActivateLeft traite les faits de la variable principale
func (en *ExistsNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{

        // Stocker le token dans la m√©moire principale
        en.mutex.Lock()
        en.MainMemory.AddToken(token)
        en.mutex.Unlock()

        // V√©rifier s'il existe des faits correspondants
        if en.checkExistence(token) </span><span class="cov0" title="0">{

                // Stocker le token avec existence v√©rifi√©e
                token.IsJoinResult = true // Marquer comme r√©sultat valid√©
                en.mutex.Lock()
                en.ResultMemory.AddToken(token)
                en.Memory.AddToken(token) // Pour compatibilit√© avec le comptage
                en.mutex.Unlock()

                // Propager le token
                if err := en.PropagateToChildren(nil, token); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else <span class="cov0" title="0">{
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ActivateRetract retrait des tokens et faits contenant le fait r√©tract√©
// factID doit √™tre l'identifiant interne (Type_ID)
func (en *ExistsNode) ActivateRetract(factID string) error <span class="cov0" title="0">{
        en.mutex.Lock()
        var mainTokensToRemove []string
        for tokenID, token := range en.MainMemory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                mainTokensToRemove = append(mainTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, tokenID := range mainTokensToRemove </span><span class="cov0" title="0">{
                delete(en.MainMemory.Tokens, tokenID)
        }</span>
        <span class="cov0" title="0">_, existsInExistsMemory := en.ExistsMemory.GetFact(factID)
        if existsInExistsMemory </span><span class="cov0" title="0">{
                en.ExistsMemory.RemoveFact(factID)
        }</span>
        <span class="cov0" title="0">var resultTokensToRemove []string
        for tokenID, token := range en.ResultMemory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                resultTokensToRemove = append(resultTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, tokenID := range resultTokensToRemove </span><span class="cov0" title="0">{
                delete(en.ResultMemory.Tokens, tokenID)
                delete(en.Memory.Tokens, tokenID)
        }</span>
        <span class="cov0" title="0">en.mutex.Unlock()
        totalRemoved := len(mainTokensToRemove) + len(resultTokensToRemove)
        if existsInExistsMemory </span><span class="cov0" title="0">{
                totalRemoved++
        }</span>
        <span class="cov0" title="0">if totalRemoved &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("üóëÔ∏è  [EXISTS_%s] R√©tractation: %d √©l√©ments retir√©s (MAIN:%d EXISTS:%v RES:%d)\n", en.ID, totalRemoved, len(mainTokensToRemove), existsInExistsMemory, len(resultTokensToRemove))
        }</span>
        <span class="cov0" title="0">return en.PropagateRetractToChildren(factID)</span>
}

// ActivateRight traite les faits pour v√©rification d'existence
func (en *ExistsNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{

        // Stocker le fait dans la m√©moire d'existence
        en.mutex.Lock()
        if err := en.ExistsMemory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                en.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans exists node: %w", err)
        }</span>
        <span class="cov0" title="0">en.mutex.Unlock()

        // Re-v√©rifier tous les tokens principaux avec ce nouveau fait
        mainTokens := en.MainMemory.GetTokens()
        for _, mainToken := range mainTokens </span><span class="cov0" title="0">{
                if en.checkExistence(mainToken) &amp;&amp; !en.isAlreadyValidated(mainToken) </span><span class="cov0" title="0">{

                        // Stocker le token avec existence v√©rifi√©e
                        validatedToken := &amp;Token{
                                ID:           mainToken.ID + "_validated",
                                Facts:        mainToken.Facts,
                                NodeID:       en.ID,
                                Bindings:     mainToken.Bindings,
                                IsJoinResult: true,
                        }

                        en.mutex.Lock()
                        en.ResultMemory.AddToken(validatedToken)
                        en.Memory.AddToken(validatedToken)
                        en.mutex.Unlock()

                        // Propager le token
                        if err := en.PropagateToChildren(nil, validatedToken); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// checkExistence v√©rifie si un token principal a des faits correspondants
func (en *ExistsNode) checkExistence(mainToken *Token) bool <span class="cov0" title="0">{
        existsFacts := en.ExistsMemory.GetFacts()

        // R√©cup√©rer le fait principal du token
        if len(mainToken.Facts) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">mainFact := mainToken.Facts[0]

        // V√©rifier les conditions d'existence
        for _, existsFact := range existsFacts </span><span class="cov0" title="0">{
                if en.evaluateExistsCondition(mainFact, existsFact) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// evaluateExistsCondition √©value la condition d'existence entre deux faits
func (en *ExistsNode) evaluateExistsCondition(mainFact *Fact, existsFact *Fact) bool <span class="cov0" title="0">{

        for i, condition := range en.ExistsCondition </span><span class="cov0" title="0">{
                fmt.Printf("    Condition %d: %s.%s %s %s.%s\n", i,
                        condition.LeftVar, condition.LeftField, condition.Operator,
                        condition.RightVar, condition.RightField)

                // D√©terminer quel fait correspond √† quelle variable
                var leftFact, rightFact *Fact

                if condition.LeftVar == en.MainVariable </span><span class="cov0" title="0">{
                        leftFact = mainFact
                        rightFact = existsFact
                        fmt.Printf("    ‚Üí MainFact comme LeftVar (%s), ExistsFact comme RightVar (%s)\n", condition.LeftVar, condition.RightVar)
                }</span> else<span class="cov0" title="0"> if condition.LeftVar == en.ExistsVariable </span><span class="cov0" title="0">{
                        leftFact = existsFact
                        rightFact = mainFact
                        fmt.Printf("    ‚Üí ExistsFact comme LeftVar (%s), MainFact comme RightVar (%s)\n", condition.LeftVar, condition.RightVar)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("    ‚ùå Variable %s non trouv√©e dans MainVariable:%s ou ExistsVariable:%s\n", condition.LeftVar, en.MainVariable, en.ExistsVariable)
                        continue</span>
                }

                <span class="cov0" title="0">leftValue := leftFact.Fields[condition.LeftField]
                rightValue := rightFact.Fields[condition.RightField]

                switch condition.Operator </span>{
                case "==":<span class="cov0" title="0">
                        if leftValue != rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("    ‚ùå Condition %d √©choue: %v != %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("    ‚úÖ Condition %d r√©ussie: %v == %v\n", i, leftValue, rightValue)</span>
                case "!=":<span class="cov0" title="0">
                        if leftValue == rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("    ‚ùå Condition %d √©choue: %v == %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("    ‚úÖ Condition %d r√©ussie: %v != %v\n", i, leftValue, rightValue)</span>
                default:<span class="cov0" title="0">
                        fmt.Printf("    ‚ùå Op√©rateur non support√©: %s\n", condition.Operator)
                        return false</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("  ‚úÖ Toutes les conditions EXISTS satisfaites\n")
        return true</span>
}

// isAlreadyValidated v√©rifie si un token a d√©j√† √©t√© valid√©
func (en *ExistsNode) isAlreadyValidated(token *Token) bool <span class="cov0" title="0">{
        validatedTokens := en.ResultMemory.GetTokens()
        for _, validatedToken := range validatedTokens </span><span class="cov0" title="0">{
                if validatedToken.ID == token.ID+"_validated" || validatedToken.ID == token.ID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "strconv"
        "sync"
)

type JoinNode struct {
        BaseNode
        Condition      map[string]interface{} `json:"condition"`
        LeftVariables  []string               `json:"left_variables"`
        RightVariables []string               `json:"right_variables"`
        AllVariables   []string               `json:"all_variables"`
        VariableTypes  map[string]string      `json:"variable_types"` // Nouveau: mapping variable -&gt; type
        JoinConditions []JoinCondition        `json:"join_conditions"`
        mutex          sync.RWMutex
        // M√©moires s√©par√©es pour architecture RETE propre
        LeftMemory   *WorkingMemory // Tokens venant de la gauche
        RightMemory  *WorkingMemory // Tokens venant de la droite
        ResultMemory *WorkingMemory // Tokens de jointure r√©ussie
}

// JoinCondition repr√©sente une condition de jointure entre variables
type JoinCondition struct {
        LeftField  string `json:"left_field"`  // p.id
        RightField string `json:"right_field"` // o.customer_id
        LeftVar    string `json:"left_var"`    // p
        RightVar   string `json:"right_var"`   // o
        Operator   string `json:"operator"`    // ==
}

// NewJoinNode cr√©e un nouveau n≈ìud de jointure
func NewJoinNode(nodeID string, condition map[string]interface{}, leftVars []string, rightVars []string, varTypes map[string]string, storage Storage) *JoinNode <span class="cov8" title="1">{
        allVars := append(leftVars, rightVars...)

        return &amp;JoinNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "join",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                Condition:      condition,
                LeftVariables:  leftVars,
                RightVariables: rightVars,
                AllVariables:   allVars,
                VariableTypes:  varTypes,
                JoinConditions: extractJoinConditions(condition),
                // Initialiser les m√©moires s√©par√©es
                LeftMemory:   &amp;WorkingMemory{NodeID: nodeID + "_left", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                RightMemory:  &amp;WorkingMemory{NodeID: nodeID + "_right", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                ResultMemory: &amp;WorkingMemory{NodeID: nodeID + "_result", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
        }
}</span>

// ActivateLeft traite les tokens de la gauche (g√©n√©ralement des AlphaNodes)
func (jn *JoinNode) ActivateLeft(token *Token) error <span class="cov8" title="1">{
        // Stocker le token dans la m√©moire gauche
        jn.mutex.Lock()
        jn.LeftMemory.AddToken(token)
        jn.mutex.Unlock()

        // Essayer de joindre avec tous les tokens de la m√©moire droite
        rightTokens := jn.RightMemory.GetTokens()

        for _, rightToken := range rightTokens </span><span class="cov8" title="1">{
                if joinedToken := jn.performJoinWithTokens(token, rightToken); joinedToken != nil </span><span class="cov0" title="0">{

                        // Stocker uniquement les tokens de jointure r√©ussie
                        joinedToken.IsJoinResult = true
                        jn.mutex.Lock()
                        jn.ResultMemory.AddToken(joinedToken)
                        jn.Memory.AddToken(joinedToken) // Pour compatibilit√© avec le comptage
                        jn.mutex.Unlock()

                        if err := jn.PropagateToChildren(nil, joinedToken); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ActivateRetract retrait des tokens contenant le fait r√©tract√© des 3 m√©moires
// factID doit √™tre l'identifiant interne (Type_ID)
func (jn *JoinNode) ActivateRetract(factID string) error <span class="cov0" title="0">{
        jn.mutex.Lock()
        var leftTokensToRemove []string
        for tokenID, token := range jn.LeftMemory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                leftTokensToRemove = append(leftTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, tokenID := range leftTokensToRemove </span><span class="cov0" title="0">{
                delete(jn.LeftMemory.Tokens, tokenID)
        }</span>
        <span class="cov0" title="0">var rightTokensToRemove []string
        for tokenID, token := range jn.RightMemory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                rightTokensToRemove = append(rightTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, tokenID := range rightTokensToRemove </span><span class="cov0" title="0">{
                delete(jn.RightMemory.Tokens, tokenID)
        }</span>
        <span class="cov0" title="0">var resultTokensToRemove []string
        for tokenID, token := range jn.ResultMemory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                resultTokensToRemove = append(resultTokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, tokenID := range resultTokensToRemove </span><span class="cov0" title="0">{
                delete(jn.ResultMemory.Tokens, tokenID)
                delete(jn.Memory.Tokens, tokenID)
        }</span>
        <span class="cov0" title="0">jn.mutex.Unlock()
        totalRemoved := len(leftTokensToRemove) + len(rightTokensToRemove) + len(resultTokensToRemove)
        if totalRemoved &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("üóëÔ∏è  [JOIN_%s] R√©tractation: %d tokens retir√©s (L:%d R:%d RES:%d)\n", jn.ID, totalRemoved, len(leftTokensToRemove), len(rightTokensToRemove), len(resultTokensToRemove))
        }</span>
        <span class="cov0" title="0">return jn.PropagateRetractToChildren(factID)</span>
}

// ActivateRight traite les faits de la droite (nouveau fait inject√© via AlphaNode)
func (jn *JoinNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // Convertir le fait en token pour la m√©moire droite
        factVar := jn.getVariableForFact(fact)
        if factVar == "" </span><span class="cov0" title="0">{
                return nil // Fait non applicable √† ce JoinNode
        }</span>

        <span class="cov8" title="1">factToken := &amp;Token{
                ID:       fmt.Sprintf("right_token_%s_%s", jn.ID, fact.ID),
                Facts:    []*Fact{fact},
                NodeID:   jn.ID,
                Bindings: map[string]*Fact{factVar: fact},
        }

        // Stocker le token dans la m√©moire droite
        jn.mutex.Lock()
        jn.RightMemory.AddToken(factToken)
        jn.mutex.Unlock()

        // Essayer de joindre avec tous les tokens de la m√©moire gauche
        leftTokens := jn.LeftMemory.GetTokens()

        for _, leftToken := range leftTokens </span><span class="cov8" title="1">{
                if joinedToken := jn.performJoinWithTokens(leftToken, factToken); joinedToken != nil </span><span class="cov0" title="0">{

                        // Stocker uniquement les tokens de jointure r√©ussie
                        joinedToken.IsJoinResult = true
                        jn.mutex.Lock()
                        jn.ResultMemory.AddToken(joinedToken)
                        jn.Memory.AddToken(joinedToken) // Pour compatibilit√© avec le comptage
                        jn.mutex.Unlock()

                        if err := jn.PropagateToChildren(nil, joinedToken); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// performJoinWithTokens effectue la jointure entre deux tokens
func (jn *JoinNode) performJoinWithTokens(token1 *Token, token2 *Token) *Token <span class="cov8" title="1">{
        // V√©rifier que les tokens ont des variables diff√©rentes
        if !jn.tokensHaveDifferentVariables(token1, token2) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Combiner les bindings des deux tokens
        <span class="cov8" title="1">combinedBindings := make(map[string]*Fact)

        // Copier les bindings du premier token
        for varName, varFact := range token1.Bindings </span><span class="cov8" title="1">{
                combinedBindings[varName] = varFact
        }</span>

        // Copier les bindings du second token
        <span class="cov8" title="1">for varName, varFact := range token2.Bindings </span><span class="cov8" title="1">{
                combinedBindings[varName] = varFact
        }</span>

        // Valider les conditions de jointure
        <span class="cov8" title="1">if !jn.evaluateJoinConditions(combinedBindings) </span><span class="cov8" title="1">{
                return nil // Jointure √©choue
        }</span>

        // Cr√©er et retourner le token joint
        <span class="cov0" title="0">return &amp;Token{
                ID:       fmt.Sprintf("%s_JOIN_%s", token1.ID, token2.ID),
                Bindings: combinedBindings,
                NodeID:   jn.ID,
                Facts:    append(token1.Facts, token2.Facts...),
        }</span>
}

// tokensHaveDifferentVariables v√©rifie que les tokens repr√©sentent des variables diff√©rentes
func (jn *JoinNode) tokensHaveDifferentVariables(token1 *Token, token2 *Token) bool <span class="cov8" title="1">{
        for var1 := range token1.Bindings </span><span class="cov8" title="1">{
                for var2 := range token2.Bindings </span><span class="cov8" title="1">{
                        if var1 == var2 </span><span class="cov0" title="0">{
                                return false // M√™me variable = pas de jointure possible
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// getVariableForFact d√©termine la variable associ√©e √† un fait bas√© sur son type
func (jn *JoinNode) getVariableForFact(fact *Fact) string <span class="cov8" title="1">{
        // Utiliser le mapping variable -&gt; type du JoinNode
        for _, varName := range jn.AllVariables </span><span class="cov8" title="1">{
                if expectedType, exists := jn.VariableTypes[varName]; exists </span><span class="cov8" title="1">{
                        if expectedType == fact.Type </span><span class="cov8" title="1">{
                                return varName
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("‚ùå JOINNODE[%s]: Aucune variable trouv√©e pour fait %s (type: %s)\n", jn.ID, fact.ID, fact.Type)
        fmt.Printf("   Variables disponibles: %v\n", jn.AllVariables)
        fmt.Printf("   Types attendus: %v\n", jn.VariableTypes)
        return ""</span>
}

// evaluateJoinConditions v√©rifie si toutes les conditions de jointure sont respect√©es
func (jn *JoinNode) evaluateJoinConditions(bindings map[string]*Fact) bool <span class="cov8" title="1">{
        for varName, fact := range bindings </span><span class="cov8" title="1">{
                fmt.Printf("    %s -&gt; %s (ID: %s)\n", varName, fact.Type, fact.ID)
        }</span>
        <span class="cov8" title="1">for i, condition := range jn.JoinConditions </span><span class="cov8" title="1">{
                fmt.Printf("    Condition %d: %s.%s %s %s.%s\n", i,
                        condition.LeftVar, condition.LeftField, condition.Operator,
                        condition.RightVar, condition.RightField)
        }</span>

        // V√©rifier qu'on a au moins 2 variables diff√©rentes
        <span class="cov8" title="1">if len(bindings) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Printf("  ‚ùå Pas assez de variables (%d &lt; 2)\n", len(bindings))
                return false
        }</span>

        // NOUVEAU: √âvaluer la condition compl√®te qui peut contenir des expressions arithm√©tiques
        <span class="cov8" title="1">if jn.Condition != nil </span><span class="cov8" title="1">{
                evaluator := NewAlphaConditionEvaluator()
                // Activer le mode d'√©valuation partielle pour les jointures en cascade
                // o√π toutes les variables ne sont pas encore disponibles
                evaluator.SetPartialEvalMode(true)

                // Lier toutes les variables aux faits
                for varName, fact := range bindings </span><span class="cov8" title="1">{
                        evaluator.variableBindings[varName] = fact
                }</span>

                <span class="cov8" title="1">result, err := evaluator.evaluateExpression(jn.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">return result</span>
        }

        // LEGACY: √âvaluer les conditions de jointure extraites (simples comparaisons)
        // Note: Ce code est maintenant redondant si jn.Condition est √©valu√© ci-dessus,
        // mais conserv√© pour compatibilit√© avec les anciens tests
        <span class="cov0" title="0">for i, joinCondition := range jn.JoinConditions </span><span class="cov0" title="0">{
                leftFact := bindings[joinCondition.LeftVar]
                rightFact := bindings[joinCondition.RightVar]

                if leftFact == nil || rightFact == nil </span><span class="cov0" title="0">{
                        fmt.Printf("  ‚ùå Condition %d: variable manquante (%s ou %s)\n", i, joinCondition.LeftVar, joinCondition.RightVar)
                        return false // Une variable manque
                }</span>

                // R√©cup√©rer les valeurs des champs
                <span class="cov0" title="0">leftValue := leftFact.Fields[joinCondition.LeftField]
                rightValue := rightFact.Fields[joinCondition.RightField]

                // √âvaluer l'op√©rateur
                switch joinCondition.Operator </span>{
                case "==":<span class="cov0" title="0">
                        if leftValue != rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚ùå Condition %d √©choue: %v != %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  ‚úÖ Condition %d r√©ussie: %v == %v\n", i, leftValue, rightValue)</span>
                case "!=":<span class="cov0" title="0">
                        if leftValue == rightValue </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚ùå Condition %d √©choue: %v == %v\n", i, leftValue, rightValue)
                                return false
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  ‚úÖ Condition %d r√©ussie: %v != %v\n", i, leftValue, rightValue)</span>
                case "&lt;":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &gt;= rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false // Comparaison num√©rique impossible
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                case "&gt;":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &lt;= rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                case "&lt;=":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &gt; rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                case "&gt;=":<span class="cov0" title="0">
                        if leftFloat, leftOk := convertToFloat64(leftValue); leftOk </span><span class="cov0" title="0">{
                                if rightFloat, rightOk := convertToFloat64(rightValue); rightOk </span><span class="cov0" title="0">{
                                        if leftFloat &lt; rightFloat </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                default:<span class="cov0" title="0">
                        return false</span> // Op√©rateur non support√©
                }
        }

        <span class="cov0" title="0">return true</span> // Toutes les conditions sont satisfaites
}

// convertToFloat64 tente de convertir une valeur en float64
func convertToFloat64(value interface{}) (float64, bool) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, true</span>
        case float32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int:<span class="cov0" title="0">
                return float64(v), true</span>
        case int32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int64:<span class="cov0" title="0">
                return float64(v), true</span>
        case string:<span class="cov0" title="0">
                if f, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov0" title="0">{
                        return f, true
                }</span>
                <span class="cov0" title="0">return 0, false</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

// extractJoinConditions extrait les conditions de jointure d'une condition complexe
func extractJoinConditions(condition map[string]interface{}) []JoinCondition <span class="cov8" title="1">{
        for key, value := range condition </span><span class="cov8" title="1">{
                fmt.Printf("    %s: %v (type: %T)\n", key, value, value)
        }</span>

        <span class="cov8" title="1">var joinConditions []JoinCondition

        // Cas 1: condition wrapp√©e dans un type "constraint"
        if conditionType, exists := condition["type"].(string); exists &amp;&amp; conditionType == "constraint" </span><span class="cov8" title="1">{
                if innerCondition, ok := condition["constraint"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        fmt.Printf("  ‚úÖ Sous-condition extraite, analyse r√©cursive\n")
                        return extractJoinConditions(innerCondition)
                }</span>
        }

        // Cas 2: condition EXISTS avec array de conditions
        <span class="cov8" title="1">if conditionType, exists := condition["type"].(string); exists &amp;&amp; conditionType == "exists" </span><span class="cov0" title="0">{
                if conditionsData, ok := condition["conditions"].([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                        fmt.Printf("  ‚úÖ Array de conditions EXISTS trouv√©: %d conditions\n", len(conditionsData))
                        for _, subCondition := range conditionsData </span><span class="cov0" title="0">{
                                subJoinConditions := extractJoinConditions(subCondition)
                                joinConditions = append(joinConditions, subJoinConditions...)
                        }</span>
                        <span class="cov0" title="0">return joinConditions</span>
                }
        }

        // Cas 3: condition directe de comparaison
        <span class="cov8" title="1">if conditionType, exists := condition["type"].(string); exists &amp;&amp; conditionType == "comparison" </span><span class="cov8" title="1">{
                fmt.Printf("  ‚úÖ Condition de comparaison d√©tect√©e\n")
                if left, leftOk := condition["left"].(map[string]interface{}); leftOk </span><span class="cov8" title="1">{
                        if right, rightOk := condition["right"].(map[string]interface{}); rightOk </span><span class="cov8" title="1">{
                                fmt.Printf("  ‚úÖ Left et Right extraits\n")
                                if leftType, _ := left["type"].(string); leftType == "fieldAccess" </span><span class="cov8" title="1">{
                                        if rightType, _ := right["type"].(string); rightType == "fieldAccess" </span><span class="cov8" title="1">{
                                                // Condition de jointure d√©tect√©e
                                                fmt.Printf("  ‚úÖ Condition de jointure fieldAccess d√©tect√©e\n")
                                                leftObj, _ := left["object"].(string)
                                                leftField, _ := left["field"].(string)
                                                rightObj, _ := right["object"].(string)
                                                rightField, _ := right["field"].(string)
                                                operator, _ := condition["operator"].(string)

                                                fmt.Printf("    üìå %s.%s %s %s.%s\n", leftObj, leftField, operator, rightObj, rightField)

                                                joinConditions = append(joinConditions, JoinCondition{
                                                        LeftField:  leftField,
                                                        RightField: rightField,
                                                        LeftVar:    leftObj,
                                                        RightVar:   rightObj,
                                                        Operator:   operator,
                                                })
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return joinConditions</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "sync"
)

// RuleReference repr√©sente une r√©f√©rence √† une r√®gle utilisant un n≈ìud
type RuleReference struct {
        RuleID   string `json:"rule_id"`
        RuleName string `json:"rule_name,omitempty"`
}

// NodeLifecycle g√®re le cycle de vie d'un n≈ìud avec tracking des r√®gles qui l'utilisent
type NodeLifecycle struct {
        NodeID         string                    `json:"node_id"`
        NodeType       string                    `json:"node_type"`
        Rules          map[string]*RuleReference `json:"rules"` // Map[RuleID] -&gt; RuleReference
        RefCount       int                       `json:"ref_count"`
        CreatedByRules []string                  `json:"created_by_rules,omitempty"`
        mutex          sync.RWMutex              `json:"-"`
}

// NewNodeLifecycle cr√©e une nouvelle instance de gestion du cycle de vie
func NewNodeLifecycle(nodeID, nodeType string) *NodeLifecycle <span class="cov8" title="1">{
        return &amp;NodeLifecycle{
                NodeID:         nodeID,
                NodeType:       nodeType,
                Rules:          make(map[string]*RuleReference),
                RefCount:       0,
                CreatedByRules: make([]string, 0),
        }
}</span>

// AddRuleReference ajoute une r√©f√©rence de r√®gle √† ce n≈ìud
func (nl *NodeLifecycle) AddRuleReference(ruleID string, ruleName string) <span class="cov0" title="0">{
        nl.mutex.Lock()
        defer nl.mutex.Unlock()

        if _, exists := nl.Rules[ruleID]; !exists </span><span class="cov0" title="0">{
                nl.Rules[ruleID] = &amp;RuleReference{
                        RuleID:   ruleID,
                        RuleName: ruleName,
                }
                nl.RefCount++
                nl.CreatedByRules = append(nl.CreatedByRules, ruleID)
        }</span>
}

// RemoveRuleReference retire une r√©f√©rence de r√®gle de ce n≈ìud
func (nl *NodeLifecycle) RemoveRuleReference(ruleID string) bool <span class="cov0" title="0">{
        nl.mutex.Lock()
        defer nl.mutex.Unlock()

        if _, exists := nl.Rules[ruleID]; exists </span><span class="cov0" title="0">{
                delete(nl.Rules, ruleID)
                nl.RefCount--

                // Retirer de la liste des r√®gles cr√©atrices
                for i, id := range nl.CreatedByRules </span><span class="cov0" title="0">{
                        if id == ruleID </span><span class="cov0" title="0">{
                                nl.CreatedByRules = append(nl.CreatedByRules[:i], nl.CreatedByRules[i+1:]...)
                                break</span>
                        }
                }

                <span class="cov0" title="0">return nl.RefCount == 0</span> // Retourne true si plus aucune r√©f√©rence
        }

        <span class="cov0" title="0">return false</span>
}

// HasReferences retourne true si le n≈ìud a encore des r√©f√©rences
func (nl *NodeLifecycle) HasReferences() bool <span class="cov0" title="0">{
        nl.mutex.RLock()
        defer nl.mutex.RUnlock()
        return nl.RefCount &gt; 0
}</span>

// GetRefCount retourne le nombre de r√©f√©rences
func (nl *NodeLifecycle) GetRefCount() int <span class="cov0" title="0">{
        nl.mutex.RLock()
        defer nl.mutex.RUnlock()
        return nl.RefCount
}</span>

// GetRules retourne la liste des IDs de r√®gles r√©f√©ren√ßant ce n≈ìud
func (nl *NodeLifecycle) GetRules() []string <span class="cov0" title="0">{
        nl.mutex.RLock()
        defer nl.mutex.RUnlock()

        rules := make([]string, 0, len(nl.Rules))
        for ruleID := range nl.Rules </span><span class="cov0" title="0">{
                rules = append(rules, ruleID)
        }</span>
        <span class="cov0" title="0">return rules</span>
}

// GetRuleInfo retourne les informations d'une r√®gle sp√©cifique
func (nl *NodeLifecycle) GetRuleInfo(ruleID string) (*RuleReference, bool) <span class="cov0" title="0">{
        nl.mutex.RLock()
        defer nl.mutex.RUnlock()

        ref, exists := nl.Rules[ruleID]
        return ref, exists
}</span>

// LifecycleManager g√®re le cycle de vie de tous les n≈ìuds du r√©seau
type LifecycleManager struct {
        Nodes map[string]*NodeLifecycle `json:"nodes"` // Map[NodeID] -&gt; NodeLifecycle
        mutex sync.RWMutex              `json:"-"`
}

// NewLifecycleManager cr√©e un nouveau gestionnaire de cycle de vie
func NewLifecycleManager() *LifecycleManager <span class="cov8" title="1">{
        return &amp;LifecycleManager{
                Nodes: make(map[string]*NodeLifecycle),
        }
}</span>

// RegisterNode enregistre un nouveau n≈ìud dans le gestionnaire
func (lm *LifecycleManager) RegisterNode(nodeID, nodeType string) *NodeLifecycle <span class="cov8" title="1">{
        lm.mutex.Lock()
        defer lm.mutex.Unlock()

        if lifecycle, exists := lm.Nodes[nodeID]; exists </span><span class="cov0" title="0">{
                return lifecycle
        }</span>

        <span class="cov8" title="1">lifecycle := NewNodeLifecycle(nodeID, nodeType)
        lm.Nodes[nodeID] = lifecycle
        return lifecycle</span>
}

// AddRuleToNode associe une r√®gle √† un n≈ìud
func (lm *LifecycleManager) AddRuleToNode(nodeID, ruleID, ruleName string) error <span class="cov0" title="0">{
        lm.mutex.RLock()
        lifecycle, exists := lm.Nodes[nodeID]
        lm.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("n≈ìud %s non enregistr√© dans le lifecycle manager", nodeID)
        }</span>

        <span class="cov0" title="0">lifecycle.AddRuleReference(ruleID, ruleName)
        return nil</span>
}

// RemoveRuleFromNode retire une r√®gle d'un n≈ìud
// Retourne true si le n≈ìud n'a plus de r√©f√©rences et peut √™tre supprim√©
func (lm *LifecycleManager) RemoveRuleFromNode(nodeID, ruleID string) (bool, error) <span class="cov0" title="0">{
        lm.mutex.RLock()
        lifecycle, exists := lm.Nodes[nodeID]
        lm.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("n≈ìud %s non trouv√©", nodeID)
        }</span>

        <span class="cov0" title="0">shouldDelete := lifecycle.RemoveRuleReference(ruleID)
        return shouldDelete, nil</span>
}

// RemoveNode supprime compl√®tement un n≈ìud du gestionnaire
func (lm *LifecycleManager) RemoveNode(nodeID string) error <span class="cov0" title="0">{
        lm.mutex.Lock()
        defer lm.mutex.Unlock()

        if lifecycle, exists := lm.Nodes[nodeID]; exists </span><span class="cov0" title="0">{
                if lifecycle.HasReferences() </span><span class="cov0" title="0">{
                        return fmt.Errorf("impossible de supprimer le n≈ìud %s: encore %d r√©f√©rence(s)",
                                nodeID, lifecycle.RefCount)
                }</span>
                <span class="cov0" title="0">delete(lm.Nodes, nodeID)
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("n≈ìud %s non trouv√©", nodeID)</span>
}

// GetNodeLifecycle r√©cup√®re le lifecycle d'un n≈ìud
func (lm *LifecycleManager) GetNodeLifecycle(nodeID string) (*NodeLifecycle, bool) <span class="cov0" title="0">{
        lm.mutex.RLock()
        defer lm.mutex.RUnlock()

        lifecycle, exists := lm.Nodes[nodeID]
        return lifecycle, exists
}</span>

// GetNodesForRule retourne tous les n≈ìuds utilis√©s par une r√®gle donn√©e
func (lm *LifecycleManager) GetNodesForRule(ruleID string) []string <span class="cov8" title="1">{
        lm.mutex.RLock()
        defer lm.mutex.RUnlock()

        nodes := make([]string, 0)
        for nodeID, lifecycle := range lm.Nodes </span><span class="cov8" title="1">{
                if _, exists := lifecycle.Rules[ruleID]; exists </span><span class="cov0" title="0">{
                        nodes = append(nodes, nodeID)
                }</span>
        }
        <span class="cov8" title="1">return nodes</span>
}

// CanRemoveNode v√©rifie si un n≈ìud peut √™tre supprim√© (pas de r√©f√©rences)
func (lm *LifecycleManager) CanRemoveNode(nodeID string) bool <span class="cov0" title="0">{
        lm.mutex.RLock()
        defer lm.mutex.RUnlock()

        if lifecycle, exists := lm.Nodes[nodeID]; exists </span><span class="cov0" title="0">{
                return !lifecycle.HasReferences()
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetStats retourne des statistiques sur le gestionnaire
func (lm *LifecycleManager) GetStats() map[string]interface{} <span class="cov8" title="1">{
        lm.mutex.RLock()
        defer lm.mutex.RUnlock()

        totalNodes := len(lm.Nodes)
        totalRefs := 0
        nodesWithoutRefs := 0

        for _, lifecycle := range lm.Nodes </span><span class="cov8" title="1">{
                totalRefs += lifecycle.RefCount
                if lifecycle.RefCount == 0 </span><span class="cov8" title="1">{
                        nodesWithoutRefs++
                }</span>
        }

        <span class="cov8" title="1">return map[string]interface{}{
                "total_nodes":        totalNodes,
                "total_references":   totalRefs,
                "nodes_without_refs": nodesWithoutRefs,
                "nodes_with_refs":    totalNodes - nodesWithoutRefs,
        }</span>
}

// Reset r√©initialise compl√®tement le gestionnaire
func (lm *LifecycleManager) Reset() <span class="cov0" title="0">{
        lm.mutex.Lock()
        defer lm.mutex.Unlock()
        lm.Nodes = make(map[string]*NodeLifecycle)
}</span>

// RuleInfo contient les informations d'une r√®gle et ses n≈ìuds
type RuleInfo struct {
        RuleID    string   `json:"rule_id"`
        RuleName  string   `json:"rule_name,omitempty"`
        NodeIDs   []string `json:"node_ids"`
        NodeCount int      `json:"node_count"`
}

// GetRuleInfo retourne les informations compl√®tes d'une r√®gle
func (lm *LifecycleManager) GetRuleInfo(ruleID string) *RuleInfo <span class="cov0" title="0">{
        nodes := lm.GetNodesForRule(ruleID)

        info := &amp;RuleInfo{
                RuleID:    ruleID,
                NodeIDs:   nodes,
                NodeCount: len(nodes),
        }

        // Essayer de r√©cup√©rer le nom de la r√®gle depuis le premier n≈ìud trouv√©
        if len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                if lifecycle, exists := lm.GetNodeLifecycle(nodes[0]); exists </span><span class="cov0" title="0">{
                        if ref, ok := lifecycle.GetRuleInfo(ruleID); ok </span><span class="cov0" title="0">{
                                info.RuleName = ref.RuleName
                        }</span>
                }
        }

        <span class="cov0" title="0">return info</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
)

type RootNode struct {
        BaseNode
}

// NewRootNode cr√©e un nouveau n≈ìud racine
func NewRootNode(storage Storage) *RootNode <span class="cov8" title="1">{
        return &amp;RootNode{
                BaseNode: BaseNode{
                        ID:       "root",
                        Type:     "root",
                        Memory:   &amp;WorkingMemory{NodeID: "root", Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
        }
}</span>

// ActivateLeft (non utilis√© pour le n≈ìud racine)
func (rn *RootNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("le n≈ìud racine ne peut pas recevoir de tokens")
}</span>

// ActivateRetract retire le fait de la m√©moire racine et propage aux enfants
func (rn *RootNode) ActivateRetract(factID string) error <span class="cov0" title="0">{
        rn.mutex.Lock()
        rn.Memory.RemoveFact(factID)
        rn.mutex.Unlock()
        fmt.Printf("üóëÔ∏è  [ROOT] R√©tractation du fait: %s\n", factID)
        return rn.PropagateRetractToChildren(factID)
}</span>

// ActivateRight distribue les faits aux n≈ìuds de type
func (rn *RootNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        rn.mutex.Lock()
        if err := rn.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                rn.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans root node: %w", err)
        }</span>
        <span class="cov8" title="1">rn.mutex.Unlock()

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[ROOT] Re√ßu fait: %s\n", fact.String())

        // Persistance d√©sactiv√©e pour les performances

        // Propager aux enfants (TypeNodes)
        return rn.PropagateToChildren(fact, nil)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
)

type TerminalNode struct {
        BaseNode
        Action *Action `json:"action"`
}

// NewTerminalNode cr√©e un nouveau n≈ìud terminal
func NewTerminalNode(nodeID string, action *Action, storage Storage) *TerminalNode <span class="cov8" title="1">{
        return &amp;TerminalNode{
                BaseNode: BaseNode{
                        ID:       nodeID,
                        Type:     "terminal",
                        Memory:   &amp;WorkingMemory{NodeID: nodeID, Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0), // Les n≈ìuds terminaux n'ont pas d'enfants
                        Storage:  storage,
                },
                Action: action,
        }
}</span>

// ActivateLeft d√©clenche l'action
func (tn *TerminalNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[TERMINAL_%s] D√©clenchement action avec token: %s\n", tn.ID, token.ID)

        // Stocker le token
        tn.mutex.Lock()
        if tn.Memory.Tokens == nil </span><span class="cov0" title="0">{
                tn.Memory.Tokens = make(map[string]*Token)
        }</span>
        <span class="cov0" title="0">tn.Memory.Tokens[token.ID] = token
        tn.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // D√©clencher l'action
        return tn.executeAction(token)</span>
}

// ActivateRetract retrait des tokens contenant le fait r√©tract√©
// factID doit √™tre l'identifiant interne (Type_ID)
func (tn *TerminalNode) ActivateRetract(factID string) error <span class="cov0" title="0">{
        tn.mutex.Lock()
        var tokensToRemove []string
        for tokenID, token := range tn.Memory.Tokens </span><span class="cov0" title="0">{
                for _, fact := range token.Facts </span><span class="cov0" title="0">{
                        if fact.GetInternalID() == factID </span><span class="cov0" title="0">{
                                tokensToRemove = append(tokensToRemove, tokenID)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, tokenID := range tokensToRemove </span><span class="cov0" title="0">{
                delete(tn.Memory.Tokens, tokenID)
        }</span>
        <span class="cov0" title="0">tn.mutex.Unlock()
        if len(tokensToRemove) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("üóëÔ∏è  [TERMINAL_%s] R√©tractation: %d tokens retir√©s\n", tn.ID, len(tokensToRemove))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetTriggeredActions retourne les actions d√©clench√©es (pour les tests)
func (tn *TerminalNode) GetTriggeredActions() []*Action <span class="cov0" title="0">{
        tn.mutex.RLock()
        defer tn.mutex.RUnlock()

        actions := make([]*Action, 0, len(tn.Memory.Tokens))
        for range tn.Memory.Tokens </span><span class="cov0" title="0">{
                actions = append(actions, tn.Action)
        }</span>
        <span class="cov0" title="0">return actions</span>
}

// ActivateRight (non utilis√© pour les n≈ìuds terminaux)
func (tn *TerminalNode) ActivateRight(fact *Fact) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds terminaux ne re√ßoivent pas de faits directement")
}</span>

// executeAction affiche l'action d√©clench√©e avec les faits d√©clencheurs (version tuple-space)
func (tn *TerminalNode) executeAction(token *Token) error <span class="cov0" title="0">{
        // Les actions sont maintenant obligatoires dans la grammaire
        // Mais nous gardons cette v√©rification par s√©curit√©
        if tn.Action == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("aucune action d√©finie pour le n≈ìud %s", tn.ID)
        }</span>

        // === VERSION TUPLE-SPACE ===
        // Au lieu d'ex√©cuter l'action, on l'affiche avec les faits d√©clencheurs
        // Les agents du tuple-space viendront "prendre" ces tuples plus tard

        <span class="cov0" title="0">actionName := tn.Action.Job.Name
        fmt.Printf("üéØ ACTION DISPONIBLE DANS TUPLE-SPACE: %s", actionName)

        // Afficher les faits d√©clencheurs entre parenth√®ses
        if len(token.Facts) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Print(" (")
                for i, fact := range token.Facts </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Print(", ")
                        }</span>
                        // Format compact : Type(id:value, field:value, ...)
                        <span class="cov0" title="0">fmt.Printf("%s(", fact.Type)
                        fieldCount := 0
                        for key, value := range fact.Fields </span><span class="cov0" title="0">{
                                if fieldCount &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Print(", ")
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("%s:%v", key, value)
                                fieldCount++</span>
                        }
                        <span class="cov0" title="0">fmt.Print(")")</span>
                }
                <span class="cov0" title="0">fmt.Print(")")</span>
        }
        <span class="cov0" title="0">fmt.Println()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
)

type TypeNode struct {
        BaseNode
        TypeName       string         `json:"type_name"`
        TypeDefinition TypeDefinition `json:"type_definition"`
}

// NewTypeNode cr√©e un nouveau n≈ìud de type
func NewTypeNode(typeName string, typeDef TypeDefinition, storage Storage) *TypeNode <span class="cov8" title="1">{
        return &amp;TypeNode{
                BaseNode: BaseNode{
                        ID:       fmt.Sprintf("type_%s", typeName),
                        Type:     "type",
                        Memory:   &amp;WorkingMemory{NodeID: fmt.Sprintf("type_%s", typeName), Facts: make(map[string]*Fact), Tokens: make(map[string]*Token)},
                        Children: make([]Node, 0),
                        Storage:  storage,
                },
                TypeName:       typeName,
                TypeDefinition: typeDef,
        }
}</span>

// ActivateLeft (non utilis√© pour les n≈ìuds de type)
func (tn *TypeNode) ActivateLeft(token *Token) error <span class="cov0" title="0">{
        return fmt.Errorf("les n≈ìuds de type ne re√ßoivent pas de tokens")
}</span>

// ActivateRetract retire le fait de la m√©moire de type et propage aux enfants
// factID doit √™tre l'identifiant interne (Type_ID)
func (tn *TypeNode) ActivateRetract(factID string) error <span class="cov0" title="0">{
        tn.mutex.Lock()
        _, exists := tn.Memory.GetFact(factID)
        if exists </span><span class="cov0" title="0">{
                tn.Memory.RemoveFact(factID)
        }</span>
        <span class="cov0" title="0">tn.mutex.Unlock()
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">fmt.Printf("üóëÔ∏è  [TYPE_%s] R√©tractation du fait: %s\n", tn.ID, factID)
        return tn.PropagateRetractToChildren(factID)</span>
}

// ActivateRight filtre les faits par type et les propage
func (tn *TypeNode) ActivateRight(fact *Fact) error <span class="cov8" title="1">{
        // V√©rifier si le fait correspond au type de ce n≈ìud
        if fact.Type != tn.TypeName </span><span class="cov8" title="1">{
                return nil // Ignorer silencieusement les faits d'autres types
        }</span>

        // Log d√©sactiv√© pour les performances
        // fmt.Printf("[TYPE_%s] Re√ßu fait: %s\n", tn.TypeName, fact.String())

        // Valider les champs du fait
        <span class="cov8" title="1">if err := tn.validateFact(fact); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation du fait √©chou√©e: %w", err)
        }</span>

        <span class="cov8" title="1">tn.mutex.Lock()
        if err := tn.Memory.AddFact(fact); err != nil </span><span class="cov0" title="0">{
                tn.mutex.Unlock()
                return fmt.Errorf("erreur ajout fait dans type node: %w", err)
        }</span>
        <span class="cov8" title="1">tn.mutex.Unlock()

        // Persistance d√©sactiv√©e pour les performances

        // Propager aux enfants (AlphaNodes)
        return tn.PropagateToChildren(fact, nil)</span>
}

// validateFact valide qu'un fait respecte la d√©finition de type
func (tn *TypeNode) validateFact(fact *Fact) error <span class="cov8" title="1">{
        for _, field := range tn.TypeDefinition.Fields </span><span class="cov8" title="1">{
                // Le champ "id" est stock√© dans fact.ID, pas dans Fields
                if field.Name == "id" </span><span class="cov8" title="1">{
                        if fact.ID == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("champ manquant: %s", field.Name)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">value, exists := fact.Fields[field.Name]
                if !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("champ manquant: %s", field.Name)
                }</span>

                // Validation basique des types
                <span class="cov8" title="1">if !tn.isValidType(value, field.Type) </span><span class="cov0" title="0">{
                        return fmt.Errorf("type invalide pour le champ %s: attendu %s", field.Name, field.Type)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// isValidType v√©rifie si une valeur correspond au type attendu
func (tn *TypeNode) isValidType(value interface{}, expectedType string) bool <span class="cov8" title="1">{
        switch expectedType </span>{
        case "string":<span class="cov8" title="1">
                _, ok := value.(string)
                return ok</span>
        case "number":<span class="cov8" title="1">
                switch value.(type) </span>{
                case int, int32, int64, float32, float64:<span class="cov8" title="1">
                        return true</span>
                }
                <span class="cov0" title="0">return false</span>
        case "bool":<span class="cov0" title="0">
                _, ok := value.(bool)
                return ok</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "sync"
        "sync/atomic"
)

// NormalizationCache stocke les expressions normalis√©es pour am√©liorer les performances
type NormalizationCache struct {
        enabled  bool
        maxSize  int
        cache    map[string]interface{}
        mutex    sync.RWMutex
        hits     atomic.Int64
        misses   atomic.Int64
        eviction string // Strat√©gie d'√©viction: "lru", "fifo", "none"
        lru      *lruTracker
}

// CacheStats contient les statistiques du cache
type CacheStats struct {
        Hits     int64   `json:"hits"`
        Misses   int64   `json:"misses"`
        Size     int     `json:"size"`
        MaxSize  int     `json:"maxSize"`
        HitRate  float64 `json:"hitRate"`
        Enabled  bool    `json:"enabled"`
        Eviction string  `json:"eviction"`
}

// lruTracker garde la trace de l'ordre d'acc√®s pour l'√©viction LRU
type lruTracker struct {
        order []string
        index map[string]int
        mutex sync.Mutex
}

// newLRUTracker cr√©e un nouveau tracker LRU
func newLRUTracker() *lruTracker <span class="cov0" title="0">{
        return &amp;lruTracker{
                order: make([]string, 0),
                index: make(map[string]int),
        }
}</span>

// touch marque une cl√© comme r√©cemment utilis√©e
func (lru *lruTracker) touch(key string) <span class="cov0" title="0">{
        lru.mutex.Lock()
        defer lru.mutex.Unlock()

        // Si la cl√© existe d√©j√†, la retirer de sa position actuelle
        if idx, exists := lru.index[key]; exists </span><span class="cov0" title="0">{
                lru.order = append(lru.order[:idx], lru.order[idx+1:]...)
                // Mettre √† jour les index
                for i := idx; i &lt; len(lru.order); i++ </span><span class="cov0" title="0">{
                        lru.index[lru.order[i]] = i
                }</span>
        }

        // Ajouter la cl√© √† la fin (plus r√©cente)
        <span class="cov0" title="0">lru.order = append(lru.order, key)
        lru.index[key] = len(lru.order) - 1</span>
}

// getLeastRecentlyUsed retourne la cl√© la moins r√©cemment utilis√©e
func (lru *lruTracker) getLeastRecentlyUsed() string <span class="cov0" title="0">{
        lru.mutex.Lock()
        defer lru.mutex.Unlock()

        if len(lru.order) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return lru.order[0]</span>
}

// remove retire une cl√© du tracker
func (lru *lruTracker) remove(key string) <span class="cov0" title="0">{
        lru.mutex.Lock()
        defer lru.mutex.Unlock()

        if idx, exists := lru.index[key]; exists </span><span class="cov0" title="0">{
                lru.order = append(lru.order[:idx], lru.order[idx+1:]...)
                delete(lru.index, key)
                // Mettre √† jour les index
                for i := idx; i &lt; len(lru.order); i++ </span><span class="cov0" title="0">{
                        lru.index[lru.order[i]] = i
                }</span>
        }
}

// clear vide le tracker
func (lru *lruTracker) clear() <span class="cov0" title="0">{
        lru.mutex.Lock()
        defer lru.mutex.Unlock()
        lru.order = make([]string, 0)
        lru.index = make(map[string]int)
}</span>

// globalNormalizationCache est l'instance globale du cache (optionnelle)
var globalNormalizationCache *NormalizationCache

// NewNormalizationCache cr√©e un nouveau cache de normalisation
func NewNormalizationCache(maxSize int) *NormalizationCache <span class="cov0" title="0">{
        return &amp;NormalizationCache{
                enabled:  true,
                maxSize:  maxSize,
                cache:    make(map[string]interface{}),
                eviction: "lru",
                lru:      newLRUTracker(),
        }
}</span>

// NewNormalizationCacheWithEviction cr√©e un cache avec une strat√©gie d'√©viction sp√©cifique
func NewNormalizationCacheWithEviction(maxSize int, eviction string) *NormalizationCache <span class="cov0" title="0">{
        cache := &amp;NormalizationCache{
                enabled:  true,
                maxSize:  maxSize,
                cache:    make(map[string]interface{}),
                eviction: eviction,
        }
        if eviction == "lru" </span><span class="cov0" title="0">{
                cache.lru = newLRUTracker()
        }</span>
        <span class="cov0" title="0">return cache</span>
}

// SetGlobalCache d√©finit le cache global de normalisation
func SetGlobalCache(cache *NormalizationCache) <span class="cov0" title="0">{
        globalNormalizationCache = cache
}</span>

// GetGlobalCache retourne le cache global de normalisation
func GetGlobalCache() *NormalizationCache <span class="cov0" title="0">{
        return globalNormalizationCache
}</span>

// Enable active le cache
func (nc *NormalizationCache) Enable() <span class="cov0" title="0">{
        nc.mutex.Lock()
        defer nc.mutex.Unlock()
        nc.enabled = true
}</span>

// Disable d√©sactive le cache
func (nc *NormalizationCache) Disable() <span class="cov0" title="0">{
        nc.mutex.Lock()
        defer nc.mutex.Unlock()
        nc.enabled = false
}</span>

// IsEnabled retourne true si le cache est activ√©
func (nc *NormalizationCache) IsEnabled() bool <span class="cov0" title="0">{
        nc.mutex.RLock()
        defer nc.mutex.RUnlock()
        return nc.enabled
}</span>

// Get r√©cup√®re une expression normalis√©e du cache
func (nc *NormalizationCache) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        if !nc.IsEnabled() </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">nc.mutex.RLock()
        value, exists := nc.cache[key]
        nc.mutex.RUnlock()

        if exists </span><span class="cov0" title="0">{
                nc.hits.Add(1)
                if nc.eviction == "lru" &amp;&amp; nc.lru != nil </span><span class="cov0" title="0">{
                        nc.lru.touch(key)
                }</span>
                <span class="cov0" title="0">return value, true</span>
        }

        <span class="cov0" title="0">nc.misses.Add(1)
        return nil, false</span>
}

// Set ajoute une expression normalis√©e au cache
func (nc *NormalizationCache) Set(key string, value interface{}) <span class="cov0" title="0">{
        if !nc.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">nc.mutex.Lock()
        defer nc.mutex.Unlock()

        // Si le cache est plein, appliquer l'√©viction
        if len(nc.cache) &gt;= nc.maxSize &amp;&amp; nc.maxSize &gt; 0 </span><span class="cov0" title="0">{
                nc.evict()
        }</span>

        <span class="cov0" title="0">nc.cache[key] = value

        if nc.eviction == "lru" &amp;&amp; nc.lru != nil </span><span class="cov0" title="0">{
                nc.lru.touch(key)
        }</span>
}

// evict retire une entr√©e du cache selon la strat√©gie d'√©viction
// DOIT √™tre appel√© avec le mutex verrouill√©
func (nc *NormalizationCache) evict() <span class="cov0" title="0">{
        if len(nc.cache) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch nc.eviction </span>{
        case "lru":<span class="cov0" title="0">
                if nc.lru != nil </span><span class="cov0" title="0">{
                        keyToEvict := nc.lru.getLeastRecentlyUsed()
                        if keyToEvict != "" </span><span class="cov0" title="0">{
                                delete(nc.cache, keyToEvict)
                                nc.lru.remove(keyToEvict)
                        }</span>
                }
        case "fifo":<span class="cov0" title="0">
                // Pour FIFO, on retire la premi√®re cl√© (arbitraire dans une map Go)
                for key := range nc.cache </span><span class="cov0" title="0">{
                        delete(nc.cache, key)
                        break</span>
                }
        default:<span class="cov0" title="0">
                // Pas d'√©viction, on refuse d'ajouter
                return</span>
        }
}

// Clear vide compl√®tement le cache
func (nc *NormalizationCache) Clear() <span class="cov0" title="0">{
        nc.mutex.Lock()
        defer nc.mutex.Unlock()

        nc.cache = make(map[string]interface{})
        if nc.lru != nil </span><span class="cov0" title="0">{
                nc.lru.clear()
        }</span>
}

// ResetStats r√©initialise les statistiques du cache
func (nc *NormalizationCache) ResetStats() <span class="cov0" title="0">{
        nc.hits.Store(0)
        nc.misses.Store(0)
}</span>

// GetStats retourne les statistiques du cache
func (nc *NormalizationCache) GetStats() CacheStats <span class="cov0" title="0">{
        nc.mutex.RLock()
        size := len(nc.cache)
        enabled := nc.enabled
        eviction := nc.eviction
        nc.mutex.RUnlock()

        hits := nc.hits.Load()
        misses := nc.misses.Load()
        total := hits + misses

        hitRate := 0.0
        if total &gt; 0 </span><span class="cov0" title="0">{
                hitRate = float64(hits) / float64(total)
        }</span>

        <span class="cov0" title="0">return CacheStats{
                Hits:     hits,
                Misses:   misses,
                Size:     size,
                MaxSize:  nc.maxSize,
                HitRate:  hitRate,
                Enabled:  enabled,
                Eviction: eviction,
        }</span>
}

// Size retourne le nombre d'entr√©es dans le cache
func (nc *NormalizationCache) Size() int <span class="cov0" title="0">{
        nc.mutex.RLock()
        defer nc.mutex.RUnlock()
        return len(nc.cache)
}</span>

// computeCacheKey calcule une cl√© de cache unique pour une expression
func computeCacheKey(expr interface{}) string <span class="cov0" title="0">{
        // S√©rialiser l'expression en JSON pour avoir une repr√©sentation unique
        jsonBytes, err := json.Marshal(expr)
        if err != nil </span><span class="cov0" title="0">{
                // En cas d'erreur, utiliser une repr√©sentation string
                return fmt.Sprintf("%T:%v", expr, expr)
        }</span>

        // Calculer le hash SHA-256
        <span class="cov0" title="0">hash := sha256.Sum256(jsonBytes)
        return fmt.Sprintf("%x", hash)</span>
}

// NormalizeExpressionWithCache normalise une expression en utilisant le cache
func NormalizeExpressionWithCache(expr interface{}, cache *NormalizationCache) (interface{}, error) <span class="cov0" title="0">{
        // Si pas de cache ou cache d√©sactiv√©, utiliser la normalisation directe
        if cache == nil || !cache.IsEnabled() </span><span class="cov0" title="0">{
                return NormalizeExpression(expr)
        }</span>

        // Calculer la cl√© du cache
        <span class="cov0" title="0">key := computeCacheKey(expr)

        // Chercher dans le cache
        if cached, found := cache.Get(key); found </span><span class="cov0" title="0">{
                return cached, nil
        }</span>

        // Pas dans le cache, normaliser
        <span class="cov0" title="0">normalized, err := NormalizeExpression(expr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Stocker dans le cache
        <span class="cov0" title="0">cache.Set(key, normalized)

        return normalized, nil</span>
}

// NormalizeExpressionCached normalise une expression en utilisant le cache global
func NormalizeExpressionCached(expr interface{}) (interface{}, error) <span class="cov0" title="0">{
        return NormalizeExpressionWithCache(expr, globalNormalizationCache)
}</span>

// SetCacheMaxSize change la taille maximum du cache
func (nc *NormalizationCache) SetCacheMaxSize(maxSize int) <span class="cov0" title="0">{
        nc.mutex.Lock()
        defer nc.mutex.Unlock()
        nc.maxSize = maxSize

        // Si le cache est maintenant trop grand, √©vincer des entr√©es
        for len(nc.cache) &gt; maxSize &amp;&amp; maxSize &gt; 0 </span><span class="cov0" title="0">{
                nc.evict()
        }</span>
}

// SetEvictionStrategy change la strat√©gie d'√©viction
func (nc *NormalizationCache) SetEvictionStrategy(strategy string) <span class="cov0" title="0">{
        nc.mutex.Lock()
        defer nc.mutex.Unlock()

        nc.eviction = strategy

        // Initialiser le tracker LRU si n√©cessaire
        if strategy == "lru" &amp;&amp; nc.lru == nil </span><span class="cov0" title="0">{
                nc.lru = newLRUTracker()
                // Peupler le tracker avec les cl√©s existantes
                for key := range nc.cache </span><span class="cov0" title="0">{
                        nc.lru.touch(key)
                }</span>
        }
}

// GetHitRate retourne le taux de succ√®s du cache (0.0 √† 1.0)
func (nc *NormalizationCache) GetHitRate() float64 <span class="cov0" title="0">{
        hits := nc.hits.Load()
        misses := nc.misses.Load()
        total := hits + misses

        if total == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return float64(hits) / float64(total)</span>
}

// String retourne une repr√©sentation string des statistiques du cache
func (cs CacheStats) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "CacheStats{Hits: %d, Misses: %d, Size: %d/%d, HitRate: %.2f%%, Enabled: %v, Eviction: %s}",
                cs.Hits,
                cs.Misses,
                cs.Size,
                cs.MaxSize,
                cs.HitRate*100,
                cs.Enabled,
                cs.Eviction,
        )
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "net/http"
        "sync"
        "time"
)

// PrometheusExporter exporte les m√©triques RETE vers Prometheus
type PrometheusExporter struct {
        alphaMetrics *ChainBuildMetrics
        betaMetrics  *BetaChainMetrics
        config       *ChainPerformanceConfig
        mutex        sync.RWMutex

        // Registres des m√©triques
        registry map[string]*prometheusMetric
}

// prometheusMetric repr√©sente une m√©trique Prometheus
type prometheusMetric struct {
        name       string
        help       string
        metricType string // "counter", "gauge", "histogram"
        value      float64
        labels     map[string]string
}

// NewPrometheusExporter cr√©e un nouveau exporteur Prometheus pour les m√©triques alpha
func NewPrometheusExporter(metrics *ChainBuildMetrics, config *ChainPerformanceConfig) *PrometheusExporter <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultChainPerformanceConfig()
        }</span>

        <span class="cov0" title="0">return &amp;PrometheusExporter{
                alphaMetrics: metrics,
                config:       config,
                registry:     make(map[string]*prometheusMetric),
        }</span>
}

// NewPrometheusExporterWithBeta cr√©e un exporteur avec m√©triques alpha et beta
func NewPrometheusExporterWithBeta(alphaMetrics *ChainBuildMetrics, betaMetrics *BetaChainMetrics, config *ChainPerformanceConfig) *PrometheusExporter <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultChainPerformanceConfig()
        }</span>

        <span class="cov0" title="0">return &amp;PrometheusExporter{
                alphaMetrics: alphaMetrics,
                betaMetrics:  betaMetrics,
                config:       config,
                registry:     make(map[string]*prometheusMetric),
        }</span>
}

// RegisterMetrics enregistre toutes les m√©triques Prometheus
func (pe *PrometheusExporter) RegisterMetrics() <span class="cov0" title="0">{
        prefix := pe.config.PrometheusPrefix

        // M√©triques de cha√Ænes alpha
        pe.registerMetric(fmt.Sprintf("%s_alpha_chains_built_total", prefix),
                "Total number of alpha chains built",
                "counter")

        pe.registerMetric(fmt.Sprintf("%s_alpha_chains_length_avg", prefix),
                "Average length of alpha chains",
                "gauge")

        // M√©triques de n≈ìuds alpha
        pe.registerMetric(fmt.Sprintf("%s_alpha_nodes_created_total", prefix),
                "Total number of alpha nodes created",
                "counter")

        pe.registerMetric(fmt.Sprintf("%s_alpha_nodes_reused_total", prefix),
                "Total number of alpha nodes reused",
                "counter")

        pe.registerMetric(fmt.Sprintf("%s_alpha_nodes_sharing_ratio", prefix),
                "Ratio of alpha node sharing (0.0 to 1.0)",
                "gauge")

        // M√©triques de cache de hash alpha
        pe.registerMetric(fmt.Sprintf("%s_alpha_hash_cache_hits_total", prefix),
                "Total number of alpha hash cache hits",
                "counter")

        pe.registerMetric(fmt.Sprintf("%s_alpha_hash_cache_misses_total", prefix),
                "Total number of alpha hash cache misses",
                "counter")

        pe.registerMetric(fmt.Sprintf("%s_alpha_hash_cache_size", prefix),
                "Current size of alpha hash cache",
                "gauge")

        pe.registerMetric(fmt.Sprintf("%s_alpha_hash_cache_efficiency", prefix),
                "Alpha hash cache efficiency (0.0 to 1.0)",
                "gauge")

        // M√©triques de cache de connexion alpha
        pe.registerMetric(fmt.Sprintf("%s_alpha_connection_cache_hits_total", prefix),
                "Total number of alpha connection cache hits",
                "counter")

        pe.registerMetric(fmt.Sprintf("%s_alpha_connection_cache_misses_total", prefix),
                "Total number of alpha connection cache misses",
                "counter")

        pe.registerMetric(fmt.Sprintf("%s_alpha_connection_cache_efficiency", prefix),
                "Alpha connection cache efficiency (0.0 to 1.0)",
                "gauge")

        // M√©triques de temps alpha
        pe.registerMetric(fmt.Sprintf("%s_alpha_build_time_seconds_total", prefix),
                "Total time spent building alpha chains in seconds",
                "counter")

        pe.registerMetric(fmt.Sprintf("%s_alpha_build_time_seconds_avg", prefix),
                "Average time spent building an alpha chain in seconds",
                "gauge")

        pe.registerMetric(fmt.Sprintf("%s_alpha_hash_compute_time_seconds_total", prefix),
                "Total time spent computing alpha hashes in seconds",
                "counter")

        // M√©triques de cha√Ænes beta (si disponibles)
        if pe.betaMetrics != nil </span><span class="cov0" title="0">{
                pe.registerMetric(fmt.Sprintf("%s_beta_chains_built_total", prefix),
                        "Total number of beta chains built",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_chains_length_avg", prefix),
                        "Average length of beta chains",
                        "gauge")

                // M√©triques de n≈ìuds beta
                pe.registerMetric(fmt.Sprintf("%s_beta_nodes_created_total", prefix),
                        "Total number of beta nodes created",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_nodes_reused_total", prefix),
                        "Total number of beta nodes reused",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_nodes_sharing_ratio", prefix),
                        "Ratio of beta node sharing (0.0 to 1.0)",
                        "gauge")

                // M√©triques de jointures
                pe.registerMetric(fmt.Sprintf("%s_beta_joins_executed_total", prefix),
                        "Total number of beta joins executed",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_joins_time_seconds_avg", prefix),
                        "Average time per beta join in seconds",
                        "gauge")

                pe.registerMetric(fmt.Sprintf("%s_beta_joins_selectivity_avg", prefix),
                        "Average beta join selectivity (0.0 to 1.0)",
                        "gauge")

                pe.registerMetric(fmt.Sprintf("%s_beta_joins_result_size_avg", prefix),
                        "Average beta join result size",
                        "gauge")

                // M√©triques de cache de hash beta
                pe.registerMetric(fmt.Sprintf("%s_beta_hash_cache_hits_total", prefix),
                        "Total number of beta hash cache hits",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_hash_cache_misses_total", prefix),
                        "Total number of beta hash cache misses",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_hash_cache_size", prefix),
                        "Current size of beta hash cache",
                        "gauge")

                pe.registerMetric(fmt.Sprintf("%s_beta_hash_cache_efficiency", prefix),
                        "Beta hash cache efficiency (0.0 to 1.0)",
                        "gauge")

                // M√©triques de cache de jointure
                pe.registerMetric(fmt.Sprintf("%s_beta_join_cache_hits_total", prefix),
                        "Total number of beta join cache hits",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_join_cache_misses_total", prefix),
                        "Total number of beta join cache misses",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_join_cache_size", prefix),
                        "Current size of beta join cache",
                        "gauge")

                pe.registerMetric(fmt.Sprintf("%s_beta_join_cache_evictions_total", prefix),
                        "Total number of beta join cache evictions",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_join_cache_efficiency", prefix),
                        "Beta join cache efficiency (0.0 to 1.0)",
                        "gauge")

                // M√©triques de cache de connexion beta
                pe.registerMetric(fmt.Sprintf("%s_beta_connection_cache_hits_total", prefix),
                        "Total number of beta connection cache hits",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_connection_cache_misses_total", prefix),
                        "Total number of beta connection cache misses",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_connection_cache_efficiency", prefix),
                        "Beta connection cache efficiency (0.0 to 1.0)",
                        "gauge")

                // M√©triques de cache de pr√©fixe beta
                pe.registerMetric(fmt.Sprintf("%s_beta_prefix_cache_hits_total", prefix),
                        "Total number of beta prefix cache hits",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_prefix_cache_misses_total", prefix),
                        "Total number of beta prefix cache misses",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_prefix_cache_size", prefix),
                        "Current size of beta prefix cache",
                        "gauge")

                pe.registerMetric(fmt.Sprintf("%s_beta_prefix_cache_efficiency", prefix),
                        "Beta prefix cache efficiency (0.0 to 1.0)",
                        "gauge")

                // M√©triques de temps beta
                pe.registerMetric(fmt.Sprintf("%s_beta_build_time_seconds_total", prefix),
                        "Total time spent building beta chains in seconds",
                        "counter")

                pe.registerMetric(fmt.Sprintf("%s_beta_build_time_seconds_avg", prefix),
                        "Average time spent building a beta chain in seconds",
                        "gauge")

                pe.registerMetric(fmt.Sprintf("%s_beta_hash_compute_time_seconds_total", prefix),
                        "Total time spent computing beta hashes in seconds",
                        "counter")
        }</span>
}

// registerMetric enregistre une m√©trique
func (pe *PrometheusExporter) registerMetric(name, help, metricType string) <span class="cov0" title="0">{
        pe.mutex.Lock()
        defer pe.mutex.Unlock()

        pe.registry[name] = &amp;prometheusMetric{
                name:       name,
                help:       help,
                metricType: metricType,
                labels:     make(map[string]string),
        }
}</span>

// UpdateMetrics met √† jour toutes les m√©triques avec les valeurs actuelles
func (pe *PrometheusExporter) UpdateMetrics() <span class="cov0" title="0">{
        pe.mutex.Lock()
        defer pe.mutex.Unlock()

        prefix := pe.config.PrometheusPrefix

        // M√©triques alpha
        if pe.alphaMetrics != nil </span><span class="cov0" title="0">{
                snapshot := pe.alphaMetrics.GetSnapshot()

                // Cha√Ænes alpha
                pe.updateValue(fmt.Sprintf("%s_alpha_chains_built_total", prefix), float64(snapshot.TotalChainsBuilt))
                pe.updateValue(fmt.Sprintf("%s_alpha_chains_length_avg", prefix), snapshot.AverageChainLength)

                // N≈ìuds alpha
                pe.updateValue(fmt.Sprintf("%s_alpha_nodes_created_total", prefix), float64(snapshot.TotalNodesCreated))
                pe.updateValue(fmt.Sprintf("%s_alpha_nodes_reused_total", prefix), float64(snapshot.TotalNodesReused))
                pe.updateValue(fmt.Sprintf("%s_alpha_nodes_sharing_ratio", prefix), snapshot.SharingRatio)

                // Cache de hash alpha
                pe.updateValue(fmt.Sprintf("%s_alpha_hash_cache_hits_total", prefix), float64(snapshot.HashCacheHits))
                pe.updateValue(fmt.Sprintf("%s_alpha_hash_cache_misses_total", prefix), float64(snapshot.HashCacheMisses))
                pe.updateValue(fmt.Sprintf("%s_alpha_hash_cache_size", prefix), float64(snapshot.HashCacheSize))
                pe.updateValue(fmt.Sprintf("%s_alpha_hash_cache_efficiency", prefix), pe.alphaMetrics.GetHashCacheEfficiency())

                // Cache de connexion alpha
                pe.updateValue(fmt.Sprintf("%s_alpha_connection_cache_hits_total", prefix), float64(snapshot.ConnectionCacheHits))
                pe.updateValue(fmt.Sprintf("%s_alpha_connection_cache_misses_total", prefix), float64(snapshot.ConnectionCacheMisses))
                pe.updateValue(fmt.Sprintf("%s_alpha_connection_cache_efficiency", prefix), pe.alphaMetrics.GetConnectionCacheEfficiency())

                // Temps alpha
                pe.updateValue(fmt.Sprintf("%s_alpha_build_time_seconds_total", prefix), snapshot.TotalBuildTime.Seconds())
                pe.updateValue(fmt.Sprintf("%s_alpha_build_time_seconds_avg", prefix), snapshot.AverageBuildTime.Seconds())
                pe.updateValue(fmt.Sprintf("%s_alpha_hash_compute_time_seconds_total", prefix), snapshot.TotalHashComputeTime.Seconds())
        }</span>

        // M√©triques beta
        <span class="cov0" title="0">if pe.betaMetrics != nil </span><span class="cov0" title="0">{
                snapshot := pe.betaMetrics.GetSnapshot()

                // Cha√Ænes beta
                pe.updateValue(fmt.Sprintf("%s_beta_chains_built_total", prefix), float64(snapshot.TotalChainsBuilt))
                pe.updateValue(fmt.Sprintf("%s_beta_chains_length_avg", prefix), snapshot.AverageChainLength)

                // N≈ìuds beta
                pe.updateValue(fmt.Sprintf("%s_beta_nodes_created_total", prefix), float64(snapshot.TotalNodesCreated))
                pe.updateValue(fmt.Sprintf("%s_beta_nodes_reused_total", prefix), float64(snapshot.TotalNodesReused))
                pe.updateValue(fmt.Sprintf("%s_beta_nodes_sharing_ratio", prefix), snapshot.SharingRatio)

                // Jointures
                pe.updateValue(fmt.Sprintf("%s_beta_joins_executed_total", prefix), float64(snapshot.TotalJoinsExecuted))
                pe.updateValue(fmt.Sprintf("%s_beta_joins_time_seconds_avg", prefix), snapshot.AverageJoinTime.Seconds())
                pe.updateValue(fmt.Sprintf("%s_beta_joins_selectivity_avg", prefix), snapshot.AverageJoinSelectivity)
                pe.updateValue(fmt.Sprintf("%s_beta_joins_result_size_avg", prefix), snapshot.AverageResultSize)

                // Cache de hash beta
                pe.updateValue(fmt.Sprintf("%s_beta_hash_cache_hits_total", prefix), float64(snapshot.HashCacheHits))
                pe.updateValue(fmt.Sprintf("%s_beta_hash_cache_misses_total", prefix), float64(snapshot.HashCacheMisses))
                pe.updateValue(fmt.Sprintf("%s_beta_hash_cache_size", prefix), float64(snapshot.HashCacheSize))
                pe.updateValue(fmt.Sprintf("%s_beta_hash_cache_efficiency", prefix), pe.betaMetrics.GetHashCacheEfficiency())

                // Cache de jointure
                pe.updateValue(fmt.Sprintf("%s_beta_join_cache_hits_total", prefix), float64(snapshot.JoinCacheHits))
                pe.updateValue(fmt.Sprintf("%s_beta_join_cache_misses_total", prefix), float64(snapshot.JoinCacheMisses))
                pe.updateValue(fmt.Sprintf("%s_beta_join_cache_size", prefix), float64(snapshot.JoinCacheSize))
                pe.updateValue(fmt.Sprintf("%s_beta_join_cache_evictions_total", prefix), float64(snapshot.JoinCacheEvictions))
                pe.updateValue(fmt.Sprintf("%s_beta_join_cache_efficiency", prefix), pe.betaMetrics.GetJoinCacheEfficiency())

                // Cache de connexion beta
                pe.updateValue(fmt.Sprintf("%s_beta_connection_cache_hits_total", prefix), float64(snapshot.ConnectionCacheHits))
                pe.updateValue(fmt.Sprintf("%s_beta_connection_cache_misses_total", prefix), float64(snapshot.ConnectionCacheMisses))
                pe.updateValue(fmt.Sprintf("%s_beta_connection_cache_efficiency", prefix), pe.betaMetrics.GetConnectionCacheEfficiency())

                // Cache de pr√©fixe beta
                pe.updateValue(fmt.Sprintf("%s_beta_prefix_cache_hits_total", prefix), float64(snapshot.PrefixCacheHits))
                pe.updateValue(fmt.Sprintf("%s_beta_prefix_cache_misses_total", prefix), float64(snapshot.PrefixCacheMisses))
                pe.updateValue(fmt.Sprintf("%s_beta_prefix_cache_size", prefix), float64(snapshot.PrefixCacheSize))
                pe.updateValue(fmt.Sprintf("%s_beta_prefix_cache_efficiency", prefix), pe.betaMetrics.GetPrefixCacheEfficiency())

                // Temps beta
                pe.updateValue(fmt.Sprintf("%s_beta_build_time_seconds_total", prefix), snapshot.TotalBuildTime.Seconds())
                pe.updateValue(fmt.Sprintf("%s_beta_build_time_seconds_avg", prefix), snapshot.AverageBuildTime.Seconds())
                pe.updateValue(fmt.Sprintf("%s_beta_hash_compute_time_seconds_total", prefix), snapshot.TotalHashComputeTime.Seconds())
        }</span>
}

// updateValue met √† jour la valeur d'une m√©trique
func (pe *PrometheusExporter) updateValue(name string, value float64) <span class="cov0" title="0">{
        if metric, exists := pe.registry[name]; exists </span><span class="cov0" title="0">{
                metric.value = value
        }</span>
}

// Handler retourne un http.Handler pour le endpoint /metrics
func (pe *PrometheusExporter) Handler() http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Mettre √† jour les m√©triques avant de les exporter
                pe.UpdateMetrics()

                // √âcrire les m√©triques au format Prometheus
                w.Header().Set("Content-Type", "text/plain; version=0.0.4")

                pe.mutex.RLock()
                defer pe.mutex.RUnlock()

                for _, metric := range pe.registry </span><span class="cov0" title="0">{
                        // HELP
                        fmt.Fprintf(w, "# HELP %s %s\n", metric.name, metric.help)
                        // TYPE
                        fmt.Fprintf(w, "# TYPE %s %s\n", metric.name, metric.metricType)
                        // VALUE
                        if len(metric.labels) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Fprintf(w, "%s{%s} %v\n", metric.name, pe.formatLabels(metric.labels), metric.value)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(w, "%s %v\n", metric.name, metric.value)
                        }</span>
                }
        })
}

// formatLabels formate les labels au format Prometheus
func (pe *PrometheusExporter) formatLabels(labels map[string]string) string <span class="cov0" title="0">{
        if len(labels) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">result := ""
        first := true
        for key, value := range labels </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        result += ","
                }</span>
                <span class="cov0" title="0">result += fmt.Sprintf("%s=\"%s\"", key, value)
                first = false</span>
        }
        <span class="cov0" title="0">return result</span>
}

// ServeHTTP d√©marre un serveur HTTP pour exposer les m√©triques
func (pe *PrometheusExporter) ServeHTTP(addr string) error <span class="cov0" title="0">{
        http.Handle("/metrics", pe.Handler())
        http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                fmt.Fprint(w, "OK")
        }</span>)

        <span class="cov0" title="0">return http.ListenAndServe(addr, nil)</span>
}

// StartAutoUpdate d√©marre une goroutine qui met √† jour automatiquement les m√©triques
func (pe *PrometheusExporter) StartAutoUpdate(interval time.Duration) chan struct{} <span class="cov0" title="0">{
        stop := make(chan struct{})

        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(interval)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                pe.UpdateMetrics()</span>
                        case &lt;-stop:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return stop</span>
}

// GetMetricsText retourne les m√©triques au format texte Prometheus
func (pe *PrometheusExporter) GetMetricsText() string <span class="cov0" title="0">{
        pe.UpdateMetrics()

        pe.mutex.RLock()
        defer pe.mutex.RUnlock()

        result := ""
        for _, metric := range pe.registry </span><span class="cov0" title="0">{
                result += fmt.Sprintf("# HELP %s %s\n", metric.name, metric.help)
                result += fmt.Sprintf("# TYPE %s %s\n", metric.name, metric.metricType)
                if len(metric.labels) &gt; 0 </span><span class="cov0" title="0">{
                        result += fmt.Sprintf("%s{%s} %v\n", metric.name, pe.formatLabels(metric.labels), metric.value)
                }</span> else<span class="cov0" title="0"> {
                        result += fmt.Sprintf("%s %v\n", metric.name, metric.value)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// PrometheusMetricsSnapshot retourne un snapshot des m√©triques pour Prometheus
type PrometheusMetricsSnapshot struct {
        Timestamp time.Time              `json:"timestamp"`
        Metrics   map[string]interface{} `json:"metrics"`
}

// GetSnapshot retourne un snapshot JSON des m√©triques
func (pe *PrometheusExporter) GetSnapshot() PrometheusMetricsSnapshot <span class="cov0" title="0">{
        pe.UpdateMetrics()

        pe.mutex.RLock()
        defer pe.mutex.RUnlock()

        metrics := make(map[string]interface{})
        for name, metric := range pe.registry </span><span class="cov0" title="0">{
                metrics[name] = map[string]interface{}{
                        "value":  metric.value,
                        "type":   metric.metricType,
                        "help":   metric.help,
                        "labels": metric.labels,
                }
        }</span>

        <span class="cov0" title="0">return PrometheusMetricsSnapshot{
                Timestamp: time.Now(),
                Metrics:   metrics,
        }</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "encoding/json"
        "fmt"
        "sync"
)

// MemoryStorage impl√©mente Storage en m√©moire (pour les tests)
type MemoryStorage struct {
        memories map[string]*WorkingMemory
        mutex    sync.RWMutex
}

// NewMemoryStorage cr√©e un nouveau storage en m√©moire
func NewMemoryStorage() *MemoryStorage <span class="cov8" title="1">{
        return &amp;MemoryStorage{
                memories: make(map[string]*WorkingMemory),
        }
}</span>

// SaveMemory sauvegarde en m√©moire
func (ms *MemoryStorage) SaveMemory(nodeID string, memory *WorkingMemory) error <span class="cov0" title="0">{
        ms.mutex.Lock()
        defer ms.mutex.Unlock()

        // Copier la m√©moire pour √©viter les modifications concurrentes
        data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var copyMemory WorkingMemory
        err = json.Unmarshal(data, &amp;copyMemory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ms.memories[nodeID] = &amp;copyMemory
        return nil</span>
}

// LoadMemory charge depuis la m√©moire
func (ms *MemoryStorage) LoadMemory(nodeID string) (*WorkingMemory, error) <span class="cov0" title="0">{
        ms.mutex.RLock()
        defer ms.mutex.RUnlock()

        memory, exists := ms.memories[nodeID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("m√©moire non trouv√©e pour le n≈ìud %s", nodeID)
        }</span>

        // Retourner une copie
        <span class="cov0" title="0">data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var copyMemory WorkingMemory
        err = json.Unmarshal(data, &amp;copyMemory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;copyMemory, nil</span>
}

// DeleteMemory supprime de la m√©moire
func (ms *MemoryStorage) DeleteMemory(nodeID string) error <span class="cov0" title="0">{
        ms.mutex.Lock()
        defer ms.mutex.Unlock()
        delete(ms.memories, nodeID)
        return nil
}</span>

// ListNodes liste les n≈ìuds en m√©moire
func (ms *MemoryStorage) ListNodes() ([]string, error) <span class="cov0" title="0">{
        ms.mutex.RLock()
        defer ms.mutex.RUnlock()

        nodes := make([]string, 0, len(ms.memories))
        for nodeID := range ms.memories </span><span class="cov0" title="0">{
                nodes = append(nodes, nodeID)
        }</span>
        <span class="cov0" title="0">return nodes, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright (c) 2025 TSD Contributors
// Licensed under the MIT License
// See LICENSE file in the project root for full license text

package rete

import (
        "fmt"
        "sync"
        "time"
)

// IndexedFactStorage fournit un stockage index√© pour les faits
type IndexedFactStorage struct {
        // Index principal par ID de fait
        factsByID map[string]*Fact

        // Index par type de fait
        factsByType map[string]map[string]*Fact

        // Index par propri√©t√©s de fait (champ -&gt; valeur -&gt; faits)
        factsByField map[string]map[interface{}]map[string]*Fact

        // Index composite pour les jointures fr√©quentes
        compositeIndex map[string]map[string]*Fact

        // Statistiques d'utilisation pour optimiser les index
        accessStats map[string]int64

        // Verrou pour la concurrence
        mutex sync.RWMutex

        // Configuration des index
        config IndexConfig
}

// IndexConfig configure les options d'indexation
type IndexConfig struct {
        // Champs √† indexer automatiquement
        IndexedFields []string

        // Taille maximale du cache
        MaxCacheSize int

        // TTL pour les entr√©es de cache
        CacheTTL time.Duration

        // Activer les index composites
        EnableCompositeIndex bool

        // Seuil pour cr√©er des index automatiques
        AutoIndexThreshold int64
}

// NewIndexedFactStorage cr√©e un nouveau stockage index√©
func NewIndexedFactStorage(config IndexConfig) *IndexedFactStorage <span class="cov0" title="0">{
        return &amp;IndexedFactStorage{
                factsByID:      make(map[string]*Fact),
                factsByType:    make(map[string]map[string]*Fact),
                factsByField:   make(map[string]map[interface{}]map[string]*Fact),
                compositeIndex: make(map[string]map[string]*Fact),
                accessStats:    make(map[string]int64),
                config:         config,
        }
}</span>

// StoreFact stocke un fait avec indexation automatique
func (ifs *IndexedFactStorage) StoreFact(fact *Fact) error <span class="cov0" title="0">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        // Stocker dans l'index principal
        ifs.factsByID[fact.ID] = fact

        // Indexer par type
        if ifs.factsByType[fact.Type] == nil </span><span class="cov0" title="0">{
                ifs.factsByType[fact.Type] = make(map[string]*Fact)
        }</span>
        <span class="cov0" title="0">ifs.factsByType[fact.Type][fact.ID] = fact

        // Indexer par champs configur√©s
        for _, fieldName := range ifs.config.IndexedFields </span><span class="cov0" title="0">{
                if value, exists := fact.Fields[fieldName]; exists </span><span class="cov0" title="0">{
                        ifs.indexFieldValue(fieldName, value, fact)
                }</span>
        }

        // Indexer par tous les champs si activ√©
        <span class="cov0" title="0">for fieldName, value := range fact.Fields </span><span class="cov0" title="0">{
                ifs.indexFieldValue(fieldName, value, fact)
        }</span>

        // Cr√©er des index composites si activ√©
        <span class="cov0" title="0">if ifs.config.EnableCompositeIndex </span><span class="cov0" title="0">{
                ifs.createCompositeIndexes(fact)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// indexFieldValue indexe une valeur de champ
func (ifs *IndexedFactStorage) indexFieldValue(fieldName string, value interface{}, fact *Fact) <span class="cov0" title="0">{
        if ifs.factsByField[fieldName] == nil </span><span class="cov0" title="0">{
                ifs.factsByField[fieldName] = make(map[interface{}]map[string]*Fact)
        }</span>
        <span class="cov0" title="0">if ifs.factsByField[fieldName][value] == nil </span><span class="cov0" title="0">{
                ifs.factsByField[fieldName][value] = make(map[string]*Fact)
        }</span>
        <span class="cov0" title="0">ifs.factsByField[fieldName][value][fact.ID] = fact</span>
}

// createCompositeIndexes cr√©e des index composites pour les jointures fr√©quentes
func (ifs *IndexedFactStorage) createCompositeIndexes(fact *Fact) <span class="cov0" title="0">{
        // Cr√©er des cl√©s composites pour des combinaisons communes
        if id, hasID := fact.Fields["id"]; hasID </span><span class="cov0" title="0">{
                if name, hasName := fact.Fields["name"]; hasName </span><span class="cov0" title="0">{
                        compositeKey := fmt.Sprintf("id_name:%v_%v", id, name)
                        if ifs.compositeIndex[compositeKey] == nil </span><span class="cov0" title="0">{
                                ifs.compositeIndex[compositeKey] = make(map[string]*Fact)
                        }</span>
                        <span class="cov0" title="0">ifs.compositeIndex[compositeKey][fact.ID] = fact</span>
                }
        }
}

// GetFactByID r√©cup√®re un fait par son ID
func (ifs *IndexedFactStorage) GetFactByID(id string) (*Fact, bool) <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        ifs.recordAccess("id:" + id)

        fact, exists := ifs.factsByID[id]
        return fact, exists
}</span>

// GetFactsByType r√©cup√®re tous les faits d'un type donn√©
func (ifs *IndexedFactStorage) GetFactsByType(factType string) []*Fact <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        ifs.recordAccess("type:" + factType)

        factsMap, exists := ifs.factsByType[factType]
        if !exists </span><span class="cov0" title="0">{
                return []*Fact{}
        }</span>

        <span class="cov0" title="0">facts := make([]*Fact, 0, len(factsMap))
        for _, fact := range factsMap </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>

        <span class="cov0" title="0">return facts</span>
}

// GetFactsByField r√©cup√®re des faits par valeur de champ
func (ifs *IndexedFactStorage) GetFactsByField(fieldName string, value interface{}) []*Fact <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        accessKey := fmt.Sprintf("field:%s:%v", fieldName, value)
        ifs.recordAccess(accessKey)

        fieldIndex, exists := ifs.factsByField[fieldName]
        if !exists </span><span class="cov0" title="0">{
                return []*Fact{}
        }</span>

        <span class="cov0" title="0">factsMap, exists := fieldIndex[value]
        if !exists </span><span class="cov0" title="0">{
                return []*Fact{}
        }</span>

        <span class="cov0" title="0">facts := make([]*Fact, 0, len(factsMap))
        for _, fact := range factsMap </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>

        <span class="cov0" title="0">return facts</span>
}

// GetFactsByCompositeKey r√©cup√®re des faits par cl√© composite
func (ifs *IndexedFactStorage) GetFactsByCompositeKey(key string) []*Fact <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        ifs.recordAccess("composite:" + key)

        factsMap, exists := ifs.compositeIndex[key]
        if !exists </span><span class="cov0" title="0">{
                return []*Fact{}
        }</span>

        <span class="cov0" title="0">facts := make([]*Fact, 0, len(factsMap))
        for _, fact := range factsMap </span><span class="cov0" title="0">{
                facts = append(facts, fact)
        }</span>

        <span class="cov0" title="0">return facts</span>
}

// RemoveFact supprime un fait et met √† jour les index
func (ifs *IndexedFactStorage) RemoveFact(factID string) bool <span class="cov0" title="0">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        fact, exists := ifs.factsByID[factID]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Supprimer de l'index principal
        <span class="cov0" title="0">delete(ifs.factsByID, factID)

        // Supprimer de l'index par type
        if typeMap := ifs.factsByType[fact.Type]; typeMap != nil </span><span class="cov0" title="0">{
                delete(typeMap, factID)
                if len(typeMap) == 0 </span><span class="cov0" title="0">{
                        delete(ifs.factsByType, fact.Type)
                }</span>
        }

        // Supprimer des index par champ
        <span class="cov0" title="0">for fieldName, value := range fact.Fields </span><span class="cov0" title="0">{
                if fieldIndex := ifs.factsByField[fieldName]; fieldIndex != nil </span><span class="cov0" title="0">{
                        if valueMap := fieldIndex[value]; valueMap != nil </span><span class="cov0" title="0">{
                                delete(valueMap, factID)
                                if len(valueMap) == 0 </span><span class="cov0" title="0">{
                                        delete(fieldIndex, value)
                                        if len(fieldIndex) == 0 </span><span class="cov0" title="0">{
                                                delete(ifs.factsByField, fieldName)
                                        }</span>
                                }
                        }
                }
        }

        // Supprimer des index composites
        <span class="cov0" title="0">ifs.removeFromCompositeIndexes(fact)

        return true</span>
}

// removeFromCompositeIndexes supprime le fait des index composites
func (ifs *IndexedFactStorage) removeFromCompositeIndexes(fact *Fact) <span class="cov0" title="0">{
        // Supprimer des cl√©s composites
        if id, hasID := fact.Fields["id"]; hasID </span><span class="cov0" title="0">{
                if name, hasName := fact.Fields["name"]; hasName </span><span class="cov0" title="0">{
                        compositeKey := fmt.Sprintf("id_name:%v_%v", id, name)
                        if compositeMap := ifs.compositeIndex[compositeKey]; compositeMap != nil </span><span class="cov0" title="0">{
                                delete(compositeMap, fact.ID)
                                if len(compositeMap) == 0 </span><span class="cov0" title="0">{
                                        delete(ifs.compositeIndex, compositeKey)
                                }</span>
                        }
                }
        }
}

// recordAccess enregistre un acc√®s pour les statistiques
func (ifs *IndexedFactStorage) recordAccess(key string) <span class="cov0" title="0">{
        ifs.accessStats[key]++

        // Cr√©er automatiquement des index pour les acc√®s fr√©quents
        if ifs.accessStats[key] &gt; ifs.config.AutoIndexThreshold </span>{<span class="cov0" title="0">
                // Logique pour cr√©er des index automatiques bas√©s sur les patterns d'acc√®s
        }</span>
}

// GetAccessStats retourne les statistiques d'acc√®s
func (ifs *IndexedFactStorage) GetAccessStats() map[string]int64 <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        stats := make(map[string]int64)
        for key, count := range ifs.accessStats </span><span class="cov0" title="0">{
                stats[key] = count
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// OptimizeIndexes optimise les index bas√©s sur les statistiques d'usage
func (ifs *IndexedFactStorage) OptimizeIndexes() <span class="cov0" title="0">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        // Analyser les patterns d'acc√®s fr√©quents
        for _, count := range ifs.accessStats </span><span class="cov0" title="0">{
                if count &gt; ifs.config.AutoIndexThreshold </span>{<span class="cov0" title="0">
                        // Cr√©er des index optimis√©s pour cet acc√®s
                        // Cette logique peut √™tre √©tendue selon les besoins
                }</span>
        }
}

// Clear vide tous les index et statistiques
func (ifs *IndexedFactStorage) Clear() <span class="cov0" title="0">{
        ifs.mutex.Lock()
        defer ifs.mutex.Unlock()

        ifs.factsByID = make(map[string]*Fact)
        ifs.factsByType = make(map[string]map[string]*Fact)
        ifs.factsByField = make(map[string]map[interface{}]map[string]*Fact)
        ifs.compositeIndex = make(map[string]map[string]*Fact)
        ifs.accessStats = make(map[string]int64)
}</span>

// Size retourne le nombre total de faits stock√©s
func (ifs *IndexedFactStorage) Size() int <span class="cov0" title="0">{
        ifs.mutex.RLock()
        defer ifs.mutex.RUnlock()

        return len(ifs.factsByID)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
